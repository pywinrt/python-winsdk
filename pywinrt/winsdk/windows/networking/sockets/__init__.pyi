# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.5

import enum
import sys
import types
import typing
import uuid

import winsdk._winrt as _winrt
import winsdk.windows.applicationmodel.background
import winsdk.windows.foundation
import winsdk.windows.foundation.collections
import winsdk.windows.networking
import winsdk.windows.networking.connectivity
import winsdk.windows.security.credentials
import winsdk.windows.security.cryptography.certificates
import winsdk.windows.storage.streams
import winsdk.windows.web

class ControlChannelTriggerResetReason(enum.IntEnum):
    FAST_USER_SWITCHED = 0
    LOW_POWER_EXIT = 1
    QUIET_HOURS_EXIT = 2
    APPLICATION_RESTART = 3

class ControlChannelTriggerResourceType(enum.IntEnum):
    REQUEST_SOFTWARE_SLOT = 0
    REQUEST_HARDWARE_SLOT = 1

class ControlChannelTriggerStatus(enum.IntEnum):
    HARDWARE_SLOT_REQUESTED = 0
    SOFTWARE_SLOT_ALLOCATED = 1
    HARDWARE_SLOT_ALLOCATED = 2
    POLICY_ERROR = 3
    SYSTEM_ERROR = 4
    TRANSPORT_DISCONNECTED = 5
    SERVICE_UNAVAILABLE = 6

class MessageWebSocketReceiveMode(enum.IntEnum):
    FULL_MESSAGE = 0
    PARTIAL_MESSAGE = 1

class SocketActivityConnectedStandbyAction(enum.IntEnum):
    DO_NOT_WAKE = 0
    WAKE = 1

class SocketActivityKind(enum.IntEnum):
    NONE = 0
    STREAM_SOCKET_LISTENER = 1
    DATAGRAM_SOCKET = 2
    STREAM_SOCKET = 3

class SocketActivityTriggerReason(enum.IntEnum):
    NONE = 0
    SOCKET_ACTIVITY = 1
    CONNECTION_ACCEPTED = 2
    KEEP_ALIVE_TIMER_EXPIRED = 3
    SOCKET_CLOSED = 4

class SocketErrorStatus(enum.IntEnum):
    UNKNOWN = 0
    OPERATION_ABORTED = 1
    HTTP_INVALID_SERVER_RESPONSE = 2
    CONNECTION_TIMED_OUT = 3
    ADDRESS_FAMILY_NOT_SUPPORTED = 4
    SOCKET_TYPE_NOT_SUPPORTED = 5
    HOST_NOT_FOUND = 6
    NO_DATA_RECORD_OF_REQUESTED_TYPE = 7
    NON_AUTHORITATIVE_HOST_NOT_FOUND = 8
    CLASS_TYPE_NOT_FOUND = 9
    ADDRESS_ALREADY_IN_USE = 10
    CANNOT_ASSIGN_REQUESTED_ADDRESS = 11
    CONNECTION_REFUSED = 12
    NETWORK_IS_UNREACHABLE = 13
    UNREACHABLE_HOST = 14
    NETWORK_IS_DOWN = 15
    NETWORK_DROPPED_CONNECTION_ON_RESET = 16
    SOFTWARE_CAUSED_CONNECTION_ABORT = 17
    CONNECTION_RESET_BY_PEER = 18
    HOST_IS_DOWN = 19
    NO_ADDRESSES_FOUND = 20
    TOO_MANY_OPEN_FILES = 21
    MESSAGE_TOO_LONG = 22
    CERTIFICATE_EXPIRED = 23
    CERTIFICATE_UNTRUSTED_ROOT = 24
    CERTIFICATE_COMMON_NAME_IS_INCORRECT = 25
    CERTIFICATE_WRONG_USAGE = 26
    CERTIFICATE_REVOKED = 27
    CERTIFICATE_NO_REVOCATION_CHECK = 28
    CERTIFICATE_REVOCATION_SERVER_OFFLINE = 29
    CERTIFICATE_IS_INVALID = 30

class SocketMessageType(enum.IntEnum):
    BINARY = 0
    UTF8 = 1

class SocketProtectionLevel(enum.IntEnum):
    PLAIN_SOCKET = 0
    SSL = 1
    SSL_ALLOW_NULL_ENCRYPTION = 2
    BLUETOOTH_ENCRYPTION_ALLOW_NULL_AUTHENTICATION = 3
    BLUETOOTH_ENCRYPTION_WITH_AUTHENTICATION = 4
    SSL3_ALLOW_WEAK_ENCRYPTION = 5
    TLS10 = 6
    TLS11 = 7
    TLS12 = 8
    UNSPECIFIED = 9

class SocketQualityOfService(enum.IntEnum):
    NORMAL = 0
    LOW_LATENCY = 1

class SocketSslErrorSeverity(enum.IntEnum):
    NONE = 0
    IGNORABLE = 1
    FATAL = 2

Self = typing.TypeVar('Self')

class BandwidthStatistics:
    outbound_bits_per_second: _winrt.UInt64
    inbound_bits_per_second: _winrt.UInt64
    outbound_bits_per_second_instability: _winrt.UInt64
    inbound_bits_per_second_instability: _winrt.UInt64
    outbound_bandwidth_peaked: _winrt.Boolean
    inbound_bandwidth_peaked: _winrt.Boolean
    def __init__(self, outbound_bits_per_second: _winrt.UInt64, inbound_bits_per_second: _winrt.UInt64, outbound_bits_per_second_instability: _winrt.UInt64, inbound_bits_per_second_instability: _winrt.UInt64, outbound_bandwidth_peaked: _winrt.Boolean, inbound_bandwidth_peaked: _winrt.Boolean) -> None: ...

class RoundTripTimeStatistics:
    variance: _winrt.UInt32
    max: _winrt.UInt32
    min: _winrt.UInt32
    sum: _winrt.UInt32
    def __init__(self, variance: _winrt.UInt32, max: _winrt.UInt32, min: _winrt.UInt32, sum: _winrt.UInt32) -> None: ...

class ControlChannelTrigger(_winrt.Object):
    server_keep_alive_interval_in_minutes: _winrt.UInt32
    control_channel_trigger_id: str
    current_keep_alive_interval_in_minutes: _winrt.UInt32
    keep_alive_trigger: typing.Optional[winsdk.windows.applicationmodel.background.IBackgroundTrigger]
    push_notification_trigger: typing.Optional[winsdk.windows.applicationmodel.background.IBackgroundTrigger]
    transport_object: typing.Optional[_winrt.Object]
    is_wake_from_low_power_supported: _winrt.Boolean
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> ControlChannelTrigger: ...
    @typing.overload
    def __init__(self, channel_id: str, server_keep_alive_interval_in_minutes: _winrt.UInt32) -> None: ...
    @typing.overload
    def __init__(self, channel_id: str, server_keep_alive_interval_in_minutes: _winrt.UInt32, resource_request_type: ControlChannelTriggerResourceType) -> None: ...
    def close(self) -> None: ...
    def decrease_network_keep_alive_interval(self) -> None: ...
    def flush_transport(self) -> None: ...
    def using_transport(self, transport: typing.Optional[_winrt.Object]) -> None: ...
    def wait_for_push_enabled(self) -> ControlChannelTriggerStatus: ...

class DatagramSocket(_winrt.Object):
    control: typing.Optional[DatagramSocketControl]
    information: typing.Optional[DatagramSocketInformation]
    output_stream: typing.Optional[winsdk.windows.storage.streams.IOutputStream]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> DatagramSocket: ...
    def __init__(self) -> None: ...
    def bind_endpoint_async(self, local_host_name: typing.Optional[winsdk.windows.networking.HostName], local_service_name: str) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str, adapter: typing.Optional[winsdk.windows.networking.connectivity.NetworkAdapter]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def cancel_i_o_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def close(self) -> None: ...
    @typing.overload
    def connect_async(self, endpoint_pair: typing.Optional[winsdk.windows.networking.EndpointPair]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def connect_async(self, remote_host_name: typing.Optional[winsdk.windows.networking.HostName], remote_service_name: str) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: uuid.UUID) -> None: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: uuid.UUID, connected_standby_action: SocketActivityConnectedStandbyAction) -> None: ...
    @typing.overload
    @staticmethod
    def get_endpoint_pairs_async(remote_host_name: typing.Optional[winsdk.windows.networking.HostName], remote_service_name: str) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.networking.EndpointPair]]: ...
    @typing.overload
    @staticmethod
    def get_endpoint_pairs_async(remote_host_name: typing.Optional[winsdk.windows.networking.HostName], remote_service_name: str, sort_options: winsdk.windows.networking.HostNameSortOptions) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.networking.EndpointPair]]: ...
    @typing.overload
    def get_output_stream_async(self, endpoint_pair: typing.Optional[winsdk.windows.networking.EndpointPair]) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.storage.streams.IOutputStream]: ...
    @typing.overload
    def get_output_stream_async(self, remote_host_name: typing.Optional[winsdk.windows.networking.HostName], remote_service_name: str) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.storage.streams.IOutputStream]: ...
    def join_multicast_group(self, host: typing.Optional[winsdk.windows.networking.HostName]) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext]) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext], keep_alive_time: winsdk.windows.foundation.TimeSpan) -> None: ...
    def add_message_received(self, event_handler: winsdk.windows.foundation.TypedEventHandler[DatagramSocket, DatagramSocketMessageReceivedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_message_received(self, event_cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class DatagramSocketControl(_winrt.Object):
    quality_of_service: SocketQualityOfService
    outbound_unicast_hop_limit: _winrt.UInt8
    inbound_buffer_size_in_bytes: _winrt.UInt32
    dont_fragment: _winrt.Boolean
    multicast_only: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> DatagramSocketControl: ...

class DatagramSocketInformation(_winrt.Object):
    local_address: typing.Optional[winsdk.windows.networking.HostName]
    local_port: str
    remote_address: typing.Optional[winsdk.windows.networking.HostName]
    remote_port: str
    @staticmethod
    def _from(obj: _winrt.Object) -> DatagramSocketInformation: ...

class DatagramSocketMessageReceivedEventArgs(_winrt.Object):
    local_address: typing.Optional[winsdk.windows.networking.HostName]
    remote_address: typing.Optional[winsdk.windows.networking.HostName]
    remote_port: str
    @staticmethod
    def _from(obj: _winrt.Object) -> DatagramSocketMessageReceivedEventArgs: ...
    def get_data_reader(self) -> typing.Optional[winsdk.windows.storage.streams.DataReader]: ...
    def get_data_stream(self) -> typing.Optional[winsdk.windows.storage.streams.IInputStream]: ...

class MessageWebSocket(_winrt.Object):
    control: typing.Optional[MessageWebSocketControl]
    information: typing.Optional[MessageWebSocketInformation]
    output_stream: typing.Optional[winsdk.windows.storage.streams.IOutputStream]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> MessageWebSocket: ...
    def __init__(self) -> None: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, code: _winrt.UInt16, reason: str) -> None: ...
    def connect_async(self, uri: typing.Optional[winsdk.windows.foundation.Uri]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def send_final_frame_async(self, data: typing.Optional[winsdk.windows.storage.streams.IBuffer]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[_winrt.UInt32, _winrt.UInt32]: ...
    def send_nonfinal_frame_async(self, data: typing.Optional[winsdk.windows.storage.streams.IBuffer]) -> winsdk.windows.foundation.IAsyncOperationWithProgress[_winrt.UInt32, _winrt.UInt32]: ...
    def set_request_header(self, header_name: str, header_value: str) -> None: ...
    def add_message_received(self, event_handler: winsdk.windows.foundation.TypedEventHandler[MessageWebSocket, MessageWebSocketMessageReceivedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_message_received(self, event_cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_closed(self, event_handler: winsdk.windows.foundation.TypedEventHandler[IWebSocket, WebSocketClosedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, event_cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_server_custom_validation_requested(self, event_handler: winsdk.windows.foundation.TypedEventHandler[MessageWebSocket, WebSocketServerCustomValidationRequestedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_server_custom_validation_requested(self, event_cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class MessageWebSocketControl(_winrt.Object):
    message_type: SocketMessageType
    max_message_size: _winrt.UInt32
    receive_mode: MessageWebSocketReceiveMode
    desired_unsolicited_pong_interval: winsdk.windows.foundation.TimeSpan
    client_certificate: typing.Optional[winsdk.windows.security.cryptography.certificates.Certificate]
    actual_unsolicited_pong_interval: winsdk.windows.foundation.TimeSpan
    server_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    proxy_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    outbound_buffer_size_in_bytes: _winrt.UInt32
    supported_protocols: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    ignorable_server_certificate_errors: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.security.cryptography.certificates.ChainValidationResult]]
    @staticmethod
    def _from(obj: _winrt.Object) -> MessageWebSocketControl: ...

class MessageWebSocketInformation(_winrt.Object):
    bandwidth_statistics: BandwidthStatistics
    local_address: typing.Optional[winsdk.windows.networking.HostName]
    protocol: str
    server_certificate: typing.Optional[winsdk.windows.security.cryptography.certificates.Certificate]
    server_certificate_error_severity: SocketSslErrorSeverity
    server_certificate_errors: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.security.cryptography.certificates.ChainValidationResult]]
    server_intermediate_certificates: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.security.cryptography.certificates.Certificate]]
    @staticmethod
    def _from(obj: _winrt.Object) -> MessageWebSocketInformation: ...

class MessageWebSocketMessageReceivedEventArgs(_winrt.Object):
    message_type: SocketMessageType
    is_message_complete: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> MessageWebSocketMessageReceivedEventArgs: ...
    def get_data_reader(self) -> typing.Optional[winsdk.windows.storage.streams.DataReader]: ...
    def get_data_stream(self) -> typing.Optional[winsdk.windows.storage.streams.IInputStream]: ...

class ServerMessageWebSocket(_winrt.Object):
    control: typing.Optional[ServerMessageWebSocketControl]
    information: typing.Optional[ServerMessageWebSocketInformation]
    output_stream: typing.Optional[winsdk.windows.storage.streams.IOutputStream]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> ServerMessageWebSocket: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, code: _winrt.UInt16, reason: str) -> None: ...
    def add_closed(self, value: winsdk.windows.foundation.TypedEventHandler[ServerMessageWebSocket, WebSocketClosedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_message_received(self, value: winsdk.windows.foundation.TypedEventHandler[ServerMessageWebSocket, MessageWebSocketMessageReceivedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_message_received(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class ServerMessageWebSocketControl(_winrt.Object):
    message_type: SocketMessageType
    @staticmethod
    def _from(obj: _winrt.Object) -> ServerMessageWebSocketControl: ...

class ServerMessageWebSocketInformation(_winrt.Object):
    bandwidth_statistics: BandwidthStatistics
    local_address: typing.Optional[winsdk.windows.networking.HostName]
    protocol: str
    @staticmethod
    def _from(obj: _winrt.Object) -> ServerMessageWebSocketInformation: ...

class ServerStreamWebSocket(_winrt.Object):
    information: typing.Optional[ServerStreamWebSocketInformation]
    input_stream: typing.Optional[winsdk.windows.storage.streams.IInputStream]
    output_stream: typing.Optional[winsdk.windows.storage.streams.IOutputStream]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> ServerStreamWebSocket: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, code: _winrt.UInt16, reason: str) -> None: ...
    def add_closed(self, value: winsdk.windows.foundation.TypedEventHandler[ServerStreamWebSocket, WebSocketClosedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class ServerStreamWebSocketInformation(_winrt.Object):
    bandwidth_statistics: BandwidthStatistics
    local_address: typing.Optional[winsdk.windows.networking.HostName]
    protocol: str
    @staticmethod
    def _from(obj: _winrt.Object) -> ServerStreamWebSocketInformation: ...

class SocketActivityContext(_winrt.Object):
    data: typing.Optional[winsdk.windows.storage.streams.IBuffer]
    @staticmethod
    def _from(obj: _winrt.Object) -> SocketActivityContext: ...
    def __init__(self, data: typing.Optional[winsdk.windows.storage.streams.IBuffer]) -> None: ...

class SocketActivityInformation(_winrt.Object):
    context: typing.Optional[SocketActivityContext]
    datagram_socket: typing.Optional[DatagramSocket]
    id: str
    socket_kind: SocketActivityKind
    stream_socket: typing.Optional[StreamSocket]
    stream_socket_listener: typing.Optional[StreamSocketListener]
    task_id: uuid.UUID
    all_sockets: typing.Optional[winsdk.windows.foundation.collections.IMapView[str, SocketActivityInformation]]
    @staticmethod
    def _from(obj: _winrt.Object) -> SocketActivityInformation: ...

class SocketActivityTriggerDetails(_winrt.Object):
    reason: SocketActivityTriggerReason
    socket_information: typing.Optional[SocketActivityInformation]
    @staticmethod
    def _from(obj: _winrt.Object) -> SocketActivityTriggerDetails: ...

class SocketError(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> SocketError: ...
    @staticmethod
    def get_status(hresult: _winrt.Int32) -> SocketErrorStatus: ...

class StreamSocket(_winrt.Object):
    control: typing.Optional[StreamSocketControl]
    information: typing.Optional[StreamSocketInformation]
    input_stream: typing.Optional[winsdk.windows.storage.streams.IInputStream]
    output_stream: typing.Optional[winsdk.windows.storage.streams.IOutputStream]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> StreamSocket: ...
    def __init__(self) -> None: ...
    def cancel_i_o_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def close(self) -> None: ...
    @typing.overload
    def connect_async(self, endpoint_pair: typing.Optional[winsdk.windows.networking.EndpointPair]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def connect_async(self, remote_host_name: typing.Optional[winsdk.windows.networking.HostName], remote_service_name: str) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def connect_async(self, remote_host_name: typing.Optional[winsdk.windows.networking.HostName], remote_service_name: str, protection_level: SocketProtectionLevel) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def connect_async(self, remote_host_name: typing.Optional[winsdk.windows.networking.HostName], remote_service_name: str, protection_level: SocketProtectionLevel, adapter: typing.Optional[winsdk.windows.networking.connectivity.NetworkAdapter]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: uuid.UUID) -> None: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: uuid.UUID, connected_standby_action: SocketActivityConnectedStandbyAction) -> None: ...
    @typing.overload
    @staticmethod
    def get_endpoint_pairs_async(remote_host_name: typing.Optional[winsdk.windows.networking.HostName], remote_service_name: str) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.networking.EndpointPair]]: ...
    @typing.overload
    @staticmethod
    def get_endpoint_pairs_async(remote_host_name: typing.Optional[winsdk.windows.networking.HostName], remote_service_name: str, sort_options: winsdk.windows.networking.HostNameSortOptions) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.networking.EndpointPair]]: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext]) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext], keep_alive_time: winsdk.windows.foundation.TimeSpan) -> None: ...
    def upgrade_to_ssl_async(self, protection_level: SocketProtectionLevel, validation_host_name: typing.Optional[winsdk.windows.networking.HostName]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...

class StreamSocketControl(_winrt.Object):
    quality_of_service: SocketQualityOfService
    outbound_unicast_hop_limit: _winrt.UInt8
    outbound_buffer_size_in_bytes: _winrt.UInt32
    no_delay: _winrt.Boolean
    keep_alive: _winrt.Boolean
    ignorable_server_certificate_errors: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.security.cryptography.certificates.ChainValidationResult]]
    serialize_connection_attempts: _winrt.Boolean
    client_certificate: typing.Optional[winsdk.windows.security.cryptography.certificates.Certificate]
    min_protection_level: SocketProtectionLevel
    @staticmethod
    def _from(obj: _winrt.Object) -> StreamSocketControl: ...

class StreamSocketInformation(_winrt.Object):
    bandwidth_statistics: BandwidthStatistics
    local_address: typing.Optional[winsdk.windows.networking.HostName]
    local_port: str
    protection_level: SocketProtectionLevel
    remote_address: typing.Optional[winsdk.windows.networking.HostName]
    remote_host_name: typing.Optional[winsdk.windows.networking.HostName]
    remote_port: str
    remote_service_name: str
    round_trip_time_statistics: RoundTripTimeStatistics
    session_key: typing.Optional[winsdk.windows.storage.streams.IBuffer]
    server_certificate: typing.Optional[winsdk.windows.security.cryptography.certificates.Certificate]
    server_certificate_error_severity: SocketSslErrorSeverity
    server_certificate_errors: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.security.cryptography.certificates.ChainValidationResult]]
    server_intermediate_certificates: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.security.cryptography.certificates.Certificate]]
    @staticmethod
    def _from(obj: _winrt.Object) -> StreamSocketInformation: ...

class StreamSocketListener(_winrt.Object):
    control: typing.Optional[StreamSocketListenerControl]
    information: typing.Optional[StreamSocketListenerInformation]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> StreamSocketListener: ...
    def __init__(self) -> None: ...
    def bind_endpoint_async(self, local_host_name: typing.Optional[winsdk.windows.networking.HostName], local_service_name: str) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str, protection_level: SocketProtectionLevel) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def bind_service_name_async(self, local_service_name: str, protection_level: SocketProtectionLevel, adapter: typing.Optional[winsdk.windows.networking.connectivity.NetworkAdapter]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def cancel_i_o_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def close(self) -> None: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: uuid.UUID) -> None: ...
    @typing.overload
    def enable_transfer_ownership(self, task_id: uuid.UUID, connected_standby_action: SocketActivityConnectedStandbyAction) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str) -> None: ...
    @typing.overload
    def transfer_ownership(self, socket_id: str, data: typing.Optional[SocketActivityContext]) -> None: ...
    def add_connection_received(self, event_handler: winsdk.windows.foundation.TypedEventHandler[StreamSocketListener, StreamSocketListenerConnectionReceivedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_connection_received(self, event_cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class StreamSocketListenerConnectionReceivedEventArgs(_winrt.Object):
    socket: typing.Optional[StreamSocket]
    @staticmethod
    def _from(obj: _winrt.Object) -> StreamSocketListenerConnectionReceivedEventArgs: ...

class StreamSocketListenerControl(_winrt.Object):
    quality_of_service: SocketQualityOfService
    outbound_unicast_hop_limit: _winrt.UInt8
    outbound_buffer_size_in_bytes: _winrt.UInt32
    no_delay: _winrt.Boolean
    keep_alive: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> StreamSocketListenerControl: ...

class StreamSocketListenerInformation(_winrt.Object):
    local_port: str
    @staticmethod
    def _from(obj: _winrt.Object) -> StreamSocketListenerInformation: ...

class StreamWebSocket(_winrt.Object):
    control: typing.Optional[StreamWebSocketControl]
    information: typing.Optional[StreamWebSocketInformation]
    input_stream: typing.Optional[winsdk.windows.storage.streams.IInputStream]
    output_stream: typing.Optional[winsdk.windows.storage.streams.IOutputStream]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> StreamWebSocket: ...
    def __init__(self) -> None: ...
    @typing.overload
    def close(self) -> None: ...
    @typing.overload
    def close(self, code: _winrt.UInt16, reason: str) -> None: ...
    def connect_async(self, uri: typing.Optional[winsdk.windows.foundation.Uri]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def set_request_header(self, header_name: str, header_value: str) -> None: ...
    def add_closed(self, event_handler: winsdk.windows.foundation.TypedEventHandler[IWebSocket, WebSocketClosedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, event_cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_server_custom_validation_requested(self, event_handler: winsdk.windows.foundation.TypedEventHandler[StreamWebSocket, WebSocketServerCustomValidationRequestedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_server_custom_validation_requested(self, event_cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class StreamWebSocketControl(_winrt.Object):
    no_delay: _winrt.Boolean
    desired_unsolicited_pong_interval: winsdk.windows.foundation.TimeSpan
    client_certificate: typing.Optional[winsdk.windows.security.cryptography.certificates.Certificate]
    actual_unsolicited_pong_interval: winsdk.windows.foundation.TimeSpan
    server_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    proxy_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    outbound_buffer_size_in_bytes: _winrt.UInt32
    supported_protocols: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    ignorable_server_certificate_errors: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.security.cryptography.certificates.ChainValidationResult]]
    @staticmethod
    def _from(obj: _winrt.Object) -> StreamWebSocketControl: ...

class StreamWebSocketInformation(_winrt.Object):
    bandwidth_statistics: BandwidthStatistics
    local_address: typing.Optional[winsdk.windows.networking.HostName]
    protocol: str
    server_certificate: typing.Optional[winsdk.windows.security.cryptography.certificates.Certificate]
    server_certificate_error_severity: SocketSslErrorSeverity
    server_certificate_errors: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.security.cryptography.certificates.ChainValidationResult]]
    server_intermediate_certificates: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.security.cryptography.certificates.Certificate]]
    @staticmethod
    def _from(obj: _winrt.Object) -> StreamWebSocketInformation: ...

class WebSocketClosedEventArgs(_winrt.Object):
    code: _winrt.UInt16
    reason: str
    @staticmethod
    def _from(obj: _winrt.Object) -> WebSocketClosedEventArgs: ...

class WebSocketError(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> WebSocketError: ...
    @staticmethod
    def get_status(hresult: _winrt.Int32) -> winsdk.windows.web.WebErrorStatus: ...

class WebSocketKeepAlive(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> WebSocketKeepAlive: ...
    def __init__(self) -> None: ...
    def run(self, task_instance: typing.Optional[winsdk.windows.applicationmodel.background.IBackgroundTaskInstance]) -> None: ...

class WebSocketServerCustomValidationRequestedEventArgs(_winrt.Object):
    server_certificate: typing.Optional[winsdk.windows.security.cryptography.certificates.Certificate]
    server_certificate_error_severity: SocketSslErrorSeverity
    server_certificate_errors: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.security.cryptography.certificates.ChainValidationResult]]
    server_intermediate_certificates: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.security.cryptography.certificates.Certificate]]
    @staticmethod
    def _from(obj: _winrt.Object) -> WebSocketServerCustomValidationRequestedEventArgs: ...
    def get_deferral(self) -> typing.Optional[winsdk.windows.foundation.Deferral]: ...
    def reject(self) -> None: ...

class IControlChannelTriggerEventDetails(_winrt.Object):
    control_channel_trigger: typing.Optional[ControlChannelTrigger]
    @staticmethod
    def _from(obj: _winrt.Object) -> IControlChannelTriggerEventDetails: ...

class IControlChannelTriggerResetEventDetails(_winrt.Object):
    hardware_slot_reset: _winrt.Boolean
    reset_reason: ControlChannelTriggerResetReason
    software_slot_reset: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> IControlChannelTriggerResetEventDetails: ...

class IWebSocket(_winrt.Object):
    output_stream: typing.Optional[winsdk.windows.storage.streams.IOutputStream]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> IWebSocket: ...
    def close(self, code: _winrt.UInt16, reason: str) -> None: ...
    def connect_async(self, uri: typing.Optional[winsdk.windows.foundation.Uri]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def set_request_header(self, header_name: str, header_value: str) -> None: ...
    def close(self) -> None: ...
    def add_closed(self, event_handler: winsdk.windows.foundation.TypedEventHandler[IWebSocket, WebSocketClosedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_closed(self, event_cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class IWebSocketControl(_winrt.Object):
    outbound_buffer_size_in_bytes: _winrt.UInt32
    proxy_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    server_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    supported_protocols: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    @staticmethod
    def _from(obj: _winrt.Object) -> IWebSocketControl: ...

class IWebSocketControl2(_winrt.Object):
    ignorable_server_certificate_errors: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.security.cryptography.certificates.ChainValidationResult]]
    outbound_buffer_size_in_bytes: _winrt.UInt32
    proxy_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    server_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    supported_protocols: typing.Optional[winsdk.windows.foundation.collections.IVector[str]]
    @staticmethod
    def _from(obj: _winrt.Object) -> IWebSocketControl2: ...

class IWebSocketInformation(_winrt.Object):
    bandwidth_statistics: BandwidthStatistics
    local_address: typing.Optional[winsdk.windows.networking.HostName]
    protocol: str
    @staticmethod
    def _from(obj: _winrt.Object) -> IWebSocketInformation: ...

class IWebSocketInformation2(_winrt.Object):
    server_certificate: typing.Optional[winsdk.windows.security.cryptography.certificates.Certificate]
    server_certificate_error_severity: SocketSslErrorSeverity
    server_certificate_errors: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.security.cryptography.certificates.ChainValidationResult]]
    server_intermediate_certificates: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.security.cryptography.certificates.Certificate]]
    bandwidth_statistics: BandwidthStatistics
    local_address: typing.Optional[winsdk.windows.networking.HostName]
    protocol: str
    @staticmethod
    def _from(obj: _winrt.Object) -> IWebSocketInformation2: ...

