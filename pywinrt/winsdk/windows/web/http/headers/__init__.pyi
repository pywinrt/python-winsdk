# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.5

import sys
import types
import typing
import uuid

import winsdk._winrt as _winrt
import winsdk.windows.foundation
import winsdk.windows.foundation.collections
import winsdk.windows.globalization
import winsdk.windows.networking
import winsdk.windows.storage.streams
import winsdk.windows.web.http

Self = typing.TypeVar('Self')

class HttpCacheDirectiveHeaderValueCollection(_winrt.Object, typing.MutableSequence[HttpNameValueHeaderValue]):
    size: _winrt.UInt32
    shared_max_age: typing.Optional[typing.Optional[winsdk.windows.foundation.TimeSpan]]
    min_fresh: typing.Optional[typing.Optional[winsdk.windows.foundation.TimeSpan]]
    max_stale: typing.Optional[typing.Optional[winsdk.windows.foundation.TimeSpan]]
    max_age: typing.Optional[typing.Optional[winsdk.windows.foundation.TimeSpan]]
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> HttpNameValueHeaderValue: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.MutableSequence[HttpNameValueHeaderValue]: ...
    def insert(self, index: int, value: HttpNameValueHeaderValue) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: HttpNameValueHeaderValue) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[HttpNameValueHeaderValue]) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpCacheDirectiveHeaderValueCollection: ...
    def append(self, value: typing.Optional[HttpNameValueHeaderValue]) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[HttpNameValueHeaderValue]]: ...
    def get_at(self, index: _winrt.UInt32) -> typing.Optional[HttpNameValueHeaderValue]: ...
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpNameValueHeaderValue]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[HttpNameValueHeaderValue]]: ...
    def index_of(self, value: typing.Optional[HttpNameValueHeaderValue]) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    def insert_at(self, index: _winrt.UInt32, value: typing.Optional[HttpNameValueHeaderValue]) -> None: ...
    def parse_add(self, input: str) -> None: ...
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Sequence[HttpNameValueHeaderValue]) -> None: ...
    def set_at(self, index: _winrt.UInt32, value: typing.Optional[HttpNameValueHeaderValue]) -> None: ...
    def to_string(self) -> str: ...
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpChallengeHeaderValue(_winrt.Object):
    parameters: typing.Optional[winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue]]
    scheme: str
    token: str
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpChallengeHeaderValue: ...
    @typing.overload
    def __init__(self, scheme: str) -> None: ...
    @typing.overload
    def __init__(self, scheme: str, token: str) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpChallengeHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpChallengeHeaderValue]]: ...

class HttpChallengeHeaderValueCollection(_winrt.Object, typing.MutableSequence[HttpChallengeHeaderValue]):
    size: _winrt.UInt32
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> HttpChallengeHeaderValue: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.MutableSequence[HttpChallengeHeaderValue]: ...
    def insert(self, index: int, value: HttpChallengeHeaderValue) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: HttpChallengeHeaderValue) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[HttpChallengeHeaderValue]) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpChallengeHeaderValueCollection: ...
    def append(self, value: typing.Optional[HttpChallengeHeaderValue]) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[HttpChallengeHeaderValue]]: ...
    def get_at(self, index: _winrt.UInt32) -> typing.Optional[HttpChallengeHeaderValue]: ...
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpChallengeHeaderValue]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[HttpChallengeHeaderValue]]: ...
    def index_of(self, value: typing.Optional[HttpChallengeHeaderValue]) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    def insert_at(self, index: _winrt.UInt32, value: typing.Optional[HttpChallengeHeaderValue]) -> None: ...
    def parse_add(self, input: str) -> None: ...
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Sequence[HttpChallengeHeaderValue]) -> None: ...
    def set_at(self, index: _winrt.UInt32, value: typing.Optional[HttpChallengeHeaderValue]) -> None: ...
    def to_string(self) -> str: ...
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpConnectionOptionHeaderValue(_winrt.Object):
    token: str
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpConnectionOptionHeaderValue: ...
    def __init__(self, token: str) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpConnectionOptionHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpConnectionOptionHeaderValue]]: ...

class HttpConnectionOptionHeaderValueCollection(_winrt.Object, typing.MutableSequence[HttpConnectionOptionHeaderValue]):
    size: _winrt.UInt32
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> HttpConnectionOptionHeaderValue: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.MutableSequence[HttpConnectionOptionHeaderValue]: ...
    def insert(self, index: int, value: HttpConnectionOptionHeaderValue) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: HttpConnectionOptionHeaderValue) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[HttpConnectionOptionHeaderValue]) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpConnectionOptionHeaderValueCollection: ...
    def append(self, value: typing.Optional[HttpConnectionOptionHeaderValue]) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[HttpConnectionOptionHeaderValue]]: ...
    def get_at(self, index: _winrt.UInt32) -> typing.Optional[HttpConnectionOptionHeaderValue]: ...
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpConnectionOptionHeaderValue]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[HttpConnectionOptionHeaderValue]]: ...
    def index_of(self, value: typing.Optional[HttpConnectionOptionHeaderValue]) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    def insert_at(self, index: _winrt.UInt32, value: typing.Optional[HttpConnectionOptionHeaderValue]) -> None: ...
    def parse_add(self, input: str) -> None: ...
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Sequence[HttpConnectionOptionHeaderValue]) -> None: ...
    def set_at(self, index: _winrt.UInt32, value: typing.Optional[HttpConnectionOptionHeaderValue]) -> None: ...
    def to_string(self) -> str: ...
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpContentCodingHeaderValue(_winrt.Object):
    content_coding: str
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpContentCodingHeaderValue: ...
    def __init__(self, content_coding: str) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpContentCodingHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpContentCodingHeaderValue]]: ...

class HttpContentCodingHeaderValueCollection(_winrt.Object, typing.MutableSequence[HttpContentCodingHeaderValue]):
    size: _winrt.UInt32
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> HttpContentCodingHeaderValue: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.MutableSequence[HttpContentCodingHeaderValue]: ...
    def insert(self, index: int, value: HttpContentCodingHeaderValue) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: HttpContentCodingHeaderValue) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[HttpContentCodingHeaderValue]) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpContentCodingHeaderValueCollection: ...
    def append(self, value: typing.Optional[HttpContentCodingHeaderValue]) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[HttpContentCodingHeaderValue]]: ...
    def get_at(self, index: _winrt.UInt32) -> typing.Optional[HttpContentCodingHeaderValue]: ...
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpContentCodingHeaderValue]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[HttpContentCodingHeaderValue]]: ...
    def index_of(self, value: typing.Optional[HttpContentCodingHeaderValue]) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    def insert_at(self, index: _winrt.UInt32, value: typing.Optional[HttpContentCodingHeaderValue]) -> None: ...
    def parse_add(self, input: str) -> None: ...
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Sequence[HttpContentCodingHeaderValue]) -> None: ...
    def set_at(self, index: _winrt.UInt32, value: typing.Optional[HttpContentCodingHeaderValue]) -> None: ...
    def to_string(self) -> str: ...
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpContentCodingWithQualityHeaderValue(_winrt.Object):
    content_coding: str
    quality: typing.Optional[typing.Optional[_winrt.Double]]
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpContentCodingWithQualityHeaderValue: ...
    @typing.overload
    def __init__(self, content_coding: str) -> None: ...
    @typing.overload
    def __init__(self, content_coding: str, quality: _winrt.Double) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpContentCodingWithQualityHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpContentCodingWithQualityHeaderValue]]: ...

class HttpContentCodingWithQualityHeaderValueCollection(_winrt.Object, typing.MutableSequence[HttpContentCodingWithQualityHeaderValue]):
    size: _winrt.UInt32
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> HttpContentCodingWithQualityHeaderValue: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.MutableSequence[HttpContentCodingWithQualityHeaderValue]: ...
    def insert(self, index: int, value: HttpContentCodingWithQualityHeaderValue) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: HttpContentCodingWithQualityHeaderValue) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[HttpContentCodingWithQualityHeaderValue]) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpContentCodingWithQualityHeaderValueCollection: ...
    def append(self, value: typing.Optional[HttpContentCodingWithQualityHeaderValue]) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[HttpContentCodingWithQualityHeaderValue]]: ...
    def get_at(self, index: _winrt.UInt32) -> typing.Optional[HttpContentCodingWithQualityHeaderValue]: ...
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpContentCodingWithQualityHeaderValue]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[HttpContentCodingWithQualityHeaderValue]]: ...
    def index_of(self, value: typing.Optional[HttpContentCodingWithQualityHeaderValue]) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    def insert_at(self, index: _winrt.UInt32, value: typing.Optional[HttpContentCodingWithQualityHeaderValue]) -> None: ...
    def parse_add(self, input: str) -> None: ...
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Sequence[HttpContentCodingWithQualityHeaderValue]) -> None: ...
    def set_at(self, index: _winrt.UInt32, value: typing.Optional[HttpContentCodingWithQualityHeaderValue]) -> None: ...
    def to_string(self) -> str: ...
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpContentDispositionHeaderValue(_winrt.Object):
    size: typing.Optional[typing.Optional[_winrt.UInt64]]
    name: str
    file_name_star: str
    file_name: str
    disposition_type: str
    parameters: typing.Optional[winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue]]
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpContentDispositionHeaderValue: ...
    def __init__(self, disposition_type: str) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpContentDispositionHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpContentDispositionHeaderValue]]: ...

class HttpContentHeaderCollection(_winrt.Object, typing.MutableMapping[str, str]):
    size: _winrt.UInt32
    last_modified: typing.Optional[typing.Optional[winsdk.windows.foundation.DateTime]]
    expires: typing.Optional[typing.Optional[winsdk.windows.foundation.DateTime]]
    content_type: typing.Optional[HttpMediaTypeHeaderValue]
    content_range: typing.Optional[HttpContentRangeHeaderValue]
    content_m_d5: typing.Optional[winsdk.windows.storage.streams.IBuffer]
    content_location: typing.Optional[winsdk.windows.foundation.Uri]
    content_length: typing.Optional[typing.Optional[_winrt.UInt64]]
    content_disposition: typing.Optional[HttpContentDispositionHeaderValue]
    content_encoding: typing.Optional[HttpContentCodingHeaderValueCollection]
    content_language: typing.Optional[HttpLanguageHeaderValueCollection]
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool:...
    def __setitem__(self, key: str, value: str) -> None: ...
    def __getitem__(self, key: str) -> str: ...
    def __delitem__(self, key: str) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpContentHeaderCollection: ...
    def __init__(self) -> None: ...
    def append(self, name: str, value: str) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[winsdk.windows.foundation.collections.IKeyValuePair[str, str]]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IMapView[str, str]]: ...
    def has_key(self, key: str) -> _winrt.Boolean: ...
    def insert(self, key: str, value: str) -> _winrt.Boolean: ...
    def lookup(self, key: str) -> str: ...
    def remove(self, key: str) -> None: ...
    def to_string(self) -> str: ...
    def try_append_without_validation(self, name: str, value: str) -> _winrt.Boolean: ...

class HttpContentRangeHeaderValue(_winrt.Object):
    unit: str
    first_byte_position: typing.Optional[typing.Optional[_winrt.UInt64]]
    last_byte_position: typing.Optional[typing.Optional[_winrt.UInt64]]
    length: typing.Optional[typing.Optional[_winrt.UInt64]]
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpContentRangeHeaderValue: ...
    @typing.overload
    def __init__(self, length: _winrt.UInt64) -> None: ...
    @typing.overload
    def __init__(self, from_: _winrt.UInt64, to: _winrt.UInt64) -> None: ...
    @typing.overload
    def __init__(self, from_: _winrt.UInt64, to: _winrt.UInt64, length: _winrt.UInt64) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpContentRangeHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpContentRangeHeaderValue]]: ...

class HttpCookiePairHeaderValue(_winrt.Object):
    value: str
    name: str
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpCookiePairHeaderValue: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, value: str) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpCookiePairHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpCookiePairHeaderValue]]: ...

class HttpCookiePairHeaderValueCollection(_winrt.Object, typing.MutableSequence[HttpCookiePairHeaderValue]):
    size: _winrt.UInt32
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> HttpCookiePairHeaderValue: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.MutableSequence[HttpCookiePairHeaderValue]: ...
    def insert(self, index: int, value: HttpCookiePairHeaderValue) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: HttpCookiePairHeaderValue) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[HttpCookiePairHeaderValue]) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpCookiePairHeaderValueCollection: ...
    def append(self, value: typing.Optional[HttpCookiePairHeaderValue]) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[HttpCookiePairHeaderValue]]: ...
    def get_at(self, index: _winrt.UInt32) -> typing.Optional[HttpCookiePairHeaderValue]: ...
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpCookiePairHeaderValue]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[HttpCookiePairHeaderValue]]: ...
    def index_of(self, value: typing.Optional[HttpCookiePairHeaderValue]) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    def insert_at(self, index: _winrt.UInt32, value: typing.Optional[HttpCookiePairHeaderValue]) -> None: ...
    def parse_add(self, input: str) -> None: ...
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Sequence[HttpCookiePairHeaderValue]) -> None: ...
    def set_at(self, index: _winrt.UInt32, value: typing.Optional[HttpCookiePairHeaderValue]) -> None: ...
    def to_string(self) -> str: ...
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpCredentialsHeaderValue(_winrt.Object):
    parameters: typing.Optional[winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue]]
    scheme: str
    token: str
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpCredentialsHeaderValue: ...
    @typing.overload
    def __init__(self, scheme: str) -> None: ...
    @typing.overload
    def __init__(self, scheme: str, token: str) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpCredentialsHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpCredentialsHeaderValue]]: ...

class HttpDateOrDeltaHeaderValue(_winrt.Object):
    date: typing.Optional[typing.Optional[winsdk.windows.foundation.DateTime]]
    delta: typing.Optional[typing.Optional[winsdk.windows.foundation.TimeSpan]]
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpDateOrDeltaHeaderValue: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpDateOrDeltaHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpDateOrDeltaHeaderValue]]: ...

class HttpExpectationHeaderValue(_winrt.Object):
    value: str
    name: str
    parameters: typing.Optional[winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue]]
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpExpectationHeaderValue: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, value: str) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpExpectationHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpExpectationHeaderValue]]: ...

class HttpExpectationHeaderValueCollection(_winrt.Object, typing.MutableSequence[HttpExpectationHeaderValue]):
    size: _winrt.UInt32
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> HttpExpectationHeaderValue: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.MutableSequence[HttpExpectationHeaderValue]: ...
    def insert(self, index: int, value: HttpExpectationHeaderValue) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: HttpExpectationHeaderValue) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[HttpExpectationHeaderValue]) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpExpectationHeaderValueCollection: ...
    def append(self, value: typing.Optional[HttpExpectationHeaderValue]) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[HttpExpectationHeaderValue]]: ...
    def get_at(self, index: _winrt.UInt32) -> typing.Optional[HttpExpectationHeaderValue]: ...
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpExpectationHeaderValue]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[HttpExpectationHeaderValue]]: ...
    def index_of(self, value: typing.Optional[HttpExpectationHeaderValue]) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    def insert_at(self, index: _winrt.UInt32, value: typing.Optional[HttpExpectationHeaderValue]) -> None: ...
    def parse_add(self, input: str) -> None: ...
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Sequence[HttpExpectationHeaderValue]) -> None: ...
    def set_at(self, index: _winrt.UInt32, value: typing.Optional[HttpExpectationHeaderValue]) -> None: ...
    def to_string(self) -> str: ...
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpLanguageHeaderValueCollection(_winrt.Object, typing.MutableSequence[winsdk.windows.globalization.Language]):
    size: _winrt.UInt32
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> winsdk.windows.globalization.Language: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.MutableSequence[winsdk.windows.globalization.Language]: ...
    def insert(self, index: int, value: winsdk.windows.globalization.Language) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: winsdk.windows.globalization.Language) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winsdk.windows.globalization.Language]) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpLanguageHeaderValueCollection: ...
    def append(self, value: typing.Optional[winsdk.windows.globalization.Language]) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[winsdk.windows.globalization.Language]]: ...
    def get_at(self, index: _winrt.UInt32) -> typing.Optional[winsdk.windows.globalization.Language]: ...
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[winsdk.windows.globalization.Language]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.globalization.Language]]: ...
    def index_of(self, value: typing.Optional[winsdk.windows.globalization.Language]) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    def insert_at(self, index: _winrt.UInt32, value: typing.Optional[winsdk.windows.globalization.Language]) -> None: ...
    def parse_add(self, input: str) -> None: ...
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Sequence[winsdk.windows.globalization.Language]) -> None: ...
    def set_at(self, index: _winrt.UInt32, value: typing.Optional[winsdk.windows.globalization.Language]) -> None: ...
    def to_string(self) -> str: ...
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpLanguageRangeWithQualityHeaderValue(_winrt.Object):
    language_range: str
    quality: typing.Optional[typing.Optional[_winrt.Double]]
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpLanguageRangeWithQualityHeaderValue: ...
    @typing.overload
    def __init__(self, language_range: str) -> None: ...
    @typing.overload
    def __init__(self, language_range: str, quality: _winrt.Double) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpLanguageRangeWithQualityHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpLanguageRangeWithQualityHeaderValue]]: ...

class HttpLanguageRangeWithQualityHeaderValueCollection(_winrt.Object, typing.MutableSequence[HttpLanguageRangeWithQualityHeaderValue]):
    size: _winrt.UInt32
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> HttpLanguageRangeWithQualityHeaderValue: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.MutableSequence[HttpLanguageRangeWithQualityHeaderValue]: ...
    def insert(self, index: int, value: HttpLanguageRangeWithQualityHeaderValue) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: HttpLanguageRangeWithQualityHeaderValue) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[HttpLanguageRangeWithQualityHeaderValue]) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpLanguageRangeWithQualityHeaderValueCollection: ...
    def append(self, value: typing.Optional[HttpLanguageRangeWithQualityHeaderValue]) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[HttpLanguageRangeWithQualityHeaderValue]]: ...
    def get_at(self, index: _winrt.UInt32) -> typing.Optional[HttpLanguageRangeWithQualityHeaderValue]: ...
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpLanguageRangeWithQualityHeaderValue]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[HttpLanguageRangeWithQualityHeaderValue]]: ...
    def index_of(self, value: typing.Optional[HttpLanguageRangeWithQualityHeaderValue]) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    def insert_at(self, index: _winrt.UInt32, value: typing.Optional[HttpLanguageRangeWithQualityHeaderValue]) -> None: ...
    def parse_add(self, input: str) -> None: ...
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Sequence[HttpLanguageRangeWithQualityHeaderValue]) -> None: ...
    def set_at(self, index: _winrt.UInt32, value: typing.Optional[HttpLanguageRangeWithQualityHeaderValue]) -> None: ...
    def to_string(self) -> str: ...
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpMediaTypeHeaderValue(_winrt.Object):
    media_type: str
    char_set: str
    parameters: typing.Optional[winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue]]
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpMediaTypeHeaderValue: ...
    def __init__(self, media_type: str) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpMediaTypeHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpMediaTypeHeaderValue]]: ...

class HttpMediaTypeWithQualityHeaderValue(_winrt.Object):
    quality: typing.Optional[typing.Optional[_winrt.Double]]
    media_type: str
    char_set: str
    parameters: typing.Optional[winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue]]
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpMediaTypeWithQualityHeaderValue: ...
    @typing.overload
    def __init__(self, media_type: str) -> None: ...
    @typing.overload
    def __init__(self, media_type: str, quality: _winrt.Double) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpMediaTypeWithQualityHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpMediaTypeWithQualityHeaderValue]]: ...

class HttpMediaTypeWithQualityHeaderValueCollection(_winrt.Object, typing.MutableSequence[HttpMediaTypeWithQualityHeaderValue]):
    size: _winrt.UInt32
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> HttpMediaTypeWithQualityHeaderValue: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.MutableSequence[HttpMediaTypeWithQualityHeaderValue]: ...
    def insert(self, index: int, value: HttpMediaTypeWithQualityHeaderValue) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: HttpMediaTypeWithQualityHeaderValue) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[HttpMediaTypeWithQualityHeaderValue]) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpMediaTypeWithQualityHeaderValueCollection: ...
    def append(self, value: typing.Optional[HttpMediaTypeWithQualityHeaderValue]) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[HttpMediaTypeWithQualityHeaderValue]]: ...
    def get_at(self, index: _winrt.UInt32) -> typing.Optional[HttpMediaTypeWithQualityHeaderValue]: ...
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpMediaTypeWithQualityHeaderValue]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[HttpMediaTypeWithQualityHeaderValue]]: ...
    def index_of(self, value: typing.Optional[HttpMediaTypeWithQualityHeaderValue]) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    def insert_at(self, index: _winrt.UInt32, value: typing.Optional[HttpMediaTypeWithQualityHeaderValue]) -> None: ...
    def parse_add(self, input: str) -> None: ...
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Sequence[HttpMediaTypeWithQualityHeaderValue]) -> None: ...
    def set_at(self, index: _winrt.UInt32, value: typing.Optional[HttpMediaTypeWithQualityHeaderValue]) -> None: ...
    def to_string(self) -> str: ...
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpMethodHeaderValueCollection(_winrt.Object, typing.MutableSequence[winsdk.windows.web.http.HttpMethod]):
    size: _winrt.UInt32
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> winsdk.windows.web.http.HttpMethod: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.MutableSequence[winsdk.windows.web.http.HttpMethod]: ...
    def insert(self, index: int, value: winsdk.windows.web.http.HttpMethod) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: winsdk.windows.web.http.HttpMethod) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[winsdk.windows.web.http.HttpMethod]) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpMethodHeaderValueCollection: ...
    def append(self, value: typing.Optional[winsdk.windows.web.http.HttpMethod]) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[winsdk.windows.web.http.HttpMethod]]: ...
    def get_at(self, index: _winrt.UInt32) -> typing.Optional[winsdk.windows.web.http.HttpMethod]: ...
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[winsdk.windows.web.http.HttpMethod]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.web.http.HttpMethod]]: ...
    def index_of(self, value: typing.Optional[winsdk.windows.web.http.HttpMethod]) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    def insert_at(self, index: _winrt.UInt32, value: typing.Optional[winsdk.windows.web.http.HttpMethod]) -> None: ...
    def parse_add(self, input: str) -> None: ...
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Sequence[winsdk.windows.web.http.HttpMethod]) -> None: ...
    def set_at(self, index: _winrt.UInt32, value: typing.Optional[winsdk.windows.web.http.HttpMethod]) -> None: ...
    def to_string(self) -> str: ...
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpNameValueHeaderValue(_winrt.Object):
    value: str
    name: str
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpNameValueHeaderValue: ...
    @typing.overload
    def __init__(self, name: str) -> None: ...
    @typing.overload
    def __init__(self, name: str, value: str) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpNameValueHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpNameValueHeaderValue]]: ...

class HttpProductHeaderValue(_winrt.Object):
    name: str
    version: str
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpProductHeaderValue: ...
    @typing.overload
    def __init__(self, product_name: str) -> None: ...
    @typing.overload
    def __init__(self, product_name: str, product_version: str) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpProductHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpProductHeaderValue]]: ...

class HttpProductInfoHeaderValue(_winrt.Object):
    comment: str
    product: typing.Optional[HttpProductHeaderValue]
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpProductInfoHeaderValue: ...
    @typing.overload
    def __init__(self, product_comment: str) -> None: ...
    @typing.overload
    def __init__(self, product_name: str, product_version: str) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpProductInfoHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpProductInfoHeaderValue]]: ...

class HttpProductInfoHeaderValueCollection(_winrt.Object, typing.MutableSequence[HttpProductInfoHeaderValue]):
    size: _winrt.UInt32
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> HttpProductInfoHeaderValue: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.MutableSequence[HttpProductInfoHeaderValue]: ...
    def insert(self, index: int, value: HttpProductInfoHeaderValue) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: HttpProductInfoHeaderValue) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[HttpProductInfoHeaderValue]) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpProductInfoHeaderValueCollection: ...
    def append(self, value: typing.Optional[HttpProductInfoHeaderValue]) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[HttpProductInfoHeaderValue]]: ...
    def get_at(self, index: _winrt.UInt32) -> typing.Optional[HttpProductInfoHeaderValue]: ...
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpProductInfoHeaderValue]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[HttpProductInfoHeaderValue]]: ...
    def index_of(self, value: typing.Optional[HttpProductInfoHeaderValue]) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    def insert_at(self, index: _winrt.UInt32, value: typing.Optional[HttpProductInfoHeaderValue]) -> None: ...
    def parse_add(self, input: str) -> None: ...
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Sequence[HttpProductInfoHeaderValue]) -> None: ...
    def set_at(self, index: _winrt.UInt32, value: typing.Optional[HttpProductInfoHeaderValue]) -> None: ...
    def to_string(self) -> str: ...
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

class HttpRequestHeaderCollection(_winrt.Object, typing.MutableMapping[str, str]):
    size: _winrt.UInt32
    referer: typing.Optional[winsdk.windows.foundation.Uri]
    proxy_authorization: typing.Optional[HttpCredentialsHeaderValue]
    max_forwards: typing.Optional[typing.Optional[_winrt.UInt32]]
    if_unmodified_since: typing.Optional[typing.Optional[winsdk.windows.foundation.DateTime]]
    if_modified_since: typing.Optional[typing.Optional[winsdk.windows.foundation.DateTime]]
    host: typing.Optional[winsdk.windows.networking.HostName]
    from_: str
    date: typing.Optional[typing.Optional[winsdk.windows.foundation.DateTime]]
    authorization: typing.Optional[HttpCredentialsHeaderValue]
    accept: typing.Optional[HttpMediaTypeWithQualityHeaderValueCollection]
    accept_encoding: typing.Optional[HttpContentCodingWithQualityHeaderValueCollection]
    accept_language: typing.Optional[HttpLanguageRangeWithQualityHeaderValueCollection]
    cache_control: typing.Optional[HttpCacheDirectiveHeaderValueCollection]
    connection: typing.Optional[HttpConnectionOptionHeaderValueCollection]
    cookie: typing.Optional[HttpCookiePairHeaderValueCollection]
    expect: typing.Optional[HttpExpectationHeaderValueCollection]
    transfer_encoding: typing.Optional[HttpTransferCodingHeaderValueCollection]
    user_agent: typing.Optional[HttpProductInfoHeaderValueCollection]
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool:...
    def __setitem__(self, key: str, value: str) -> None: ...
    def __getitem__(self, key: str) -> str: ...
    def __delitem__(self, key: str) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpRequestHeaderCollection: ...
    def append(self, name: str, value: str) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[winsdk.windows.foundation.collections.IKeyValuePair[str, str]]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IMapView[str, str]]: ...
    def has_key(self, key: str) -> _winrt.Boolean: ...
    def insert(self, key: str, value: str) -> _winrt.Boolean: ...
    def lookup(self, key: str) -> str: ...
    def remove(self, key: str) -> None: ...
    def to_string(self) -> str: ...
    def try_append_without_validation(self, name: str, value: str) -> _winrt.Boolean: ...

class HttpResponseHeaderCollection(_winrt.Object, typing.MutableMapping[str, str]):
    size: _winrt.UInt32
    retry_after: typing.Optional[HttpDateOrDeltaHeaderValue]
    location: typing.Optional[winsdk.windows.foundation.Uri]
    date: typing.Optional[typing.Optional[winsdk.windows.foundation.DateTime]]
    age: typing.Optional[typing.Optional[winsdk.windows.foundation.TimeSpan]]
    allow: typing.Optional[HttpMethodHeaderValueCollection]
    cache_control: typing.Optional[HttpCacheDirectiveHeaderValueCollection]
    connection: typing.Optional[HttpConnectionOptionHeaderValueCollection]
    proxy_authenticate: typing.Optional[HttpChallengeHeaderValueCollection]
    transfer_encoding: typing.Optional[HttpTransferCodingHeaderValueCollection]
    www_authenticate: typing.Optional[HttpChallengeHeaderValueCollection]
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    def __iter__(self) -> typing.Iterator[str]: ...
    def __contains__(self, key: object) -> bool:...
    def __setitem__(self, key: str, value: str) -> None: ...
    def __getitem__(self, key: str) -> str: ...
    def __delitem__(self, key: str) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpResponseHeaderCollection: ...
    def append(self, name: str, value: str) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[winsdk.windows.foundation.collections.IKeyValuePair[str, str]]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IMapView[str, str]]: ...
    def has_key(self, key: str) -> _winrt.Boolean: ...
    def insert(self, key: str, value: str) -> _winrt.Boolean: ...
    def lookup(self, key: str) -> str: ...
    def remove(self, key: str) -> None: ...
    def to_string(self) -> str: ...
    def try_append_without_validation(self, name: str, value: str) -> _winrt.Boolean: ...

class HttpTransferCodingHeaderValue(_winrt.Object):
    parameters: typing.Optional[winsdk.windows.foundation.collections.IVector[HttpNameValueHeaderValue]]
    value: str
    def __str__(self) -> str: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpTransferCodingHeaderValue: ...
    def __init__(self, input: str) -> None: ...
    @staticmethod
    def parse(input: str) -> typing.Optional[HttpTransferCodingHeaderValue]: ...
    def to_string(self) -> str: ...
    @staticmethod
    def try_parse(input: str) -> typing.Tuple[_winrt.Boolean, typing.Optional[HttpTransferCodingHeaderValue]]: ...

class HttpTransferCodingHeaderValueCollection(_winrt.Object, typing.MutableSequence[HttpTransferCodingHeaderValue]):
    size: _winrt.UInt32
    def __str__(self) -> str: ...
    def __len__(self) -> int: ...
    @typing.overload
    def __getitem__(self, index: int) -> HttpTransferCodingHeaderValue: ...
    @typing.overload
    def __getitem__(self, index: slice) -> typing.MutableSequence[HttpTransferCodingHeaderValue]: ...
    def insert(self, index: int, value: HttpTransferCodingHeaderValue) -> None: ...
    @typing.overload
    def __delitem__(self, index: int) -> None: ...
    @typing.overload
    def __delitem__(self, index: slice) -> None: ...
    @typing.overload
    def __setitem__(self, index: int, value: HttpTransferCodingHeaderValue) -> None: ...
    @typing.overload
    def __setitem__(self, index: slice, value: typing.Iterable[HttpTransferCodingHeaderValue]) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> HttpTransferCodingHeaderValueCollection: ...
    def append(self, value: typing.Optional[HttpTransferCodingHeaderValue]) -> None: ...
    def clear(self) -> None: ...
    def first(self) -> typing.Optional[winsdk.windows.foundation.collections.IIterator[HttpTransferCodingHeaderValue]]: ...
    def get_at(self, index: _winrt.UInt32) -> typing.Optional[HttpTransferCodingHeaderValue]: ...
    def get_many(self, start_index: _winrt.UInt32, items_size: _winrt.UInt32) -> typing.Tuple[_winrt.UInt32, typing.List[HttpTransferCodingHeaderValue]]: ...
    def get_view(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[HttpTransferCodingHeaderValue]]: ...
    def index_of(self, value: typing.Optional[HttpTransferCodingHeaderValue]) -> typing.Tuple[_winrt.Boolean, _winrt.UInt32]: ...
    def insert_at(self, index: _winrt.UInt32, value: typing.Optional[HttpTransferCodingHeaderValue]) -> None: ...
    def parse_add(self, input: str) -> None: ...
    def remove_at(self, index: _winrt.UInt32) -> None: ...
    def remove_at_end(self) -> None: ...
    def replace_all(self, items: typing.Sequence[HttpTransferCodingHeaderValue]) -> None: ...
    def set_at(self, index: _winrt.UInt32, value: typing.Optional[HttpTransferCodingHeaderValue]) -> None: ...
    def to_string(self) -> str: ...
    def try_parse_add(self, input: str) -> _winrt.Boolean: ...

