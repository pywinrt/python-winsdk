# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.3

import enum
import sys
import types
import typing
import uuid

import winsdk._winrt as _winrt

try:
    import winsdk.windows.applicationmodel.activation
except Exception:
    pass

try:
    import winsdk.windows.applicationmodel.calls.background
except Exception:
    pass

try:
    import winsdk.windows.devices.bluetooth
except Exception:
    pass

try:
    import winsdk.windows.devices.bluetooth.advertisement
except Exception:
    pass

try:
    import winsdk.windows.devices.bluetooth.background
except Exception:
    pass

try:
    import winsdk.windows.devices.bluetooth.genericattributeprofile
except Exception:
    pass

try:
    import winsdk.windows.devices.geolocation
except Exception:
    pass

try:
    import winsdk.windows.devices.sensors
except Exception:
    pass

try:
    import winsdk.windows.devices.smartcards
except Exception:
    pass

try:
    import winsdk.windows.devices.sms
except Exception:
    pass

try:
    import winsdk.windows.foundation
except Exception:
    pass

try:
    import winsdk.windows.foundation.collections
except Exception:
    pass

try:
    import winsdk.windows.networking
except Exception:
    pass

try:
    import winsdk.windows.networking.sockets
except Exception:
    pass

try:
    import winsdk.windows.storage
except Exception:
    pass

try:
    import winsdk.windows.storage.provider
except Exception:
    pass

try:
    import winsdk.windows.system
except Exception:
    pass

try:
    import winsdk.windows.ui.notifications
except Exception:
    pass

class ApplicationTriggerResult(enum.IntEnum):
    ALLOWED = 0
    CURRENTLY_RUNNING = 1
    DISABLED_BY_POLICY = 2
    UNKNOWN_ERROR = 3

class BackgroundAccessRequestKind(enum.IntEnum):
    ALWAYS_ALLOWED = 0
    ALLOWED_SUBJECT_TO_SYSTEM_POLICY = 1

class BackgroundAccessStatus(enum.IntEnum):
    UNSPECIFIED = 0
    ALLOWED_WITH_ALWAYS_ON_REAL_TIME_CONNECTIVITY = 1
    ALLOWED_MAY_USE_ACTIVE_REAL_TIME_CONNECTIVITY = 2
    DENIED = 3
    ALWAYS_ALLOWED = 4
    ALLOWED_SUBJECT_TO_SYSTEM_POLICY = 5
    DENIED_BY_SYSTEM_POLICY = 6
    DENIED_BY_USER = 7

class BackgroundTaskCancellationReason(enum.IntEnum):
    ABORT = 0
    TERMINATING = 1
    LOGGING_OFF = 2
    SERVICING_UPDATE = 3
    IDLE_TASK = 4
    UNINSTALL = 5
    CONDITION_LOSS = 6
    SYSTEM_POLICY = 7
    QUIET_HOURS_ENTERED = 8
    EXECUTION_TIME_EXCEEDED = 9
    RESOURCE_REVOCATION = 10
    ENERGY_SAVER = 11

class BackgroundTaskThrottleCounter(enum.IntEnum):
    ALL = 0
    CPU = 1
    NETWORK = 2

class BackgroundWorkCostValue(enum.IntEnum):
    LOW = 0
    MEDIUM = 1
    HIGH = 2

class CustomSystemEventTriggerRecurrence(enum.IntEnum):
    ONCE = 0
    ALWAYS = 1

class DeviceTriggerResult(enum.IntEnum):
    ALLOWED = 0
    DENIED_BY_USER = 1
    DENIED_BY_SYSTEM = 2
    LOW_BATTERY = 3

class LocationTriggerType(enum.IntEnum):
    GEOFENCE = 0

class MediaProcessingTriggerResult(enum.IntEnum):
    ALLOWED = 0
    CURRENTLY_RUNNING = 1
    DISABLED_BY_POLICY = 2
    UNKNOWN_ERROR = 3

class SystemConditionType(enum.IntEnum):
    INVALID = 0
    USER_PRESENT = 1
    USER_NOT_PRESENT = 2
    INTERNET_AVAILABLE = 3
    INTERNET_NOT_AVAILABLE = 4
    SESSION_CONNECTED = 5
    SESSION_DISCONNECTED = 6
    FREE_NETWORK_AVAILABLE = 7
    BACKGROUND_WORK_COST_NOT_HIGH = 8

class SystemTriggerType(enum.IntEnum):
    INVALID = 0
    SMS_RECEIVED = 1
    USER_PRESENT = 2
    USER_AWAY = 3
    NETWORK_STATE_CHANGE = 4
    CONTROL_CHANNEL_RESET = 5
    INTERNET_AVAILABLE = 6
    SESSION_CONNECTED = 7
    SERVICING_COMPLETE = 8
    LOCK_SCREEN_APPLICATION_ADDED = 9
    LOCK_SCREEN_APPLICATION_REMOVED = 10
    TIME_ZONE_CHANGE = 11
    ONLINE_ID_CONNECTED_STATE_CHANGE = 12
    BACKGROUND_WORK_COST_CHANGE = 13
    POWER_STATE_CHANGE = 14
    DEFAULT_SIGN_IN_ACCOUNT_CHANGE = 15

class ActivitySensorTrigger(IBackgroundTrigger, _winrt.Object):
    minimum_report_interval: _winrt.UInt32
    report_interval: _winrt.UInt32
    subscribed_activities: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.devices.sensors.ActivityType]]
    supported_activities: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.devices.sensors.ActivityType]]
    @staticmethod
    def _from(obj: _winrt.Object) -> ActivitySensorTrigger: ...
    def __init__(self, report_interval_in_milliseconds: _winrt.UInt32) -> None: ...

class ApplicationTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ApplicationTrigger: ...
    def __init__(self) -> None: ...
    @typing.overload
    def request_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[ApplicationTriggerResult]]: ...
    @typing.overload
    def request_async(self, arguments: typing.Optional[winsdk.windows.foundation.collections.ValueSet]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[ApplicationTriggerResult]]: ...

class ApplicationTriggerDetails(_winrt.Object):
    arguments: typing.Optional[winsdk.windows.foundation.collections.ValueSet]
    @staticmethod
    def _from(obj: _winrt.Object) -> ApplicationTriggerDetails: ...

class AppointmentStoreNotificationTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> AppointmentStoreNotificationTrigger: ...
    def __init__(self) -> None: ...

class BackgroundExecutionManager(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundExecutionManager: ...
    @typing.overload
    @staticmethod
    def get_access_status() -> BackgroundAccessStatus: ...
    @typing.overload
    @staticmethod
    def get_access_status(application_id: str) -> BackgroundAccessStatus: ...
    @typing.overload
    @staticmethod
    def get_access_status_for_modern_standby() -> BackgroundAccessStatus: ...
    @typing.overload
    @staticmethod
    def get_access_status_for_modern_standby(application_id: str) -> BackgroundAccessStatus: ...
    @typing.overload
    @staticmethod
    def remove_access() -> None: ...
    @typing.overload
    @staticmethod
    def remove_access(application_id: str) -> None: ...
    @typing.overload
    @staticmethod
    def request_access_async() -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[BackgroundAccessStatus]]: ...
    @typing.overload
    @staticmethod
    def request_access_async(application_id: str) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[BackgroundAccessStatus]]: ...
    @staticmethod
    def request_access_kind_async(requested_access: BackgroundAccessRequestKind, reason: str) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[_winrt.Boolean]]: ...
    @staticmethod
    def request_access_kind_for_modern_standby_async(requested_access: BackgroundAccessRequestKind, reason: str) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[_winrt.Boolean]]: ...

class BackgroundTaskBuilder(_winrt.Object):
    task_entry_point: str
    name: str
    cancel_on_condition_loss: _winrt.Boolean
    is_network_requested: _winrt.Boolean
    task_group: typing.Optional[BackgroundTaskRegistrationGroup]
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundTaskBuilder: ...
    def __init__(self) -> None: ...
    def add_condition(self, condition: typing.Optional[IBackgroundCondition]) -> None: ...
    def register(self) -> typing.Optional[BackgroundTaskRegistration]: ...
    def set_task_entry_point_clsid(self, task_entry_point: uuid.UUID) -> None: ...
    def set_trigger(self, trigger: typing.Optional[IBackgroundTrigger]) -> None: ...

class BackgroundTaskCompletedEventArgs(_winrt.Object):
    instance_id: uuid.UUID
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundTaskCompletedEventArgs: ...
    def check_result(self) -> None: ...

class BackgroundTaskDeferral(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundTaskDeferral: ...
    def complete(self) -> None: ...

class BackgroundTaskProgressEventArgs(_winrt.Object):
    instance_id: uuid.UUID
    progress: _winrt.UInt32
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundTaskProgressEventArgs: ...

class BackgroundTaskRegistration(IBackgroundTaskRegistration, IBackgroundTaskRegistration2, IBackgroundTaskRegistration3, _winrt.Object):
    name: str
    task_id: uuid.UUID
    trigger: typing.Optional[IBackgroundTrigger]
    task_group: typing.Optional[BackgroundTaskRegistrationGroup]
    all_tasks: typing.Optional[winsdk.windows.foundation.collections.IMapView[uuid.UUID, IBackgroundTaskRegistration]]
    all_task_groups: typing.Optional[winsdk.windows.foundation.collections.IMapView[str, BackgroundTaskRegistrationGroup]]
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundTaskRegistration: ...
    @staticmethod
    def get_task_group(group_id: str) -> typing.Optional[BackgroundTaskRegistrationGroup]: ...
    def unregister(self, cancel_task: _winrt.Boolean) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class BackgroundTaskRegistrationGroup(_winrt.Object):
    all_tasks: typing.Optional[winsdk.windows.foundation.collections.IMapView[uuid.UUID, BackgroundTaskRegistration]]
    id: str
    name: str
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundTaskRegistrationGroup: ...
    @typing.overload
    def __init__(self, id: str) -> None: ...
    @typing.overload
    def __init__(self, id: str, name: str) -> None: ...
    def add_background_activated(self, handler: winsdk.windows.foundation.TypedEventHandler[BackgroundTaskRegistrationGroup, winsdk.windows.applicationmodel.activation.BackgroundActivatedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_background_activated(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class BackgroundWorkCost(_winrt.Object):
    current_background_work_cost: BackgroundWorkCostValue
    @staticmethod
    def _from(obj: _winrt.Object) -> BackgroundWorkCost: ...

class BluetoothLEAdvertisementPublisherTrigger(IBackgroundTrigger, _winrt.Object):
    advertisement: typing.Optional[winsdk.windows.devices.bluetooth.advertisement.BluetoothLEAdvertisement]
    use_extended_format: _winrt.Boolean
    preferred_transmit_power_level_in_d_bm: typing.Optional[typing.Optional[_winrt.Int16]]
    is_anonymous: _winrt.Boolean
    include_transmit_power_level: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> BluetoothLEAdvertisementPublisherTrigger: ...
    def __init__(self) -> None: ...

class BluetoothLEAdvertisementWatcherTrigger(IBackgroundTrigger, _winrt.Object):
    signal_strength_filter: typing.Optional[winsdk.windows.devices.bluetooth.BluetoothSignalStrengthFilter]
    advertisement_filter: typing.Optional[winsdk.windows.devices.bluetooth.advertisement.BluetoothLEAdvertisementFilter]
    max_out_of_range_timeout: winsdk.windows.foundation.TimeSpan
    max_sampling_interval: winsdk.windows.foundation.TimeSpan
    min_out_of_range_timeout: winsdk.windows.foundation.TimeSpan
    min_sampling_interval: winsdk.windows.foundation.TimeSpan
    allow_extended_advertisements: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> BluetoothLEAdvertisementWatcherTrigger: ...
    def __init__(self) -> None: ...

class CachedFileUpdaterTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> CachedFileUpdaterTrigger: ...
    def __init__(self) -> None: ...

class CachedFileUpdaterTriggerDetails(_winrt.Object):
    can_request_user_input: _winrt.Boolean
    update_request: typing.Optional[winsdk.windows.storage.provider.FileUpdateRequest]
    update_target: winsdk.windows.storage.provider.CachedFileTarget
    @staticmethod
    def _from(obj: _winrt.Object) -> CachedFileUpdaterTriggerDetails: ...

class ChatMessageNotificationTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ChatMessageNotificationTrigger: ...
    def __init__(self) -> None: ...

class ChatMessageReceivedNotificationTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ChatMessageReceivedNotificationTrigger: ...
    def __init__(self) -> None: ...

class CommunicationBlockingAppSetAsActiveTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> CommunicationBlockingAppSetAsActiveTrigger: ...
    def __init__(self) -> None: ...

class ContactStoreNotificationTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ContactStoreNotificationTrigger: ...
    def __init__(self) -> None: ...

class ContentPrefetchTrigger(IBackgroundTrigger, _winrt.Object):
    wait_interval: winsdk.windows.foundation.TimeSpan
    @staticmethod
    def _from(obj: _winrt.Object) -> ContentPrefetchTrigger: ...
    @typing.overload
    def __init__(self, wait_interval: winsdk.windows.foundation.TimeSpan) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...

class ConversationalAgentTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ConversationalAgentTrigger: ...
    def __init__(self) -> None: ...

class CustomSystemEventTrigger(IBackgroundTrigger, _winrt.Object):
    recurrence: CustomSystemEventTriggerRecurrence
    trigger_id: str
    @staticmethod
    def _from(obj: _winrt.Object) -> CustomSystemEventTrigger: ...
    def __init__(self, trigger_id: str, recurrence: CustomSystemEventTriggerRecurrence) -> None: ...

class DeviceConnectionChangeTrigger(IBackgroundTrigger, _winrt.Object):
    maintain_connection: _winrt.Boolean
    can_maintain_connection: _winrt.Boolean
    device_id: str
    @staticmethod
    def _from(obj: _winrt.Object) -> DeviceConnectionChangeTrigger: ...
    @staticmethod
    def from_id_async(device_id: str) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[DeviceConnectionChangeTrigger]]: ...

class DeviceManufacturerNotificationTrigger(IBackgroundTrigger, _winrt.Object):
    one_shot: _winrt.Boolean
    trigger_qualifier: str
    @staticmethod
    def _from(obj: _winrt.Object) -> DeviceManufacturerNotificationTrigger: ...
    def __init__(self, trigger_qualifier: str, one_shot: _winrt.Boolean) -> None: ...

class DeviceServicingTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> DeviceServicingTrigger: ...
    def __init__(self) -> None: ...
    @typing.overload
    def request_async(self, device_id: str, expected_duration: winsdk.windows.foundation.TimeSpan) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[DeviceTriggerResult]]: ...
    @typing.overload
    def request_async(self, device_id: str, expected_duration: winsdk.windows.foundation.TimeSpan, arguments: str) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[DeviceTriggerResult]]: ...

class DeviceUseTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> DeviceUseTrigger: ...
    def __init__(self) -> None: ...
    @typing.overload
    def request_async(self, device_id: str) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[DeviceTriggerResult]]: ...
    @typing.overload
    def request_async(self, device_id: str, arguments: str) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[DeviceTriggerResult]]: ...

class DeviceWatcherTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> DeviceWatcherTrigger: ...

class EmailStoreNotificationTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> EmailStoreNotificationTrigger: ...
    def __init__(self) -> None: ...

class GattCharacteristicNotificationTrigger(IBackgroundTrigger, _winrt.Object):
    characteristic: typing.Optional[winsdk.windows.devices.bluetooth.genericattributeprofile.GattCharacteristic]
    event_triggering_mode: winsdk.windows.devices.bluetooth.background.BluetoothEventTriggeringMode
    @staticmethod
    def _from(obj: _winrt.Object) -> GattCharacteristicNotificationTrigger: ...
    @typing.overload
    def __init__(self, characteristic: typing.Optional[winsdk.windows.devices.bluetooth.genericattributeprofile.GattCharacteristic], event_triggering_mode: winsdk.windows.devices.bluetooth.background.BluetoothEventTriggeringMode) -> None: ...
    @typing.overload
    def __init__(self, characteristic: typing.Optional[winsdk.windows.devices.bluetooth.genericattributeprofile.GattCharacteristic]) -> None: ...

class GattServiceProviderTrigger(IBackgroundTrigger, _winrt.Object):
    advertising_parameters: typing.Optional[winsdk.windows.devices.bluetooth.genericattributeprofile.GattServiceProviderAdvertisingParameters]
    service: typing.Optional[winsdk.windows.devices.bluetooth.genericattributeprofile.GattLocalService]
    trigger_id: str
    @staticmethod
    def _from(obj: _winrt.Object) -> GattServiceProviderTrigger: ...
    @staticmethod
    def create_async(trigger_id: str, service_uuid: uuid.UUID) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[GattServiceProviderTriggerResult]]: ...

class GattServiceProviderTriggerResult(_winrt.Object):
    error: winsdk.windows.devices.bluetooth.BluetoothError
    trigger: typing.Optional[GattServiceProviderTrigger]
    @staticmethod
    def _from(obj: _winrt.Object) -> GattServiceProviderTriggerResult: ...

class GeovisitTrigger(IBackgroundTrigger, _winrt.Object):
    monitoring_scope: winsdk.windows.devices.geolocation.VisitMonitoringScope
    @staticmethod
    def _from(obj: _winrt.Object) -> GeovisitTrigger: ...
    def __init__(self) -> None: ...

class LocationTrigger(IBackgroundTrigger, _winrt.Object):
    trigger_type: LocationTriggerType
    @staticmethod
    def _from(obj: _winrt.Object) -> LocationTrigger: ...
    def __init__(self, trigger_type: LocationTriggerType) -> None: ...

class MaintenanceTrigger(IBackgroundTrigger, _winrt.Object):
    freshness_time: _winrt.UInt32
    one_shot: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> MaintenanceTrigger: ...
    def __init__(self, freshness_time: _winrt.UInt32, one_shot: _winrt.Boolean) -> None: ...

class MediaProcessingTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> MediaProcessingTrigger: ...
    def __init__(self) -> None: ...
    @typing.overload
    def request_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[MediaProcessingTriggerResult]]: ...
    @typing.overload
    def request_async(self, arguments: typing.Optional[winsdk.windows.foundation.collections.ValueSet]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[MediaProcessingTriggerResult]]: ...

class MobileBroadbandDeviceServiceNotificationTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> MobileBroadbandDeviceServiceNotificationTrigger: ...
    def __init__(self) -> None: ...

class MobileBroadbandPcoDataChangeTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> MobileBroadbandPcoDataChangeTrigger: ...
    def __init__(self) -> None: ...

class MobileBroadbandPinLockStateChangeTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> MobileBroadbandPinLockStateChangeTrigger: ...
    def __init__(self) -> None: ...

class MobileBroadbandRadioStateChangeTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> MobileBroadbandRadioStateChangeTrigger: ...
    def __init__(self) -> None: ...

class MobileBroadbandRegistrationStateChangeTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> MobileBroadbandRegistrationStateChangeTrigger: ...
    def __init__(self) -> None: ...

class NetworkOperatorDataUsageTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> NetworkOperatorDataUsageTrigger: ...
    def __init__(self) -> None: ...

class NetworkOperatorHotspotAuthenticationTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> NetworkOperatorHotspotAuthenticationTrigger: ...
    def __init__(self) -> None: ...

class NetworkOperatorNotificationTrigger(IBackgroundTrigger, _winrt.Object):
    network_account_id: str
    @staticmethod
    def _from(obj: _winrt.Object) -> NetworkOperatorNotificationTrigger: ...
    def __init__(self, network_account_id: str) -> None: ...

class PaymentAppCanMakePaymentTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> PaymentAppCanMakePaymentTrigger: ...
    def __init__(self) -> None: ...

class PhoneTrigger(IBackgroundTrigger, _winrt.Object):
    one_shot: _winrt.Boolean
    trigger_type: winsdk.windows.applicationmodel.calls.background.PhoneTriggerType
    @staticmethod
    def _from(obj: _winrt.Object) -> PhoneTrigger: ...
    def __init__(self, type: winsdk.windows.applicationmodel.calls.background.PhoneTriggerType, one_shot: _winrt.Boolean) -> None: ...

class PushNotificationTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> PushNotificationTrigger: ...
    @typing.overload
    def __init__(self, application_id: str) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...

class RcsEndUserMessageAvailableTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> RcsEndUserMessageAvailableTrigger: ...
    def __init__(self) -> None: ...

class RfcommConnectionTrigger(IBackgroundTrigger, _winrt.Object):
    remote_host_name: typing.Optional[winsdk.windows.networking.HostName]
    protection_level: winsdk.windows.networking.sockets.SocketProtectionLevel
    allow_multiple_connections: _winrt.Boolean
    inbound_connection: typing.Optional[winsdk.windows.devices.bluetooth.background.RfcommInboundConnectionInformation]
    outbound_connection: typing.Optional[winsdk.windows.devices.bluetooth.background.RfcommOutboundConnectionInformation]
    @staticmethod
    def _from(obj: _winrt.Object) -> RfcommConnectionTrigger: ...
    def __init__(self) -> None: ...

class SecondaryAuthenticationFactorAuthenticationTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> SecondaryAuthenticationFactorAuthenticationTrigger: ...
    def __init__(self) -> None: ...

class SensorDataThresholdTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> SensorDataThresholdTrigger: ...
    def __init__(self, threshold: typing.Optional[winsdk.windows.devices.sensors.ISensorDataThreshold]) -> None: ...

class SmartCardTrigger(IBackgroundTrigger, _winrt.Object):
    trigger_type: winsdk.windows.devices.smartcards.SmartCardTriggerType
    @staticmethod
    def _from(obj: _winrt.Object) -> SmartCardTrigger: ...
    def __init__(self, trigger_type: winsdk.windows.devices.smartcards.SmartCardTriggerType) -> None: ...

class SmsMessageReceivedTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> SmsMessageReceivedTrigger: ...
    def __init__(self, filter_rules: typing.Optional[winsdk.windows.devices.sms.SmsFilterRules]) -> None: ...

class SocketActivityTrigger(IBackgroundTrigger, _winrt.Object):
    is_wake_from_low_power_supported: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> SocketActivityTrigger: ...
    def __init__(self) -> None: ...

class StorageLibraryChangeTrackerTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> StorageLibraryChangeTrackerTrigger: ...
    def __init__(self, tracker: typing.Optional[winsdk.windows.storage.StorageLibraryChangeTracker]) -> None: ...

class StorageLibraryContentChangedTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> StorageLibraryContentChangedTrigger: ...
    @staticmethod
    def create(storage_library: typing.Optional[winsdk.windows.storage.StorageLibrary]) -> typing.Optional[StorageLibraryContentChangedTrigger]: ...
    @staticmethod
    def create_from_libraries(storage_libraries: typing.Iterable[typing.Optional[winsdk.windows.storage.StorageLibrary]]) -> typing.Optional[StorageLibraryContentChangedTrigger]: ...

class SystemCondition(IBackgroundCondition, _winrt.Object):
    condition_type: SystemConditionType
    @staticmethod
    def _from(obj: _winrt.Object) -> SystemCondition: ...
    def __init__(self, condition_type: SystemConditionType) -> None: ...

class SystemTrigger(IBackgroundTrigger, _winrt.Object):
    one_shot: _winrt.Boolean
    trigger_type: SystemTriggerType
    @staticmethod
    def _from(obj: _winrt.Object) -> SystemTrigger: ...
    def __init__(self, trigger_type: SystemTriggerType, one_shot: _winrt.Boolean) -> None: ...

class TetheringEntitlementCheckTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> TetheringEntitlementCheckTrigger: ...
    def __init__(self) -> None: ...

class TimeTrigger(IBackgroundTrigger, _winrt.Object):
    freshness_time: _winrt.UInt32
    one_shot: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> TimeTrigger: ...
    def __init__(self, freshness_time: _winrt.UInt32, one_shot: _winrt.Boolean) -> None: ...

class ToastNotificationActionTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ToastNotificationActionTrigger: ...
    @typing.overload
    def __init__(self, application_id: str) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...

class ToastNotificationHistoryChangedTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> ToastNotificationHistoryChangedTrigger: ...
    @typing.overload
    def __init__(self, application_id: str) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...

class UserNotificationChangedTrigger(IBackgroundTrigger, _winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> UserNotificationChangedTrigger: ...
    def __init__(self, notification_kinds: winsdk.windows.ui.notifications.NotificationKinds) -> None: ...

class IBackgroundCondition(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundCondition: ...

class IBackgroundTask(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTask: ...
    def run(self, task_instance: typing.Optional[IBackgroundTaskInstance]) -> None: ...

class IBackgroundTaskInstance(_winrt.Object):
    instance_id: uuid.UUID
    progress: _winrt.UInt32
    suspended_count: _winrt.UInt32
    task: typing.Optional[BackgroundTaskRegistration]
    trigger_details: typing.Optional[_winrt.Object]
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTaskInstance: ...
    def get_deferral(self) -> typing.Optional[BackgroundTaskDeferral]: ...
    def add_canceled(self, cancel_handler: typing.Optional[BackgroundTaskCanceledEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_canceled(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class IBackgroundTaskInstance2(IBackgroundTaskInstance, _winrt.Object):
    instance_id: uuid.UUID
    progress: _winrt.UInt32
    suspended_count: _winrt.UInt32
    task: typing.Optional[BackgroundTaskRegistration]
    trigger_details: typing.Optional[_winrt.Object]
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTaskInstance2: ...
    def get_throttle_count(self, counter: BackgroundTaskThrottleCounter) -> _winrt.UInt32: ...
    def get_deferral(self) -> typing.Optional[BackgroundTaskDeferral]: ...
    def add_canceled(self, cancel_handler: typing.Optional[BackgroundTaskCanceledEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_canceled(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class IBackgroundTaskInstance4(IBackgroundTaskInstance, _winrt.Object):
    user: typing.Optional[winsdk.windows.system.User]
    instance_id: uuid.UUID
    progress: _winrt.UInt32
    suspended_count: _winrt.UInt32
    task: typing.Optional[BackgroundTaskRegistration]
    trigger_details: typing.Optional[_winrt.Object]
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTaskInstance4: ...
    def get_deferral(self) -> typing.Optional[BackgroundTaskDeferral]: ...
    def add_canceled(self, cancel_handler: typing.Optional[BackgroundTaskCanceledEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_canceled(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class IBackgroundTaskRegistration(_winrt.Object):
    name: str
    task_id: uuid.UUID
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTaskRegistration: ...
    def unregister(self, cancel_task: _winrt.Boolean) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class IBackgroundTaskRegistration2(IBackgroundTaskRegistration, _winrt.Object):
    trigger: typing.Optional[IBackgroundTrigger]
    name: str
    task_id: uuid.UUID
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTaskRegistration2: ...
    def unregister(self, cancel_task: _winrt.Boolean) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class IBackgroundTaskRegistration3(IBackgroundTaskRegistration, _winrt.Object):
    task_group: typing.Optional[BackgroundTaskRegistrationGroup]
    name: str
    task_id: uuid.UUID
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTaskRegistration3: ...
    def unregister(self, cancel_task: _winrt.Boolean) -> None: ...
    def add_completed(self, handler: typing.Optional[BackgroundTaskCompletedEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_completed(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_progress(self, handler: typing.Optional[BackgroundTaskProgressEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_progress(self, cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class IBackgroundTrigger(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> IBackgroundTrigger: ...

BackgroundTaskCanceledEventHandler = typing.Callable[[typing.Optional[IBackgroundTaskInstance], BackgroundTaskCancellationReason], None]

BackgroundTaskCompletedEventHandler = typing.Callable[[typing.Optional[BackgroundTaskRegistration], typing.Optional[BackgroundTaskCompletedEventArgs]], None]

BackgroundTaskProgressEventHandler = typing.Callable[[typing.Optional[BackgroundTaskRegistration], typing.Optional[BackgroundTaskProgressEventArgs]], None]

