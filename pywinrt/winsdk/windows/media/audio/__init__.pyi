# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.5

import enum
import sys
import types
import typing
import uuid

import winsdk._winrt as _winrt
import winsdk.windows.devices.enumeration
import winsdk.windows.foundation
import winsdk.windows.foundation.collections
import winsdk.windows.foundation.numerics
import winsdk.windows.media
import winsdk.windows.media.capture
import winsdk.windows.media.core
import winsdk.windows.media.devices
import winsdk.windows.media.effects
import winsdk.windows.media.mediaproperties
import winsdk.windows.media.render
import winsdk.windows.media.transcoding
import winsdk.windows.storage

class AudioDeviceNodeCreationStatus(enum.IntEnum):
    SUCCESS = 0
    DEVICE_NOT_AVAILABLE = 1
    FORMAT_NOT_SUPPORTED = 2
    UNKNOWN_FAILURE = 3
    ACCESS_DENIED = 4

class AudioFileNodeCreationStatus(enum.IntEnum):
    SUCCESS = 0
    FILE_NOT_FOUND = 1
    INVALID_FILE_TYPE = 2
    FORMAT_NOT_SUPPORTED = 3
    UNKNOWN_FAILURE = 4

class AudioGraphCreationStatus(enum.IntEnum):
    SUCCESS = 0
    DEVICE_NOT_AVAILABLE = 1
    FORMAT_NOT_SUPPORTED = 2
    UNKNOWN_FAILURE = 3

class AudioGraphUnrecoverableError(enum.IntEnum):
    NONE = 0
    AUDIO_DEVICE_LOST = 1
    AUDIO_SESSION_DISCONNECTED = 2
    UNKNOWN_FAILURE = 3

class AudioNodeEmitterDecayKind(enum.IntEnum):
    NATURAL = 0
    CUSTOM = 1

class AudioNodeEmitterSettings(enum.IntFlag):
    NONE = 0
    DISABLE_DOPPLER = 0x1

class AudioNodeEmitterShapeKind(enum.IntEnum):
    OMNIDIRECTIONAL = 0
    CONE = 1

class AudioPlaybackConnectionOpenResultStatus(enum.IntEnum):
    SUCCESS = 0
    REQUEST_TIMED_OUT = 1
    DENIED_BY_SYSTEM = 2
    UNKNOWN_FAILURE = 3

class AudioPlaybackConnectionState(enum.IntEnum):
    CLOSED = 0
    OPENED = 1

class MediaSourceAudioInputNodeCreationStatus(enum.IntEnum):
    SUCCESS = 0
    FORMAT_NOT_SUPPORTED = 1
    NETWORK_ERROR = 2
    UNKNOWN_FAILURE = 3

class MixedRealitySpatialAudioFormatPolicy(enum.IntEnum):
    USE_MIXED_REALITY_DEFAULT_SPATIAL_AUDIO_FORMAT = 0
    USE_DEVICE_CONFIGURATION_DEFAULT_SPATIAL_AUDIO_FORMAT = 1

class QuantumSizeSelectionMode(enum.IntEnum):
    SYSTEM_DEFAULT = 0
    LOWEST_LATENCY = 1
    CLOSEST_TO_DESIRED = 2

class SetDefaultSpatialAudioFormatStatus(enum.IntEnum):
    SUCCEEDED = 0
    ACCESS_DENIED = 1
    LICENSE_EXPIRED = 2
    LICENSE_NOT_VALID_FOR_AUDIO_ENDPOINT = 3
    NOT_SUPPORTED_ON_AUDIO_ENDPOINT = 4
    UNKNOWN_ERROR = 5

class SpatialAudioModel(enum.IntEnum):
    OBJECT_BASED = 0
    FOLD_DOWN = 1

Self = typing.TypeVar('Self')

class AudioDeviceInputNode(_winrt.Object):
    device: typing.Optional[winsdk.windows.devices.enumeration.DeviceInformation]
    outgoing_connections: typing.Optional[winsdk.windows.foundation.collections.IVectorView[AudioGraphConnection]]
    emitter: typing.Optional[AudioNodeEmitter]
    outgoing_gain: _winrt.Double
    consume_input: _winrt.Boolean
    effect_definitions: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioDeviceInputNode: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode]) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], gain: _winrt.Double) -> None: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def remove_outgoing_connection(self, destination: typing.Optional[IAudioNode]) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class AudioDeviceOutputNode(_winrt.Object):
    device: typing.Optional[winsdk.windows.devices.enumeration.DeviceInformation]
    outgoing_gain: _winrt.Double
    consume_input: _winrt.Boolean
    effect_definitions: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]
    listener: typing.Optional[AudioNodeListener]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioDeviceOutputNode: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class AudioFileInputNode(_winrt.Object):
    playback_speed_factor: _winrt.Double
    loop_count: typing.Optional[typing.Optional[_winrt.Int32]]
    end_time: typing.Optional[typing.Optional[winsdk.windows.foundation.TimeSpan]]
    start_time: typing.Optional[typing.Optional[winsdk.windows.foundation.TimeSpan]]
    position: winsdk.windows.foundation.TimeSpan
    source_file: typing.Optional[winsdk.windows.storage.StorageFile]
    duration: winsdk.windows.foundation.TimeSpan
    outgoing_connections: typing.Optional[winsdk.windows.foundation.collections.IVectorView[AudioGraphConnection]]
    emitter: typing.Optional[AudioNodeEmitter]
    outgoing_gain: _winrt.Double
    consume_input: _winrt.Boolean
    effect_definitions: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioFileInputNode: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode]) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], gain: _winrt.Double) -> None: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def remove_outgoing_connection(self, destination: typing.Optional[IAudioNode]) -> None: ...
    def reset(self) -> None: ...
    def seek(self, position: winsdk.windows.foundation.TimeSpan) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_file_completed(self, handler: winsdk.windows.foundation.TypedEventHandler[AudioFileInputNode, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_file_completed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class AudioFileOutputNode(_winrt.Object):
    file: typing.Optional[winsdk.windows.storage.IStorageFile]
    file_encoding_profile: typing.Optional[winsdk.windows.media.mediaproperties.MediaEncodingProfile]
    outgoing_gain: _winrt.Double
    consume_input: _winrt.Boolean
    effect_definitions: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioFileOutputNode: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def finalize_async(self) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.media.transcoding.TranscodeFailureReason]: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class AudioFrameCompletedEventArgs(_winrt.Object):
    frame: typing.Optional[winsdk.windows.media.AudioFrame]
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioFrameCompletedEventArgs: ...

class AudioFrameInputNode(_winrt.Object):
    playback_speed_factor: _winrt.Double
    queued_sample_count: _winrt.UInt64
    outgoing_connections: typing.Optional[winsdk.windows.foundation.collections.IVectorView[AudioGraphConnection]]
    emitter: typing.Optional[AudioNodeEmitter]
    outgoing_gain: _winrt.Double
    consume_input: _winrt.Boolean
    effect_definitions: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioFrameInputNode: ...
    def add_frame(self, frame: typing.Optional[winsdk.windows.media.AudioFrame]) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode]) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], gain: _winrt.Double) -> None: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def discard_queued_frames(self) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def remove_outgoing_connection(self, destination: typing.Optional[IAudioNode]) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_audio_frame_completed(self, handler: winsdk.windows.foundation.TypedEventHandler[AudioFrameInputNode, AudioFrameCompletedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_audio_frame_completed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_quantum_started(self, handler: winsdk.windows.foundation.TypedEventHandler[AudioFrameInputNode, FrameInputNodeQuantumStartedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_quantum_started(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class AudioFrameOutputNode(_winrt.Object):
    outgoing_gain: _winrt.Double
    consume_input: _winrt.Boolean
    effect_definitions: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioFrameOutputNode: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def get_frame(self) -> typing.Optional[winsdk.windows.media.AudioFrame]: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class AudioGraph(_winrt.Object):
    completed_quantum_count: _winrt.UInt64
    encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]
    latency_in_samples: _winrt.Int32
    primary_render_device: typing.Optional[winsdk.windows.devices.enumeration.DeviceInformation]
    render_device_audio_processing: winsdk.windows.media.AudioProcessing
    samples_per_quantum: _winrt.Int32
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioGraph: ...
    def close(self) -> None: ...
    @staticmethod
    def create_async(settings: typing.Optional[AudioGraphSettings]) -> winsdk.windows.foundation.IAsyncOperation[CreateAudioGraphResult]: ...
    def create_batch_updater(self) -> typing.Optional[AudioGraphBatchUpdater]: ...
    @typing.overload
    def create_device_input_node_async(self, category: winsdk.windows.media.capture.MediaCategory) -> winsdk.windows.foundation.IAsyncOperation[CreateAudioDeviceInputNodeResult]: ...
    @typing.overload
    def create_device_input_node_async(self, category: winsdk.windows.media.capture.MediaCategory, encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]) -> winsdk.windows.foundation.IAsyncOperation[CreateAudioDeviceInputNodeResult]: ...
    @typing.overload
    def create_device_input_node_async(self, category: winsdk.windows.media.capture.MediaCategory, encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties], device: typing.Optional[winsdk.windows.devices.enumeration.DeviceInformation]) -> winsdk.windows.foundation.IAsyncOperation[CreateAudioDeviceInputNodeResult]: ...
    @typing.overload
    def create_device_input_node_async(self, category: winsdk.windows.media.capture.MediaCategory, encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties], device: typing.Optional[winsdk.windows.devices.enumeration.DeviceInformation], emitter: typing.Optional[AudioNodeEmitter]) -> winsdk.windows.foundation.IAsyncOperation[CreateAudioDeviceInputNodeResult]: ...
    def create_device_output_node_async(self) -> winsdk.windows.foundation.IAsyncOperation[CreateAudioDeviceOutputNodeResult]: ...
    @typing.overload
    def create_file_input_node_async(self, file: typing.Optional[winsdk.windows.storage.IStorageFile]) -> winsdk.windows.foundation.IAsyncOperation[CreateAudioFileInputNodeResult]: ...
    @typing.overload
    def create_file_input_node_async(self, file: typing.Optional[winsdk.windows.storage.IStorageFile], emitter: typing.Optional[AudioNodeEmitter]) -> winsdk.windows.foundation.IAsyncOperation[CreateAudioFileInputNodeResult]: ...
    @typing.overload
    def create_file_output_node_async(self, file: typing.Optional[winsdk.windows.storage.IStorageFile]) -> winsdk.windows.foundation.IAsyncOperation[CreateAudioFileOutputNodeResult]: ...
    @typing.overload
    def create_file_output_node_async(self, file: typing.Optional[winsdk.windows.storage.IStorageFile], file_encoding_profile: typing.Optional[winsdk.windows.media.mediaproperties.MediaEncodingProfile]) -> winsdk.windows.foundation.IAsyncOperation[CreateAudioFileOutputNodeResult]: ...
    @typing.overload
    def create_frame_input_node(self) -> typing.Optional[AudioFrameInputNode]: ...
    @typing.overload
    def create_frame_input_node(self, encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]) -> typing.Optional[AudioFrameInputNode]: ...
    @typing.overload
    def create_frame_input_node(self, encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties], emitter: typing.Optional[AudioNodeEmitter]) -> typing.Optional[AudioFrameInputNode]: ...
    @typing.overload
    def create_frame_output_node(self) -> typing.Optional[AudioFrameOutputNode]: ...
    @typing.overload
    def create_frame_output_node(self, encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]) -> typing.Optional[AudioFrameOutputNode]: ...
    @typing.overload
    def create_media_source_audio_input_node_async(self, media_source: typing.Optional[winsdk.windows.media.core.MediaSource]) -> winsdk.windows.foundation.IAsyncOperation[CreateMediaSourceAudioInputNodeResult]: ...
    @typing.overload
    def create_media_source_audio_input_node_async(self, media_source: typing.Optional[winsdk.windows.media.core.MediaSource], emitter: typing.Optional[AudioNodeEmitter]) -> winsdk.windows.foundation.IAsyncOperation[CreateMediaSourceAudioInputNodeResult]: ...
    @typing.overload
    def create_submix_node(self) -> typing.Optional[AudioSubmixNode]: ...
    @typing.overload
    def create_submix_node(self, encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]) -> typing.Optional[AudioSubmixNode]: ...
    @typing.overload
    def create_submix_node(self, encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties], emitter: typing.Optional[AudioNodeEmitter]) -> typing.Optional[AudioSubmixNode]: ...
    def reset_all_nodes(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_quantum_processed(self, handler: winsdk.windows.foundation.TypedEventHandler[AudioGraph, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_quantum_processed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_quantum_started(self, handler: winsdk.windows.foundation.TypedEventHandler[AudioGraph, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_quantum_started(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_unrecoverable_error_occurred(self, handler: winsdk.windows.foundation.TypedEventHandler[AudioGraph, AudioGraphUnrecoverableErrorOccurredEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_unrecoverable_error_occurred(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class AudioGraphBatchUpdater(_winrt.Object):
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioGraphBatchUpdater: ...
    def close(self) -> None: ...

class AudioGraphConnection(_winrt.Object):
    gain: _winrt.Double
    destination: typing.Optional[IAudioNode]
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioGraphConnection: ...

class AudioGraphSettings(_winrt.Object):
    quantum_size_selection_mode: QuantumSizeSelectionMode
    primary_render_device: typing.Optional[winsdk.windows.devices.enumeration.DeviceInformation]
    encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]
    desired_samples_per_quantum: _winrt.Int32
    desired_render_device_audio_processing: winsdk.windows.media.AudioProcessing
    audio_render_category: winsdk.windows.media.render.AudioRenderCategory
    max_playback_speed_factor: _winrt.Double
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioGraphSettings: ...
    def __init__(self, audio_render_category: winsdk.windows.media.render.AudioRenderCategory) -> None: ...

class AudioGraphUnrecoverableErrorOccurredEventArgs(_winrt.Object):
    error: AudioGraphUnrecoverableError
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioGraphUnrecoverableErrorOccurredEventArgs: ...

class AudioNodeEmitter(_winrt.Object):
    position: winsdk.windows.foundation.numerics.Vector3
    gain: _winrt.Double
    doppler_velocity: winsdk.windows.foundation.numerics.Vector3
    doppler_scale: _winrt.Double
    distance_scale: _winrt.Double
    direction: winsdk.windows.foundation.numerics.Vector3
    decay_model: typing.Optional[AudioNodeEmitterDecayModel]
    is_doppler_disabled: _winrt.Boolean
    shape: typing.Optional[AudioNodeEmitterShape]
    spatial_audio_model: SpatialAudioModel
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioNodeEmitter: ...
    @typing.overload
    def __init__(self, shape: typing.Optional[AudioNodeEmitterShape], decay_model: typing.Optional[AudioNodeEmitterDecayModel], settings: AudioNodeEmitterSettings) -> None: ...
    @typing.overload
    def __init__(self) -> None: ...

class AudioNodeEmitterConeProperties(_winrt.Object):
    inner_angle: _winrt.Double
    outer_angle: _winrt.Double
    outer_angle_gain: _winrt.Double
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioNodeEmitterConeProperties: ...

class AudioNodeEmitterDecayModel(_winrt.Object):
    kind: AudioNodeEmitterDecayKind
    max_gain: _winrt.Double
    min_gain: _winrt.Double
    natural_properties: typing.Optional[AudioNodeEmitterNaturalDecayModelProperties]
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioNodeEmitterDecayModel: ...
    @staticmethod
    def create_custom(min_gain: _winrt.Double, max_gain: _winrt.Double) -> typing.Optional[AudioNodeEmitterDecayModel]: ...
    @staticmethod
    def create_natural(min_gain: _winrt.Double, max_gain: _winrt.Double, unity_gain_distance: _winrt.Double, cutoff_distance: _winrt.Double) -> typing.Optional[AudioNodeEmitterDecayModel]: ...

class AudioNodeEmitterNaturalDecayModelProperties(_winrt.Object):
    cutoff_distance: _winrt.Double
    unity_gain_distance: _winrt.Double
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioNodeEmitterNaturalDecayModelProperties: ...

class AudioNodeEmitterShape(_winrt.Object):
    cone_properties: typing.Optional[AudioNodeEmitterConeProperties]
    kind: AudioNodeEmitterShapeKind
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioNodeEmitterShape: ...
    @staticmethod
    def create_cone(inner_angle: _winrt.Double, outer_angle: _winrt.Double, outer_angle_gain: _winrt.Double) -> typing.Optional[AudioNodeEmitterShape]: ...
    @staticmethod
    def create_omnidirectional() -> typing.Optional[AudioNodeEmitterShape]: ...

class AudioNodeListener(_winrt.Object):
    speed_of_sound: _winrt.Double
    position: winsdk.windows.foundation.numerics.Vector3
    orientation: winsdk.windows.foundation.numerics.Quaternion
    doppler_velocity: winsdk.windows.foundation.numerics.Vector3
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioNodeListener: ...
    def __init__(self) -> None: ...

class AudioPlaybackConnection(_winrt.Object):
    device_id: str
    state: AudioPlaybackConnectionState
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioPlaybackConnection: ...
    def close(self) -> None: ...
    @staticmethod
    def get_device_selector() -> str: ...
    def open(self) -> typing.Optional[AudioPlaybackConnectionOpenResult]: ...
    def open_async(self) -> winsdk.windows.foundation.IAsyncOperation[AudioPlaybackConnectionOpenResult]: ...
    def start(self) -> None: ...
    def start_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @staticmethod
    def try_create_from_id(id: str) -> typing.Optional[AudioPlaybackConnection]: ...
    def add_state_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[AudioPlaybackConnection, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_state_changed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class AudioPlaybackConnectionOpenResult(_winrt.Object):
    extended_error: winsdk.windows.foundation.HResult
    status: AudioPlaybackConnectionOpenResultStatus
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioPlaybackConnectionOpenResult: ...

class AudioStateMonitor(_winrt.Object):
    sound_level: winsdk.windows.media.SoundLevel
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioStateMonitor: ...
    @typing.overload
    @staticmethod
    def create_for_capture_monitoring() -> typing.Optional[AudioStateMonitor]: ...
    @typing.overload
    @staticmethod
    def create_for_capture_monitoring(category: winsdk.windows.media.capture.MediaCategory) -> typing.Optional[AudioStateMonitor]: ...
    @typing.overload
    @staticmethod
    def create_for_capture_monitoring(category: winsdk.windows.media.capture.MediaCategory, role: winsdk.windows.media.devices.AudioDeviceRole) -> typing.Optional[AudioStateMonitor]: ...
    @staticmethod
    def create_for_capture_monitoring_with_category_and_device_id(category: winsdk.windows.media.capture.MediaCategory, device_id: str) -> typing.Optional[AudioStateMonitor]: ...
    @typing.overload
    @staticmethod
    def create_for_render_monitoring() -> typing.Optional[AudioStateMonitor]: ...
    @typing.overload
    @staticmethod
    def create_for_render_monitoring(category: winsdk.windows.media.render.AudioRenderCategory) -> typing.Optional[AudioStateMonitor]: ...
    @typing.overload
    @staticmethod
    def create_for_render_monitoring(category: winsdk.windows.media.render.AudioRenderCategory, role: winsdk.windows.media.devices.AudioDeviceRole) -> typing.Optional[AudioStateMonitor]: ...
    @staticmethod
    def create_for_render_monitoring_with_category_and_device_id(category: winsdk.windows.media.render.AudioRenderCategory, device_id: str) -> typing.Optional[AudioStateMonitor]: ...
    def add_sound_level_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[AudioStateMonitor, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_sound_level_changed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class AudioSubmixNode(_winrt.Object):
    outgoing_connections: typing.Optional[winsdk.windows.foundation.collections.IVectorView[AudioGraphConnection]]
    emitter: typing.Optional[AudioNodeEmitter]
    outgoing_gain: _winrt.Double
    consume_input: _winrt.Boolean
    effect_definitions: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> AudioSubmixNode: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode]) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], gain: _winrt.Double) -> None: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def remove_outgoing_connection(self, destination: typing.Optional[IAudioNode]) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

class CreateAudioDeviceInputNodeResult(_winrt.Object):
    device_input_node: typing.Optional[AudioDeviceInputNode]
    status: AudioDeviceNodeCreationStatus
    extended_error: winsdk.windows.foundation.HResult
    @staticmethod
    def _from(obj: _winrt.Object) -> CreateAudioDeviceInputNodeResult: ...

class CreateAudioDeviceOutputNodeResult(_winrt.Object):
    device_output_node: typing.Optional[AudioDeviceOutputNode]
    status: AudioDeviceNodeCreationStatus
    extended_error: winsdk.windows.foundation.HResult
    @staticmethod
    def _from(obj: _winrt.Object) -> CreateAudioDeviceOutputNodeResult: ...

class CreateAudioFileInputNodeResult(_winrt.Object):
    file_input_node: typing.Optional[AudioFileInputNode]
    status: AudioFileNodeCreationStatus
    extended_error: winsdk.windows.foundation.HResult
    @staticmethod
    def _from(obj: _winrt.Object) -> CreateAudioFileInputNodeResult: ...

class CreateAudioFileOutputNodeResult(_winrt.Object):
    file_output_node: typing.Optional[AudioFileOutputNode]
    status: AudioFileNodeCreationStatus
    extended_error: winsdk.windows.foundation.HResult
    @staticmethod
    def _from(obj: _winrt.Object) -> CreateAudioFileOutputNodeResult: ...

class CreateAudioGraphResult(_winrt.Object):
    graph: typing.Optional[AudioGraph]
    status: AudioGraphCreationStatus
    extended_error: winsdk.windows.foundation.HResult
    @staticmethod
    def _from(obj: _winrt.Object) -> CreateAudioGraphResult: ...

class CreateMediaSourceAudioInputNodeResult(_winrt.Object):
    node: typing.Optional[MediaSourceAudioInputNode]
    status: MediaSourceAudioInputNodeCreationStatus
    extended_error: winsdk.windows.foundation.HResult
    @staticmethod
    def _from(obj: _winrt.Object) -> CreateMediaSourceAudioInputNodeResult: ...

class EchoEffectDefinition(_winrt.Object):
    wet_dry_mix: _winrt.Double
    feedback: _winrt.Double
    delay: _winrt.Double
    activatable_class_id: str
    properties: typing.Optional[winsdk.windows.foundation.collections.IPropertySet]
    @staticmethod
    def _from(obj: _winrt.Object) -> EchoEffectDefinition: ...
    def __init__(self, audio_graph: typing.Optional[AudioGraph]) -> None: ...

class EqualizerBand(_winrt.Object):
    gain: _winrt.Double
    frequency_center: _winrt.Double
    bandwidth: _winrt.Double
    @staticmethod
    def _from(obj: _winrt.Object) -> EqualizerBand: ...

class EqualizerEffectDefinition(_winrt.Object):
    bands: typing.Optional[winsdk.windows.foundation.collections.IVectorView[EqualizerBand]]
    activatable_class_id: str
    properties: typing.Optional[winsdk.windows.foundation.collections.IPropertySet]
    @staticmethod
    def _from(obj: _winrt.Object) -> EqualizerEffectDefinition: ...
    def __init__(self, audio_graph: typing.Optional[AudioGraph]) -> None: ...

class FrameInputNodeQuantumStartedEventArgs(_winrt.Object):
    required_samples: _winrt.Int32
    @staticmethod
    def _from(obj: _winrt.Object) -> FrameInputNodeQuantumStartedEventArgs: ...

class LimiterEffectDefinition(_winrt.Object):
    release: _winrt.UInt32
    loudness: _winrt.UInt32
    activatable_class_id: str
    properties: typing.Optional[winsdk.windows.foundation.collections.IPropertySet]
    @staticmethod
    def _from(obj: _winrt.Object) -> LimiterEffectDefinition: ...
    def __init__(self, audio_graph: typing.Optional[AudioGraph]) -> None: ...

class MediaSourceAudioInputNode(_winrt.Object):
    outgoing_connections: typing.Optional[winsdk.windows.foundation.collections.IVectorView[AudioGraphConnection]]
    emitter: typing.Optional[AudioNodeEmitter]
    outgoing_gain: _winrt.Double
    consume_input: _winrt.Boolean
    effect_definitions: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]
    start_time: typing.Optional[typing.Optional[winsdk.windows.foundation.TimeSpan]]
    playback_speed_factor: _winrt.Double
    loop_count: typing.Optional[typing.Optional[_winrt.Int32]]
    end_time: typing.Optional[typing.Optional[winsdk.windows.foundation.TimeSpan]]
    duration: winsdk.windows.foundation.TimeSpan
    media_source: typing.Optional[winsdk.windows.media.core.MediaSource]
    position: winsdk.windows.foundation.TimeSpan
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> MediaSourceAudioInputNode: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode]) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], gain: _winrt.Double) -> None: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def remove_outgoing_connection(self, destination: typing.Optional[IAudioNode]) -> None: ...
    def reset(self) -> None: ...
    def seek(self, position: winsdk.windows.foundation.TimeSpan) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_media_source_completed(self, handler: winsdk.windows.foundation.TypedEventHandler[MediaSourceAudioInputNode, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_media_source_completed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class ReverbEffectDefinition(_winrt.Object):
    high_e_q_gain: _winrt.UInt8
    high_e_q_cutoff: _winrt.UInt8
    disable_late_field: _winrt.Boolean
    density: _winrt.Double
    position_right: _winrt.UInt8
    decay_time: _winrt.Double
    late_diffusion: _winrt.UInt8
    position_matrix_right: _winrt.UInt8
    position_matrix_left: _winrt.UInt8
    position_left: _winrt.UInt8
    low_e_q_gain: _winrt.UInt8
    low_e_q_cutoff: _winrt.UInt8
    room_filter_freq: _winrt.Double
    reverb_gain: _winrt.Double
    reverb_delay: _winrt.UInt8
    reflections_gain: _winrt.Double
    reflections_delay: _winrt.UInt32
    rear_delay: _winrt.UInt8
    wet_dry_mix: _winrt.Double
    early_diffusion: _winrt.UInt8
    room_size: _winrt.Double
    room_filter_main: _winrt.Double
    room_filter_h_f: _winrt.Double
    activatable_class_id: str
    properties: typing.Optional[winsdk.windows.foundation.collections.IPropertySet]
    @staticmethod
    def _from(obj: _winrt.Object) -> ReverbEffectDefinition: ...
    def __init__(self, audio_graph: typing.Optional[AudioGraph]) -> None: ...

class SetDefaultSpatialAudioFormatResult(_winrt.Object):
    status: SetDefaultSpatialAudioFormatStatus
    @staticmethod
    def _from(obj: _winrt.Object) -> SetDefaultSpatialAudioFormatResult: ...

class SpatialAudioDeviceConfiguration(_winrt.Object):
    active_spatial_audio_format: str
    default_spatial_audio_format: str
    device_id: str
    is_spatial_audio_supported: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialAudioDeviceConfiguration: ...
    @staticmethod
    def get_for_device_id(device_id: str) -> typing.Optional[SpatialAudioDeviceConfiguration]: ...
    def is_spatial_audio_format_supported(self, subtype: str) -> _winrt.Boolean: ...
    def set_default_spatial_audio_format_async(self, subtype: str) -> winsdk.windows.foundation.IAsyncOperation[SetDefaultSpatialAudioFormatResult]: ...
    def add_configuration_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[SpatialAudioDeviceConfiguration, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_configuration_changed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class SpatialAudioFormatConfiguration(_winrt.Object):
    mixed_reality_exclusive_mode_policy: MixedRealitySpatialAudioFormatPolicy
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialAudioFormatConfiguration: ...
    @staticmethod
    def get_default() -> typing.Optional[SpatialAudioFormatConfiguration]: ...
    def report_configuration_changed_async(self, subtype: str) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def report_license_changed_async(self, subtype: str) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...

class SpatialAudioFormatSubtype(_winrt.Object):
    d_t_s_headphone_x: str
    d_t_s_x_ultra: str
    dolby_atmos_for_headphones: str
    dolby_atmos_for_home_theater: str
    dolby_atmos_for_speakers: str
    windows_sonic: str
    d_t_s_x_for_home_theater: str
    @staticmethod
    def _from(obj: _winrt.Object) -> SpatialAudioFormatSubtype: ...

class IAudioInputNode(_winrt.Object):
    outgoing_connections: typing.Optional[winsdk.windows.foundation.collections.IVectorView[AudioGraphConnection]]
    consume_input: _winrt.Boolean
    effect_definitions: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]
    outgoing_gain: _winrt.Double
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> IAudioInputNode: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode]) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], gain: _winrt.Double) -> None: ...
    def remove_outgoing_connection(self, destination: typing.Optional[IAudioNode]) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def close(self) -> None: ...

class IAudioInputNode2(_winrt.Object):
    emitter: typing.Optional[AudioNodeEmitter]
    consume_input: _winrt.Boolean
    effect_definitions: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]
    outgoing_gain: _winrt.Double
    outgoing_connections: typing.Optional[winsdk.windows.foundation.collections.IVectorView[AudioGraphConnection]]
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> IAudioInputNode2: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def close(self) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode]) -> None: ...
    @typing.overload
    def add_outgoing_connection(self, destination: typing.Optional[IAudioNode], gain: _winrt.Double) -> None: ...
    def remove_outgoing_connection(self, destination: typing.Optional[IAudioNode]) -> None: ...

class IAudioNode(_winrt.Object):
    consume_input: _winrt.Boolean
    effect_definitions: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]
    outgoing_gain: _winrt.Double
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> IAudioNode: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def close(self) -> None: ...

class IAudioNodeWithListener(_winrt.Object):
    listener: typing.Optional[AudioNodeListener]
    consume_input: _winrt.Boolean
    effect_definitions: typing.Optional[winsdk.windows.foundation.collections.IVector[winsdk.windows.media.effects.IAudioEffectDefinition]]
    encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.AudioEncodingProperties]
    outgoing_gain: _winrt.Double
    def __enter__(self: Self) -> Self: ...
    def __exit__(self, *args) -> None: ...
    @staticmethod
    def _from(obj: _winrt.Object) -> IAudioNodeWithListener: ...
    def close(self) -> None: ...
    def disable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def enable_effects_by_definition(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> None: ...
    def reset(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...

