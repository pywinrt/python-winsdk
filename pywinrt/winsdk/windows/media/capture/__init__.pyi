# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.3

import enum
import sys
import types
import typing
import uuid

import winsdk._winrt as _winrt

try:
    import winsdk.windows.devices.enumeration
except Exception:
    pass

try:
    import winsdk.windows.foundation
except Exception:
    pass

try:
    import winsdk.windows.foundation.collections
except Exception:
    pass

try:
    import winsdk.windows.graphics.directx.direct3d11
except Exception:
    pass

try:
    import winsdk.windows.graphics.imaging
except Exception:
    pass

try:
    import winsdk.windows.media
except Exception:
    pass

try:
    import winsdk.windows.media.capture.core
except Exception:
    pass

try:
    import winsdk.windows.media.capture.frames
except Exception:
    pass

try:
    import winsdk.windows.media.core
except Exception:
    pass

try:
    import winsdk.windows.media.devices
except Exception:
    pass

try:
    import winsdk.windows.media.effects
except Exception:
    pass

try:
    import winsdk.windows.media.mediaproperties
except Exception:
    pass

try:
    import winsdk.windows.security.credentials
except Exception:
    pass

try:
    import winsdk.windows.storage
except Exception:
    pass

try:
    import winsdk.windows.storage.streams
except Exception:
    pass

try:
    import winsdk.windows.ui.windowmanagement
except Exception:
    pass

class CameraCaptureUIMaxPhotoResolution(enum.IntEnum):
    HIGHEST_AVAILABLE = 0
    VERY_SMALL_QVGA = 1
    SMALL_VGA = 2
    MEDIUM_XGA = 3
    LARGE3_M = 4
    VERY_LARGE5_M = 5

class CameraCaptureUIMaxVideoResolution(enum.IntEnum):
    HIGHEST_AVAILABLE = 0
    LOW_DEFINITION = 1
    STANDARD_DEFINITION = 2
    HIGH_DEFINITION = 3

class CameraCaptureUIMode(enum.IntEnum):
    PHOTO_OR_VIDEO = 0
    PHOTO = 1
    VIDEO = 2

class CameraCaptureUIPhotoFormat(enum.IntEnum):
    JPEG = 0
    PNG = 1
    JPEG_X_R = 2

class CameraCaptureUIVideoFormat(enum.IntEnum):
    MP4 = 0
    WMV = 1

class KnownVideoProfile(enum.IntEnum):
    VIDEO_RECORDING = 0
    HIGH_QUALITY_PHOTO = 1
    BALANCED_VIDEO_AND_PHOTO = 2
    VIDEO_CONFERENCING = 3
    PHOTO_SEQUENCE = 4
    HIGH_FRAME_RATE = 5
    VARIABLE_PHOTO_SEQUENCE = 6
    HDR_WITH_WCG_VIDEO = 7
    HDR_WITH_WCG_PHOTO = 8
    VIDEO_HDR8 = 9
    COMPRESSED_CAMERA = 10

class MediaCaptureDeviceExclusiveControlStatus(enum.IntEnum):
    EXCLUSIVE_CONTROL_AVAILABLE = 0
    SHARED_READ_ONLY_AVAILABLE = 1

class MediaCaptureMemoryPreference(enum.IntEnum):
    AUTO = 0
    CPU = 1

class MediaCaptureSharingMode(enum.IntEnum):
    EXCLUSIVE_CONTROL = 0
    SHARED_READ_ONLY = 1

class MediaCaptureThermalStatus(enum.IntEnum):
    NORMAL = 0
    OVERHEATED = 1

class MediaCategory(enum.IntEnum):
    OTHER = 0
    COMMUNICATIONS = 1
    MEDIA = 2
    GAME_CHAT = 3
    SPEECH = 4
    FAR_FIELD_SPEECH = 5
    UNIFORM_SPEECH = 6
    VOICE_TYPING = 7

class MediaStreamType(enum.IntEnum):
    VIDEO_PREVIEW = 0
    VIDEO_RECORD = 1
    AUDIO = 2
    PHOTO = 3
    METADATA = 4

class PhotoCaptureSource(enum.IntEnum):
    AUTO = 0
    VIDEO_PREVIEW = 1
    PHOTO = 2

class PowerlineFrequency(enum.IntEnum):
    DISABLED = 0
    FIFTY_HERTZ = 1
    SIXTY_HERTZ = 2
    AUTO = 3

class StreamingCaptureMode(enum.IntEnum):
    AUDIO_AND_VIDEO = 0
    AUDIO = 1
    VIDEO = 2

class VideoDeviceCharacteristic(enum.IntEnum):
    ALL_STREAMS_INDEPENDENT = 0
    PREVIEW_RECORD_STREAMS_IDENTICAL = 1
    PREVIEW_PHOTO_STREAMS_IDENTICAL = 2
    RECORD_PHOTO_STREAMS_IDENTICAL = 3
    ALL_STREAMS_IDENTICAL = 4

class VideoRotation(enum.IntEnum):
    NONE = 0
    CLOCKWISE90_DEGREES = 1
    CLOCKWISE180_DEGREES = 2
    CLOCKWISE270_DEGREES = 3

class WhiteBalanceGain:
    r: _winrt.Double
    g: _winrt.Double
    b: _winrt.Double
    def __init__(self, r: _winrt.Double, g: _winrt.Double, b: _winrt.Double) -> None: ...

class AdvancedCapturedPhoto(_winrt.Object):
    context: typing.Optional[_winrt.Object]
    frame: typing.Optional[CapturedFrame]
    mode: winsdk.windows.media.devices.AdvancedPhotoMode
    frame_bounds_relative_to_reference_photo: typing.Optional[typing.Optional[winsdk.windows.foundation.Rect]]
    @staticmethod
    def _from(obj: _winrt.Object) -> AdvancedCapturedPhoto: ...

class AdvancedPhotoCapture(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> AdvancedPhotoCapture: ...
    @typing.overload
    def capture_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[AdvancedCapturedPhoto]]: ...
    @typing.overload
    def capture_async(self, context: typing.Optional[_winrt.Object]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[AdvancedCapturedPhoto]]: ...
    def finish_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def add_all_photos_captured(self, handler: winsdk.windows.foundation.TypedEventHandler[AdvancedPhotoCapture, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_all_photos_captured(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_optional_reference_photo_captured(self, handler: winsdk.windows.foundation.TypedEventHandler[AdvancedPhotoCapture, OptionalReferencePhotoCapturedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_optional_reference_photo_captured(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class AppCapture(_winrt.Object):
    is_capturing_audio: _winrt.Boolean
    is_capturing_video: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> AppCapture: ...
    @staticmethod
    def get_for_current_view() -> typing.Optional[AppCapture]: ...
    @staticmethod
    def set_allowed_async(allowed: _winrt.Boolean) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def add_capturing_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[AppCapture, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_capturing_changed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class CameraCaptureUI(_winrt.Object):
    photo_settings: typing.Optional[CameraCaptureUIPhotoCaptureSettings]
    video_settings: typing.Optional[CameraCaptureUIVideoCaptureSettings]
    @staticmethod
    def _from(obj: _winrt.Object) -> CameraCaptureUI: ...
    def __init__(self) -> None: ...
    def capture_file_async(self, mode: CameraCaptureUIMode) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[winsdk.windows.storage.StorageFile]]: ...

class CameraCaptureUIPhotoCaptureSettings(_winrt.Object):
    max_resolution: CameraCaptureUIMaxPhotoResolution
    format: CameraCaptureUIPhotoFormat
    cropped_size_in_pixels: winsdk.windows.foundation.Size
    cropped_aspect_ratio: winsdk.windows.foundation.Size
    allow_cropping: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> CameraCaptureUIPhotoCaptureSettings: ...

class CameraCaptureUIVideoCaptureSettings(_winrt.Object):
    max_resolution: CameraCaptureUIMaxVideoResolution
    max_duration_in_seconds: _winrt.Single
    format: CameraCaptureUIVideoFormat
    allow_trimming: _winrt.Boolean
    @staticmethod
    def _from(obj: _winrt.Object) -> CameraCaptureUIVideoCaptureSettings: ...

class CapturedFrame(winsdk.windows.storage.streams.IRandomAccessStreamWithContentType, winsdk.windows.storage.streams.IContentTypeProvider, winsdk.windows.storage.streams.IRandomAccessStream, winsdk.windows.storage.streams.IOutputStream, winsdk.windows.foundation.IClosable, winsdk.windows.storage.streams.IInputStream, _winrt.Object):
    height: _winrt.UInt32
    width: _winrt.UInt32
    bitmap_properties: typing.Optional[winsdk.windows.graphics.imaging.BitmapPropertySet]
    control_values: typing.Optional[CapturedFrameControlValues]
    software_bitmap: typing.Optional[winsdk.windows.graphics.imaging.SoftwareBitmap]
    content_type: str
    size: _winrt.UInt64
    can_read: _winrt.Boolean
    can_write: _winrt.Boolean
    position: _winrt.UInt64
    @staticmethod
    def _from(obj: _winrt.Object) -> CapturedFrame: ...
    def clone_stream(self) -> typing.Optional[winsdk.windows.storage.streams.IRandomAccessStream]: ...
    def close(self) -> None: ...
    def flush_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[_winrt.Boolean]]: ...
    def get_input_stream_at(self, position: _winrt.UInt64) -> typing.Optional[winsdk.windows.storage.streams.IInputStream]: ...
    def get_output_stream_at(self, position: _winrt.UInt64) -> typing.Optional[winsdk.windows.storage.streams.IOutputStream]: ...
    def read_async(self, buffer: typing.Optional[winsdk.windows.storage.streams.IBuffer], count: _winrt.UInt32, options: winsdk.windows.storage.streams.InputStreamOptions) -> typing.Optional[winsdk.windows.foundation.IAsyncOperationWithProgress[winsdk.windows.storage.streams.IBuffer, _winrt.UInt32]]: ...
    def seek(self, position: _winrt.UInt64) -> None: ...
    def write_async(self, buffer: typing.Optional[winsdk.windows.storage.streams.IBuffer]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperationWithProgress[_winrt.UInt32, _winrt.UInt32]]: ...

class CapturedFrameControlValues(_winrt.Object):
    exposure: typing.Optional[typing.Optional[winsdk.windows.foundation.TimeSpan]]
    exposure_compensation: typing.Optional[typing.Optional[_winrt.Single]]
    flash_power_percent: typing.Optional[typing.Optional[_winrt.Single]]
    flashed: typing.Optional[typing.Optional[_winrt.Boolean]]
    focus: typing.Optional[typing.Optional[_winrt.UInt32]]
    iso_speed: typing.Optional[typing.Optional[_winrt.UInt32]]
    scene_mode: typing.Optional[typing.Optional[winsdk.windows.media.devices.CaptureSceneMode]]
    white_balance: typing.Optional[typing.Optional[_winrt.UInt32]]
    zoom_factor: typing.Optional[typing.Optional[_winrt.Single]]
    focus_state: typing.Optional[typing.Optional[winsdk.windows.media.devices.MediaCaptureFocusState]]
    iso_analog_gain: typing.Optional[typing.Optional[_winrt.Double]]
    iso_digital_gain: typing.Optional[typing.Optional[_winrt.Double]]
    sensor_frame_rate: typing.Optional[winsdk.windows.media.mediaproperties.MediaRatio]
    white_balance_gain: typing.Optional[typing.Optional[WhiteBalanceGain]]
    @staticmethod
    def _from(obj: _winrt.Object) -> CapturedFrameControlValues: ...

class CapturedPhoto(_winrt.Object):
    frame: typing.Optional[CapturedFrame]
    thumbnail: typing.Optional[CapturedFrame]
    @staticmethod
    def _from(obj: _winrt.Object) -> CapturedPhoto: ...

class LowLagMediaRecording(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> LowLagMediaRecording: ...
    def finish_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def pause_async(self, behavior: winsdk.windows.media.devices.MediaCapturePauseBehavior) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def pause_with_result_async(self, behavior: winsdk.windows.media.devices.MediaCapturePauseBehavior) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[MediaCapturePauseResult]]: ...
    def resume_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def start_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def stop_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def stop_with_result_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[MediaCaptureStopResult]]: ...

class LowLagPhotoCapture(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> LowLagPhotoCapture: ...
    def capture_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[CapturedPhoto]]: ...
    def finish_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...

class LowLagPhotoSequenceCapture(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> LowLagPhotoSequenceCapture: ...
    def finish_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def start_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def stop_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def add_photo_captured(self, handler: winsdk.windows.foundation.TypedEventHandler[LowLagPhotoSequenceCapture, PhotoCapturedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_photo_captured(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class MediaCapture(winsdk.windows.foundation.IClosable, _winrt.Object):
    audio_device_controller: typing.Optional[winsdk.windows.media.devices.AudioDeviceController]
    media_capture_settings: typing.Optional[MediaCaptureSettings]
    video_device_controller: typing.Optional[winsdk.windows.media.devices.VideoDeviceController]
    camera_stream_state: winsdk.windows.media.devices.CameraStreamState
    thermal_status: MediaCaptureThermalStatus
    frame_sources: typing.Optional[winsdk.windows.foundation.collections.IMapView[str, winsdk.windows.media.capture.frames.MediaFrameSource]]
    @staticmethod
    def _from(obj: _winrt.Object) -> MediaCapture: ...
    def __init__(self) -> None: ...
    def add_audio_effect_async(self, definition: typing.Optional[winsdk.windows.media.effects.IAudioEffectDefinition]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[winsdk.windows.media.IMediaExtension]]: ...
    def add_effect_async(self, media_stream_type: MediaStreamType, effect_activation_i_d: str, effect_settings: typing.Optional[winsdk.windows.foundation.collections.IPropertySet]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def add_video_effect_async(self, definition: typing.Optional[winsdk.windows.media.effects.IVideoEffectDefinition], media_stream_type: MediaStreamType) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[winsdk.windows.media.IMediaExtension]]: ...
    def capture_photo_to_storage_file_async(self, type: typing.Optional[winsdk.windows.media.mediaproperties.ImageEncodingProperties], file: typing.Optional[winsdk.windows.storage.IStorageFile]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def capture_photo_to_stream_async(self, type: typing.Optional[winsdk.windows.media.mediaproperties.ImageEncodingProperties], stream: typing.Optional[winsdk.windows.storage.streams.IRandomAccessStream]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def clear_effects_async(self, media_stream_type: MediaStreamType) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def close(self) -> None: ...
    @typing.overload
    def create_frame_reader_async(self, input_source: typing.Optional[winsdk.windows.media.capture.frames.MediaFrameSource]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[winsdk.windows.media.capture.frames.MediaFrameReader]]: ...
    @typing.overload
    def create_frame_reader_async(self, input_source: typing.Optional[winsdk.windows.media.capture.frames.MediaFrameSource], output_subtype: str) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[winsdk.windows.media.capture.frames.MediaFrameReader]]: ...
    @typing.overload
    def create_frame_reader_async(self, input_source: typing.Optional[winsdk.windows.media.capture.frames.MediaFrameSource], output_subtype: str, output_size: winsdk.windows.graphics.imaging.BitmapSize) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[winsdk.windows.media.capture.frames.MediaFrameReader]]: ...
    def create_multi_source_frame_reader_async(self, input_sources: typing.Iterable[typing.Optional[winsdk.windows.media.capture.frames.MediaFrameSource]]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[winsdk.windows.media.capture.frames.MultiSourceMediaFrameReader]]: ...
    def create_relative_panel_watcher(self, capture_mode: StreamingCaptureMode, display_region: typing.Optional[winsdk.windows.ui.windowmanagement.DisplayRegion]) -> typing.Optional[MediaCaptureRelativePanelWatcher]: ...
    @staticmethod
    def find_all_video_profiles(video_device_id: str) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[MediaCaptureVideoProfile]]: ...
    @staticmethod
    def find_concurrent_profiles(video_device_id: str) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[MediaCaptureVideoProfile]]: ...
    @staticmethod
    def find_known_video_profiles(video_device_id: str, name: KnownVideoProfile) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[MediaCaptureVideoProfile]]: ...
    def get_encoder_property(self, media_stream_type: MediaStreamType, property_id: uuid.UUID) -> typing.Optional[_winrt.Object]: ...
    @typing.overload
    def get_preview_frame_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[winsdk.windows.media.VideoFrame]]: ...
    @typing.overload
    def get_preview_frame_async(self, destination: typing.Optional[winsdk.windows.media.VideoFrame]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[winsdk.windows.media.VideoFrame]]: ...
    def get_preview_mirroring(self) -> _winrt.Boolean: ...
    def get_preview_rotation(self) -> VideoRotation: ...
    def get_record_rotation(self) -> VideoRotation: ...
    @typing.overload
    def initialize_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def initialize_async(self, media_capture_initialization_settings: typing.Optional[MediaCaptureInitializationSettings]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @staticmethod
    def is_video_profile_supported(video_device_id: str) -> _winrt.Boolean: ...
    def pause_record_async(self, behavior: winsdk.windows.media.devices.MediaCapturePauseBehavior) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def pause_record_with_result_async(self, behavior: winsdk.windows.media.devices.MediaCapturePauseBehavior) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[MediaCapturePauseResult]]: ...
    def prepare_advanced_photo_capture_async(self, encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.ImageEncodingProperties]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[AdvancedPhotoCapture]]: ...
    def prepare_low_lag_photo_capture_async(self, type: typing.Optional[winsdk.windows.media.mediaproperties.ImageEncodingProperties]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[LowLagPhotoCapture]]: ...
    def prepare_low_lag_photo_sequence_capture_async(self, type: typing.Optional[winsdk.windows.media.mediaproperties.ImageEncodingProperties]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[LowLagPhotoSequenceCapture]]: ...
    @typing.overload
    def prepare_low_lag_record_to_custom_sink_async(self, encoding_profile: typing.Optional[winsdk.windows.media.mediaproperties.MediaEncodingProfile], custom_media_sink: typing.Optional[winsdk.windows.media.IMediaExtension]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[LowLagMediaRecording]]: ...
    @typing.overload
    def prepare_low_lag_record_to_custom_sink_async(self, encoding_profile: typing.Optional[winsdk.windows.media.mediaproperties.MediaEncodingProfile], custom_sink_activation_id: str, custom_sink_settings: typing.Optional[winsdk.windows.foundation.collections.IPropertySet]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[LowLagMediaRecording]]: ...
    def prepare_low_lag_record_to_storage_file_async(self, encoding_profile: typing.Optional[winsdk.windows.media.mediaproperties.MediaEncodingProfile], file: typing.Optional[winsdk.windows.storage.IStorageFile]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[LowLagMediaRecording]]: ...
    def prepare_low_lag_record_to_stream_async(self, encoding_profile: typing.Optional[winsdk.windows.media.mediaproperties.MediaEncodingProfile], stream: typing.Optional[winsdk.windows.storage.streams.IRandomAccessStream]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[LowLagMediaRecording]]: ...
    def prepare_variable_photo_sequence_capture_async(self, type: typing.Optional[winsdk.windows.media.mediaproperties.ImageEncodingProperties]) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[winsdk.windows.media.capture.core.VariablePhotoSequenceCapture]]: ...
    def remove_effect_async(self, effect: typing.Optional[winsdk.windows.media.IMediaExtension]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def resume_record_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def set_encoder_property(self, media_stream_type: MediaStreamType, property_id: uuid.UUID, property_value: typing.Optional[_winrt.Object]) -> None: ...
    def set_encoding_properties_async(self, media_stream_type: MediaStreamType, media_encoding_properties: typing.Optional[winsdk.windows.media.mediaproperties.IMediaEncodingProperties], encoder_properties: typing.Optional[winsdk.windows.media.mediaproperties.MediaPropertySet]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def set_preview_mirroring(self, value: _winrt.Boolean) -> None: ...
    def set_preview_rotation(self, value: VideoRotation) -> None: ...
    def set_record_rotation(self, value: VideoRotation) -> None: ...
    def start_preview_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def start_preview_to_custom_sink_async(self, encoding_profile: typing.Optional[winsdk.windows.media.mediaproperties.MediaEncodingProfile], custom_media_sink: typing.Optional[winsdk.windows.media.IMediaExtension]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def start_preview_to_custom_sink_async(self, encoding_profile: typing.Optional[winsdk.windows.media.mediaproperties.MediaEncodingProfile], custom_sink_activation_id: str, custom_sink_settings: typing.Optional[winsdk.windows.foundation.collections.IPropertySet]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def start_record_to_custom_sink_async(self, encoding_profile: typing.Optional[winsdk.windows.media.mediaproperties.MediaEncodingProfile], custom_media_sink: typing.Optional[winsdk.windows.media.IMediaExtension]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    @typing.overload
    def start_record_to_custom_sink_async(self, encoding_profile: typing.Optional[winsdk.windows.media.mediaproperties.MediaEncodingProfile], custom_sink_activation_id: str, custom_sink_settings: typing.Optional[winsdk.windows.foundation.collections.IPropertySet]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def start_record_to_storage_file_async(self, encoding_profile: typing.Optional[winsdk.windows.media.mediaproperties.MediaEncodingProfile], file: typing.Optional[winsdk.windows.storage.IStorageFile]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def start_record_to_stream_async(self, encoding_profile: typing.Optional[winsdk.windows.media.mediaproperties.MediaEncodingProfile], stream: typing.Optional[winsdk.windows.storage.streams.IRandomAccessStream]) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def stop_preview_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def stop_record_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncAction]: ...
    def stop_record_with_result_async(self) -> typing.Optional[winsdk.windows.foundation.IAsyncOperation[MediaCaptureStopResult]]: ...
    def add_failed(self, error_event_handler: typing.Optional[MediaCaptureFailedEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_failed(self, event_cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_record_limitation_exceeded(self, record_limitation_exceeded_event_handler: typing.Optional[RecordLimitationExceededEventHandler]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_record_limitation_exceeded(self, event_cookie: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_focus_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[MediaCapture, MediaCaptureFocusChangedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_focus_changed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_photo_confirmation_captured(self, handler: winsdk.windows.foundation.TypedEventHandler[MediaCapture, PhotoConfirmationCapturedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_photo_confirmation_captured(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_camera_stream_state_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[MediaCapture, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_camera_stream_state_changed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_thermal_status_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[MediaCapture, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_thermal_status_changed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...
    def add_capture_device_exclusive_control_status_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[MediaCapture, MediaCaptureDeviceExclusiveControlStatusChangedEventArgs]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_capture_device_exclusive_control_status_changed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(_winrt.Object):
    device_id: str
    status: MediaCaptureDeviceExclusiveControlStatus
    @staticmethod
    def _from(obj: _winrt.Object) -> MediaCaptureDeviceExclusiveControlStatusChangedEventArgs: ...

class MediaCaptureFailedEventArgs(_winrt.Object):
    code: _winrt.UInt32
    message: str
    @staticmethod
    def _from(obj: _winrt.Object) -> MediaCaptureFailedEventArgs: ...

class MediaCaptureFocusChangedEventArgs(_winrt.Object):
    focus_state: winsdk.windows.media.devices.MediaCaptureFocusState
    @staticmethod
    def _from(obj: _winrt.Object) -> MediaCaptureFocusChangedEventArgs: ...

class MediaCaptureInitializationSettings(_winrt.Object):
    video_device_id: str
    streaming_capture_mode: StreamingCaptureMode
    photo_capture_source: PhotoCaptureSource
    audio_device_id: str
    media_category: MediaCategory
    audio_processing: winsdk.windows.media.AudioProcessing
    video_source: typing.Optional[winsdk.windows.media.core.IMediaSource]
    audio_source: typing.Optional[winsdk.windows.media.core.IMediaSource]
    video_profile: typing.Optional[MediaCaptureVideoProfile]
    record_media_description: typing.Optional[MediaCaptureVideoProfileMediaDescription]
    preview_media_description: typing.Optional[MediaCaptureVideoProfileMediaDescription]
    photo_media_description: typing.Optional[MediaCaptureVideoProfileMediaDescription]
    source_group: typing.Optional[winsdk.windows.media.capture.frames.MediaFrameSourceGroup]
    sharing_mode: MediaCaptureSharingMode
    memory_preference: MediaCaptureMemoryPreference
    always_play_system_shutter_sound: _winrt.Boolean
    device_uri_password_credential: typing.Optional[winsdk.windows.security.credentials.PasswordCredential]
    device_uri: typing.Optional[winsdk.windows.foundation.Uri]
    @staticmethod
    def _from(obj: _winrt.Object) -> MediaCaptureInitializationSettings: ...
    def __init__(self) -> None: ...

class MediaCapturePauseResult(winsdk.windows.foundation.IClosable, _winrt.Object):
    last_frame: typing.Optional[winsdk.windows.media.VideoFrame]
    record_duration: winsdk.windows.foundation.TimeSpan
    @staticmethod
    def _from(obj: _winrt.Object) -> MediaCapturePauseResult: ...
    def close(self) -> None: ...

class MediaCaptureRelativePanelWatcher(winsdk.windows.foundation.IClosable, _winrt.Object):
    relative_panel: winsdk.windows.devices.enumeration.Panel
    @staticmethod
    def _from(obj: _winrt.Object) -> MediaCaptureRelativePanelWatcher: ...
    def close(self) -> None: ...
    def start(self) -> None: ...
    def stop(self) -> None: ...
    def add_changed(self, handler: winsdk.windows.foundation.TypedEventHandler[MediaCaptureRelativePanelWatcher, _winrt.Object]) -> winsdk.windows.foundation.EventRegistrationToken: ...
    def remove_changed(self, token: winsdk.windows.foundation.EventRegistrationToken) -> None: ...

class MediaCaptureSettings(_winrt.Object):
    audio_device_id: str
    photo_capture_source: PhotoCaptureSource
    streaming_capture_mode: StreamingCaptureMode
    video_device_characteristic: VideoDeviceCharacteristic
    video_device_id: str
    audio_processing: winsdk.windows.media.AudioProcessing
    camera_sound_required_for_region: _winrt.Boolean
    concurrent_record_and_photo_sequence_supported: _winrt.Boolean
    concurrent_record_and_photo_supported: _winrt.Boolean
    horizontal35mm_equivalent_focal_length: typing.Optional[typing.Optional[_winrt.UInt32]]
    media_category: MediaCategory
    pitch_offset_degrees: typing.Optional[typing.Optional[_winrt.Int32]]
    vertical35mm_equivalent_focal_length: typing.Optional[typing.Optional[_winrt.UInt32]]
    direct3_d11_device: typing.Optional[winsdk.windows.graphics.directx.direct3d11.IDirect3DDevice]
    @staticmethod
    def _from(obj: _winrt.Object) -> MediaCaptureSettings: ...

class MediaCaptureStopResult(winsdk.windows.foundation.IClosable, _winrt.Object):
    last_frame: typing.Optional[winsdk.windows.media.VideoFrame]
    record_duration: winsdk.windows.foundation.TimeSpan
    @staticmethod
    def _from(obj: _winrt.Object) -> MediaCaptureStopResult: ...
    def close(self) -> None: ...

class MediaCaptureVideoProfile(_winrt.Object):
    id: str
    supported_photo_media_description: typing.Optional[winsdk.windows.foundation.collections.IVectorView[MediaCaptureVideoProfileMediaDescription]]
    supported_preview_media_description: typing.Optional[winsdk.windows.foundation.collections.IVectorView[MediaCaptureVideoProfileMediaDescription]]
    supported_record_media_description: typing.Optional[winsdk.windows.foundation.collections.IVectorView[MediaCaptureVideoProfileMediaDescription]]
    video_device_id: str
    frame_source_infos: typing.Optional[winsdk.windows.foundation.collections.IVectorView[winsdk.windows.media.capture.frames.MediaFrameSourceInfo]]
    properties: typing.Optional[winsdk.windows.foundation.collections.IMapView[uuid.UUID, _winrt.Object]]
    @staticmethod
    def _from(obj: _winrt.Object) -> MediaCaptureVideoProfile: ...
    def get_concurrency(self) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[MediaCaptureVideoProfile]]: ...

class MediaCaptureVideoProfileMediaDescription(_winrt.Object):
    frame_rate: _winrt.Double
    height: _winrt.UInt32
    is_hdr_video_supported: _winrt.Boolean
    is_variable_photo_sequence_supported: _winrt.Boolean
    width: _winrt.UInt32
    properties: typing.Optional[winsdk.windows.foundation.collections.IMapView[uuid.UUID, _winrt.Object]]
    subtype: str
    @staticmethod
    def _from(obj: _winrt.Object) -> MediaCaptureVideoProfileMediaDescription: ...

class OptionalReferencePhotoCapturedEventArgs(_winrt.Object):
    context: typing.Optional[_winrt.Object]
    frame: typing.Optional[CapturedFrame]
    @staticmethod
    def _from(obj: _winrt.Object) -> OptionalReferencePhotoCapturedEventArgs: ...

class PhotoCapturedEventArgs(_winrt.Object):
    capture_time_offset: winsdk.windows.foundation.TimeSpan
    frame: typing.Optional[CapturedFrame]
    thumbnail: typing.Optional[CapturedFrame]
    @staticmethod
    def _from(obj: _winrt.Object) -> PhotoCapturedEventArgs: ...

class PhotoConfirmationCapturedEventArgs(_winrt.Object):
    capture_time_offset: winsdk.windows.foundation.TimeSpan
    frame: typing.Optional[CapturedFrame]
    @staticmethod
    def _from(obj: _winrt.Object) -> PhotoConfirmationCapturedEventArgs: ...

class VideoStreamConfiguration(_winrt.Object):
    input_properties: typing.Optional[winsdk.windows.media.mediaproperties.VideoEncodingProperties]
    output_properties: typing.Optional[winsdk.windows.media.mediaproperties.VideoEncodingProperties]
    @staticmethod
    def _from(obj: _winrt.Object) -> VideoStreamConfiguration: ...

MediaCaptureFailedEventHandler = typing.Callable[[typing.Optional[MediaCapture], typing.Optional[MediaCaptureFailedEventArgs]], None]

RecordLimitationExceededEventHandler = typing.Callable[[typing.Optional[MediaCapture]], None]

