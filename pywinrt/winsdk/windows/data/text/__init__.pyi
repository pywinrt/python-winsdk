# WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.5

import enum
import sys
import types
import typing
import uuid

import winsdk._winrt as _winrt
import winsdk.windows.foundation
import winsdk.windows.foundation.collections
import winsdk.windows.ui.text.core

class AlternateNormalizationFormat(enum.IntEnum):
    NOT_NORMALIZED = 0
    NUMBER = 1
    CURRENCY = 3
    DATE = 4
    TIME = 5

class TextPredictionOptions(enum.IntFlag):
    NONE = 0
    PREDICTIONS = 0x1
    CORRECTIONS = 0x2

class UnicodeGeneralCategory(enum.IntEnum):
    UPPERCASE_LETTER = 0
    LOWERCASE_LETTER = 1
    TITLECASE_LETTER = 2
    MODIFIER_LETTER = 3
    OTHER_LETTER = 4
    NONSPACING_MARK = 5
    SPACING_COMBINING_MARK = 6
    ENCLOSING_MARK = 7
    DECIMAL_DIGIT_NUMBER = 8
    LETTER_NUMBER = 9
    OTHER_NUMBER = 10
    SPACE_SEPARATOR = 11
    LINE_SEPARATOR = 12
    PARAGRAPH_SEPARATOR = 13
    CONTROL = 14
    FORMAT = 15
    SURROGATE = 16
    PRIVATE_USE = 17
    CONNECTOR_PUNCTUATION = 18
    DASH_PUNCTUATION = 19
    OPEN_PUNCTUATION = 20
    CLOSE_PUNCTUATION = 21
    INITIAL_QUOTE_PUNCTUATION = 22
    FINAL_QUOTE_PUNCTUATION = 23
    OTHER_PUNCTUATION = 24
    MATH_SYMBOL = 25
    CURRENCY_SYMBOL = 26
    MODIFIER_SYMBOL = 27
    OTHER_SYMBOL = 28
    NOT_ASSIGNED = 29

class UnicodeNumericType(enum.IntEnum):
    NONE = 0
    DECIMAL = 1
    DIGIT = 2
    NUMERIC = 3

Self = typing.TypeVar('Self')

class TextSegment:
    start_position: _winrt.UInt32
    length: _winrt.UInt32
    def __init__(self, start_position: _winrt.UInt32, length: _winrt.UInt32) -> None: ...

class AlternateWordForm(_winrt.Object):
    alternate_text: str
    normalization_format: AlternateNormalizationFormat
    source_text_segment: TextSegment
    @staticmethod
    def _from(obj: _winrt.Object) -> AlternateWordForm: ...

class SelectableWordSegment(_winrt.Object):
    source_text_segment: TextSegment
    text: str
    @staticmethod
    def _from(obj: _winrt.Object) -> SelectableWordSegment: ...

class SelectableWordsSegmenter(_winrt.Object):
    resolved_language: str
    @staticmethod
    def _from(obj: _winrt.Object) -> SelectableWordsSegmenter: ...
    def __init__(self, language: str) -> None: ...
    def get_token_at(self, text: str, start_index: _winrt.UInt32) -> typing.Optional[SelectableWordSegment]: ...
    def get_tokens(self, text: str) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[SelectableWordSegment]]: ...
    def tokenize(self, text: str, start_index: _winrt.UInt32, handler: typing.Optional[SelectableWordSegmentsTokenizingHandler]) -> None: ...

class SemanticTextQuery(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> SemanticTextQuery: ...
    @typing.overload
    def __init__(self, aqs_filter: str) -> None: ...
    @typing.overload
    def __init__(self, aqs_filter: str, filter_language: str) -> None: ...
    def find(self, content: str) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[TextSegment]]: ...
    def find_in_property(self, property_content: str, property_name: str) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[TextSegment]]: ...

class TextConversionGenerator(_winrt.Object):
    language_available_but_not_installed: _winrt.Boolean
    resolved_language: str
    @staticmethod
    def _from(obj: _winrt.Object) -> TextConversionGenerator: ...
    def __init__(self, language_tag: str) -> None: ...
    @typing.overload
    def get_candidates_async(self, input: str) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[str]]: ...
    @typing.overload
    def get_candidates_async(self, input: str, max_candidates: _winrt.UInt32) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[str]]: ...

class TextPhoneme(_winrt.Object):
    display_text: str
    reading_text: str
    @staticmethod
    def _from(obj: _winrt.Object) -> TextPhoneme: ...

class TextPredictionGenerator(_winrt.Object):
    language_available_but_not_installed: _winrt.Boolean
    resolved_language: str
    input_scope: winsdk.windows.ui.text.core.CoreTextInputScope
    @staticmethod
    def _from(obj: _winrt.Object) -> TextPredictionGenerator: ...
    def __init__(self, language_tag: str) -> None: ...
    @typing.overload
    def get_candidates_async(self, input: str) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[str]]: ...
    @typing.overload
    def get_candidates_async(self, input: str, max_candidates: _winrt.UInt32) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[str]]: ...
    @typing.overload
    def get_candidates_async(self, input: str, max_candidates: _winrt.UInt32, prediction_options: TextPredictionOptions, previous_strings: typing.Iterable[str]) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[str]]: ...
    def get_next_word_candidates_async(self, max_candidates: _winrt.UInt32, previous_strings: typing.Iterable[str]) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[str]]: ...

class TextReverseConversionGenerator(_winrt.Object):
    language_available_but_not_installed: _winrt.Boolean
    resolved_language: str
    @staticmethod
    def _from(obj: _winrt.Object) -> TextReverseConversionGenerator: ...
    def __init__(self, language_tag: str) -> None: ...
    def convert_back_async(self, input: str) -> winsdk.windows.foundation.IAsyncOperation[str]: ...
    def get_phonemes_async(self, input: str) -> winsdk.windows.foundation.IAsyncOperation[winsdk.windows.foundation.collections.IVectorView[TextPhoneme]]: ...

class UnicodeCharacters(_winrt.Object):
    @staticmethod
    def _from(obj: _winrt.Object) -> UnicodeCharacters: ...
    @staticmethod
    def get_codepoint_from_surrogate_pair(high_surrogate: _winrt.UInt32, low_surrogate: _winrt.UInt32) -> _winrt.UInt32: ...
    @staticmethod
    def get_general_category(codepoint: _winrt.UInt32) -> UnicodeGeneralCategory: ...
    @staticmethod
    def get_numeric_type(codepoint: _winrt.UInt32) -> UnicodeNumericType: ...
    @staticmethod
    def get_surrogate_pair_from_codepoint(codepoint: _winrt.UInt32) -> typing.Tuple[_winrt.Char16, _winrt.Char16]: ...
    @staticmethod
    def is_alphabetic(codepoint: _winrt.UInt32) -> _winrt.Boolean: ...
    @staticmethod
    def is_cased(codepoint: _winrt.UInt32) -> _winrt.Boolean: ...
    @staticmethod
    def is_grapheme_base(codepoint: _winrt.UInt32) -> _winrt.Boolean: ...
    @staticmethod
    def is_grapheme_extend(codepoint: _winrt.UInt32) -> _winrt.Boolean: ...
    @staticmethod
    def is_high_surrogate(codepoint: _winrt.UInt32) -> _winrt.Boolean: ...
    @staticmethod
    def is_id_continue(codepoint: _winrt.UInt32) -> _winrt.Boolean: ...
    @staticmethod
    def is_id_start(codepoint: _winrt.UInt32) -> _winrt.Boolean: ...
    @staticmethod
    def is_low_surrogate(codepoint: _winrt.UInt32) -> _winrt.Boolean: ...
    @staticmethod
    def is_lowercase(codepoint: _winrt.UInt32) -> _winrt.Boolean: ...
    @staticmethod
    def is_noncharacter(codepoint: _winrt.UInt32) -> _winrt.Boolean: ...
    @staticmethod
    def is_supplementary(codepoint: _winrt.UInt32) -> _winrt.Boolean: ...
    @staticmethod
    def is_uppercase(codepoint: _winrt.UInt32) -> _winrt.Boolean: ...
    @staticmethod
    def is_whitespace(codepoint: _winrt.UInt32) -> _winrt.Boolean: ...

class WordSegment(_winrt.Object):
    alternate_forms: typing.Optional[winsdk.windows.foundation.collections.IVectorView[AlternateWordForm]]
    source_text_segment: TextSegment
    text: str
    @staticmethod
    def _from(obj: _winrt.Object) -> WordSegment: ...

class WordsSegmenter(_winrt.Object):
    resolved_language: str
    @staticmethod
    def _from(obj: _winrt.Object) -> WordsSegmenter: ...
    def __init__(self, language: str) -> None: ...
    def get_token_at(self, text: str, start_index: _winrt.UInt32) -> typing.Optional[WordSegment]: ...
    def get_tokens(self, text: str) -> typing.Optional[winsdk.windows.foundation.collections.IVectorView[WordSegment]]: ...
    def tokenize(self, text: str, start_index: _winrt.UInt32, handler: typing.Optional[WordSegmentsTokenizingHandler]) -> None: ...

SelectableWordSegmentsTokenizingHandler = typing.Callable[[typing.Iterable[SelectableWordSegment], typing.Iterable[SelectableWordSegment]], None]

WordSegmentsTokenizingHandler = typing.Callable[[typing.Iterable[WordSegment], typing.Iterable[WordSegment]], None]

