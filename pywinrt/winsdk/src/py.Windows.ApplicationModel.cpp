// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.ApplicationModel.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::AppDisplayInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::AppInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::AppInstallerInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::AppInstance>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DesignMode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::EnteredBackgroundEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::LeavingBackgroundEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::LimitedAccessFeatureRequestResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::LimitedAccessFeatures>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Package>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalog>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageContentGroup>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageId>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageInstallingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageStagingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageStatus>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageUpdateAvailabilityResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::StartupTask>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::SuspendingDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::SuspendingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::SuspendingOperation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::IEnteredBackgroundEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ILeavingBackgroundEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingOperation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageInstallProgress>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::PackageVersion>::python_type;

PyObject* py::converter<winrt::Windows::ApplicationModel::PackageInstallProgress>::convert(winrt::Windows::ApplicationModel::PackageInstallProgress instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::ApplicationModel::PackageInstallProgress>());
}
winrt::Windows::ApplicationModel::PackageInstallProgress py::converter<winrt::Windows::ApplicationModel::PackageInstallProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::ApplicationModel::PackageInstallProgress>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::ApplicationModel::PackageInstallProgress>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::ApplicationModel::PackageInstallProgress return_value{};

    PyObject* py_PercentComplete = PyDict_GetItemString(obj, "percent_complete");
    if (!py_PercentComplete) { throw winrt::hresult_invalid_argument(); }
    return_value.PercentComplete = converter<uint32_t>::convert_to(py_PercentComplete);

    return return_value;
}

PyObject* py::converter<winrt::Windows::ApplicationModel::PackageVersion>::convert(winrt::Windows::ApplicationModel::PackageVersion instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::ApplicationModel::PackageVersion>());
}
winrt::Windows::ApplicationModel::PackageVersion py::converter<winrt::Windows::ApplicationModel::PackageVersion>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::ApplicationModel::PackageVersion>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::ApplicationModel::PackageVersion>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::ApplicationModel::PackageVersion return_value{};

    PyObject* py_Major = PyDict_GetItemString(obj, "major");
    if (!py_Major) { throw winrt::hresult_invalid_argument(); }
    return_value.Major = converter<uint16_t>::convert_to(py_Major);

    PyObject* py_Minor = PyDict_GetItemString(obj, "minor");
    if (!py_Minor) { throw winrt::hresult_invalid_argument(); }
    return_value.Minor = converter<uint16_t>::convert_to(py_Minor);

    PyObject* py_Build = PyDict_GetItemString(obj, "build");
    if (!py_Build) { throw winrt::hresult_invalid_argument(); }
    return_value.Build = converter<uint16_t>::convert_to(py_Build);

    PyObject* py_Revision = PyDict_GetItemString(obj, "revision");
    if (!py_Revision) { throw winrt::hresult_invalid_argument(); }
    return_value.Revision = converter<uint16_t>::convert_to(py_Revision);

    return return_value;
}

namespace py::cpp::Windows::ApplicationModel
{
    // ----- AppDisplayInfo class --------------------
    constexpr const char* const _type_name_AppDisplayInfo = "AppDisplayInfo";

    static PyObject* _new_AppDisplayInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppDisplayInfo);
        return nullptr;
    }

    static void _dealloc_AppDisplayInfo(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppDisplayInfo_GetLogo(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(self->obj.GetLogo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppDisplayInfo_get_Description(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppDisplayInfo_get_DisplayName(py::wrapper::Windows::ApplicationModel::AppDisplayInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppDisplayInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppDisplayInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppDisplayInfo[] = {
        { "get_logo", reinterpret_cast<PyCFunction>(AppDisplayInfo_GetLogo), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppDisplayInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppDisplayInfo[] = {
        { "description", reinterpret_cast<getter>(AppDisplayInfo_get_Description), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(AppDisplayInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppDisplayInfo[] = 
    {
        { Py_tp_new, _new_AppDisplayInfo },
        { Py_tp_dealloc, _dealloc_AppDisplayInfo },
        { Py_tp_methods, _methods_AppDisplayInfo },
        { Py_tp_getset, _getset_AppDisplayInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppDisplayInfo =
    {
        "_winsdk_Windows_ApplicationModel.AppDisplayInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::AppDisplayInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppDisplayInfo
    };

    // ----- AppInfo class --------------------
    constexpr const char* const _type_name_AppInfo = "AppInfo";

    static PyObject* _new_AppInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppInfo);
        return nullptr;
    }

    static void _dealloc_AppInfo(py::wrapper::Windows::ApplicationModel::AppInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppInfo_GetFromAppUserModelId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::AppInfo::GetFromAppUserModelId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInfo_GetFromAppUserModelIdForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::AppInfo::GetFromAppUserModelIdForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_AppUserModelId(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppUserModelId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_DisplayInfo(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_Id(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_PackageFamilyName(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_Package(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_ExecutionContext(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExecutionContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_SupportedFileExtensions(py::wrapper::Windows::ApplicationModel::AppInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedFileExtensions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInfo_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::AppInfo::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInfo[] = {
        { "get_from_app_user_model_id", reinterpret_cast<PyCFunction>(AppInfo_GetFromAppUserModelId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_from_app_user_model_id_for_user", reinterpret_cast<PyCFunction>(AppInfo_GetFromAppUserModelIdForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current", reinterpret_cast<PyCFunction>(AppInfo_get_Current), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppInfo[] = {
        { "app_user_model_id", reinterpret_cast<getter>(AppInfo_get_AppUserModelId), nullptr, nullptr, nullptr },
        { "display_info", reinterpret_cast<getter>(AppInfo_get_DisplayInfo), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(AppInfo_get_Id), nullptr, nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(AppInfo_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(AppInfo_get_Package), nullptr, nullptr, nullptr },
        { "execution_context", reinterpret_cast<getter>(AppInfo_get_ExecutionContext), nullptr, nullptr, nullptr },
        { "supported_file_extensions", reinterpret_cast<getter>(AppInfo_get_SupportedFileExtensions), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppInfo[] = 
    {
        { Py_tp_new, _new_AppInfo },
        { Py_tp_dealloc, _dealloc_AppInfo },
        { Py_tp_methods, _methods_AppInfo },
        { Py_tp_getset, _getset_AppInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppInfo =
    {
        "_winsdk_Windows_ApplicationModel.AppInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::AppInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInfo
    };

    // ----- AppInstallerInfo class --------------------
    constexpr const char* const _type_name_AppInstallerInfo = "AppInstallerInfo";

    static PyObject* _new_AppInstallerInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppInstallerInfo);
        return nullptr;
    }

    static void _dealloc_AppInstallerInfo(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppInstallerInfo_get_Uri(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_AutomaticBackgroundTask(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutomaticBackgroundTask());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_DependencyPackageUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_HoursBetweenUpdateChecks(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HoursBetweenUpdateChecks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_IsAutoRepairEnabled(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAutoRepairEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_LastChecked(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastChecked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_OnLaunch(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OnLaunch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_OptionalPackageUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_PausedUntil(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PausedUntil());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_PolicySource(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PolicySource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_RepairUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepairUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_ShowPrompt(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShowPrompt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_UpdateBlocksActivation(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateBlocksActivation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_UpdateUris(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstallerInfo_get_Version(py::wrapper::Windows::ApplicationModel::AppInstallerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppInstallerInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppInstallerInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInstallerInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AppInstallerInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppInstallerInfo[] = {
        { "uri", reinterpret_cast<getter>(AppInstallerInfo_get_Uri), nullptr, nullptr, nullptr },
        { "automatic_background_task", reinterpret_cast<getter>(AppInstallerInfo_get_AutomaticBackgroundTask), nullptr, nullptr, nullptr },
        { "dependency_package_uris", reinterpret_cast<getter>(AppInstallerInfo_get_DependencyPackageUris), nullptr, nullptr, nullptr },
        { "force_update_from_any_version", reinterpret_cast<getter>(AppInstallerInfo_get_ForceUpdateFromAnyVersion), nullptr, nullptr, nullptr },
        { "hours_between_update_checks", reinterpret_cast<getter>(AppInstallerInfo_get_HoursBetweenUpdateChecks), nullptr, nullptr, nullptr },
        { "is_auto_repair_enabled", reinterpret_cast<getter>(AppInstallerInfo_get_IsAutoRepairEnabled), nullptr, nullptr, nullptr },
        { "last_checked", reinterpret_cast<getter>(AppInstallerInfo_get_LastChecked), nullptr, nullptr, nullptr },
        { "on_launch", reinterpret_cast<getter>(AppInstallerInfo_get_OnLaunch), nullptr, nullptr, nullptr },
        { "optional_package_uris", reinterpret_cast<getter>(AppInstallerInfo_get_OptionalPackageUris), nullptr, nullptr, nullptr },
        { "paused_until", reinterpret_cast<getter>(AppInstallerInfo_get_PausedUntil), nullptr, nullptr, nullptr },
        { "policy_source", reinterpret_cast<getter>(AppInstallerInfo_get_PolicySource), nullptr, nullptr, nullptr },
        { "repair_uris", reinterpret_cast<getter>(AppInstallerInfo_get_RepairUris), nullptr, nullptr, nullptr },
        { "show_prompt", reinterpret_cast<getter>(AppInstallerInfo_get_ShowPrompt), nullptr, nullptr, nullptr },
        { "update_blocks_activation", reinterpret_cast<getter>(AppInstallerInfo_get_UpdateBlocksActivation), nullptr, nullptr, nullptr },
        { "update_uris", reinterpret_cast<getter>(AppInstallerInfo_get_UpdateUris), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(AppInstallerInfo_get_Version), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppInstallerInfo[] = 
    {
        { Py_tp_new, _new_AppInstallerInfo },
        { Py_tp_dealloc, _dealloc_AppInstallerInfo },
        { Py_tp_methods, _methods_AppInstallerInfo },
        { Py_tp_getset, _getset_AppInstallerInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppInstallerInfo =
    {
        "_winsdk_Windows_ApplicationModel.AppInstallerInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::AppInstallerInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInstallerInfo
    };

    // ----- AppInstance class --------------------
    constexpr const char* const _type_name_AppInstance = "AppInstance";

    static PyObject* _new_AppInstance(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppInstance);
        return nullptr;
    }

    static void _dealloc_AppInstance(py::wrapper::Windows::ApplicationModel::AppInstance* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppInstance_FindOrRegisterInstanceForKey(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::AppInstance::FindOrRegisterInstanceForKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_GetActivatedEventArgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::AppInstance::GetActivatedEventArgs());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_GetInstances(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::AppInstance::GetInstances());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_RedirectActivationTo(py::wrapper::Windows::ApplicationModel::AppInstance* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RedirectActivationTo();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_Unregister(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::AppInstance::Unregister();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstance_get_IsCurrentInstance(py::wrapper::Windows::ApplicationModel::AppInstance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCurrentInstance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstance_get_Key(py::wrapper::Windows::ApplicationModel::AppInstance* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Key());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppInstance_get_RecommendedInstance(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::AppInstance::RecommendedInstance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppInstance(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::AppInstance>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInstance[] = {
        { "find_or_register_instance_for_key", reinterpret_cast<PyCFunction>(AppInstance_FindOrRegisterInstanceForKey), METH_VARARGS | METH_STATIC, nullptr },
        { "get_activated_event_args", reinterpret_cast<PyCFunction>(AppInstance_GetActivatedEventArgs), METH_VARARGS | METH_STATIC, nullptr },
        { "get_instances", reinterpret_cast<PyCFunction>(AppInstance_GetInstances), METH_VARARGS | METH_STATIC, nullptr },
        { "redirect_activation_to", reinterpret_cast<PyCFunction>(AppInstance_RedirectActivationTo), METH_VARARGS, nullptr },
        { "unregister", reinterpret_cast<PyCFunction>(AppInstance_Unregister), METH_VARARGS | METH_STATIC, nullptr },
        { "get_recommended_instance", reinterpret_cast<PyCFunction>(AppInstance_get_RecommendedInstance), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppInstance), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppInstance[] = {
        { "is_current_instance", reinterpret_cast<getter>(AppInstance_get_IsCurrentInstance), nullptr, nullptr, nullptr },
        { "key", reinterpret_cast<getter>(AppInstance_get_Key), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppInstance[] = 
    {
        { Py_tp_new, _new_AppInstance },
        { Py_tp_dealloc, _dealloc_AppInstance },
        { Py_tp_methods, _methods_AppInstance },
        { Py_tp_getset, _getset_AppInstance },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppInstance =
    {
        "_winsdk_Windows_ApplicationModel.AppInstance",
        sizeof(py::wrapper::Windows::ApplicationModel::AppInstance),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInstance
    };

    // ----- DesignMode class --------------------
    constexpr const char* const _type_name_DesignMode = "DesignMode";

    static PyObject* _new_DesignMode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DesignMode);
        return nullptr;
    }

    static PyObject* DesignMode_get_DesignModeEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DesignMode::DesignModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DesignMode_get_DesignMode2Enabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DesignMode::DesignMode2Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DesignMode[] = {
        { "get_design_mode_enabled", reinterpret_cast<PyCFunction>(DesignMode_get_DesignModeEnabled), METH_NOARGS | METH_STATIC, nullptr },
        { "get_design_mode2_enabled", reinterpret_cast<PyCFunction>(DesignMode_get_DesignMode2Enabled), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DesignMode[] = {
        { }
    };

    static PyType_Slot _type_slots_DesignMode[] = 
    {
        { Py_tp_new, _new_DesignMode },
        { Py_tp_methods, _methods_DesignMode },
        { Py_tp_getset, _getset_DesignMode },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DesignMode =
    {
        "_winsdk_Windows_ApplicationModel.DesignMode",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DesignMode
    };

    // ----- EnteredBackgroundEventArgs class --------------------
    constexpr const char* const _type_name_EnteredBackgroundEventArgs = "EnteredBackgroundEventArgs";

    static PyObject* _new_EnteredBackgroundEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EnteredBackgroundEventArgs);
        return nullptr;
    }

    static void _dealloc_EnteredBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::EnteredBackgroundEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EnteredBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::EnteredBackgroundEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_EnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::EnteredBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EnteredBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(EnteredBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_EnteredBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EnteredBackgroundEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_EnteredBackgroundEventArgs[] = 
    {
        { Py_tp_new, _new_EnteredBackgroundEventArgs },
        { Py_tp_dealloc, _dealloc_EnteredBackgroundEventArgs },
        { Py_tp_methods, _methods_EnteredBackgroundEventArgs },
        { Py_tp_getset, _getset_EnteredBackgroundEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_EnteredBackgroundEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.EnteredBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::EnteredBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EnteredBackgroundEventArgs
    };

    // ----- LeavingBackgroundEventArgs class --------------------
    constexpr const char* const _type_name_LeavingBackgroundEventArgs = "LeavingBackgroundEventArgs";

    static PyObject* _new_LeavingBackgroundEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LeavingBackgroundEventArgs);
        return nullptr;
    }

    static void _dealloc_LeavingBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::LeavingBackgroundEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LeavingBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::LeavingBackgroundEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_LeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::LeavingBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LeavingBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(LeavingBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LeavingBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LeavingBackgroundEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_LeavingBackgroundEventArgs[] = 
    {
        { Py_tp_new, _new_LeavingBackgroundEventArgs },
        { Py_tp_dealloc, _dealloc_LeavingBackgroundEventArgs },
        { Py_tp_methods, _methods_LeavingBackgroundEventArgs },
        { Py_tp_getset, _getset_LeavingBackgroundEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LeavingBackgroundEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.LeavingBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::LeavingBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LeavingBackgroundEventArgs
    };

    // ----- LimitedAccessFeatureRequestResult class --------------------
    constexpr const char* const _type_name_LimitedAccessFeatureRequestResult = "LimitedAccessFeatureRequestResult";

    static PyObject* _new_LimitedAccessFeatureRequestResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LimitedAccessFeatureRequestResult);
        return nullptr;
    }

    static void _dealloc_LimitedAccessFeatureRequestResult(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LimitedAccessFeatureRequestResult_get_EstimatedRemovalDate(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EstimatedRemovalDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LimitedAccessFeatureRequestResult_get_FeatureId(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FeatureId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LimitedAccessFeatureRequestResult_get_Status(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LimitedAccessFeatureRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::LimitedAccessFeatureRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LimitedAccessFeatureRequestResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LimitedAccessFeatureRequestResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LimitedAccessFeatureRequestResult[] = {
        { "estimated_removal_date", reinterpret_cast<getter>(LimitedAccessFeatureRequestResult_get_EstimatedRemovalDate), nullptr, nullptr, nullptr },
        { "feature_id", reinterpret_cast<getter>(LimitedAccessFeatureRequestResult_get_FeatureId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(LimitedAccessFeatureRequestResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LimitedAccessFeatureRequestResult[] = 
    {
        { Py_tp_new, _new_LimitedAccessFeatureRequestResult },
        { Py_tp_dealloc, _dealloc_LimitedAccessFeatureRequestResult },
        { Py_tp_methods, _methods_LimitedAccessFeatureRequestResult },
        { Py_tp_getset, _getset_LimitedAccessFeatureRequestResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LimitedAccessFeatureRequestResult =
    {
        "_winsdk_Windows_ApplicationModel.LimitedAccessFeatureRequestResult",
        sizeof(py::wrapper::Windows::ApplicationModel::LimitedAccessFeatureRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LimitedAccessFeatureRequestResult
    };

    // ----- LimitedAccessFeatures class --------------------
    constexpr const char* const _type_name_LimitedAccessFeatures = "LimitedAccessFeatures";

    static PyObject* _new_LimitedAccessFeatures(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LimitedAccessFeatures);
        return nullptr;
    }

    static PyObject* LimitedAccessFeatures_TryUnlockFeature(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::ApplicationModel::LimitedAccessFeatures::TryUnlockFeature(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_LimitedAccessFeatures[] = {
        { "try_unlock_feature", reinterpret_cast<PyCFunction>(LimitedAccessFeatures_TryUnlockFeature), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LimitedAccessFeatures[] = {
        { }
    };

    static PyType_Slot _type_slots_LimitedAccessFeatures[] = 
    {
        { Py_tp_new, _new_LimitedAccessFeatures },
        { Py_tp_methods, _methods_LimitedAccessFeatures },
        { Py_tp_getset, _getset_LimitedAccessFeatures },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LimitedAccessFeatures =
    {
        "_winsdk_Windows_ApplicationModel.LimitedAccessFeatures",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LimitedAccessFeatures
    };

    // ----- Package class --------------------
    constexpr const char* const _type_name_Package = "Package";

    static PyObject* _new_Package(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Package);
        return nullptr;
    }

    static void _dealloc_Package(py::wrapper::Windows::ApplicationModel::Package* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Package_CheckUpdateAvailabilityAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CheckUpdateAvailabilityAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetAppInstallerInfo(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAppInstallerInfo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetAppListEntries(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAppListEntries());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetAppListEntriesAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAppListEntriesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetContentGroupAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetContentGroupAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetContentGroupsAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetContentGroupsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetLogoAsRandomAccessStreamReference(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(args, 0);

                return py::convert(self->obj.GetLogoAsRandomAccessStreamReference(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_GetThumbnailToken(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetThumbnailToken());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_Launch(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Launch(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_SetInUseAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetInUseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_StageContentGroupsAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.StageContentGroupsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.StageContentGroupsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_VerifyContentIntegrityAsync(py::wrapper::Windows::ApplicationModel::Package* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.VerifyContentIntegrityAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Package_get_Dependencies(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Dependencies());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Id(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstalledLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstalledLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsFramework(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsFramework());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Description(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_DisplayName(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsBundle(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBundle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsDevelopmentMode(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDevelopmentMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsResourcePackage(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsResourcePackage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Logo(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_PublisherDisplayName(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublisherDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstalledDate(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstalledDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Status(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsOptional(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOptional());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_SignatureKind(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignatureKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectiveLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectiveLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MutableLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MutableLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectiveExternalLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectiveExternalLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectiveExternalPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectiveExternalPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_EffectivePath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectivePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstalledPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstalledPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_IsStub(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStub());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MachineExternalLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MachineExternalLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MachineExternalPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MachineExternalPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_MutablePath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MutablePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_UserExternalLocation(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserExternalLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_UserExternalPath(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserExternalPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_InstallDate(py::wrapper::Windows::ApplicationModel::Package* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstallDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Package_get_Current(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Package::Current());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Package(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Package>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Package[] = {
        { "check_update_availability_async", reinterpret_cast<PyCFunction>(Package_CheckUpdateAvailabilityAsync), METH_VARARGS, nullptr },
        { "get_app_installer_info", reinterpret_cast<PyCFunction>(Package_GetAppInstallerInfo), METH_VARARGS, nullptr },
        { "get_app_list_entries", reinterpret_cast<PyCFunction>(Package_GetAppListEntries), METH_VARARGS, nullptr },
        { "get_app_list_entries_async", reinterpret_cast<PyCFunction>(Package_GetAppListEntriesAsync), METH_VARARGS, nullptr },
        { "get_content_group_async", reinterpret_cast<PyCFunction>(Package_GetContentGroupAsync), METH_VARARGS, nullptr },
        { "get_content_groups_async", reinterpret_cast<PyCFunction>(Package_GetContentGroupsAsync), METH_VARARGS, nullptr },
        { "get_logo_as_random_access_stream_reference", reinterpret_cast<PyCFunction>(Package_GetLogoAsRandomAccessStreamReference), METH_VARARGS, nullptr },
        { "get_thumbnail_token", reinterpret_cast<PyCFunction>(Package_GetThumbnailToken), METH_VARARGS, nullptr },
        { "launch", reinterpret_cast<PyCFunction>(Package_Launch), METH_VARARGS, nullptr },
        { "set_in_use_async", reinterpret_cast<PyCFunction>(Package_SetInUseAsync), METH_VARARGS, nullptr },
        { "stage_content_groups_async", reinterpret_cast<PyCFunction>(Package_StageContentGroupsAsync), METH_VARARGS, nullptr },
        { "verify_content_integrity_async", reinterpret_cast<PyCFunction>(Package_VerifyContentIntegrityAsync), METH_VARARGS, nullptr },
        { "get_current", reinterpret_cast<PyCFunction>(Package_get_Current), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Package), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Package[] = {
        { "dependencies", reinterpret_cast<getter>(Package_get_Dependencies), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(Package_get_Id), nullptr, nullptr, nullptr },
        { "installed_location", reinterpret_cast<getter>(Package_get_InstalledLocation), nullptr, nullptr, nullptr },
        { "is_framework", reinterpret_cast<getter>(Package_get_IsFramework), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(Package_get_Description), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(Package_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_bundle", reinterpret_cast<getter>(Package_get_IsBundle), nullptr, nullptr, nullptr },
        { "is_development_mode", reinterpret_cast<getter>(Package_get_IsDevelopmentMode), nullptr, nullptr, nullptr },
        { "is_resource_package", reinterpret_cast<getter>(Package_get_IsResourcePackage), nullptr, nullptr, nullptr },
        { "logo", reinterpret_cast<getter>(Package_get_Logo), nullptr, nullptr, nullptr },
        { "publisher_display_name", reinterpret_cast<getter>(Package_get_PublisherDisplayName), nullptr, nullptr, nullptr },
        { "installed_date", reinterpret_cast<getter>(Package_get_InstalledDate), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(Package_get_Status), nullptr, nullptr, nullptr },
        { "is_optional", reinterpret_cast<getter>(Package_get_IsOptional), nullptr, nullptr, nullptr },
        { "signature_kind", reinterpret_cast<getter>(Package_get_SignatureKind), nullptr, nullptr, nullptr },
        { "effective_location", reinterpret_cast<getter>(Package_get_EffectiveLocation), nullptr, nullptr, nullptr },
        { "mutable_location", reinterpret_cast<getter>(Package_get_MutableLocation), nullptr, nullptr, nullptr },
        { "effective_external_location", reinterpret_cast<getter>(Package_get_EffectiveExternalLocation), nullptr, nullptr, nullptr },
        { "effective_external_path", reinterpret_cast<getter>(Package_get_EffectiveExternalPath), nullptr, nullptr, nullptr },
        { "effective_path", reinterpret_cast<getter>(Package_get_EffectivePath), nullptr, nullptr, nullptr },
        { "installed_path", reinterpret_cast<getter>(Package_get_InstalledPath), nullptr, nullptr, nullptr },
        { "is_stub", reinterpret_cast<getter>(Package_get_IsStub), nullptr, nullptr, nullptr },
        { "machine_external_location", reinterpret_cast<getter>(Package_get_MachineExternalLocation), nullptr, nullptr, nullptr },
        { "machine_external_path", reinterpret_cast<getter>(Package_get_MachineExternalPath), nullptr, nullptr, nullptr },
        { "mutable_path", reinterpret_cast<getter>(Package_get_MutablePath), nullptr, nullptr, nullptr },
        { "user_external_location", reinterpret_cast<getter>(Package_get_UserExternalLocation), nullptr, nullptr, nullptr },
        { "user_external_path", reinterpret_cast<getter>(Package_get_UserExternalPath), nullptr, nullptr, nullptr },
        { "install_date", reinterpret_cast<getter>(Package_get_InstallDate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Package[] = 
    {
        { Py_tp_new, _new_Package },
        { Py_tp_dealloc, _dealloc_Package },
        { Py_tp_methods, _methods_Package },
        { Py_tp_getset, _getset_Package },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Package =
    {
        "_winsdk_Windows_ApplicationModel.Package",
        sizeof(py::wrapper::Windows::ApplicationModel::Package),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Package
    };

    // ----- PackageCatalog class --------------------
    constexpr const char* const _type_name_PackageCatalog = "PackageCatalog";

    static PyObject* _new_PackageCatalog(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageCatalog);
        return nullptr;
    }

    static void _dealloc_PackageCatalog(py::wrapper::Windows::ApplicationModel::PackageCatalog* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageCatalog_AddOptionalPackageAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddOptionalPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_AddResourcePackageAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::AddResourcePackageOptions>(args, 2);

                return py::convert(self->obj.AddResourcePackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_OpenForCurrentPackage(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::PackageCatalog::OpenForCurrentPackage());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_OpenForCurrentUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::PackageCatalog::OpenForCurrentUser());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_RemoveOptionalPackagesAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RemoveOptionalPackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_RemoveResourcePackagesAsync(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Package>>(args, 0);

                return py::convert(self->obj.RemoveResourcePackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageInstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageInstallingEventArgs>>(arg);

            return py::convert(self->obj.PackageInstalling(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageInstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageInstalling(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageStagingEventArgs>>(arg);

            return py::convert(self->obj.PackageStaging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageStaging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageStatusChanged(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>>(arg);

            return py::convert(self->obj.PackageStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageStatusChanged(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageUninstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>>(arg);

            return py::convert(self->obj.PackageUninstalling(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageUninstalling(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageUninstalling(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageUpdating(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>>(arg);

            return py::convert(self->obj.PackageUpdating(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageUpdating(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageUpdating(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_add_PackageContentGroupStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::PackageCatalog, winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>>(arg);

            return py::convert(self->obj.PackageContentGroupStaging(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalog_remove_PackageContentGroupStaging(py::wrapper::Windows::ApplicationModel::PackageCatalog* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PackageContentGroupStaging(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageCatalog(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalog>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalog[] = {
        { "add_optional_package_async", reinterpret_cast<PyCFunction>(PackageCatalog_AddOptionalPackageAsync), METH_VARARGS, nullptr },
        { "add_resource_package_async", reinterpret_cast<PyCFunction>(PackageCatalog_AddResourcePackageAsync), METH_VARARGS, nullptr },
        { "open_for_current_package", reinterpret_cast<PyCFunction>(PackageCatalog_OpenForCurrentPackage), METH_VARARGS | METH_STATIC, nullptr },
        { "open_for_current_user", reinterpret_cast<PyCFunction>(PackageCatalog_OpenForCurrentUser), METH_VARARGS | METH_STATIC, nullptr },
        { "remove_optional_packages_async", reinterpret_cast<PyCFunction>(PackageCatalog_RemoveOptionalPackagesAsync), METH_VARARGS, nullptr },
        { "remove_resource_packages_async", reinterpret_cast<PyCFunction>(PackageCatalog_RemoveResourcePackagesAsync), METH_VARARGS, nullptr },
        { "add_package_installing", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageInstalling), METH_O, nullptr },
        { "remove_package_installing", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageInstalling), METH_O, nullptr },
        { "add_package_staging", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageStaging), METH_O, nullptr },
        { "remove_package_staging", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageStaging), METH_O, nullptr },
        { "add_package_status_changed", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageStatusChanged), METH_O, nullptr },
        { "remove_package_status_changed", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageStatusChanged), METH_O, nullptr },
        { "add_package_uninstalling", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageUninstalling), METH_O, nullptr },
        { "remove_package_uninstalling", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageUninstalling), METH_O, nullptr },
        { "add_package_updating", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageUpdating), METH_O, nullptr },
        { "remove_package_updating", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageUpdating), METH_O, nullptr },
        { "add_package_content_group_staging", reinterpret_cast<PyCFunction>(PackageCatalog_add_PackageContentGroupStaging), METH_O, nullptr },
        { "remove_package_content_group_staging", reinterpret_cast<PyCFunction>(PackageCatalog_remove_PackageContentGroupStaging), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalog), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalog[] = {
        { }
    };

    static PyType_Slot _type_slots_PackageCatalog[] = 
    {
        { Py_tp_new, _new_PackageCatalog },
        { Py_tp_dealloc, _dealloc_PackageCatalog },
        { Py_tp_methods, _methods_PackageCatalog },
        { Py_tp_getset, _getset_PackageCatalog },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageCatalog =
    {
        "_winsdk_Windows_ApplicationModel.PackageCatalog",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalog),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalog
    };

    // ----- PackageCatalogAddOptionalPackageResult class --------------------
    constexpr const char* const _type_name_PackageCatalogAddOptionalPackageResult = "PackageCatalogAddOptionalPackageResult";

    static PyObject* _new_PackageCatalogAddOptionalPackageResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageCatalogAddOptionalPackageResult);
        return nullptr;
    }

    static void _dealloc_PackageCatalogAddOptionalPackageResult(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageCatalogAddOptionalPackageResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogAddOptionalPackageResult_get_Package(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageCatalogAddOptionalPackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogAddOptionalPackageResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalogAddOptionalPackageResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalogAddOptionalPackageResult[] = {
        { "extended_error", reinterpret_cast<getter>(PackageCatalogAddOptionalPackageResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageCatalogAddOptionalPackageResult_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageCatalogAddOptionalPackageResult[] = 
    {
        { Py_tp_new, _new_PackageCatalogAddOptionalPackageResult },
        { Py_tp_dealloc, _dealloc_PackageCatalogAddOptionalPackageResult },
        { Py_tp_methods, _methods_PackageCatalogAddOptionalPackageResult },
        { Py_tp_getset, _getset_PackageCatalogAddOptionalPackageResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageCatalogAddOptionalPackageResult =
    {
        "_winsdk_Windows_ApplicationModel.PackageCatalogAddOptionalPackageResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogAddOptionalPackageResult
    };

    // ----- PackageCatalogAddResourcePackageResult class --------------------
    constexpr const char* const _type_name_PackageCatalogAddResourcePackageResult = "PackageCatalogAddResourcePackageResult";

    static PyObject* _new_PackageCatalogAddResourcePackageResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageCatalogAddResourcePackageResult);
        return nullptr;
    }

    static void _dealloc_PackageCatalogAddResourcePackageResult(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageCatalogAddResourcePackageResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogAddResourcePackageResult_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogAddResourcePackageResult_get_Package(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageCatalogAddResourcePackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogAddResourcePackageResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalogAddResourcePackageResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalogAddResourcePackageResult[] = {
        { "extended_error", reinterpret_cast<getter>(PackageCatalogAddResourcePackageResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageCatalogAddResourcePackageResult_get_IsComplete), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageCatalogAddResourcePackageResult_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageCatalogAddResourcePackageResult[] = 
    {
        { Py_tp_new, _new_PackageCatalogAddResourcePackageResult },
        { Py_tp_dealloc, _dealloc_PackageCatalogAddResourcePackageResult },
        { Py_tp_methods, _methods_PackageCatalogAddResourcePackageResult },
        { Py_tp_getset, _getset_PackageCatalogAddResourcePackageResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageCatalogAddResourcePackageResult =
    {
        "_winsdk_Windows_ApplicationModel.PackageCatalogAddResourcePackageResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogAddResourcePackageResult
    };

    // ----- PackageCatalogRemoveOptionalPackagesResult class --------------------
    constexpr const char* const _type_name_PackageCatalogRemoveOptionalPackagesResult = "PackageCatalogRemoveOptionalPackagesResult";

    static PyObject* _new_PackageCatalogRemoveOptionalPackagesResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageCatalogRemoveOptionalPackagesResult);
        return nullptr;
    }

    static void _dealloc_PackageCatalogRemoveOptionalPackagesResult(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageCatalogRemoveOptionalPackagesResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogRemoveOptionalPackagesResult_get_PackagesRemoved(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackagesRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageCatalogRemoveOptionalPackagesResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogRemoveOptionalPackagesResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalogRemoveOptionalPackagesResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalogRemoveOptionalPackagesResult[] = {
        { "extended_error", reinterpret_cast<getter>(PackageCatalogRemoveOptionalPackagesResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "packages_removed", reinterpret_cast<getter>(PackageCatalogRemoveOptionalPackagesResult_get_PackagesRemoved), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageCatalogRemoveOptionalPackagesResult[] = 
    {
        { Py_tp_new, _new_PackageCatalogRemoveOptionalPackagesResult },
        { Py_tp_dealloc, _dealloc_PackageCatalogRemoveOptionalPackagesResult },
        { Py_tp_methods, _methods_PackageCatalogRemoveOptionalPackagesResult },
        { Py_tp_getset, _getset_PackageCatalogRemoveOptionalPackagesResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageCatalogRemoveOptionalPackagesResult =
    {
        "_winsdk_Windows_ApplicationModel.PackageCatalogRemoveOptionalPackagesResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogRemoveOptionalPackagesResult
    };

    // ----- PackageCatalogRemoveResourcePackagesResult class --------------------
    constexpr const char* const _type_name_PackageCatalogRemoveResourcePackagesResult = "PackageCatalogRemoveResourcePackagesResult";

    static PyObject* _new_PackageCatalogRemoveResourcePackagesResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageCatalogRemoveResourcePackagesResult);
        return nullptr;
    }

    static void _dealloc_PackageCatalogRemoveResourcePackagesResult(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageCatalogRemoveResourcePackagesResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageCatalogRemoveResourcePackagesResult_get_PackagesRemoved(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackagesRemoved());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageCatalogRemoveResourcePackagesResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageCatalogRemoveResourcePackagesResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageCatalogRemoveResourcePackagesResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageCatalogRemoveResourcePackagesResult[] = {
        { "extended_error", reinterpret_cast<getter>(PackageCatalogRemoveResourcePackagesResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "packages_removed", reinterpret_cast<getter>(PackageCatalogRemoveResourcePackagesResult_get_PackagesRemoved), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageCatalogRemoveResourcePackagesResult[] = 
    {
        { Py_tp_new, _new_PackageCatalogRemoveResourcePackagesResult },
        { Py_tp_dealloc, _dealloc_PackageCatalogRemoveResourcePackagesResult },
        { Py_tp_methods, _methods_PackageCatalogRemoveResourcePackagesResult },
        { Py_tp_getset, _getset_PackageCatalogRemoveResourcePackagesResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageCatalogRemoveResourcePackagesResult =
    {
        "_winsdk_Windows_ApplicationModel.PackageCatalogRemoveResourcePackagesResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageCatalogRemoveResourcePackagesResult
    };

    // ----- PackageContentGroup class --------------------
    constexpr const char* const _type_name_PackageContentGroup = "PackageContentGroup";

    static PyObject* _new_PackageContentGroup(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageContentGroup);
        return nullptr;
    }

    static void _dealloc_PackageContentGroup(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageContentGroup_get_IsRequired(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_Name(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_Package(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_State(py::wrapper::Windows::ApplicationModel::PackageContentGroup* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroup_get_RequiredGroupName(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::PackageContentGroup::RequiredGroupName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageContentGroup(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageContentGroup>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageContentGroup[] = {
        { "get_required_group_name", reinterpret_cast<PyCFunction>(PackageContentGroup_get_RequiredGroupName), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageContentGroup), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageContentGroup[] = {
        { "is_required", reinterpret_cast<getter>(PackageContentGroup_get_IsRequired), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PackageContentGroup_get_Name), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageContentGroup_get_Package), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(PackageContentGroup_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageContentGroup[] = 
    {
        { Py_tp_new, _new_PackageContentGroup },
        { Py_tp_dealloc, _dealloc_PackageContentGroup },
        { Py_tp_methods, _methods_PackageContentGroup },
        { Py_tp_getset, _getset_PackageContentGroup },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageContentGroup =
    {
        "_winsdk_Windows_ApplicationModel.PackageContentGroup",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageContentGroup),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageContentGroup
    };

    // ----- PackageContentGroupStagingEventArgs class --------------------
    constexpr const char* const _type_name_PackageContentGroupStagingEventArgs = "PackageContentGroupStagingEventArgs";

    static PyObject* _new_PackageContentGroupStagingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageContentGroupStagingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageContentGroupStagingEventArgs(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_ContentGroupName(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentGroupName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_IsContentGroupRequired(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsContentGroupRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageContentGroupStagingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageContentGroupStagingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageContentGroupStagingEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageContentGroupStagingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageContentGroupStagingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "content_group_name", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_ContentGroupName), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "is_content_group_required", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_IsContentGroupRequired), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_Package), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageContentGroupStagingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageContentGroupStagingEventArgs[] = 
    {
        { Py_tp_new, _new_PackageContentGroupStagingEventArgs },
        { Py_tp_dealloc, _dealloc_PackageContentGroupStagingEventArgs },
        { Py_tp_methods, _methods_PackageContentGroupStagingEventArgs },
        { Py_tp_getset, _getset_PackageContentGroupStagingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageContentGroupStagingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.PackageContentGroupStagingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageContentGroupStagingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageContentGroupStagingEventArgs
    };

    // ----- PackageId class --------------------
    constexpr const char* const _type_name_PackageId = "PackageId";

    static PyObject* _new_PackageId(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageId);
        return nullptr;
    }

    static void _dealloc_PackageId(py::wrapper::Windows::ApplicationModel::PackageId* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageId_get_Architecture(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Architecture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_FamilyName(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_FullName(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FullName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Name(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Publisher(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Publisher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_PublisherId(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PublisherId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_ResourceId(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Version(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_Author(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Author());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageId_get_ProductId(py::wrapper::Windows::ApplicationModel::PackageId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageId(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageId>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageId[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageId), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageId[] = {
        { "architecture", reinterpret_cast<getter>(PackageId_get_Architecture), nullptr, nullptr, nullptr },
        { "family_name", reinterpret_cast<getter>(PackageId_get_FamilyName), nullptr, nullptr, nullptr },
        { "full_name", reinterpret_cast<getter>(PackageId_get_FullName), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PackageId_get_Name), nullptr, nullptr, nullptr },
        { "publisher", reinterpret_cast<getter>(PackageId_get_Publisher), nullptr, nullptr, nullptr },
        { "publisher_id", reinterpret_cast<getter>(PackageId_get_PublisherId), nullptr, nullptr, nullptr },
        { "resource_id", reinterpret_cast<getter>(PackageId_get_ResourceId), nullptr, nullptr, nullptr },
        { "version", reinterpret_cast<getter>(PackageId_get_Version), nullptr, nullptr, nullptr },
        { "author", reinterpret_cast<getter>(PackageId_get_Author), nullptr, nullptr, nullptr },
        { "product_id", reinterpret_cast<getter>(PackageId_get_ProductId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageId[] = 
    {
        { Py_tp_new, _new_PackageId },
        { Py_tp_dealloc, _dealloc_PackageId },
        { Py_tp_methods, _methods_PackageId },
        { Py_tp_getset, _getset_PackageId },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageId =
    {
        "_winsdk_Windows_ApplicationModel.PackageId",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageId
    };

    // ----- PackageInstallingEventArgs class --------------------
    constexpr const char* const _type_name_PackageInstallingEventArgs = "PackageInstallingEventArgs";

    static PyObject* _new_PackageInstallingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageInstallingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageInstallingEventArgs(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageInstallingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageInstallingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageInstallingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageInstallingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageInstallingEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageInstallingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageInstallingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageInstallingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageInstallingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageInstallingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageInstallingEventArgs_get_Package), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageInstallingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageInstallingEventArgs[] = 
    {
        { Py_tp_new, _new_PackageInstallingEventArgs },
        { Py_tp_dealloc, _dealloc_PackageInstallingEventArgs },
        { Py_tp_methods, _methods_PackageInstallingEventArgs },
        { Py_tp_getset, _getset_PackageInstallingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageInstallingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.PackageInstallingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageInstallingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageInstallingEventArgs
    };

    // ----- PackageStagingEventArgs class --------------------
    constexpr const char* const _type_name_PackageStagingEventArgs = "PackageStagingEventArgs";

    static PyObject* _new_PackageStagingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageStagingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageStagingEventArgs(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageStagingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStagingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageStagingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageStagingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageStagingEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageStagingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageStagingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageStagingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageStagingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageStagingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageStagingEventArgs_get_Package), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageStagingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageStagingEventArgs[] = 
    {
        { Py_tp_new, _new_PackageStagingEventArgs },
        { Py_tp_dealloc, _dealloc_PackageStagingEventArgs },
        { Py_tp_methods, _methods_PackageStagingEventArgs },
        { Py_tp_getset, _getset_PackageStagingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageStagingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.PackageStagingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageStagingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageStagingEventArgs
    };

    // ----- PackageStatus class --------------------
    constexpr const char* const _type_name_PackageStatus = "PackageStatus";

    static PyObject* _new_PackageStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageStatus);
        return nullptr;
    }

    static void _dealloc_PackageStatus(py::wrapper::Windows::ApplicationModel::PackageStatus* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageStatus_VerifyIsOK(py::wrapper::Windows::ApplicationModel::PackageStatus* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.VerifyIsOK());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_DataOffline(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataOffline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_DependencyIssue(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DependencyIssue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_DeploymentInProgress(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeploymentInProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Disabled(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Disabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_LicenseIssue(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LicenseIssue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Modified(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Modified());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_NeedsRemediation(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NeedsRemediation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_NotAvailable(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NotAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_PackageOffline(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageOffline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Servicing(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Servicing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_Tampered(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tampered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageStatus_get_IsPartiallyStaged(py::wrapper::Windows::ApplicationModel::PackageStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPartiallyStaged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageStatus[] = {
        { "verify_is_o_k", reinterpret_cast<PyCFunction>(PackageStatus_VerifyIsOK), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageStatus[] = {
        { "data_offline", reinterpret_cast<getter>(PackageStatus_get_DataOffline), nullptr, nullptr, nullptr },
        { "dependency_issue", reinterpret_cast<getter>(PackageStatus_get_DependencyIssue), nullptr, nullptr, nullptr },
        { "deployment_in_progress", reinterpret_cast<getter>(PackageStatus_get_DeploymentInProgress), nullptr, nullptr, nullptr },
        { "disabled", reinterpret_cast<getter>(PackageStatus_get_Disabled), nullptr, nullptr, nullptr },
        { "license_issue", reinterpret_cast<getter>(PackageStatus_get_LicenseIssue), nullptr, nullptr, nullptr },
        { "modified", reinterpret_cast<getter>(PackageStatus_get_Modified), nullptr, nullptr, nullptr },
        { "needs_remediation", reinterpret_cast<getter>(PackageStatus_get_NeedsRemediation), nullptr, nullptr, nullptr },
        { "not_available", reinterpret_cast<getter>(PackageStatus_get_NotAvailable), nullptr, nullptr, nullptr },
        { "package_offline", reinterpret_cast<getter>(PackageStatus_get_PackageOffline), nullptr, nullptr, nullptr },
        { "servicing", reinterpret_cast<getter>(PackageStatus_get_Servicing), nullptr, nullptr, nullptr },
        { "tampered", reinterpret_cast<getter>(PackageStatus_get_Tampered), nullptr, nullptr, nullptr },
        { "is_partially_staged", reinterpret_cast<getter>(PackageStatus_get_IsPartiallyStaged), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageStatus[] = 
    {
        { Py_tp_new, _new_PackageStatus },
        { Py_tp_dealloc, _dealloc_PackageStatus },
        { Py_tp_methods, _methods_PackageStatus },
        { Py_tp_getset, _getset_PackageStatus },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageStatus =
    {
        "_winsdk_Windows_ApplicationModel.PackageStatus",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageStatus
    };

    // ----- PackageStatusChangedEventArgs class --------------------
    constexpr const char* const _type_name_PackageStatusChangedEventArgs = "PackageStatusChangedEventArgs";

    static PyObject* _new_PackageStatusChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageStatusChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageStatusChangedEventArgs(py::wrapper::Windows::ApplicationModel::PackageStatusChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageStatusChangedEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageStatusChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageStatusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageStatusChangedEventArgs[] = {
        { "package", reinterpret_cast<getter>(PackageStatusChangedEventArgs_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageStatusChangedEventArgs[] = 
    {
        { Py_tp_new, _new_PackageStatusChangedEventArgs },
        { Py_tp_dealloc, _dealloc_PackageStatusChangedEventArgs },
        { Py_tp_methods, _methods_PackageStatusChangedEventArgs },
        { Py_tp_getset, _getset_PackageStatusChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageStatusChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.PackageStatusChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageStatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageStatusChangedEventArgs
    };

    // ----- PackageUninstallingEventArgs class --------------------
    constexpr const char* const _type_name_PackageUninstallingEventArgs = "PackageUninstallingEventArgs";

    static PyObject* _new_PackageUninstallingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageUninstallingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageUninstallingEventArgs(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageUninstallingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_Package(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUninstallingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageUninstallingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUninstallingEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageUninstallingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageUninstallingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_Package), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageUninstallingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageUninstallingEventArgs[] = 
    {
        { Py_tp_new, _new_PackageUninstallingEventArgs },
        { Py_tp_dealloc, _dealloc_PackageUninstallingEventArgs },
        { Py_tp_methods, _methods_PackageUninstallingEventArgs },
        { Py_tp_getset, _getset_PackageUninstallingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageUninstallingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.PackageUninstallingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageUninstallingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUninstallingEventArgs
    };

    // ----- PackageUpdateAvailabilityResult class --------------------
    constexpr const char* const _type_name_PackageUpdateAvailabilityResult = "PackageUpdateAvailabilityResult";

    static PyObject* _new_PackageUpdateAvailabilityResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageUpdateAvailabilityResult);
        return nullptr;
    }

    static void _dealloc_PackageUpdateAvailabilityResult(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageUpdateAvailabilityResult_get_Availability(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Availability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdateAvailabilityResult_get_ExtendedError(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageUpdateAvailabilityResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageUpdateAvailabilityResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUpdateAvailabilityResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageUpdateAvailabilityResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageUpdateAvailabilityResult[] = {
        { "availability", reinterpret_cast<getter>(PackageUpdateAvailabilityResult_get_Availability), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(PackageUpdateAvailabilityResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageUpdateAvailabilityResult[] = 
    {
        { Py_tp_new, _new_PackageUpdateAvailabilityResult },
        { Py_tp_dealloc, _dealloc_PackageUpdateAvailabilityResult },
        { Py_tp_methods, _methods_PackageUpdateAvailabilityResult },
        { Py_tp_getset, _getset_PackageUpdateAvailabilityResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageUpdateAvailabilityResult =
    {
        "_winsdk_Windows_ApplicationModel.PackageUpdateAvailabilityResult",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageUpdateAvailabilityResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUpdateAvailabilityResult
    };

    // ----- PackageUpdatingEventArgs class --------------------
    constexpr const char* const _type_name_PackageUpdatingEventArgs = "PackageUpdatingEventArgs";

    static PyObject* _new_PackageUpdatingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageUpdatingEventArgs);
        return nullptr;
    }

    static void _dealloc_PackageUpdatingEventArgs(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageUpdatingEventArgs_get_ActivityId(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_ErrorCode(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_IsComplete(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_Progress(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Progress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_SourcePackage(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourcePackage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUpdatingEventArgs_get_TargetPackage(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TargetPackage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageUpdatingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUpdatingEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageUpdatingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageUpdatingEventArgs[] = {
        { "activity_id", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_ActivityId), nullptr, nullptr, nullptr },
        { "error_code", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_ErrorCode), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_IsComplete), nullptr, nullptr, nullptr },
        { "progress", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_Progress), nullptr, nullptr, nullptr },
        { "source_package", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_SourcePackage), nullptr, nullptr, nullptr },
        { "target_package", reinterpret_cast<getter>(PackageUpdatingEventArgs_get_TargetPackage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageUpdatingEventArgs[] = 
    {
        { Py_tp_new, _new_PackageUpdatingEventArgs },
        { Py_tp_dealloc, _dealloc_PackageUpdatingEventArgs },
        { Py_tp_methods, _methods_PackageUpdatingEventArgs },
        { Py_tp_getset, _getset_PackageUpdatingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageUpdatingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.PackageUpdatingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageUpdatingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUpdatingEventArgs
    };

    // ----- StartupTask class --------------------
    constexpr const char* const _type_name_StartupTask = "StartupTask";

    static PyObject* _new_StartupTask(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StartupTask);
        return nullptr;
    }

    static void _dealloc_StartupTask(py::wrapper::Windows::ApplicationModel::StartupTask* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StartupTask_Disable(py::wrapper::Windows::ApplicationModel::StartupTask* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Disable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_GetAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::StartupTask::GetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_GetForCurrentPackageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::StartupTask::GetForCurrentPackageAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_RequestEnableAsync(py::wrapper::Windows::ApplicationModel::StartupTask* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestEnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StartupTask_get_State(py::wrapper::Windows::ApplicationModel::StartupTask* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTask_get_TaskId(py::wrapper::Windows::ApplicationModel::StartupTask* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StartupTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::StartupTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StartupTask[] = {
        { "disable", reinterpret_cast<PyCFunction>(StartupTask_Disable), METH_VARARGS, nullptr },
        { "get_async", reinterpret_cast<PyCFunction>(StartupTask_GetAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_current_package_async", reinterpret_cast<PyCFunction>(StartupTask_GetForCurrentPackageAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_enable_async", reinterpret_cast<PyCFunction>(StartupTask_RequestEnableAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StartupTask), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StartupTask[] = {
        { "state", reinterpret_cast<getter>(StartupTask_get_State), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(StartupTask_get_TaskId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StartupTask[] = 
    {
        { Py_tp_new, _new_StartupTask },
        { Py_tp_dealloc, _dealloc_StartupTask },
        { Py_tp_methods, _methods_StartupTask },
        { Py_tp_getset, _getset_StartupTask },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StartupTask =
    {
        "_winsdk_Windows_ApplicationModel.StartupTask",
        sizeof(py::wrapper::Windows::ApplicationModel::StartupTask),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StartupTask
    };

    // ----- SuspendingDeferral class --------------------
    constexpr const char* const _type_name_SuspendingDeferral = "SuspendingDeferral";

    static PyObject* _new_SuspendingDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SuspendingDeferral);
        return nullptr;
    }

    static void _dealloc_SuspendingDeferral(py::wrapper::Windows::ApplicationModel::SuspendingDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SuspendingDeferral_Complete(py::wrapper::Windows::ApplicationModel::SuspendingDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_SuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::SuspendingDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(SuspendingDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SuspendingDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_SuspendingDeferral[] = 
    {
        { Py_tp_new, _new_SuspendingDeferral },
        { Py_tp_dealloc, _dealloc_SuspendingDeferral },
        { Py_tp_methods, _methods_SuspendingDeferral },
        { Py_tp_getset, _getset_SuspendingDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SuspendingDeferral =
    {
        "_winsdk_Windows_ApplicationModel.SuspendingDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::SuspendingDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingDeferral
    };

    // ----- SuspendingEventArgs class --------------------
    constexpr const char* const _type_name_SuspendingEventArgs = "SuspendingEventArgs";

    static PyObject* _new_SuspendingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SuspendingEventArgs);
        return nullptr;
    }

    static void _dealloc_SuspendingEventArgs(py::wrapper::Windows::ApplicationModel::SuspendingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SuspendingEventArgs_get_SuspendingOperation(py::wrapper::Windows::ApplicationModel::SuspendingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuspendingOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::SuspendingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SuspendingEventArgs[] = {
        { "suspending_operation", reinterpret_cast<getter>(SuspendingEventArgs_get_SuspendingOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SuspendingEventArgs[] = 
    {
        { Py_tp_new, _new_SuspendingEventArgs },
        { Py_tp_dealloc, _dealloc_SuspendingEventArgs },
        { Py_tp_methods, _methods_SuspendingEventArgs },
        { Py_tp_getset, _getset_SuspendingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SuspendingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.SuspendingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::SuspendingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingEventArgs
    };

    // ----- SuspendingOperation class --------------------
    constexpr const char* const _type_name_SuspendingOperation = "SuspendingOperation";

    static PyObject* _new_SuspendingOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SuspendingOperation);
        return nullptr;
    }

    static void _dealloc_SuspendingOperation(py::wrapper::Windows::ApplicationModel::SuspendingOperation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SuspendingOperation_GetDeferral(py::wrapper::Windows::ApplicationModel::SuspendingOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SuspendingOperation_get_Deadline(py::wrapper::Windows::ApplicationModel::SuspendingOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::SuspendingOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SuspendingOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(SuspendingOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SuspendingOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SuspendingOperation[] = {
        { "deadline", reinterpret_cast<getter>(SuspendingOperation_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SuspendingOperation[] = 
    {
        { Py_tp_new, _new_SuspendingOperation },
        { Py_tp_dealloc, _dealloc_SuspendingOperation },
        { Py_tp_methods, _methods_SuspendingOperation },
        { Py_tp_getset, _getset_SuspendingOperation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SuspendingOperation =
    {
        "_winsdk_Windows_ApplicationModel.SuspendingOperation",
        sizeof(py::wrapper::Windows::ApplicationModel::SuspendingOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SuspendingOperation
    };

    // ----- IEnteredBackgroundEventArgs interface --------------------
    constexpr const char* const _type_name_IEnteredBackgroundEventArgs = "IEnteredBackgroundEventArgs";

    static PyObject* _new_IEnteredBackgroundEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IEnteredBackgroundEventArgs);
        return nullptr;
    }

    static void _dealloc_IEnteredBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::IEnteredBackgroundEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IEnteredBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::IEnteredBackgroundEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IEnteredBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::IEnteredBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IEnteredBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(IEnteredBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IEnteredBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IEnteredBackgroundEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_IEnteredBackgroundEventArgs[] = 
    {
        { Py_tp_new, _new_IEnteredBackgroundEventArgs },
        { Py_tp_dealloc, _dealloc_IEnteredBackgroundEventArgs },
        { Py_tp_methods, _methods_IEnteredBackgroundEventArgs },
        { Py_tp_getset, _getset_IEnteredBackgroundEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IEnteredBackgroundEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.IEnteredBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::IEnteredBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IEnteredBackgroundEventArgs
    };

    // ----- ILeavingBackgroundEventArgs interface --------------------
    constexpr const char* const _type_name_ILeavingBackgroundEventArgs = "ILeavingBackgroundEventArgs";

    static PyObject* _new_ILeavingBackgroundEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILeavingBackgroundEventArgs);
        return nullptr;
    }

    static void _dealloc_ILeavingBackgroundEventArgs(py::wrapper::Windows::ApplicationModel::ILeavingBackgroundEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILeavingBackgroundEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::ILeavingBackgroundEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ILeavingBackgroundEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ILeavingBackgroundEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILeavingBackgroundEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ILeavingBackgroundEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILeavingBackgroundEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILeavingBackgroundEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ILeavingBackgroundEventArgs[] = 
    {
        { Py_tp_new, _new_ILeavingBackgroundEventArgs },
        { Py_tp_dealloc, _dealloc_ILeavingBackgroundEventArgs },
        { Py_tp_methods, _methods_ILeavingBackgroundEventArgs },
        { Py_tp_getset, _getset_ILeavingBackgroundEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ILeavingBackgroundEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.ILeavingBackgroundEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ILeavingBackgroundEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILeavingBackgroundEventArgs
    };

    // ----- ISuspendingDeferral interface --------------------
    constexpr const char* const _type_name_ISuspendingDeferral = "ISuspendingDeferral";

    static PyObject* _new_ISuspendingDeferral(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ISuspendingDeferral);
        return nullptr;
    }

    static void _dealloc_ISuspendingDeferral(py::wrapper::Windows::ApplicationModel::ISuspendingDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ISuspendingDeferral_Complete(py::wrapper::Windows::ApplicationModel::ISuspendingDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ISuspendingDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ISuspendingDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISuspendingDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(ISuspendingDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISuspendingDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISuspendingDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_ISuspendingDeferral[] = 
    {
        { Py_tp_new, _new_ISuspendingDeferral },
        { Py_tp_dealloc, _dealloc_ISuspendingDeferral },
        { Py_tp_methods, _methods_ISuspendingDeferral },
        { Py_tp_getset, _getset_ISuspendingDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ISuspendingDeferral =
    {
        "_winsdk_Windows_ApplicationModel.ISuspendingDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::ISuspendingDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISuspendingDeferral
    };

    // ----- ISuspendingEventArgs interface --------------------
    constexpr const char* const _type_name_ISuspendingEventArgs = "ISuspendingEventArgs";

    static PyObject* _new_ISuspendingEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ISuspendingEventArgs);
        return nullptr;
    }

    static void _dealloc_ISuspendingEventArgs(py::wrapper::Windows::ApplicationModel::ISuspendingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ISuspendingEventArgs_get_SuspendingOperation(py::wrapper::Windows::ApplicationModel::ISuspendingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuspendingOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ISuspendingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ISuspendingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISuspendingEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ISuspendingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISuspendingEventArgs[] = {
        { "suspending_operation", reinterpret_cast<getter>(ISuspendingEventArgs_get_SuspendingOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISuspendingEventArgs[] = 
    {
        { Py_tp_new, _new_ISuspendingEventArgs },
        { Py_tp_dealloc, _dealloc_ISuspendingEventArgs },
        { Py_tp_methods, _methods_ISuspendingEventArgs },
        { Py_tp_getset, _getset_ISuspendingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ISuspendingEventArgs =
    {
        "_winsdk_Windows_ApplicationModel.ISuspendingEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ISuspendingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISuspendingEventArgs
    };

    // ----- ISuspendingOperation interface --------------------
    constexpr const char* const _type_name_ISuspendingOperation = "ISuspendingOperation";

    static PyObject* _new_ISuspendingOperation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ISuspendingOperation);
        return nullptr;
    }

    static void _dealloc_ISuspendingOperation(py::wrapper::Windows::ApplicationModel::ISuspendingOperation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ISuspendingOperation_GetDeferral(py::wrapper::Windows::ApplicationModel::ISuspendingOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ISuspendingOperation_get_Deadline(py::wrapper::Windows::ApplicationModel::ISuspendingOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ISuspendingOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ISuspendingOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISuspendingOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ISuspendingOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISuspendingOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISuspendingOperation[] = {
        { "deadline", reinterpret_cast<getter>(ISuspendingOperation_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISuspendingOperation[] = 
    {
        { Py_tp_new, _new_ISuspendingOperation },
        { Py_tp_dealloc, _dealloc_ISuspendingOperation },
        { Py_tp_methods, _methods_ISuspendingOperation },
        { Py_tp_getset, _getset_ISuspendingOperation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ISuspendingOperation =
    {
        "_winsdk_Windows_ApplicationModel.ISuspendingOperation",
        sizeof(py::wrapper::Windows::ApplicationModel::ISuspendingOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISuspendingOperation
    };

    // ----- PackageInstallProgress struct --------------------
    constexpr const char* const _type_name_PackageInstallProgress = "PackageInstallProgress";

    PyObject* _new_PackageInstallProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::ApplicationModel::PackageInstallProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::ApplicationModel::PackageInstallProgress>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _PercentComplete{};

        static const char* kwlist[] = {"percent_complete", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "I", const_cast<char**>(kwlist), &_PercentComplete))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::ApplicationModel::PackageInstallProgress return_value{ _PercentComplete };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_PackageInstallProgress(py::wrapper::Windows::ApplicationModel::PackageInstallProgress* self)
    {
    }

    static PyObject* PackageInstallProgress_get_PercentComplete(py::wrapper::Windows::ApplicationModel::PackageInstallProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PercentComplete);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageInstallProgress_set_PercentComplete(py::wrapper::Windows::ApplicationModel::PackageInstallProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PercentComplete = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PackageInstallProgress[] = {
        { "percent_complete", reinterpret_cast<getter>(PackageInstallProgress_get_PercentComplete), reinterpret_cast<setter>(PackageInstallProgress_set_PercentComplete), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageInstallProgress[] = 
    {
        { Py_tp_new, _new_PackageInstallProgress },
        { Py_tp_dealloc, _dealloc_PackageInstallProgress },
        { Py_tp_getset, _getset_PackageInstallProgress },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageInstallProgress =
    {
        "_winsdk_Windows_ApplicationModel.PackageInstallProgress",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageInstallProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageInstallProgress
    };

    // ----- PackageVersion struct --------------------
    constexpr const char* const _type_name_PackageVersion = "PackageVersion";

    PyObject* _new_PackageVersion(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::ApplicationModel::PackageVersion return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::ApplicationModel::PackageVersion>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint16_t _Major{};
        uint16_t _Minor{};
        uint16_t _Build{};
        uint16_t _Revision{};

        static const char* kwlist[] = {"major", "minor", "build", "revision", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "HHHH", const_cast<char**>(kwlist), &_Major, &_Minor, &_Build, &_Revision))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::ApplicationModel::PackageVersion return_value{ _Major, _Minor, _Build, _Revision };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_PackageVersion(py::wrapper::Windows::ApplicationModel::PackageVersion* self)
    {
    }

    static PyObject* PackageVersion_get_Major(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Major);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Major(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Major = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageVersion_get_Minor(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Minor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Minor(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Minor = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageVersion_get_Build(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Build);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Build(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Build = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PackageVersion_get_Revision(py::wrapper::Windows::ApplicationModel::PackageVersion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Revision);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PackageVersion_set_Revision(py::wrapper::Windows::ApplicationModel::PackageVersion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Revision = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PackageVersion[] = {
        { "major", reinterpret_cast<getter>(PackageVersion_get_Major), reinterpret_cast<setter>(PackageVersion_set_Major), nullptr, nullptr },
        { "minor", reinterpret_cast<getter>(PackageVersion_get_Minor), reinterpret_cast<setter>(PackageVersion_set_Minor), nullptr, nullptr },
        { "build", reinterpret_cast<getter>(PackageVersion_get_Build), reinterpret_cast<setter>(PackageVersion_set_Build), nullptr, nullptr },
        { "revision", reinterpret_cast<getter>(PackageVersion_get_Revision), reinterpret_cast<setter>(PackageVersion_set_Revision), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageVersion[] = 
    {
        { Py_tp_new, _new_PackageVersion },
        { Py_tp_dealloc, _dealloc_PackageVersion },
        { Py_tp_getset, _getset_PackageVersion },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageVersion =
    {
        "_winsdk_Windows_ApplicationModel.PackageVersion",
        sizeof(py::wrapper::Windows::ApplicationModel::PackageVersion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageVersion
    };

    // ----- Windows.ApplicationModel Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::AppDisplayInfo>::python_type = py::register_python_type(module, _type_name_AppDisplayInfo, &_type_spec_AppDisplayInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::AppInfo>::python_type = py::register_python_type(module, _type_name_AppInfo, &_type_spec_AppInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::AppInstallerInfo>::python_type = py::register_python_type(module, _type_name_AppInstallerInfo, &_type_spec_AppInstallerInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::AppInstance>::python_type = py::register_python_type(module, _type_name_AppInstance, &_type_spec_AppInstance, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DesignMode>::python_type = py::register_python_type(module, _type_name_DesignMode, &_type_spec_DesignMode, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::EnteredBackgroundEventArgs>::python_type = py::register_python_type(module, _type_name_EnteredBackgroundEventArgs, &_type_spec_EnteredBackgroundEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::LeavingBackgroundEventArgs>::python_type = py::register_python_type(module, _type_name_LeavingBackgroundEventArgs, &_type_spec_LeavingBackgroundEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::LimitedAccessFeatureRequestResult>::python_type = py::register_python_type(module, _type_name_LimitedAccessFeatureRequestResult, &_type_spec_LimitedAccessFeatureRequestResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::LimitedAccessFeatures>::python_type = py::register_python_type(module, _type_name_LimitedAccessFeatures, &_type_spec_LimitedAccessFeatures, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Package>::python_type = py::register_python_type(module, _type_name_Package, &_type_spec_Package, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalog>::python_type = py::register_python_type(module, _type_name_PackageCatalog, &_type_spec_PackageCatalog, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogAddOptionalPackageResult>::python_type = py::register_python_type(module, _type_name_PackageCatalogAddOptionalPackageResult, &_type_spec_PackageCatalogAddOptionalPackageResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogAddResourcePackageResult>::python_type = py::register_python_type(module, _type_name_PackageCatalogAddResourcePackageResult, &_type_spec_PackageCatalogAddResourcePackageResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogRemoveOptionalPackagesResult>::python_type = py::register_python_type(module, _type_name_PackageCatalogRemoveOptionalPackagesResult, &_type_spec_PackageCatalogRemoveOptionalPackagesResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageCatalogRemoveResourcePackagesResult>::python_type = py::register_python_type(module, _type_name_PackageCatalogRemoveResourcePackagesResult, &_type_spec_PackageCatalogRemoveResourcePackagesResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageContentGroup>::python_type = py::register_python_type(module, _type_name_PackageContentGroup, &_type_spec_PackageContentGroup, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageContentGroupStagingEventArgs>::python_type = py::register_python_type(module, _type_name_PackageContentGroupStagingEventArgs, &_type_spec_PackageContentGroupStagingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageId>::python_type = py::register_python_type(module, _type_name_PackageId, &_type_spec_PackageId, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageInstallingEventArgs>::python_type = py::register_python_type(module, _type_name_PackageInstallingEventArgs, &_type_spec_PackageInstallingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageStagingEventArgs>::python_type = py::register_python_type(module, _type_name_PackageStagingEventArgs, &_type_spec_PackageStagingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageStatus>::python_type = py::register_python_type(module, _type_name_PackageStatus, &_type_spec_PackageStatus, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageStatusChangedEventArgs>::python_type = py::register_python_type(module, _type_name_PackageStatusChangedEventArgs, &_type_spec_PackageStatusChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageUninstallingEventArgs>::python_type = py::register_python_type(module, _type_name_PackageUninstallingEventArgs, &_type_spec_PackageUninstallingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageUpdateAvailabilityResult>::python_type = py::register_python_type(module, _type_name_PackageUpdateAvailabilityResult, &_type_spec_PackageUpdateAvailabilityResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageUpdatingEventArgs>::python_type = py::register_python_type(module, _type_name_PackageUpdatingEventArgs, &_type_spec_PackageUpdatingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::StartupTask>::python_type = py::register_python_type(module, _type_name_StartupTask, &_type_spec_StartupTask, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::SuspendingDeferral>::python_type = py::register_python_type(module, _type_name_SuspendingDeferral, &_type_spec_SuspendingDeferral, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::SuspendingEventArgs>::python_type = py::register_python_type(module, _type_name_SuspendingEventArgs, &_type_spec_SuspendingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::SuspendingOperation>::python_type = py::register_python_type(module, _type_name_SuspendingOperation, &_type_spec_SuspendingOperation, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::IEnteredBackgroundEventArgs>::python_type = py::register_python_type(module, _type_name_IEnteredBackgroundEventArgs, &_type_spec_IEnteredBackgroundEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ILeavingBackgroundEventArgs>::python_type = py::register_python_type(module, _type_name_ILeavingBackgroundEventArgs, &_type_spec_ILeavingBackgroundEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingDeferral>::python_type = py::register_python_type(module, _type_name_ISuspendingDeferral, &_type_spec_ISuspendingDeferral, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingEventArgs>::python_type = py::register_python_type(module, _type_name_ISuspendingEventArgs, &_type_spec_ISuspendingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ISuspendingOperation>::python_type = py::register_python_type(module, _type_name_ISuspendingOperation, &_type_spec_ISuspendingOperation, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageInstallProgress>::python_type = py::register_python_type(module, _type_name_PackageInstallProgress, &_type_spec_PackageInstallProgress, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::PackageVersion>::python_type = py::register_python_type(module, _type_name_PackageVersion, &_type_spec_PackageVersion, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::ApplicationModel

PyMODINIT_FUNC
PyInit__winsdk_Windows_ApplicationModel (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::module_def);
}
