// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.3

#include "pybase.h"
#include "py.Windows.Media.Audio.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioDeviceInputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioDeviceOutputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFileInputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFileOutputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFrameInputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioFrameOutputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraph>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraphConnection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraphSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterShape>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioNodeListener>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioPlaybackConnection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioStateMonitor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::AudioSubmixNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateAudioGraphResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::EchoEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::EqualizerBand>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::EqualizerEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::LimiterEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::ReverbEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioFormatSubtype>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::IAudioInputNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::IAudioInputNode2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::IAudioNode>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Audio::IAudioNodeWithListener>::python_type;

namespace py::cpp::Windows::Media::Audio
{
    // ----- AudioDeviceInputNode class --------------------
    constexpr const char* const _type_name_AudioDeviceInputNode = "AudioDeviceInputNode";

    static PyObject* _new_AudioDeviceInputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioDeviceInputNode);
        return nullptr;
    }

    static void _dealloc_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioDeviceInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Close(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Start(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_Device(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioDeviceInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioDeviceInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioDeviceInputNode(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioDeviceInputNode_Stop), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioDeviceInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioDeviceInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioDeviceInputNode[] = {
        { "device", reinterpret_cast<getter>(AudioDeviceInputNode_get_Device), nullptr, nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(AudioDeviceInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioDeviceInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioDeviceInputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioDeviceInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioDeviceInputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioDeviceInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioDeviceInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioDeviceInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioDeviceInputNode[] = 
    {
        { Py_tp_new, _new_AudioDeviceInputNode },
        { Py_tp_dealloc, _dealloc_AudioDeviceInputNode },
        { Py_tp_methods, _methods_AudioDeviceInputNode },
        { Py_tp_getset, _getset_AudioDeviceInputNode },
        { },
    };

    static PyType_Spec _type_spec_AudioDeviceInputNode =
    {
        "_winsdk_Windows_Media_Audio.AudioDeviceInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioDeviceInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceInputNode
    };

    // ----- AudioDeviceOutputNode class --------------------
    constexpr const char* const _type_name_AudioDeviceOutputNode = "AudioDeviceOutputNode";

    static PyObject* _new_AudioDeviceOutputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioDeviceOutputNode);
        return nullptr;
    }

    static void _dealloc_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioDeviceOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_Device(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceOutputNode_get_Listener(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Listener());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceOutputNode_put_Listener(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeListener>(arg);

            self->obj.Listener(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AudioDeviceOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioDeviceOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioDeviceOutputNode(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceOutputNode[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioDeviceOutputNode_Stop), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceOutputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioDeviceOutputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioDeviceOutputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioDeviceOutputNode[] = {
        { "device", reinterpret_cast<getter>(AudioDeviceOutputNode_get_Device), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioDeviceOutputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioDeviceOutputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioDeviceOutputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioDeviceOutputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioDeviceOutputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioDeviceOutputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "listener", reinterpret_cast<getter>(AudioDeviceOutputNode_get_Listener), reinterpret_cast<setter>(AudioDeviceOutputNode_put_Listener), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioDeviceOutputNode[] = 
    {
        { Py_tp_new, _new_AudioDeviceOutputNode },
        { Py_tp_dealloc, _dealloc_AudioDeviceOutputNode },
        { Py_tp_methods, _methods_AudioDeviceOutputNode },
        { Py_tp_getset, _getset_AudioDeviceOutputNode },
        { },
    };

    static PyType_Spec _type_spec_AudioDeviceOutputNode =
    {
        "_winsdk_Windows_Media_Audio.AudioDeviceOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioDeviceOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceOutputNode
    };

    // ----- AudioFileInputNode class --------------------
    constexpr const char* const _type_name_AudioFileInputNode = "AudioFileInputNode";

    static PyObject* _new_AudioFileInputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioFileInputNode);
        return nullptr;
    }

    static void _dealloc_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioFileInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Close(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Seek(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Start(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_LoopCount(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LoopCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_LoopCount(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.LoopCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_EndTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_EndTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.EndTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_StartTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_StartTime(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_Position(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_SourceFile(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_Duration(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_add_FileCompleted(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFileInputNode, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.FileCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileInputNode_remove_FileCompleted(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FileCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioFileInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFileInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioFileInputNode(py::wrapper::Windows::Media::Audio::AudioFileInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFileInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFileInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioFileInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFileInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFileInputNode_Reset), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(AudioFileInputNode_Seek), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFileInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFileInputNode_Stop), METH_VARARGS, nullptr },
        { "add_file_completed", reinterpret_cast<PyCFunction>(AudioFileInputNode_add_FileCompleted), METH_O, nullptr },
        { "remove_file_completed", reinterpret_cast<PyCFunction>(AudioFileInputNode_remove_FileCompleted), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFileInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFileInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioFileInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFileInputNode[] = {
        { "playback_speed_factor", reinterpret_cast<getter>(AudioFileInputNode_get_PlaybackSpeedFactor), reinterpret_cast<setter>(AudioFileInputNode_put_PlaybackSpeedFactor), nullptr, nullptr },
        { "loop_count", reinterpret_cast<getter>(AudioFileInputNode_get_LoopCount), reinterpret_cast<setter>(AudioFileInputNode_put_LoopCount), nullptr, nullptr },
        { "end_time", reinterpret_cast<getter>(AudioFileInputNode_get_EndTime), reinterpret_cast<setter>(AudioFileInputNode_put_EndTime), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(AudioFileInputNode_get_StartTime), reinterpret_cast<setter>(AudioFileInputNode_put_StartTime), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(AudioFileInputNode_get_Position), nullptr, nullptr, nullptr },
        { "source_file", reinterpret_cast<getter>(AudioFileInputNode_get_SourceFile), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AudioFileInputNode_get_Duration), nullptr, nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(AudioFileInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioFileInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioFileInputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFileInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFileInputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFileInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFileInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFileInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFileInputNode[] = 
    {
        { Py_tp_new, _new_AudioFileInputNode },
        { Py_tp_dealloc, _dealloc_AudioFileInputNode },
        { Py_tp_methods, _methods_AudioFileInputNode },
        { Py_tp_getset, _getset_AudioFileInputNode },
        { },
    };

    static PyType_Spec _type_spec_AudioFileInputNode =
    {
        "_winsdk_Windows_Media_Audio.AudioFileInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFileInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFileInputNode
    };

    // ----- AudioFileOutputNode class --------------------
    constexpr const char* const _type_name_AudioFileOutputNode = "AudioFileOutputNode";

    static PyObject* _new_AudioFileOutputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioFileOutputNode);
        return nullptr;
    }

    static void _dealloc_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioFileOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_FinalizeAsync(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FinalizeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_File(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_FileEncodingProfile(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileEncodingProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFileOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFileOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFileOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioFileOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFileOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioFileOutputNode(py::wrapper::Windows::Media::Audio::AudioFileOutputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFileOutputNode[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileOutputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFileOutputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "finalize_async", reinterpret_cast<PyCFunction>(AudioFileOutputNode_FinalizeAsync), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFileOutputNode_Stop), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFileOutputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFileOutputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioFileOutputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFileOutputNode[] = {
        { "file", reinterpret_cast<getter>(AudioFileOutputNode_get_File), nullptr, nullptr, nullptr },
        { "file_encoding_profile", reinterpret_cast<getter>(AudioFileOutputNode_get_FileEncodingProfile), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioFileOutputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFileOutputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFileOutputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFileOutputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFileOutputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFileOutputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFileOutputNode[] = 
    {
        { Py_tp_new, _new_AudioFileOutputNode },
        { Py_tp_dealloc, _dealloc_AudioFileOutputNode },
        { Py_tp_methods, _methods_AudioFileOutputNode },
        { Py_tp_getset, _getset_AudioFileOutputNode },
        { },
    };

    static PyType_Spec _type_spec_AudioFileOutputNode =
    {
        "_winsdk_Windows_Media_Audio.AudioFileOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFileOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFileOutputNode
    };

    // ----- AudioFrameCompletedEventArgs class --------------------
    constexpr const char* const _type_name_AudioFrameCompletedEventArgs = "AudioFrameCompletedEventArgs";

    static PyObject* _new_AudioFrameCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioFrameCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_AudioFrameCompletedEventArgs(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioFrameCompletedEventArgs_get_Frame(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioFrameCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameCompletedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFrameCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFrameCompletedEventArgs[] = {
        { "frame", reinterpret_cast<getter>(AudioFrameCompletedEventArgs_get_Frame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFrameCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_AudioFrameCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_AudioFrameCompletedEventArgs },
        { Py_tp_methods, _methods_AudioFrameCompletedEventArgs },
        { Py_tp_getset, _getset_AudioFrameCompletedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_AudioFrameCompletedEventArgs =
    {
        "_winsdk_Windows_Media_Audio.AudioFrameCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameCompletedEventArgs
    };

    // ----- AudioFrameInputNode class --------------------
    constexpr const char* const _type_name_AudioFrameInputNode = "AudioFrameInputNode";

    static PyObject* _new_AudioFrameInputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioFrameInputNode);
        return nullptr;
    }

    static void _dealloc_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioFrameInputNode_AddFrame(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::AudioFrame>(args, 0);

                self->obj.AddFrame(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Close(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_DiscardQueuedFrames(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.DiscardQueuedFrames();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Start(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_QueuedSampleCount(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QueuedSampleCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_add_AudioFrameCompleted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFrameInputNode, winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>>(arg);

            return py::convert(self->obj.AudioFrameCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_remove_AudioFrameCompleted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioFrameCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_add_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioFrameInputNode, winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>>(arg);

            return py::convert(self->obj.QuantumStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameInputNode_remove_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QuantumStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioFrameInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioFrameInputNode(py::wrapper::Windows::Media::Audio::AudioFrameInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameInputNode[] = {
        { "add_frame", reinterpret_cast<PyCFunction>(AudioFrameInputNode_AddFrame), METH_VARARGS, nullptr },
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFrameInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "discard_queued_frames", reinterpret_cast<PyCFunction>(AudioFrameInputNode_DiscardQueuedFrames), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioFrameInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFrameInputNode_Stop), METH_VARARGS, nullptr },
        { "add_audio_frame_completed", reinterpret_cast<PyCFunction>(AudioFrameInputNode_add_AudioFrameCompleted), METH_O, nullptr },
        { "remove_audio_frame_completed", reinterpret_cast<PyCFunction>(AudioFrameInputNode_remove_AudioFrameCompleted), METH_O, nullptr },
        { "add_quantum_started", reinterpret_cast<PyCFunction>(AudioFrameInputNode_add_QuantumStarted), METH_O, nullptr },
        { "remove_quantum_started", reinterpret_cast<PyCFunction>(AudioFrameInputNode_remove_QuantumStarted), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFrameInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFrameInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioFrameInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFrameInputNode[] = {
        { "playback_speed_factor", reinterpret_cast<getter>(AudioFrameInputNode_get_PlaybackSpeedFactor), reinterpret_cast<setter>(AudioFrameInputNode_put_PlaybackSpeedFactor), nullptr, nullptr },
        { "queued_sample_count", reinterpret_cast<getter>(AudioFrameInputNode_get_QueuedSampleCount), nullptr, nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(AudioFrameInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioFrameInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioFrameInputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFrameInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFrameInputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFrameInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFrameInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFrameInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFrameInputNode[] = 
    {
        { Py_tp_new, _new_AudioFrameInputNode },
        { Py_tp_dealloc, _dealloc_AudioFrameInputNode },
        { Py_tp_methods, _methods_AudioFrameInputNode },
        { Py_tp_getset, _getset_AudioFrameInputNode },
        { },
    };

    static PyType_Spec _type_spec_AudioFrameInputNode =
    {
        "_winsdk_Windows_Media_Audio.AudioFrameInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameInputNode
    };

    // ----- AudioFrameOutputNode class --------------------
    constexpr const char* const _type_name_AudioFrameOutputNode = "AudioFrameOutputNode";

    static PyObject* _new_AudioFrameOutputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioFrameOutputNode);
        return nullptr;
    }

    static void _dealloc_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioFrameOutputNode_Close(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_GetFrame(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Reset(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Start(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_Stop(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameOutputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameOutputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioFrameOutputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioFrameOutputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioFrameOutputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioFrameOutputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioFrameOutputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioFrameOutputNode[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "get_frame", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_GetFrame), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioFrameOutputNode_Stop), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioFrameOutputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioFrameOutputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioFrameOutputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioFrameOutputNode[] = {
        { "outgoing_gain", reinterpret_cast<getter>(AudioFrameOutputNode_get_OutgoingGain), reinterpret_cast<setter>(AudioFrameOutputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioFrameOutputNode_get_ConsumeInput), reinterpret_cast<setter>(AudioFrameOutputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioFrameOutputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioFrameOutputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioFrameOutputNode[] = 
    {
        { Py_tp_new, _new_AudioFrameOutputNode },
        { Py_tp_dealloc, _dealloc_AudioFrameOutputNode },
        { Py_tp_methods, _methods_AudioFrameOutputNode },
        { Py_tp_getset, _getset_AudioFrameOutputNode },
        { },
    };

    static PyType_Spec _type_spec_AudioFrameOutputNode =
    {
        "_winsdk_Windows_Media_Audio.AudioFrameOutputNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioFrameOutputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioFrameOutputNode
    };

    // ----- AudioGraph class --------------------
    constexpr const char* const _type_name_AudioGraph = "AudioGraph";

    static PyObject* _new_AudioGraph(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioGraph);
        return nullptr;
    }

    static void _dealloc_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioGraph_Close(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraphSettings>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioGraph::CreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateBatchUpdater());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateDeviceInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 2);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 3);

                return py::convert(self->obj.CreateDeviceInputNodeAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateDeviceOutputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateDeviceOutputNodeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFileInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CreateFileInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateFileInputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFileOutputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(self->obj.CreateFileOutputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 1);

                return py::convert(self->obj.CreateFileOutputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFrameInputNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateFrameInputNode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert(self->obj.CreateFrameInputNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateFrameInputNode(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateFrameOutputNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateFrameOutputNode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert(self->obj.CreateFrameOutputNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateMediaSourceAudioInputNodeAsync(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);

                return py::convert(self->obj.CreateMediaSourceAudioInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaSource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateMediaSourceAudioInputNodeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_CreateSubmixNode(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateSubmixNode());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                return py::convert(self->obj.CreateSubmixNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitter>(args, 1);

                return py::convert(self->obj.CreateSubmixNode(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_ResetAllNodes(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ResetAllNodes();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_Start(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_Stop(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_CompletedQuantumCount(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompletedQuantumCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_LatencyInSamples(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LatencyInSamples());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrimaryRenderDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_RenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RenderDeviceAudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_get_SamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraph* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SamplesPerQuantum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_QuantumProcessed(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.QuantumProcessed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_QuantumProcessed(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QuantumProcessed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.QuantumStarted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_QuantumStarted(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.QuantumStarted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_add_UnrecoverableErrorOccurred(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioGraph, winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>>(arg);

            return py::convert(self->obj.UnrecoverableErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioGraph_remove_UnrecoverableErrorOccurred(py::wrapper::Windows::Media::Audio::AudioGraph* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UnrecoverableErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioGraph(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraph>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioGraph(py::wrapper::Windows::Media::Audio::AudioGraph* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraph[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioGraph_Close), METH_VARARGS, nullptr },
        { "create_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_batch_updater", reinterpret_cast<PyCFunction>(AudioGraph_CreateBatchUpdater), METH_VARARGS, nullptr },
        { "create_device_input_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateDeviceInputNodeAsync), METH_VARARGS, nullptr },
        { "create_device_output_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateDeviceOutputNodeAsync), METH_VARARGS, nullptr },
        { "create_file_input_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateFileInputNodeAsync), METH_VARARGS, nullptr },
        { "create_file_output_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateFileOutputNodeAsync), METH_VARARGS, nullptr },
        { "create_frame_input_node", reinterpret_cast<PyCFunction>(AudioGraph_CreateFrameInputNode), METH_VARARGS, nullptr },
        { "create_frame_output_node", reinterpret_cast<PyCFunction>(AudioGraph_CreateFrameOutputNode), METH_VARARGS, nullptr },
        { "create_media_source_audio_input_node_async", reinterpret_cast<PyCFunction>(AudioGraph_CreateMediaSourceAudioInputNodeAsync), METH_VARARGS, nullptr },
        { "create_submix_node", reinterpret_cast<PyCFunction>(AudioGraph_CreateSubmixNode), METH_VARARGS, nullptr },
        { "reset_all_nodes", reinterpret_cast<PyCFunction>(AudioGraph_ResetAllNodes), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioGraph_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioGraph_Stop), METH_VARARGS, nullptr },
        { "add_quantum_processed", reinterpret_cast<PyCFunction>(AudioGraph_add_QuantumProcessed), METH_O, nullptr },
        { "remove_quantum_processed", reinterpret_cast<PyCFunction>(AudioGraph_remove_QuantumProcessed), METH_O, nullptr },
        { "add_quantum_started", reinterpret_cast<PyCFunction>(AudioGraph_add_QuantumStarted), METH_O, nullptr },
        { "remove_quantum_started", reinterpret_cast<PyCFunction>(AudioGraph_remove_QuantumStarted), METH_O, nullptr },
        { "add_unrecoverable_error_occurred", reinterpret_cast<PyCFunction>(AudioGraph_add_UnrecoverableErrorOccurred), METH_O, nullptr },
        { "remove_unrecoverable_error_occurred", reinterpret_cast<PyCFunction>(AudioGraph_remove_UnrecoverableErrorOccurred), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraph), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioGraph), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioGraph), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraph[] = {
        { "completed_quantum_count", reinterpret_cast<getter>(AudioGraph_get_CompletedQuantumCount), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioGraph_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "latency_in_samples", reinterpret_cast<getter>(AudioGraph_get_LatencyInSamples), nullptr, nullptr, nullptr },
        { "primary_render_device", reinterpret_cast<getter>(AudioGraph_get_PrimaryRenderDevice), nullptr, nullptr, nullptr },
        { "render_device_audio_processing", reinterpret_cast<getter>(AudioGraph_get_RenderDeviceAudioProcessing), nullptr, nullptr, nullptr },
        { "samples_per_quantum", reinterpret_cast<getter>(AudioGraph_get_SamplesPerQuantum), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioGraph[] = 
    {
        { Py_tp_new, _new_AudioGraph },
        { Py_tp_dealloc, _dealloc_AudioGraph },
        { Py_tp_methods, _methods_AudioGraph },
        { Py_tp_getset, _getset_AudioGraph },
        { },
    };

    static PyType_Spec _type_spec_AudioGraph =
    {
        "_winsdk_Windows_Media_Audio.AudioGraph",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraph),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraph
    };

    // ----- AudioGraphBatchUpdater class --------------------
    constexpr const char* const _type_name_AudioGraphBatchUpdater = "AudioGraphBatchUpdater";

    static PyObject* _new_AudioGraphBatchUpdater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioGraphBatchUpdater);
        return nullptr;
    }

    static void _dealloc_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioGraphBatchUpdater_Close(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_AudioGraphBatchUpdater(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioGraphBatchUpdater(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphBatchUpdater[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioGraphBatchUpdater_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphBatchUpdater), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioGraphBatchUpdater), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioGraphBatchUpdater), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraphBatchUpdater[] = {
        { }
    };

    static PyType_Slot _type_slots_AudioGraphBatchUpdater[] = 
    {
        { Py_tp_new, _new_AudioGraphBatchUpdater },
        { Py_tp_dealloc, _dealloc_AudioGraphBatchUpdater },
        { Py_tp_methods, _methods_AudioGraphBatchUpdater },
        { Py_tp_getset, _getset_AudioGraphBatchUpdater },
        { },
    };

    static PyType_Spec _type_spec_AudioGraphBatchUpdater =
    {
        "_winsdk_Windows_Media_Audio.AudioGraphBatchUpdater",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphBatchUpdater),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphBatchUpdater
    };

    // ----- AudioGraphConnection class --------------------
    constexpr const char* const _type_name_AudioGraphConnection = "AudioGraphConnection";

    static PyObject* _new_AudioGraphConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioGraphConnection);
        return nullptr;
    }

    static void _dealloc_AudioGraphConnection(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioGraphConnection_get_Gain(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Gain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphConnection_put_Gain(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Gain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphConnection_get_Destination(py::wrapper::Windows::Media::Audio::AudioGraphConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Destination());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioGraphConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphConnection[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphConnection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraphConnection[] = {
        { "gain", reinterpret_cast<getter>(AudioGraphConnection_get_Gain), reinterpret_cast<setter>(AudioGraphConnection_put_Gain), nullptr, nullptr },
        { "destination", reinterpret_cast<getter>(AudioGraphConnection_get_Destination), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioGraphConnection[] = 
    {
        { Py_tp_new, _new_AudioGraphConnection },
        { Py_tp_dealloc, _dealloc_AudioGraphConnection },
        { Py_tp_methods, _methods_AudioGraphConnection },
        { Py_tp_getset, _getset_AudioGraphConnection },
        { },
    };

    static PyType_Spec _type_spec_AudioGraphConnection =
    {
        "_winsdk_Windows_Media_Audio.AudioGraphConnection",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphConnection
    };

    // ----- AudioGraphSettings class --------------------
    constexpr const char* const _type_name_AudioGraphSettings = "AudioGraphSettings";

    static PyObject* _new_AudioGraphSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);

                winrt::Windows::Media::Audio::AudioGraphSettings instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioGraphSettings(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioGraphSettings_get_QuantumSizeSelectionMode(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QuantumSizeSelectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_QuantumSizeSelectionMode(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::QuantumSizeSelectionMode>(arg);

            self->obj.QuantumSizeSelectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrimaryRenderDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_PrimaryRenderDevice(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(arg);

            self->obj.PrimaryRenderDevice(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(arg);

            self->obj.EncodingProperties(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_DesiredSamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredSamplesPerQuantum());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_DesiredSamplesPerQuantum(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DesiredSamplesPerQuantum(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_DesiredRenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredRenderDeviceAudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_DesiredRenderDeviceAudioProcessing(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::AudioProcessing>(arg);

            self->obj.DesiredRenderDeviceAudioProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_AudioRenderCategory(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioRenderCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_AudioRenderCategory(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(arg);

            self->obj.AudioRenderCategory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioGraphSettings_get_MaxPlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioGraphSettings_put_MaxPlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::AudioGraphSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MaxPlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AudioGraphSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphSettings[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraphSettings[] = {
        { "quantum_size_selection_mode", reinterpret_cast<getter>(AudioGraphSettings_get_QuantumSizeSelectionMode), reinterpret_cast<setter>(AudioGraphSettings_put_QuantumSizeSelectionMode), nullptr, nullptr },
        { "primary_render_device", reinterpret_cast<getter>(AudioGraphSettings_get_PrimaryRenderDevice), reinterpret_cast<setter>(AudioGraphSettings_put_PrimaryRenderDevice), nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioGraphSettings_get_EncodingProperties), reinterpret_cast<setter>(AudioGraphSettings_put_EncodingProperties), nullptr, nullptr },
        { "desired_samples_per_quantum", reinterpret_cast<getter>(AudioGraphSettings_get_DesiredSamplesPerQuantum), reinterpret_cast<setter>(AudioGraphSettings_put_DesiredSamplesPerQuantum), nullptr, nullptr },
        { "desired_render_device_audio_processing", reinterpret_cast<getter>(AudioGraphSettings_get_DesiredRenderDeviceAudioProcessing), reinterpret_cast<setter>(AudioGraphSettings_put_DesiredRenderDeviceAudioProcessing), nullptr, nullptr },
        { "audio_render_category", reinterpret_cast<getter>(AudioGraphSettings_get_AudioRenderCategory), reinterpret_cast<setter>(AudioGraphSettings_put_AudioRenderCategory), nullptr, nullptr },
        { "max_playback_speed_factor", reinterpret_cast<getter>(AudioGraphSettings_get_MaxPlaybackSpeedFactor), reinterpret_cast<setter>(AudioGraphSettings_put_MaxPlaybackSpeedFactor), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioGraphSettings[] = 
    {
        { Py_tp_new, _new_AudioGraphSettings },
        { Py_tp_dealloc, _dealloc_AudioGraphSettings },
        { Py_tp_methods, _methods_AudioGraphSettings },
        { Py_tp_getset, _getset_AudioGraphSettings },
        { },
    };

    static PyType_Spec _type_spec_AudioGraphSettings =
    {
        "_winsdk_Windows_Media_Audio.AudioGraphSettings",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphSettings
    };

    // ----- AudioGraphUnrecoverableErrorOccurredEventArgs class --------------------
    constexpr const char* const _type_name_AudioGraphUnrecoverableErrorOccurredEventArgs = "AudioGraphUnrecoverableErrorOccurredEventArgs";

    static PyObject* _new_AudioGraphUnrecoverableErrorOccurredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioGraphUnrecoverableErrorOccurredEventArgs);
        return nullptr;
    }

    static void _dealloc_AudioGraphUnrecoverableErrorOccurredEventArgs(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioGraphUnrecoverableErrorOccurredEventArgs_get_Error(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioGraphUnrecoverableErrorOccurredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioGraphUnrecoverableErrorOccurredEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioGraphUnrecoverableErrorOccurredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioGraphUnrecoverableErrorOccurredEventArgs[] = {
        { "error", reinterpret_cast<getter>(AudioGraphUnrecoverableErrorOccurredEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioGraphUnrecoverableErrorOccurredEventArgs[] = 
    {
        { Py_tp_new, _new_AudioGraphUnrecoverableErrorOccurredEventArgs },
        { Py_tp_dealloc, _dealloc_AudioGraphUnrecoverableErrorOccurredEventArgs },
        { Py_tp_methods, _methods_AudioGraphUnrecoverableErrorOccurredEventArgs },
        { Py_tp_getset, _getset_AudioGraphUnrecoverableErrorOccurredEventArgs },
        { },
    };

    static PyType_Spec _type_spec_AudioGraphUnrecoverableErrorOccurredEventArgs =
    {
        "_winsdk_Windows_Media_Audio.AudioGraphUnrecoverableErrorOccurredEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioGraphUnrecoverableErrorOccurredEventArgs
    };

    // ----- AudioNodeEmitter class --------------------
    constexpr const char* const _type_name_AudioNodeEmitter = "AudioNodeEmitter";

    static PyObject* _new_AudioNodeEmitter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterShape>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeEmitterSettings>(args, 2);

                winrt::Windows::Media::Audio::AudioNodeEmitter instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Audio::AudioNodeEmitter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioNodeEmitter(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioNodeEmitter_get_Position(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Position(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_Gain(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Gain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Gain(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Gain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DopplerVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.DopplerVelocity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DopplerScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DopplerScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DopplerScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DopplerScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DistanceScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DistanceScale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_DistanceScale(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DistanceScale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_Direction(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_Direction(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Direction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeEmitter_get_DecayModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecayModel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_IsDopplerDisabled(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDopplerDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_Shape(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shape());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitter_get_SpatialAudioModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpatialAudioModel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeEmitter_put_SpatialAudioModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::SpatialAudioModel>(arg);

            self->obj.SpatialAudioModel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AudioNodeEmitter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitter[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitter[] = {
        { "position", reinterpret_cast<getter>(AudioNodeEmitter_get_Position), reinterpret_cast<setter>(AudioNodeEmitter_put_Position), nullptr, nullptr },
        { "gain", reinterpret_cast<getter>(AudioNodeEmitter_get_Gain), reinterpret_cast<setter>(AudioNodeEmitter_put_Gain), nullptr, nullptr },
        { "doppler_velocity", reinterpret_cast<getter>(AudioNodeEmitter_get_DopplerVelocity), reinterpret_cast<setter>(AudioNodeEmitter_put_DopplerVelocity), nullptr, nullptr },
        { "doppler_scale", reinterpret_cast<getter>(AudioNodeEmitter_get_DopplerScale), reinterpret_cast<setter>(AudioNodeEmitter_put_DopplerScale), nullptr, nullptr },
        { "distance_scale", reinterpret_cast<getter>(AudioNodeEmitter_get_DistanceScale), reinterpret_cast<setter>(AudioNodeEmitter_put_DistanceScale), nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(AudioNodeEmitter_get_Direction), reinterpret_cast<setter>(AudioNodeEmitter_put_Direction), nullptr, nullptr },
        { "decay_model", reinterpret_cast<getter>(AudioNodeEmitter_get_DecayModel), nullptr, nullptr, nullptr },
        { "is_doppler_disabled", reinterpret_cast<getter>(AudioNodeEmitter_get_IsDopplerDisabled), nullptr, nullptr, nullptr },
        { "shape", reinterpret_cast<getter>(AudioNodeEmitter_get_Shape), nullptr, nullptr, nullptr },
        { "spatial_audio_model", reinterpret_cast<getter>(AudioNodeEmitter_get_SpatialAudioModel), reinterpret_cast<setter>(AudioNodeEmitter_put_SpatialAudioModel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitter[] = 
    {
        { Py_tp_new, _new_AudioNodeEmitter },
        { Py_tp_dealloc, _dealloc_AudioNodeEmitter },
        { Py_tp_methods, _methods_AudioNodeEmitter },
        { Py_tp_getset, _getset_AudioNodeEmitter },
        { },
    };

    static PyType_Spec _type_spec_AudioNodeEmitter =
    {
        "_winsdk_Windows_Media_Audio.AudioNodeEmitter",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitter
    };

    // ----- AudioNodeEmitterConeProperties class --------------------
    constexpr const char* const _type_name_AudioNodeEmitterConeProperties = "AudioNodeEmitterConeProperties";

    static PyObject* _new_AudioNodeEmitterConeProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioNodeEmitterConeProperties);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterConeProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioNodeEmitterConeProperties_get_InnerAngle(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InnerAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterConeProperties_get_OuterAngle(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OuterAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterConeProperties_get_OuterAngleGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OuterAngleGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioNodeEmitterConeProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterConeProperties[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterConeProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitterConeProperties[] = {
        { "inner_angle", reinterpret_cast<getter>(AudioNodeEmitterConeProperties_get_InnerAngle), nullptr, nullptr, nullptr },
        { "outer_angle", reinterpret_cast<getter>(AudioNodeEmitterConeProperties_get_OuterAngle), nullptr, nullptr, nullptr },
        { "outer_angle_gain", reinterpret_cast<getter>(AudioNodeEmitterConeProperties_get_OuterAngleGain), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterConeProperties[] = 
    {
        { Py_tp_new, _new_AudioNodeEmitterConeProperties },
        { Py_tp_dealloc, _dealloc_AudioNodeEmitterConeProperties },
        { Py_tp_methods, _methods_AudioNodeEmitterConeProperties },
        { Py_tp_getset, _getset_AudioNodeEmitterConeProperties },
        { },
    };

    static PyType_Spec _type_spec_AudioNodeEmitterConeProperties =
    {
        "_winsdk_Windows_Media_Audio.AudioNodeEmitterConeProperties",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterConeProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterConeProperties
    };

    // ----- AudioNodeEmitterDecayModel class --------------------
    constexpr const char* const _type_name_AudioNodeEmitterDecayModel = "AudioNodeEmitterDecayModel";

    static PyObject* _new_AudioNodeEmitterDecayModel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioNodeEmitterDecayModel);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterDecayModel(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioNodeEmitterDecayModel_CreateCustom(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel::CreateCustom(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_CreateNatural(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel::CreateNatural(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_Kind(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_MaxGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_MinGain(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterDecayModel_get_NaturalProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NaturalProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioNodeEmitterDecayModel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterDecayModel[] = {
        { "create_custom", reinterpret_cast<PyCFunction>(AudioNodeEmitterDecayModel_CreateCustom), METH_VARARGS | METH_STATIC, nullptr },
        { "create_natural", reinterpret_cast<PyCFunction>(AudioNodeEmitterDecayModel_CreateNatural), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterDecayModel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitterDecayModel[] = {
        { "kind", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_Kind), nullptr, nullptr, nullptr },
        { "max_gain", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_MaxGain), nullptr, nullptr, nullptr },
        { "min_gain", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_MinGain), nullptr, nullptr, nullptr },
        { "natural_properties", reinterpret_cast<getter>(AudioNodeEmitterDecayModel_get_NaturalProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterDecayModel[] = 
    {
        { Py_tp_new, _new_AudioNodeEmitterDecayModel },
        { Py_tp_dealloc, _dealloc_AudioNodeEmitterDecayModel },
        { Py_tp_methods, _methods_AudioNodeEmitterDecayModel },
        { Py_tp_getset, _getset_AudioNodeEmitterDecayModel },
        { },
    };

    static PyType_Spec _type_spec_AudioNodeEmitterDecayModel =
    {
        "_winsdk_Windows_Media_Audio.AudioNodeEmitterDecayModel",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterDecayModel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterDecayModel
    };

    // ----- AudioNodeEmitterNaturalDecayModelProperties class --------------------
    constexpr const char* const _type_name_AudioNodeEmitterNaturalDecayModelProperties = "AudioNodeEmitterNaturalDecayModelProperties";

    static PyObject* _new_AudioNodeEmitterNaturalDecayModelProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioNodeEmitterNaturalDecayModelProperties);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterNaturalDecayModelProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioNodeEmitterNaturalDecayModelProperties_get_CutoffDistance(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CutoffDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterNaturalDecayModelProperties_get_UnityGainDistance(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnityGainDistance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioNodeEmitterNaturalDecayModelProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterNaturalDecayModelProperties[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterNaturalDecayModelProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitterNaturalDecayModelProperties[] = {
        { "cutoff_distance", reinterpret_cast<getter>(AudioNodeEmitterNaturalDecayModelProperties_get_CutoffDistance), nullptr, nullptr, nullptr },
        { "unity_gain_distance", reinterpret_cast<getter>(AudioNodeEmitterNaturalDecayModelProperties_get_UnityGainDistance), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterNaturalDecayModelProperties[] = 
    {
        { Py_tp_new, _new_AudioNodeEmitterNaturalDecayModelProperties },
        { Py_tp_dealloc, _dealloc_AudioNodeEmitterNaturalDecayModelProperties },
        { Py_tp_methods, _methods_AudioNodeEmitterNaturalDecayModelProperties },
        { Py_tp_getset, _getset_AudioNodeEmitterNaturalDecayModelProperties },
        { },
    };

    static PyType_Spec _type_spec_AudioNodeEmitterNaturalDecayModelProperties =
    {
        "_winsdk_Windows_Media_Audio.AudioNodeEmitterNaturalDecayModelProperties",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterNaturalDecayModelProperties
    };

    // ----- AudioNodeEmitterShape class --------------------
    constexpr const char* const _type_name_AudioNodeEmitterShape = "AudioNodeEmitterShape";

    static PyObject* _new_AudioNodeEmitterShape(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioNodeEmitterShape);
        return nullptr;
    }

    static void _dealloc_AudioNodeEmitterShape(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioNodeEmitterShape_CreateCone(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<double>(args, 2);

                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterShape::CreateCone(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_CreateOmnidirectional(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioNodeEmitterShape::CreateOmnidirectional());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_get_ConeProperties(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConeProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioNodeEmitterShape_get_Kind(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioNodeEmitterShape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeEmitterShape>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeEmitterShape[] = {
        { "create_cone", reinterpret_cast<PyCFunction>(AudioNodeEmitterShape_CreateCone), METH_VARARGS | METH_STATIC, nullptr },
        { "create_omnidirectional", reinterpret_cast<PyCFunction>(AudioNodeEmitterShape_CreateOmnidirectional), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeEmitterShape), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeEmitterShape[] = {
        { "cone_properties", reinterpret_cast<getter>(AudioNodeEmitterShape_get_ConeProperties), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(AudioNodeEmitterShape_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeEmitterShape[] = 
    {
        { Py_tp_new, _new_AudioNodeEmitterShape },
        { Py_tp_dealloc, _dealloc_AudioNodeEmitterShape },
        { Py_tp_methods, _methods_AudioNodeEmitterShape },
        { Py_tp_getset, _getset_AudioNodeEmitterShape },
        { },
    };

    static PyType_Spec _type_spec_AudioNodeEmitterShape =
    {
        "_winsdk_Windows_Media_Audio.AudioNodeEmitterShape",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeEmitterShape),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeEmitterShape
    };

    // ----- AudioNodeListener class --------------------
    constexpr const char* const _type_name_AudioNodeListener = "AudioNodeListener";

    static PyObject* _new_AudioNodeListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Audio::AudioNodeListener instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioNodeListener(py::wrapper::Windows::Media::Audio::AudioNodeListener* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioNodeListener_get_SpeedOfSound(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpeedOfSound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_SpeedOfSound(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.SpeedOfSound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_Position(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_Position(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_Orientation(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_Orientation(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioNodeListener_get_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DopplerVelocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioNodeListener_put_DopplerVelocity(py::wrapper::Windows::Media::Audio::AudioNodeListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(arg);

            self->obj.DopplerVelocity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AudioNodeListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioNodeListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioNodeListener[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioNodeListener), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioNodeListener[] = {
        { "speed_of_sound", reinterpret_cast<getter>(AudioNodeListener_get_SpeedOfSound), reinterpret_cast<setter>(AudioNodeListener_put_SpeedOfSound), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(AudioNodeListener_get_Position), reinterpret_cast<setter>(AudioNodeListener_put_Position), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(AudioNodeListener_get_Orientation), reinterpret_cast<setter>(AudioNodeListener_put_Orientation), nullptr, nullptr },
        { "doppler_velocity", reinterpret_cast<getter>(AudioNodeListener_get_DopplerVelocity), reinterpret_cast<setter>(AudioNodeListener_put_DopplerVelocity), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioNodeListener[] = 
    {
        { Py_tp_new, _new_AudioNodeListener },
        { Py_tp_dealloc, _dealloc_AudioNodeListener },
        { Py_tp_methods, _methods_AudioNodeListener },
        { Py_tp_getset, _getset_AudioNodeListener },
        { },
    };

    static PyType_Spec _type_spec_AudioNodeListener =
    {
        "_winsdk_Windows_Media_Audio.AudioNodeListener",
        sizeof(py::wrapper::Windows::Media::Audio::AudioNodeListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioNodeListener
    };

    // ----- AudioPlaybackConnection class --------------------
    constexpr const char* const _type_name_AudioPlaybackConnection = "AudioPlaybackConnection";

    static PyObject* _new_AudioPlaybackConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioPlaybackConnection);
        return nullptr;
    }

    static void _dealloc_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioPlaybackConnection_Close(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioPlaybackConnection::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_Open(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Open());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_OpenAsync(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_Start(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_StartAsync(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_TryCreateFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioPlaybackConnection::TryCreateFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_get_DeviceId(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_get_State(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_add_StateChanged(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioPlaybackConnection, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnection_remove_StateChanged(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioPlaybackConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioPlaybackConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioPlaybackConnection(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioPlaybackConnection[] = {
        { "close", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_Close), METH_VARARGS, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "open", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_Open), METH_VARARGS, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_OpenAsync), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_Start), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_StartAsync), METH_VARARGS, nullptr },
        { "try_create_from_id", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_TryCreateFromId), METH_VARARGS | METH_STATIC, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(AudioPlaybackConnection_remove_StateChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioPlaybackConnection), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioPlaybackConnection), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioPlaybackConnection), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioPlaybackConnection[] = {
        { "device_id", reinterpret_cast<getter>(AudioPlaybackConnection_get_DeviceId), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(AudioPlaybackConnection_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioPlaybackConnection[] = 
    {
        { Py_tp_new, _new_AudioPlaybackConnection },
        { Py_tp_dealloc, _dealloc_AudioPlaybackConnection },
        { Py_tp_methods, _methods_AudioPlaybackConnection },
        { Py_tp_getset, _getset_AudioPlaybackConnection },
        { },
    };

    static PyType_Spec _type_spec_AudioPlaybackConnection =
    {
        "_winsdk_Windows_Media_Audio.AudioPlaybackConnection",
        sizeof(py::wrapper::Windows::Media::Audio::AudioPlaybackConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioPlaybackConnection
    };

    // ----- AudioPlaybackConnectionOpenResult class --------------------
    constexpr const char* const _type_name_AudioPlaybackConnectionOpenResult = "AudioPlaybackConnectionOpenResult";

    static PyObject* _new_AudioPlaybackConnectionOpenResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioPlaybackConnectionOpenResult);
        return nullptr;
    }

    static void _dealloc_AudioPlaybackConnectionOpenResult(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioPlaybackConnectionOpenResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioPlaybackConnectionOpenResult_get_Status(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioPlaybackConnectionOpenResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioPlaybackConnectionOpenResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioPlaybackConnectionOpenResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioPlaybackConnectionOpenResult[] = {
        { "extended_error", reinterpret_cast<getter>(AudioPlaybackConnectionOpenResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AudioPlaybackConnectionOpenResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioPlaybackConnectionOpenResult[] = 
    {
        { Py_tp_new, _new_AudioPlaybackConnectionOpenResult },
        { Py_tp_dealloc, _dealloc_AudioPlaybackConnectionOpenResult },
        { Py_tp_methods, _methods_AudioPlaybackConnectionOpenResult },
        { Py_tp_getset, _getset_AudioPlaybackConnectionOpenResult },
        { },
    };

    static PyType_Spec _type_spec_AudioPlaybackConnectionOpenResult =
    {
        "_winsdk_Windows_Media_Audio.AudioPlaybackConnectionOpenResult",
        sizeof(py::wrapper::Windows::Media::Audio::AudioPlaybackConnectionOpenResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioPlaybackConnectionOpenResult
    };

    // ----- AudioStateMonitor class --------------------
    constexpr const char* const _type_name_AudioStateMonitor = "AudioStateMonitor";

    static PyObject* _new_AudioStateMonitor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioStateMonitor);
        return nullptr;
    }

    static void _dealloc_AudioStateMonitor(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioStateMonitor_CreateForCaptureMonitoring(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoring(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForCaptureMonitoringWithCategoryAndDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForCaptureMonitoringWithCategoryAndDeviceId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForRenderMonitoring(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoring(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_CreateForRenderMonitoringWithCategoryAndDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Audio::AudioStateMonitor::CreateForRenderMonitoringWithCategoryAndDeviceId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_get_SoundLevel(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SoundLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_add_SoundLevelChanged(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::AudioStateMonitor, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SoundLevelChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStateMonitor_remove_SoundLevelChanged(py::wrapper::Windows::Media::Audio::AudioStateMonitor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SoundLevelChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioStateMonitor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioStateMonitor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioStateMonitor[] = {
        { "create_for_capture_monitoring", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForCaptureMonitoring), METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_capture_monitoring_with_category_and_device_id", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForCaptureMonitoringWithCategoryAndDeviceId), METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_render_monitoring", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForRenderMonitoring), METH_VARARGS | METH_STATIC, nullptr },
        { "create_for_render_monitoring_with_category_and_device_id", reinterpret_cast<PyCFunction>(AudioStateMonitor_CreateForRenderMonitoringWithCategoryAndDeviceId), METH_VARARGS | METH_STATIC, nullptr },
        { "add_sound_level_changed", reinterpret_cast<PyCFunction>(AudioStateMonitor_add_SoundLevelChanged), METH_O, nullptr },
        { "remove_sound_level_changed", reinterpret_cast<PyCFunction>(AudioStateMonitor_remove_SoundLevelChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioStateMonitor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioStateMonitor[] = {
        { "sound_level", reinterpret_cast<getter>(AudioStateMonitor_get_SoundLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioStateMonitor[] = 
    {
        { Py_tp_new, _new_AudioStateMonitor },
        { Py_tp_dealloc, _dealloc_AudioStateMonitor },
        { Py_tp_methods, _methods_AudioStateMonitor },
        { Py_tp_getset, _getset_AudioStateMonitor },
        { },
    };

    static PyType_Spec _type_spec_AudioStateMonitor =
    {
        "_winsdk_Windows_Media_Audio.AudioStateMonitor",
        sizeof(py::wrapper::Windows::Media::Audio::AudioStateMonitor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioStateMonitor
    };

    // ----- AudioSubmixNode class --------------------
    constexpr const char* const _type_name_AudioSubmixNode = "AudioSubmixNode";

    static PyObject* _new_AudioSubmixNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioSubmixNode);
        return nullptr;
    }

    static void _dealloc_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioSubmixNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Close(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Reset(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Start(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_Stop(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_Emitter(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioSubmixNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioSubmixNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioSubmixNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioSubmixNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioSubmixNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioSubmixNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::AudioSubmixNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_AudioSubmixNode(py::wrapper::Windows::Media::Audio::AudioSubmixNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioSubmixNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(AudioSubmixNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(AudioSubmixNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioSubmixNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(AudioSubmixNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(AudioSubmixNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AudioSubmixNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(AudioSubmixNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(AudioSubmixNode_Stop), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioSubmixNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_AudioSubmixNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_AudioSubmixNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioSubmixNode[] = {
        { "outgoing_connections", reinterpret_cast<getter>(AudioSubmixNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(AudioSubmixNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(AudioSubmixNode_get_OutgoingGain), reinterpret_cast<setter>(AudioSubmixNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(AudioSubmixNode_get_ConsumeInput), reinterpret_cast<setter>(AudioSubmixNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(AudioSubmixNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(AudioSubmixNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioSubmixNode[] = 
    {
        { Py_tp_new, _new_AudioSubmixNode },
        { Py_tp_dealloc, _dealloc_AudioSubmixNode },
        { Py_tp_methods, _methods_AudioSubmixNode },
        { Py_tp_getset, _getset_AudioSubmixNode },
        { },
    };

    static PyType_Spec _type_spec_AudioSubmixNode =
    {
        "_winsdk_Windows_Media_Audio.AudioSubmixNode",
        sizeof(py::wrapper::Windows::Media::Audio::AudioSubmixNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioSubmixNode
    };

    // ----- CreateAudioDeviceInputNodeResult class --------------------
    constexpr const char* const _type_name_CreateAudioDeviceInputNodeResult = "CreateAudioDeviceInputNodeResult";

    static PyObject* _new_CreateAudioDeviceInputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CreateAudioDeviceInputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioDeviceInputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_DeviceInputNode(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CreateAudioDeviceInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioDeviceInputNodeResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioDeviceInputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioDeviceInputNodeResult[] = {
        { "device_input_node", reinterpret_cast<getter>(CreateAudioDeviceInputNodeResult_get_DeviceInputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioDeviceInputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioDeviceInputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioDeviceInputNodeResult[] = 
    {
        { Py_tp_new, _new_CreateAudioDeviceInputNodeResult },
        { Py_tp_dealloc, _dealloc_CreateAudioDeviceInputNodeResult },
        { Py_tp_methods, _methods_CreateAudioDeviceInputNodeResult },
        { Py_tp_getset, _getset_CreateAudioDeviceInputNodeResult },
        { },
    };

    static PyType_Spec _type_spec_CreateAudioDeviceInputNodeResult =
    {
        "_winsdk_Windows_Media_Audio.CreateAudioDeviceInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioDeviceInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioDeviceInputNodeResult
    };

    // ----- CreateAudioDeviceOutputNodeResult class --------------------
    constexpr const char* const _type_name_CreateAudioDeviceOutputNodeResult = "CreateAudioDeviceOutputNodeResult";

    static PyObject* _new_CreateAudioDeviceOutputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CreateAudioDeviceOutputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioDeviceOutputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_DeviceOutputNode(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceOutputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioDeviceOutputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CreateAudioDeviceOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioDeviceOutputNodeResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioDeviceOutputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioDeviceOutputNodeResult[] = {
        { "device_output_node", reinterpret_cast<getter>(CreateAudioDeviceOutputNodeResult_get_DeviceOutputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioDeviceOutputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioDeviceOutputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioDeviceOutputNodeResult[] = 
    {
        { Py_tp_new, _new_CreateAudioDeviceOutputNodeResult },
        { Py_tp_dealloc, _dealloc_CreateAudioDeviceOutputNodeResult },
        { Py_tp_methods, _methods_CreateAudioDeviceOutputNodeResult },
        { Py_tp_getset, _getset_CreateAudioDeviceOutputNodeResult },
        { },
    };

    static PyType_Spec _type_spec_CreateAudioDeviceOutputNodeResult =
    {
        "_winsdk_Windows_Media_Audio.CreateAudioDeviceOutputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioDeviceOutputNodeResult
    };

    // ----- CreateAudioFileInputNodeResult class --------------------
    constexpr const char* const _type_name_CreateAudioFileInputNodeResult = "CreateAudioFileInputNodeResult";

    static PyObject* _new_CreateAudioFileInputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CreateAudioFileInputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioFileInputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CreateAudioFileInputNodeResult_get_FileInputNode(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileInputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CreateAudioFileInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioFileInputNodeResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioFileInputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioFileInputNodeResult[] = {
        { "file_input_node", reinterpret_cast<getter>(CreateAudioFileInputNodeResult_get_FileInputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioFileInputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioFileInputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioFileInputNodeResult[] = 
    {
        { Py_tp_new, _new_CreateAudioFileInputNodeResult },
        { Py_tp_dealloc, _dealloc_CreateAudioFileInputNodeResult },
        { Py_tp_methods, _methods_CreateAudioFileInputNodeResult },
        { Py_tp_getset, _getset_CreateAudioFileInputNodeResult },
        { },
    };

    static PyType_Spec _type_spec_CreateAudioFileInputNodeResult =
    {
        "_winsdk_Windows_Media_Audio.CreateAudioFileInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioFileInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioFileInputNodeResult
    };

    // ----- CreateAudioFileOutputNodeResult class --------------------
    constexpr const char* const _type_name_CreateAudioFileOutputNodeResult = "CreateAudioFileOutputNodeResult";

    static PyObject* _new_CreateAudioFileOutputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CreateAudioFileOutputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioFileOutputNodeResult(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_FileOutputNode(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileOutputNode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioFileOutputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CreateAudioFileOutputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioFileOutputNodeResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioFileOutputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioFileOutputNodeResult[] = {
        { "file_output_node", reinterpret_cast<getter>(CreateAudioFileOutputNodeResult_get_FileOutputNode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioFileOutputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioFileOutputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioFileOutputNodeResult[] = 
    {
        { Py_tp_new, _new_CreateAudioFileOutputNodeResult },
        { Py_tp_dealloc, _dealloc_CreateAudioFileOutputNodeResult },
        { Py_tp_methods, _methods_CreateAudioFileOutputNodeResult },
        { Py_tp_getset, _getset_CreateAudioFileOutputNodeResult },
        { },
    };

    static PyType_Spec _type_spec_CreateAudioFileOutputNodeResult =
    {
        "_winsdk_Windows_Media_Audio.CreateAudioFileOutputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioFileOutputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioFileOutputNodeResult
    };

    // ----- CreateAudioGraphResult class --------------------
    constexpr const char* const _type_name_CreateAudioGraphResult = "CreateAudioGraphResult";

    static PyObject* _new_CreateAudioGraphResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CreateAudioGraphResult);
        return nullptr;
    }

    static void _dealloc_CreateAudioGraphResult(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CreateAudioGraphResult_get_Graph(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Graph());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioGraphResult_get_Status(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateAudioGraphResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CreateAudioGraphResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateAudioGraphResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateAudioGraphResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateAudioGraphResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateAudioGraphResult[] = {
        { "graph", reinterpret_cast<getter>(CreateAudioGraphResult_get_Graph), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateAudioGraphResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateAudioGraphResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateAudioGraphResult[] = 
    {
        { Py_tp_new, _new_CreateAudioGraphResult },
        { Py_tp_dealloc, _dealloc_CreateAudioGraphResult },
        { Py_tp_methods, _methods_CreateAudioGraphResult },
        { Py_tp_getset, _getset_CreateAudioGraphResult },
        { },
    };

    static PyType_Spec _type_spec_CreateAudioGraphResult =
    {
        "_winsdk_Windows_Media_Audio.CreateAudioGraphResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateAudioGraphResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateAudioGraphResult
    };

    // ----- CreateMediaSourceAudioInputNodeResult class --------------------
    constexpr const char* const _type_name_CreateMediaSourceAudioInputNodeResult = "CreateMediaSourceAudioInputNodeResult";

    static PyObject* _new_CreateMediaSourceAudioInputNodeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CreateMediaSourceAudioInputNodeResult);
        return nullptr;
    }

    static void _dealloc_CreateMediaSourceAudioInputNodeResult(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_Node(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Node());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_Status(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CreateMediaSourceAudioInputNodeResult_get_ExtendedError(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CreateMediaSourceAudioInputNodeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CreateMediaSourceAudioInputNodeResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CreateMediaSourceAudioInputNodeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CreateMediaSourceAudioInputNodeResult[] = {
        { "node", reinterpret_cast<getter>(CreateMediaSourceAudioInputNodeResult_get_Node), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(CreateMediaSourceAudioInputNodeResult_get_Status), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(CreateMediaSourceAudioInputNodeResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CreateMediaSourceAudioInputNodeResult[] = 
    {
        { Py_tp_new, _new_CreateMediaSourceAudioInputNodeResult },
        { Py_tp_dealloc, _dealloc_CreateMediaSourceAudioInputNodeResult },
        { Py_tp_methods, _methods_CreateMediaSourceAudioInputNodeResult },
        { Py_tp_getset, _getset_CreateMediaSourceAudioInputNodeResult },
        { },
    };

    static PyType_Spec _type_spec_CreateMediaSourceAudioInputNodeResult =
    {
        "_winsdk_Windows_Media_Audio.CreateMediaSourceAudioInputNodeResult",
        sizeof(py::wrapper::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CreateMediaSourceAudioInputNodeResult
    };

    // ----- EchoEffectDefinition class --------------------
    constexpr const char* const _type_name_EchoEffectDefinition = "EchoEffectDefinition";

    static PyObject* _new_EchoEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::EchoEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EchoEffectDefinition(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EchoEffectDefinition_get_WetDryMix(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WetDryMix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_WetDryMix(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.WetDryMix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_Feedback(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Feedback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_Feedback(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Feedback(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_Delay(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Delay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EchoEffectDefinition_put_Delay(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Delay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EchoEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EchoEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::EchoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EchoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EchoEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EchoEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_EchoEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EchoEffectDefinition[] = {
        { "wet_dry_mix", reinterpret_cast<getter>(EchoEffectDefinition_get_WetDryMix), reinterpret_cast<setter>(EchoEffectDefinition_put_WetDryMix), nullptr, nullptr },
        { "feedback", reinterpret_cast<getter>(EchoEffectDefinition_get_Feedback), reinterpret_cast<setter>(EchoEffectDefinition_put_Feedback), nullptr, nullptr },
        { "delay", reinterpret_cast<getter>(EchoEffectDefinition_get_Delay), reinterpret_cast<setter>(EchoEffectDefinition_put_Delay), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(EchoEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(EchoEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EchoEffectDefinition[] = 
    {
        { Py_tp_new, _new_EchoEffectDefinition },
        { Py_tp_dealloc, _dealloc_EchoEffectDefinition },
        { Py_tp_methods, _methods_EchoEffectDefinition },
        { Py_tp_getset, _getset_EchoEffectDefinition },
        { },
    };

    static PyType_Spec _type_spec_EchoEffectDefinition =
    {
        "_winsdk_Windows_Media_Audio.EchoEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::EchoEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EchoEffectDefinition
    };

    // ----- EqualizerBand class --------------------
    constexpr const char* const _type_name_EqualizerBand = "EqualizerBand";

    static PyObject* _new_EqualizerBand(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_EqualizerBand);
        return nullptr;
    }

    static void _dealloc_EqualizerBand(py::wrapper::Windows::Media::Audio::EqualizerBand* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EqualizerBand_get_Gain(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Gain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_Gain(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Gain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EqualizerBand_get_FrequencyCenter(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrequencyCenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_FrequencyCenter(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FrequencyCenter(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* EqualizerBand_get_Bandwidth(py::wrapper::Windows::Media::Audio::EqualizerBand* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bandwidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int EqualizerBand_put_Bandwidth(py::wrapper::Windows::Media::Audio::EqualizerBand* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Bandwidth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_EqualizerBand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EqualizerBand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EqualizerBand[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_EqualizerBand), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EqualizerBand[] = {
        { "gain", reinterpret_cast<getter>(EqualizerBand_get_Gain), reinterpret_cast<setter>(EqualizerBand_put_Gain), nullptr, nullptr },
        { "frequency_center", reinterpret_cast<getter>(EqualizerBand_get_FrequencyCenter), reinterpret_cast<setter>(EqualizerBand_put_FrequencyCenter), nullptr, nullptr },
        { "bandwidth", reinterpret_cast<getter>(EqualizerBand_get_Bandwidth), reinterpret_cast<setter>(EqualizerBand_put_Bandwidth), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EqualizerBand[] = 
    {
        { Py_tp_new, _new_EqualizerBand },
        { Py_tp_dealloc, _dealloc_EqualizerBand },
        { Py_tp_methods, _methods_EqualizerBand },
        { Py_tp_getset, _getset_EqualizerBand },
        { },
    };

    static PyType_Spec _type_spec_EqualizerBand =
    {
        "_winsdk_Windows_Media_Audio.EqualizerBand",
        sizeof(py::wrapper::Windows::Media::Audio::EqualizerBand),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EqualizerBand
    };

    // ----- EqualizerEffectDefinition class --------------------
    constexpr const char* const _type_name_EqualizerEffectDefinition = "EqualizerEffectDefinition";

    static PyObject* _new_EqualizerEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::EqualizerEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_EqualizerEffectDefinition(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* EqualizerEffectDefinition_get_Bands(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EqualizerEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* EqualizerEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_EqualizerEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::EqualizerEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_EqualizerEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_EqualizerEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_EqualizerEffectDefinition[] = {
        { "bands", reinterpret_cast<getter>(EqualizerEffectDefinition_get_Bands), nullptr, nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(EqualizerEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(EqualizerEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_EqualizerEffectDefinition[] = 
    {
        { Py_tp_new, _new_EqualizerEffectDefinition },
        { Py_tp_dealloc, _dealloc_EqualizerEffectDefinition },
        { Py_tp_methods, _methods_EqualizerEffectDefinition },
        { Py_tp_getset, _getset_EqualizerEffectDefinition },
        { },
    };

    static PyType_Spec _type_spec_EqualizerEffectDefinition =
    {
        "_winsdk_Windows_Media_Audio.EqualizerEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::EqualizerEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_EqualizerEffectDefinition
    };

    // ----- FrameInputNodeQuantumStartedEventArgs class --------------------
    constexpr const char* const _type_name_FrameInputNodeQuantumStartedEventArgs = "FrameInputNodeQuantumStartedEventArgs";

    static PyObject* _new_FrameInputNodeQuantumStartedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameInputNodeQuantumStartedEventArgs);
        return nullptr;
    }

    static void _dealloc_FrameInputNodeQuantumStartedEventArgs(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameInputNodeQuantumStartedEventArgs_get_RequiredSamples(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequiredSamples());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameInputNodeQuantumStartedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameInputNodeQuantumStartedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameInputNodeQuantumStartedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameInputNodeQuantumStartedEventArgs[] = {
        { "required_samples", reinterpret_cast<getter>(FrameInputNodeQuantumStartedEventArgs_get_RequiredSamples), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameInputNodeQuantumStartedEventArgs[] = 
    {
        { Py_tp_new, _new_FrameInputNodeQuantumStartedEventArgs },
        { Py_tp_dealloc, _dealloc_FrameInputNodeQuantumStartedEventArgs },
        { Py_tp_methods, _methods_FrameInputNodeQuantumStartedEventArgs },
        { Py_tp_getset, _getset_FrameInputNodeQuantumStartedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_FrameInputNodeQuantumStartedEventArgs =
    {
        "_winsdk_Windows_Media_Audio.FrameInputNodeQuantumStartedEventArgs",
        sizeof(py::wrapper::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameInputNodeQuantumStartedEventArgs
    };

    // ----- LimiterEffectDefinition class --------------------
    constexpr const char* const _type_name_LimiterEffectDefinition = "LimiterEffectDefinition";

    static PyObject* _new_LimiterEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::LimiterEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LimiterEffectDefinition(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LimiterEffectDefinition_get_Release(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Release());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LimiterEffectDefinition_put_Release(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Release(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LimiterEffectDefinition_get_Loudness(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Loudness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LimiterEffectDefinition_put_Loudness(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Loudness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LimiterEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LimiterEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LimiterEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::LimiterEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LimiterEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LimiterEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LimiterEffectDefinition[] = {
        { "release", reinterpret_cast<getter>(LimiterEffectDefinition_get_Release), reinterpret_cast<setter>(LimiterEffectDefinition_put_Release), nullptr, nullptr },
        { "loudness", reinterpret_cast<getter>(LimiterEffectDefinition_get_Loudness), reinterpret_cast<setter>(LimiterEffectDefinition_put_Loudness), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(LimiterEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(LimiterEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LimiterEffectDefinition[] = 
    {
        { Py_tp_new, _new_LimiterEffectDefinition },
        { Py_tp_dealloc, _dealloc_LimiterEffectDefinition },
        { Py_tp_methods, _methods_LimiterEffectDefinition },
        { Py_tp_getset, _getset_LimiterEffectDefinition },
        { },
    };

    static PyType_Spec _type_spec_LimiterEffectDefinition =
    {
        "_winsdk_Windows_Media_Audio.LimiterEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::LimiterEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LimiterEffectDefinition
    };

    // ----- MediaSourceAudioInputNode class --------------------
    constexpr const char* const _type_name_MediaSourceAudioInputNode = "MediaSourceAudioInputNode";

    static PyObject* _new_MediaSourceAudioInputNode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaSourceAudioInputNode);
        return nullptr;
    }

    static void _dealloc_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaSourceAudioInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Close(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Reset(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Seek(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Start(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_Stop(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Emitter(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_StartTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_StartTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackSpeedFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_PlaybackSpeedFactor(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.PlaybackSpeedFactor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_LoopCount(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LoopCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_LoopCount(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.LoopCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_EndTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaSourceAudioInputNode_put_EndTime(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.EndTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Duration(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_MediaSource(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_get_Position(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_add_MediaSourceCompleted(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::MediaSourceAudioInputNode, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.MediaSourceCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAudioInputNode_remove_MediaSourceCompleted(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MediaSourceCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSourceAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MediaSourceAudioInputNode(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceAudioInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Reset), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Seek), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_Stop), METH_VARARGS, nullptr },
        { "add_media_source_completed", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_add_MediaSourceCompleted), METH_O, nullptr },
        { "remove_media_source_completed", reinterpret_cast<PyCFunction>(MediaSourceAudioInputNode_remove_MediaSourceCompleted), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceAudioInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaSourceAudioInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaSourceAudioInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceAudioInputNode[] = {
        { "outgoing_connections", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "emitter", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_Emitter), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_OutgoingGain), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_OutgoingGain), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_ConsumeInput), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_StartTime), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_StartTime), nullptr, nullptr },
        { "playback_speed_factor", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_PlaybackSpeedFactor), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_PlaybackSpeedFactor), nullptr, nullptr },
        { "loop_count", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_LoopCount), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_LoopCount), nullptr, nullptr },
        { "end_time", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_EndTime), reinterpret_cast<setter>(MediaSourceAudioInputNode_put_EndTime), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_Duration), nullptr, nullptr, nullptr },
        { "media_source", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_MediaSource), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(MediaSourceAudioInputNode_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceAudioInputNode[] = 
    {
        { Py_tp_new, _new_MediaSourceAudioInputNode },
        { Py_tp_dealloc, _dealloc_MediaSourceAudioInputNode },
        { Py_tp_methods, _methods_MediaSourceAudioInputNode },
        { Py_tp_getset, _getset_MediaSourceAudioInputNode },
        { },
    };

    static PyType_Spec _type_spec_MediaSourceAudioInputNode =
    {
        "_winsdk_Windows_Media_Audio.MediaSourceAudioInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::MediaSourceAudioInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceAudioInputNode
    };

    // ----- ReverbEffectDefinition class --------------------
    constexpr const char* const _type_name_ReverbEffectDefinition = "ReverbEffectDefinition";

    static PyObject* _new_ReverbEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                winrt::Windows::Media::Audio::ReverbEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ReverbEffectDefinition(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ReverbEffectDefinition_get_HighEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighEQGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_HighEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.HighEQGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_HighEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighEQCutoff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_HighEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.HighEQCutoff(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_DisableLateField(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisableLateField());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_DisableLateField(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DisableLateField(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_Density(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Density());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_Density(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Density(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionRight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionRight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_DecayTime(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecayTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_DecayTime(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.DecayTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LateDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LateDiffusion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LateDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.LateDiffusion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionMatrixRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionMatrixRight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionMatrixRight(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionMatrixRight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionMatrixLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionMatrixLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionMatrixLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionMatrixLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_PositionLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_PositionLeft(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.PositionLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LowEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LowEQGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LowEQGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.LowEQGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_LowEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LowEQCutoff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_LowEQCutoff(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.LowEQCutoff(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterFreq(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoomFilterFreq());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterFreq(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomFilterFreq(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReverbGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReverbGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReverbGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ReverbGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReverbDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReverbDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReverbDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.ReverbDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReflectionsGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReflectionsGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReflectionsGain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.ReflectionsGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ReflectionsDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReflectionsDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_ReflectionsDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReflectionsDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RearDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RearDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RearDelay(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.RearDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_WetDryMix(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WetDryMix());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_WetDryMix(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.WetDryMix(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_EarlyDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EarlyDiffusion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_EarlyDiffusion(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.EarlyDiffusion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomSize(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoomSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomSize(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterMain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoomFilterMain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterMain(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomFilterMain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_RoomFilterHF(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoomFilterHF());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ReverbEffectDefinition_put_RoomFilterHF(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RoomFilterHF(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ReverbEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ReverbEffectDefinition_get_Properties(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ReverbEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::ReverbEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ReverbEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ReverbEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ReverbEffectDefinition[] = {
        { "high_e_q_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_HighEQGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_HighEQGain), nullptr, nullptr },
        { "high_e_q_cutoff", reinterpret_cast<getter>(ReverbEffectDefinition_get_HighEQCutoff), reinterpret_cast<setter>(ReverbEffectDefinition_put_HighEQCutoff), nullptr, nullptr },
        { "disable_late_field", reinterpret_cast<getter>(ReverbEffectDefinition_get_DisableLateField), reinterpret_cast<setter>(ReverbEffectDefinition_put_DisableLateField), nullptr, nullptr },
        { "density", reinterpret_cast<getter>(ReverbEffectDefinition_get_Density), reinterpret_cast<setter>(ReverbEffectDefinition_put_Density), nullptr, nullptr },
        { "position_right", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionRight), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionRight), nullptr, nullptr },
        { "decay_time", reinterpret_cast<getter>(ReverbEffectDefinition_get_DecayTime), reinterpret_cast<setter>(ReverbEffectDefinition_put_DecayTime), nullptr, nullptr },
        { "late_diffusion", reinterpret_cast<getter>(ReverbEffectDefinition_get_LateDiffusion), reinterpret_cast<setter>(ReverbEffectDefinition_put_LateDiffusion), nullptr, nullptr },
        { "position_matrix_right", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionMatrixRight), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionMatrixRight), nullptr, nullptr },
        { "position_matrix_left", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionMatrixLeft), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionMatrixLeft), nullptr, nullptr },
        { "position_left", reinterpret_cast<getter>(ReverbEffectDefinition_get_PositionLeft), reinterpret_cast<setter>(ReverbEffectDefinition_put_PositionLeft), nullptr, nullptr },
        { "low_e_q_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_LowEQGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_LowEQGain), nullptr, nullptr },
        { "low_e_q_cutoff", reinterpret_cast<getter>(ReverbEffectDefinition_get_LowEQCutoff), reinterpret_cast<setter>(ReverbEffectDefinition_put_LowEQCutoff), nullptr, nullptr },
        { "room_filter_freq", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomFilterFreq), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomFilterFreq), nullptr, nullptr },
        { "reverb_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReverbGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReverbGain), nullptr, nullptr },
        { "reverb_delay", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReverbDelay), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReverbDelay), nullptr, nullptr },
        { "reflections_gain", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReflectionsGain), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReflectionsGain), nullptr, nullptr },
        { "reflections_delay", reinterpret_cast<getter>(ReverbEffectDefinition_get_ReflectionsDelay), reinterpret_cast<setter>(ReverbEffectDefinition_put_ReflectionsDelay), nullptr, nullptr },
        { "rear_delay", reinterpret_cast<getter>(ReverbEffectDefinition_get_RearDelay), reinterpret_cast<setter>(ReverbEffectDefinition_put_RearDelay), nullptr, nullptr },
        { "wet_dry_mix", reinterpret_cast<getter>(ReverbEffectDefinition_get_WetDryMix), reinterpret_cast<setter>(ReverbEffectDefinition_put_WetDryMix), nullptr, nullptr },
        { "early_diffusion", reinterpret_cast<getter>(ReverbEffectDefinition_get_EarlyDiffusion), reinterpret_cast<setter>(ReverbEffectDefinition_put_EarlyDiffusion), nullptr, nullptr },
        { "room_size", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomSize), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomSize), nullptr, nullptr },
        { "room_filter_main", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomFilterMain), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomFilterMain), nullptr, nullptr },
        { "room_filter_h_f", reinterpret_cast<getter>(ReverbEffectDefinition_get_RoomFilterHF), reinterpret_cast<setter>(ReverbEffectDefinition_put_RoomFilterHF), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(ReverbEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(ReverbEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ReverbEffectDefinition[] = 
    {
        { Py_tp_new, _new_ReverbEffectDefinition },
        { Py_tp_dealloc, _dealloc_ReverbEffectDefinition },
        { Py_tp_methods, _methods_ReverbEffectDefinition },
        { Py_tp_getset, _getset_ReverbEffectDefinition },
        { },
    };

    static PyType_Spec _type_spec_ReverbEffectDefinition =
    {
        "_winsdk_Windows_Media_Audio.ReverbEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Audio::ReverbEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ReverbEffectDefinition
    };

    // ----- SetDefaultSpatialAudioFormatResult class --------------------
    constexpr const char* const _type_name_SetDefaultSpatialAudioFormatResult = "SetDefaultSpatialAudioFormatResult";

    static PyObject* _new_SetDefaultSpatialAudioFormatResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SetDefaultSpatialAudioFormatResult);
        return nullptr;
    }

    static void _dealloc_SetDefaultSpatialAudioFormatResult(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SetDefaultSpatialAudioFormatResult_get_Status(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SetDefaultSpatialAudioFormatResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SetDefaultSpatialAudioFormatResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SetDefaultSpatialAudioFormatResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SetDefaultSpatialAudioFormatResult[] = {
        { "status", reinterpret_cast<getter>(SetDefaultSpatialAudioFormatResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SetDefaultSpatialAudioFormatResult[] = 
    {
        { Py_tp_new, _new_SetDefaultSpatialAudioFormatResult },
        { Py_tp_dealloc, _dealloc_SetDefaultSpatialAudioFormatResult },
        { Py_tp_methods, _methods_SetDefaultSpatialAudioFormatResult },
        { Py_tp_getset, _getset_SetDefaultSpatialAudioFormatResult },
        { },
    };

    static PyType_Spec _type_spec_SetDefaultSpatialAudioFormatResult =
    {
        "_winsdk_Windows_Media_Audio.SetDefaultSpatialAudioFormatResult",
        sizeof(py::wrapper::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SetDefaultSpatialAudioFormatResult
    };

    // ----- SpatialAudioDeviceConfiguration class --------------------
    constexpr const char* const _type_name_SpatialAudioDeviceConfiguration = "SpatialAudioDeviceConfiguration";

    static PyObject* _new_SpatialAudioDeviceConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpatialAudioDeviceConfiguration);
        return nullptr;
    }

    static void _dealloc_SpatialAudioDeviceConfiguration(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpatialAudioDeviceConfiguration_GetForDeviceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration::GetForDeviceId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_IsSpatialAudioFormatSupported(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsSpatialAudioFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_SetDefaultSpatialAudioFormatAsync(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetDefaultSpatialAudioFormatAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_ActiveSpatialAudioFormat(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActiveSpatialAudioFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_DefaultSpatialAudioFormat(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DefaultSpatialAudioFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_DeviceId(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_get_IsSpatialAudioSupported(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSpatialAudioSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_add_ConfigurationChanged(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ConfigurationChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioDeviceConfiguration_remove_ConfigurationChanged(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConfigurationChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpatialAudioDeviceConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioDeviceConfiguration[] = {
        { "get_for_device_id", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_GetForDeviceId), METH_VARARGS | METH_STATIC, nullptr },
        { "is_spatial_audio_format_supported", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_IsSpatialAudioFormatSupported), METH_VARARGS, nullptr },
        { "set_default_spatial_audio_format_async", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_SetDefaultSpatialAudioFormatAsync), METH_VARARGS, nullptr },
        { "add_configuration_changed", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_add_ConfigurationChanged), METH_O, nullptr },
        { "remove_configuration_changed", reinterpret_cast<PyCFunction>(SpatialAudioDeviceConfiguration_remove_ConfigurationChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialAudioDeviceConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialAudioDeviceConfiguration[] = {
        { "active_spatial_audio_format", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_ActiveSpatialAudioFormat), nullptr, nullptr, nullptr },
        { "default_spatial_audio_format", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_DefaultSpatialAudioFormat), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_spatial_audio_supported", reinterpret_cast<getter>(SpatialAudioDeviceConfiguration_get_IsSpatialAudioSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialAudioDeviceConfiguration[] = 
    {
        { Py_tp_new, _new_SpatialAudioDeviceConfiguration },
        { Py_tp_dealloc, _dealloc_SpatialAudioDeviceConfiguration },
        { Py_tp_methods, _methods_SpatialAudioDeviceConfiguration },
        { Py_tp_getset, _getset_SpatialAudioDeviceConfiguration },
        { },
    };

    static PyType_Spec _type_spec_SpatialAudioDeviceConfiguration =
    {
        "_winsdk_Windows_Media_Audio.SpatialAudioDeviceConfiguration",
        sizeof(py::wrapper::Windows::Media::Audio::SpatialAudioDeviceConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioDeviceConfiguration
    };

    // ----- SpatialAudioFormatConfiguration class --------------------
    constexpr const char* const _type_name_SpatialAudioFormatConfiguration = "SpatialAudioFormatConfiguration";

    static PyObject* _new_SpatialAudioFormatConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpatialAudioFormatConfiguration);
        return nullptr;
    }

    static void _dealloc_SpatialAudioFormatConfiguration(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpatialAudioFormatConfiguration_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_ReportConfigurationChangedAsync(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ReportConfigurationChangedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_ReportLicenseChangedAsync(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ReportLicenseChangedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatConfiguration_get_MixedRealityExclusiveModePolicy(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MixedRealityExclusiveModePolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpatialAudioFormatConfiguration_put_MixedRealityExclusiveModePolicy(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::MixedRealitySpatialAudioFormatPolicy>(arg);

            self->obj.MixedRealityExclusiveModePolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_SpatialAudioFormatConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioFormatConfiguration[] = {
        { "get_default", reinterpret_cast<PyCFunction>(SpatialAudioFormatConfiguration_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "report_configuration_changed_async", reinterpret_cast<PyCFunction>(SpatialAudioFormatConfiguration_ReportConfigurationChangedAsync), METH_VARARGS, nullptr },
        { "report_license_changed_async", reinterpret_cast<PyCFunction>(SpatialAudioFormatConfiguration_ReportLicenseChangedAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpatialAudioFormatConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialAudioFormatConfiguration[] = {
        { "mixed_reality_exclusive_mode_policy", reinterpret_cast<getter>(SpatialAudioFormatConfiguration_get_MixedRealityExclusiveModePolicy), reinterpret_cast<setter>(SpatialAudioFormatConfiguration_put_MixedRealityExclusiveModePolicy), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpatialAudioFormatConfiguration[] = 
    {
        { Py_tp_new, _new_SpatialAudioFormatConfiguration },
        { Py_tp_dealloc, _dealloc_SpatialAudioFormatConfiguration },
        { Py_tp_methods, _methods_SpatialAudioFormatConfiguration },
        { Py_tp_getset, _getset_SpatialAudioFormatConfiguration },
        { },
    };

    static PyType_Spec _type_spec_SpatialAudioFormatConfiguration =
    {
        "_winsdk_Windows_Media_Audio.SpatialAudioFormatConfiguration",
        sizeof(py::wrapper::Windows::Media::Audio::SpatialAudioFormatConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioFormatConfiguration
    };

    // ----- SpatialAudioFormatSubtype class --------------------
    constexpr const char* const _type_name_SpatialAudioFormatSubtype = "SpatialAudioFormatSubtype";

    static PyObject* _new_SpatialAudioFormatSubtype(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpatialAudioFormatSubtype);
        return nullptr;
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSHeadphoneX(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSHeadphoneX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSXUltra(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSXUltra());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForHeadphones(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForHeadphones());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForHomeTheater(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForHomeTheater());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DolbyAtmosForSpeakers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DolbyAtmosForSpeakers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_WindowsSonic(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::WindowsSonic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpatialAudioFormatSubtype_get_DTSXForHomeTheater(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Audio::SpatialAudioFormatSubtype::DTSXForHomeTheater());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpatialAudioFormatSubtype[] = {
        { "get_d_t_s_headphone_x", reinterpret_cast<PyCFunction>(SpatialAudioFormatSubtype_get_DTSHeadphoneX), METH_NOARGS | METH_STATIC, nullptr },
        { "get_d_t_s_x_ultra", reinterpret_cast<PyCFunction>(SpatialAudioFormatSubtype_get_DTSXUltra), METH_NOARGS | METH_STATIC, nullptr },
        { "get_dolby_atmos_for_headphones", reinterpret_cast<PyCFunction>(SpatialAudioFormatSubtype_get_DolbyAtmosForHeadphones), METH_NOARGS | METH_STATIC, nullptr },
        { "get_dolby_atmos_for_home_theater", reinterpret_cast<PyCFunction>(SpatialAudioFormatSubtype_get_DolbyAtmosForHomeTheater), METH_NOARGS | METH_STATIC, nullptr },
        { "get_dolby_atmos_for_speakers", reinterpret_cast<PyCFunction>(SpatialAudioFormatSubtype_get_DolbyAtmosForSpeakers), METH_NOARGS | METH_STATIC, nullptr },
        { "get_windows_sonic", reinterpret_cast<PyCFunction>(SpatialAudioFormatSubtype_get_WindowsSonic), METH_NOARGS | METH_STATIC, nullptr },
        { "get_d_t_s_x_for_home_theater", reinterpret_cast<PyCFunction>(SpatialAudioFormatSubtype_get_DTSXForHomeTheater), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpatialAudioFormatSubtype[] = {
        { }
    };

    static PyType_Slot _type_slots_SpatialAudioFormatSubtype[] = 
    {
        { Py_tp_new, _new_SpatialAudioFormatSubtype },
        { Py_tp_methods, _methods_SpatialAudioFormatSubtype },
        { Py_tp_getset, _getset_SpatialAudioFormatSubtype },
        { },
    };

    static PyType_Spec _type_spec_SpatialAudioFormatSubtype =
    {
        "_winsdk_Windows_Media_Audio.SpatialAudioFormatSubtype",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpatialAudioFormatSubtype
    };

    // ----- IAudioInputNode interface --------------------
    constexpr const char* const _type_name_IAudioInputNode = "IAudioInputNode";

    static PyObject* _new_IAudioInputNode(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAudioInputNode);
        return nullptr;
    }

    static void _dealloc_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IAudioInputNode_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Close(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Reset(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Start(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_Stop(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IAudioInputNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioInputNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IAudioInputNode(py::wrapper::Windows::Media::Audio::IAudioInputNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioInputNode[] = {
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioInputNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioInputNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioInputNode_Stop), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAudioInputNode_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioInputNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioInputNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IAudioInputNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioInputNode[] = {
        { "outgoing_connections", reinterpret_cast<getter>(IAudioInputNode_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(IAudioInputNode_get_ConsumeInput), reinterpret_cast<setter>(IAudioInputNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioInputNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioInputNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioInputNode_get_OutgoingGain), reinterpret_cast<setter>(IAudioInputNode_put_OutgoingGain), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioInputNode[] = 
    {
        { Py_tp_new, _new_IAudioInputNode },
        { Py_tp_dealloc, _dealloc_IAudioInputNode },
        { Py_tp_methods, _methods_IAudioInputNode },
        { Py_tp_getset, _getset_IAudioInputNode },
        { },
    };

    static PyType_Spec _type_spec_IAudioInputNode =
    {
        "_winsdk_Windows_Media_Audio.IAudioInputNode",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioInputNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioInputNode
    };

    // ----- IAudioInputNode2 interface --------------------
    constexpr const char* const _type_name_IAudioInputNode2 = "IAudioInputNode2";

    static PyObject* _new_IAudioInputNode2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAudioInputNode2);
        return nullptr;
    }

    static void _dealloc_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IAudioInputNode2_AddOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.AddOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddOutgoingConnection(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Close(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_RemoveOutgoingConnection(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::IAudioNode>(args, 0);

                self->obj.RemoveOutgoingConnection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Reset(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Start(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_Stop(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_Emitter(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Emitter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode2_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode2_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioInputNode2_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioInputNode2_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioInputNode2_get_OutgoingConnections(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingConnections());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IAudioInputNode2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioInputNode2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IAudioInputNode2(py::wrapper::Windows::Media::Audio::IAudioInputNode2* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioInputNode2[] = {
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode2_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioInputNode2_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioInputNode2_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioInputNode2_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioInputNode2_Stop), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAudioInputNode2_Close), METH_VARARGS, nullptr },
        { "add_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode2_AddOutgoingConnection), METH_VARARGS, nullptr },
        { "remove_outgoing_connection", reinterpret_cast<PyCFunction>(IAudioInputNode2_RemoveOutgoingConnection), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioInputNode2), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioInputNode2), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IAudioInputNode2), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioInputNode2[] = {
        { "emitter", reinterpret_cast<getter>(IAudioInputNode2_get_Emitter), nullptr, nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(IAudioInputNode2_get_ConsumeInput), reinterpret_cast<setter>(IAudioInputNode2_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioInputNode2_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioInputNode2_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioInputNode2_get_OutgoingGain), reinterpret_cast<setter>(IAudioInputNode2_put_OutgoingGain), nullptr, nullptr },
        { "outgoing_connections", reinterpret_cast<getter>(IAudioInputNode2_get_OutgoingConnections), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioInputNode2[] = 
    {
        { Py_tp_new, _new_IAudioInputNode2 },
        { Py_tp_dealloc, _dealloc_IAudioInputNode2 },
        { Py_tp_methods, _methods_IAudioInputNode2 },
        { Py_tp_getset, _getset_IAudioInputNode2 },
        { },
    };

    static PyType_Spec _type_spec_IAudioInputNode2 =
    {
        "_winsdk_Windows_Media_Audio.IAudioInputNode2",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioInputNode2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioInputNode2
    };

    // ----- IAudioNode interface --------------------
    constexpr const char* const _type_name_IAudioNode = "IAudioNode";

    static PyObject* _new_IAudioNode(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAudioNode);
        return nullptr;
    }

    static void _dealloc_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IAudioNode_Close(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Reset(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Start(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_Stop(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNode_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNode_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNode_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNode_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNode* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IAudioNode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioNode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IAudioNode(py::wrapper::Windows::Media::Audio::IAudioNode* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioNode[] = {
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNode_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNode_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioNode_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioNode_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioNode_Stop), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IAudioNode_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioNode), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioNode), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IAudioNode), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioNode[] = {
        { "consume_input", reinterpret_cast<getter>(IAudioNode_get_ConsumeInput), reinterpret_cast<setter>(IAudioNode_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioNode_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioNode_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioNode_get_OutgoingGain), reinterpret_cast<setter>(IAudioNode_put_OutgoingGain), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioNode[] = 
    {
        { Py_tp_new, _new_IAudioNode },
        { Py_tp_dealloc, _dealloc_IAudioNode },
        { Py_tp_methods, _methods_IAudioNode },
        { Py_tp_getset, _getset_IAudioNode },
        { },
    };

    static PyType_Spec _type_spec_IAudioNode =
    {
        "_winsdk_Windows_Media_Audio.IAudioNode",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioNode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioNode
    };

    // ----- IAudioNodeWithListener interface --------------------
    constexpr const char* const _type_name_IAudioNodeWithListener = "IAudioNodeWithListener";

    static PyObject* _new_IAudioNodeWithListener(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAudioNodeWithListener);
        return nullptr;
    }

    static void _dealloc_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IAudioNodeWithListener_Close(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_DisableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.DisableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_EnableEffectsByDefinition(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                self->obj.EnableEffectsByDefinition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Reset(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Start(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_Stop(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_Listener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Listener());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_Listener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioNodeListener>(arg);

            self->obj.Listener(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNodeWithListener_get_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConsumeInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_ConsumeInput(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ConsumeInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAudioNodeWithListener_get_EffectDefinitions(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_EncodingProperties(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioNodeWithListener_get_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutgoingGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAudioNodeWithListener_put_OutgoingGain(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.OutgoingGain(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IAudioNodeWithListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Audio::IAudioNodeWithListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IAudioNodeWithListener(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioNodeWithListener[] = {
        { "close", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Close), METH_VARARGS, nullptr },
        { "disable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_DisableEffectsByDefinition), METH_VARARGS, nullptr },
        { "enable_effects_by_definition", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_EnableEffectsByDefinition), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Reset), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(IAudioNodeWithListener_Stop), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioNodeWithListener), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IAudioNodeWithListener), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IAudioNodeWithListener), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioNodeWithListener[] = {
        { "listener", reinterpret_cast<getter>(IAudioNodeWithListener_get_Listener), reinterpret_cast<setter>(IAudioNodeWithListener_put_Listener), nullptr, nullptr },
        { "consume_input", reinterpret_cast<getter>(IAudioNodeWithListener_get_ConsumeInput), reinterpret_cast<setter>(IAudioNodeWithListener_put_ConsumeInput), nullptr, nullptr },
        { "effect_definitions", reinterpret_cast<getter>(IAudioNodeWithListener_get_EffectDefinitions), nullptr, nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(IAudioNodeWithListener_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "outgoing_gain", reinterpret_cast<getter>(IAudioNodeWithListener_get_OutgoingGain), reinterpret_cast<setter>(IAudioNodeWithListener_put_OutgoingGain), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioNodeWithListener[] = 
    {
        { Py_tp_new, _new_IAudioNodeWithListener },
        { Py_tp_dealloc, _dealloc_IAudioNodeWithListener },
        { Py_tp_methods, _methods_IAudioNodeWithListener },
        { Py_tp_getset, _getset_IAudioNodeWithListener },
        { },
    };

    static PyType_Spec _type_spec_IAudioNodeWithListener =
    {
        "_winsdk_Windows_Media_Audio.IAudioNodeWithListener",
        sizeof(py::wrapper::Windows::Media::Audio::IAudioNodeWithListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioNodeWithListener
    };

    // ----- Windows.Media.Audio Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Media::Audio::AudioDeviceInputNode>::python_type = py::register_python_type(module, _type_name_AudioDeviceInputNode, &_type_spec_AudioDeviceInputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioDeviceOutputNode>::python_type = py::register_python_type(module, _type_name_AudioDeviceOutputNode, &_type_spec_AudioDeviceOutputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioFileInputNode>::python_type = py::register_python_type(module, _type_name_AudioFileInputNode, &_type_spec_AudioFileInputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioFileOutputNode>::python_type = py::register_python_type(module, _type_name_AudioFileOutputNode, &_type_spec_AudioFileOutputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioFrameCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_AudioFrameCompletedEventArgs, &_type_spec_AudioFrameCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioFrameInputNode>::python_type = py::register_python_type(module, _type_name_AudioFrameInputNode, &_type_spec_AudioFrameInputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioFrameOutputNode>::python_type = py::register_python_type(module, _type_name_AudioFrameOutputNode, &_type_spec_AudioFrameOutputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioGraph>::python_type = py::register_python_type(module, _type_name_AudioGraph, &_type_spec_AudioGraph, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioGraphBatchUpdater>::python_type = py::register_python_type(module, _type_name_AudioGraphBatchUpdater, &_type_spec_AudioGraphBatchUpdater, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioGraphConnection>::python_type = py::register_python_type(module, _type_name_AudioGraphConnection, &_type_spec_AudioGraphConnection, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioGraphSettings>::python_type = py::register_python_type(module, _type_name_AudioGraphSettings, &_type_spec_AudioGraphSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioGraphUnrecoverableErrorOccurredEventArgs>::python_type = py::register_python_type(module, _type_name_AudioGraphUnrecoverableErrorOccurredEventArgs, &_type_spec_AudioGraphUnrecoverableErrorOccurredEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitter>::python_type = py::register_python_type(module, _type_name_AudioNodeEmitter, &_type_spec_AudioNodeEmitter, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterConeProperties>::python_type = py::register_python_type(module, _type_name_AudioNodeEmitterConeProperties, &_type_spec_AudioNodeEmitterConeProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterDecayModel>::python_type = py::register_python_type(module, _type_name_AudioNodeEmitterDecayModel, &_type_spec_AudioNodeEmitterDecayModel, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterNaturalDecayModelProperties>::python_type = py::register_python_type(module, _type_name_AudioNodeEmitterNaturalDecayModelProperties, &_type_spec_AudioNodeEmitterNaturalDecayModelProperties, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioNodeEmitterShape>::python_type = py::register_python_type(module, _type_name_AudioNodeEmitterShape, &_type_spec_AudioNodeEmitterShape, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioNodeListener>::python_type = py::register_python_type(module, _type_name_AudioNodeListener, &_type_spec_AudioNodeListener, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioPlaybackConnection>::python_type = py::register_python_type(module, _type_name_AudioPlaybackConnection, &_type_spec_AudioPlaybackConnection, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioPlaybackConnectionOpenResult>::python_type = py::register_python_type(module, _type_name_AudioPlaybackConnectionOpenResult, &_type_spec_AudioPlaybackConnectionOpenResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioStateMonitor>::python_type = py::register_python_type(module, _type_name_AudioStateMonitor, &_type_spec_AudioStateMonitor, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::AudioSubmixNode>::python_type = py::register_python_type(module, _type_name_AudioSubmixNode, &_type_spec_AudioSubmixNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::CreateAudioDeviceInputNodeResult>::python_type = py::register_python_type(module, _type_name_CreateAudioDeviceInputNodeResult, &_type_spec_CreateAudioDeviceInputNodeResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::CreateAudioDeviceOutputNodeResult>::python_type = py::register_python_type(module, _type_name_CreateAudioDeviceOutputNodeResult, &_type_spec_CreateAudioDeviceOutputNodeResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::CreateAudioFileInputNodeResult>::python_type = py::register_python_type(module, _type_name_CreateAudioFileInputNodeResult, &_type_spec_CreateAudioFileInputNodeResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::CreateAudioFileOutputNodeResult>::python_type = py::register_python_type(module, _type_name_CreateAudioFileOutputNodeResult, &_type_spec_CreateAudioFileOutputNodeResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::CreateAudioGraphResult>::python_type = py::register_python_type(module, _type_name_CreateAudioGraphResult, &_type_spec_CreateAudioGraphResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::CreateMediaSourceAudioInputNodeResult>::python_type = py::register_python_type(module, _type_name_CreateMediaSourceAudioInputNodeResult, &_type_spec_CreateMediaSourceAudioInputNodeResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::EchoEffectDefinition>::python_type = py::register_python_type(module, _type_name_EchoEffectDefinition, &_type_spec_EchoEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::EqualizerBand>::python_type = py::register_python_type(module, _type_name_EqualizerBand, &_type_spec_EqualizerBand, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::EqualizerEffectDefinition>::python_type = py::register_python_type(module, _type_name_EqualizerEffectDefinition, &_type_spec_EqualizerEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::FrameInputNodeQuantumStartedEventArgs>::python_type = py::register_python_type(module, _type_name_FrameInputNodeQuantumStartedEventArgs, &_type_spec_FrameInputNodeQuantumStartedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::LimiterEffectDefinition>::python_type = py::register_python_type(module, _type_name_LimiterEffectDefinition, &_type_spec_LimiterEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::MediaSourceAudioInputNode>::python_type = py::register_python_type(module, _type_name_MediaSourceAudioInputNode, &_type_spec_MediaSourceAudioInputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::ReverbEffectDefinition>::python_type = py::register_python_type(module, _type_name_ReverbEffectDefinition, &_type_spec_ReverbEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::SetDefaultSpatialAudioFormatResult>::python_type = py::register_python_type(module, _type_name_SetDefaultSpatialAudioFormatResult, &_type_spec_SetDefaultSpatialAudioFormatResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioDeviceConfiguration>::python_type = py::register_python_type(module, _type_name_SpatialAudioDeviceConfiguration, &_type_spec_SpatialAudioDeviceConfiguration, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioFormatConfiguration>::python_type = py::register_python_type(module, _type_name_SpatialAudioFormatConfiguration, &_type_spec_SpatialAudioFormatConfiguration, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::SpatialAudioFormatSubtype>::python_type = py::register_python_type(module, _type_name_SpatialAudioFormatSubtype, &_type_spec_SpatialAudioFormatSubtype, nullptr);
            py::winrt_type<winrt::Windows::Media::Audio::IAudioInputNode>::python_type = py::register_python_type(module, _type_name_IAudioInputNode, &_type_spec_IAudioInputNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::IAudioInputNode2>::python_type = py::register_python_type(module, _type_name_IAudioInputNode2, &_type_spec_IAudioInputNode2, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::IAudioNode>::python_type = py::register_python_type(module, _type_name_IAudioNode, &_type_spec_IAudioNode, bases.get());
            py::winrt_type<winrt::Windows::Media::Audio::IAudioNodeWithListener>::python_type = py::register_python_type(module, _type_name_IAudioNodeWithListener, &_type_spec_IAudioNodeWithListener, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Media.Audio");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_Audio",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Media::Audio

PyMODINIT_FUNC
PyInit__winsdk_Windows_Media_Audio (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::Audio::module_def);
}
