// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Devices.Geolocation.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::CivicAddress>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeoboundingBox>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geocircle>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geocoordinate>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geolocator>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geopath>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geopoint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geoposition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::Geovisit>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitMonitor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::VenueData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::IGeoshape>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>::python_type;

PyObject* py::converter<winrt::Windows::Devices::Geolocation::BasicGeoposition>::convert(winrt::Windows::Devices::Geolocation::BasicGeoposition instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>());
}
winrt::Windows::Devices::Geolocation::BasicGeoposition py::converter<winrt::Windows::Devices::Geolocation::BasicGeoposition>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Geolocation::BasicGeoposition>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Devices::Geolocation::BasicGeoposition return_value{};

    PyObject* py_Latitude = PyDict_GetItemString(obj, "latitude");
    if (!py_Latitude) { throw winrt::hresult_invalid_argument(); }
    return_value.Latitude = converter<double>::convert_to(py_Latitude);

    PyObject* py_Longitude = PyDict_GetItemString(obj, "longitude");
    if (!py_Longitude) { throw winrt::hresult_invalid_argument(); }
    return_value.Longitude = converter<double>::convert_to(py_Longitude);

    PyObject* py_Altitude = PyDict_GetItemString(obj, "altitude");
    if (!py_Altitude) { throw winrt::hresult_invalid_argument(); }
    return_value.Altitude = converter<double>::convert_to(py_Altitude);

    return return_value;
}

namespace py::cpp::Windows::Devices::Geolocation
{
    // ----- CivicAddress class --------------------
    constexpr const char* const _type_name_CivicAddress = "CivicAddress";

    static PyObject* _new_CivicAddress(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CivicAddress);
        return nullptr;
    }

    static void _dealloc_CivicAddress(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CivicAddress_get_City(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.City());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CivicAddress_get_Country(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Country());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CivicAddress_get_PostalCode(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PostalCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CivicAddress_get_State(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CivicAddress_get_Timestamp(py::wrapper::Windows::Devices::Geolocation::CivicAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CivicAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::CivicAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CivicAddress[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CivicAddress), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CivicAddress[] = {
        { "city", reinterpret_cast<getter>(CivicAddress_get_City), nullptr, nullptr, nullptr },
        { "country", reinterpret_cast<getter>(CivicAddress_get_Country), nullptr, nullptr, nullptr },
        { "postal_code", reinterpret_cast<getter>(CivicAddress_get_PostalCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(CivicAddress_get_State), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(CivicAddress_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CivicAddress[] = 
    {
        { Py_tp_new, _new_CivicAddress },
        { Py_tp_dealloc, _dealloc_CivicAddress },
        { Py_tp_methods, _methods_CivicAddress },
        { Py_tp_getset, _getset_CivicAddress },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CivicAddress =
    {
        "_winsdk_Windows_Devices_Geolocation.CivicAddress",
        sizeof(py::wrapper::Windows::Devices::Geolocation::CivicAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CivicAddress
    };

    // ----- GeoboundingBox class --------------------
    constexpr const char* const _type_name_GeoboundingBox = "GeoboundingBox";

    static PyObject* _new_GeoboundingBox(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);

                winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);

                winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                winrt::Windows::Devices::Geolocation::GeoboundingBox instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GeoboundingBox(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GeoboundingBox_TryCompute(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);

                return py::convert(winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);

                return py::convert(winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Devices::Geolocation::GeoboundingBox::TryCompute(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_Center(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Center());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_MaxAltitude(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxAltitude());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_MinAltitude(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinAltitude());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_NorthwestCorner(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NorthwestCorner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_SoutheastCorner(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SoutheastCorner());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AltitudeReferenceSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GeoshapeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeoboundingBox_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpatialReferenceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GeoboundingBox(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeoboundingBox>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeoboundingBox[] = {
        { "try_compute", reinterpret_cast<PyCFunction>(GeoboundingBox_TryCompute), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeoboundingBox), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeoboundingBox[] = {
        { "center", reinterpret_cast<getter>(GeoboundingBox_get_Center), nullptr, nullptr, nullptr },
        { "max_altitude", reinterpret_cast<getter>(GeoboundingBox_get_MaxAltitude), nullptr, nullptr, nullptr },
        { "min_altitude", reinterpret_cast<getter>(GeoboundingBox_get_MinAltitude), nullptr, nullptr, nullptr },
        { "northwest_corner", reinterpret_cast<getter>(GeoboundingBox_get_NorthwestCorner), nullptr, nullptr, nullptr },
        { "southeast_corner", reinterpret_cast<getter>(GeoboundingBox_get_SoutheastCorner), nullptr, nullptr, nullptr },
        { "altitude_reference_system", reinterpret_cast<getter>(GeoboundingBox_get_AltitudeReferenceSystem), nullptr, nullptr, nullptr },
        { "geoshape_type", reinterpret_cast<getter>(GeoboundingBox_get_GeoshapeType), nullptr, nullptr, nullptr },
        { "spatial_reference_id", reinterpret_cast<getter>(GeoboundingBox_get_SpatialReferenceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GeoboundingBox[] = 
    {
        { Py_tp_new, _new_GeoboundingBox },
        { Py_tp_dealloc, _dealloc_GeoboundingBox },
        { Py_tp_methods, _methods_GeoboundingBox },
        { Py_tp_getset, _getset_GeoboundingBox },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GeoboundingBox =
    {
        "_winsdk_Windows_Devices_Geolocation.GeoboundingBox",
        sizeof(py::wrapper::Windows::Devices::Geolocation::GeoboundingBox),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeoboundingBox
    };

    // ----- Geocircle class --------------------
    constexpr const char* const _type_name_Geocircle = "Geocircle";

    static PyObject* _new_Geocircle(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);

                winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                winrt::Windows::Devices::Geolocation::Geocircle instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Geocircle(py::wrapper::Windows::Devices::Geolocation::Geocircle* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Geocircle_get_Center(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Center());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocircle_get_Radius(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Radius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocircle_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AltitudeReferenceSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocircle_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GeoshapeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocircle_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::Geocircle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpatialReferenceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Geocircle(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geocircle>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geocircle[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_Geocircle), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Geocircle[] = {
        { "center", reinterpret_cast<getter>(Geocircle_get_Center), nullptr, nullptr, nullptr },
        { "radius", reinterpret_cast<getter>(Geocircle_get_Radius), nullptr, nullptr, nullptr },
        { "altitude_reference_system", reinterpret_cast<getter>(Geocircle_get_AltitudeReferenceSystem), nullptr, nullptr, nullptr },
        { "geoshape_type", reinterpret_cast<getter>(Geocircle_get_GeoshapeType), nullptr, nullptr, nullptr },
        { "spatial_reference_id", reinterpret_cast<getter>(Geocircle_get_SpatialReferenceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Geocircle[] = 
    {
        { Py_tp_new, _new_Geocircle },
        { Py_tp_dealloc, _dealloc_Geocircle },
        { Py_tp_methods, _methods_Geocircle },
        { Py_tp_getset, _getset_Geocircle },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Geocircle =
    {
        "_winsdk_Windows_Devices_Geolocation.Geocircle",
        sizeof(py::wrapper::Windows::Devices::Geolocation::Geocircle),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geocircle
    };

    // ----- Geocoordinate class --------------------
    constexpr const char* const _type_name_Geocoordinate = "Geocoordinate";

    static PyObject* _new_Geocoordinate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Geocoordinate);
        return nullptr;
    }

    static void _dealloc_Geocoordinate(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Geocoordinate_get_Accuracy(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Accuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_Altitude(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Altitude());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_AltitudeAccuracy(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AltitudeAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_Heading(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Heading());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_Latitude(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Latitude());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_Longitude(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Longitude());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_Speed(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Speed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_Timestamp(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_Point(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Point());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_PositionSource(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_SatelliteData(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SatelliteData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_PositionSourceTimestamp(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionSourceTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geocoordinate_get_IsRemoteSource(py::wrapper::Windows::Devices::Geolocation::Geocoordinate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRemoteSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Geocoordinate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geocoordinate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geocoordinate[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_Geocoordinate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Geocoordinate[] = {
        { "accuracy", reinterpret_cast<getter>(Geocoordinate_get_Accuracy), nullptr, nullptr, nullptr },
        { "altitude", reinterpret_cast<getter>(Geocoordinate_get_Altitude), nullptr, nullptr, nullptr },
        { "altitude_accuracy", reinterpret_cast<getter>(Geocoordinate_get_AltitudeAccuracy), nullptr, nullptr, nullptr },
        { "heading", reinterpret_cast<getter>(Geocoordinate_get_Heading), nullptr, nullptr, nullptr },
        { "latitude", reinterpret_cast<getter>(Geocoordinate_get_Latitude), nullptr, nullptr, nullptr },
        { "longitude", reinterpret_cast<getter>(Geocoordinate_get_Longitude), nullptr, nullptr, nullptr },
        { "speed", reinterpret_cast<getter>(Geocoordinate_get_Speed), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(Geocoordinate_get_Timestamp), nullptr, nullptr, nullptr },
        { "point", reinterpret_cast<getter>(Geocoordinate_get_Point), nullptr, nullptr, nullptr },
        { "position_source", reinterpret_cast<getter>(Geocoordinate_get_PositionSource), nullptr, nullptr, nullptr },
        { "satellite_data", reinterpret_cast<getter>(Geocoordinate_get_SatelliteData), nullptr, nullptr, nullptr },
        { "position_source_timestamp", reinterpret_cast<getter>(Geocoordinate_get_PositionSourceTimestamp), nullptr, nullptr, nullptr },
        { "is_remote_source", reinterpret_cast<getter>(Geocoordinate_get_IsRemoteSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Geocoordinate[] = 
    {
        { Py_tp_new, _new_Geocoordinate },
        { Py_tp_dealloc, _dealloc_Geocoordinate },
        { Py_tp_methods, _methods_Geocoordinate },
        { Py_tp_getset, _getset_Geocoordinate },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Geocoordinate =
    {
        "_winsdk_Windows_Devices_Geolocation.Geocoordinate",
        sizeof(py::wrapper::Windows::Devices::Geolocation::Geocoordinate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geocoordinate
    };

    // ----- GeocoordinateSatelliteData class --------------------
    constexpr const char* const _type_name_GeocoordinateSatelliteData = "GeocoordinateSatelliteData";

    static PyObject* _new_GeocoordinateSatelliteData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GeocoordinateSatelliteData);
        return nullptr;
    }

    static void _dealloc_GeocoordinateSatelliteData(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GeocoordinateSatelliteData_get_HorizontalDilutionOfPrecision(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HorizontalDilutionOfPrecision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeocoordinateSatelliteData_get_PositionDilutionOfPrecision(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionDilutionOfPrecision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeocoordinateSatelliteData_get_VerticalDilutionOfPrecision(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VerticalDilutionOfPrecision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeocoordinateSatelliteData_get_GeometricDilutionOfPrecision(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GeometricDilutionOfPrecision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeocoordinateSatelliteData_get_TimeDilutionOfPrecision(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeDilutionOfPrecision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GeocoordinateSatelliteData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeocoordinateSatelliteData[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_GeocoordinateSatelliteData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeocoordinateSatelliteData[] = {
        { "horizontal_dilution_of_precision", reinterpret_cast<getter>(GeocoordinateSatelliteData_get_HorizontalDilutionOfPrecision), nullptr, nullptr, nullptr },
        { "position_dilution_of_precision", reinterpret_cast<getter>(GeocoordinateSatelliteData_get_PositionDilutionOfPrecision), nullptr, nullptr, nullptr },
        { "vertical_dilution_of_precision", reinterpret_cast<getter>(GeocoordinateSatelliteData_get_VerticalDilutionOfPrecision), nullptr, nullptr, nullptr },
        { "geometric_dilution_of_precision", reinterpret_cast<getter>(GeocoordinateSatelliteData_get_GeometricDilutionOfPrecision), nullptr, nullptr, nullptr },
        { "time_dilution_of_precision", reinterpret_cast<getter>(GeocoordinateSatelliteData_get_TimeDilutionOfPrecision), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GeocoordinateSatelliteData[] = 
    {
        { Py_tp_new, _new_GeocoordinateSatelliteData },
        { Py_tp_dealloc, _dealloc_GeocoordinateSatelliteData },
        { Py_tp_methods, _methods_GeocoordinateSatelliteData },
        { Py_tp_getset, _getset_GeocoordinateSatelliteData },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GeocoordinateSatelliteData =
    {
        "_winsdk_Windows_Devices_Geolocation.GeocoordinateSatelliteData",
        sizeof(py::wrapper::Windows::Devices::Geolocation::GeocoordinateSatelliteData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeocoordinateSatelliteData
    };

    // ----- Geolocator class --------------------
    constexpr const char* const _type_name_Geolocator = "Geolocator";

    static PyObject* _new_Geolocator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Geolocation::Geolocator instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Geolocator(py::wrapper::Windows::Devices::Geolocation::Geolocator* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Geolocator_AllowFallbackToConsentlessPositions(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.AllowFallbackToConsentlessPositions();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Geolocator_GetGeopositionAsync(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetGeopositionAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.GetGeopositionAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Geolocator_GetGeopositionHistoryAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(winrt::Windows::Devices::Geolocation::Geolocator::GetGeopositionHistoryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Devices::Geolocation::Geolocator::GetGeopositionHistoryAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Geolocator_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Geolocation::Geolocator::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Geolocator_get_ReportInterval(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReportInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Geolocator_put_ReportInterval(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ReportInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Geolocator_get_MovementThreshold(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MovementThreshold());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Geolocator_put_MovementThreshold(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.MovementThreshold(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Geolocator_get_DesiredAccuracy(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredAccuracy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Geolocator_put_DesiredAccuracy(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::PositionAccuracy>(arg);

            self->obj.DesiredAccuracy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Geolocator_get_LocationStatus(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geolocator_get_DesiredAccuracyInMeters(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredAccuracyInMeters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Geolocator_put_DesiredAccuracyInMeters(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.DesiredAccuracyInMeters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Geolocator_get_DefaultGeoposition(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Geolocation::Geolocator::DefaultGeoposition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geolocator_put_DefaultGeoposition(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(arg);

            winrt::Windows::Devices::Geolocation::Geolocator::DefaultGeoposition(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geolocator_get_IsDefaultGeopositionRecommended(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Geolocation::Geolocator::IsDefaultGeopositionRecommended());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geolocator_add_PositionChanged(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::Geolocator, winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>>(arg);

            return py::convert(self->obj.PositionChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geolocator_remove_PositionChanged(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PositionChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geolocator_add_StatusChanged(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::Geolocator, winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geolocator_remove_StatusChanged(py::wrapper::Windows::Devices::Geolocation::Geolocator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Geolocator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geolocator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geolocator[] = {
        { "allow_fallback_to_consentless_positions", reinterpret_cast<PyCFunction>(Geolocator_AllowFallbackToConsentlessPositions), METH_VARARGS, nullptr },
        { "get_geoposition_async", reinterpret_cast<PyCFunction>(Geolocator_GetGeopositionAsync), METH_VARARGS, nullptr },
        { "get_geoposition_history_async", reinterpret_cast<PyCFunction>(Geolocator_GetGeopositionHistoryAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(Geolocator_RequestAccessAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_geoposition", reinterpret_cast<PyCFunction>(Geolocator_get_DefaultGeoposition), METH_NOARGS | METH_STATIC, nullptr },
        { "put_default_geoposition", reinterpret_cast<PyCFunction>(Geolocator_put_DefaultGeoposition), METH_O | METH_STATIC, nullptr },
        { "get_is_default_geoposition_recommended", reinterpret_cast<PyCFunction>(Geolocator_get_IsDefaultGeopositionRecommended), METH_NOARGS | METH_STATIC, nullptr },
        { "add_position_changed", reinterpret_cast<PyCFunction>(Geolocator_add_PositionChanged), METH_O, nullptr },
        { "remove_position_changed", reinterpret_cast<PyCFunction>(Geolocator_remove_PositionChanged), METH_O, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(Geolocator_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(Geolocator_remove_StatusChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Geolocator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Geolocator[] = {
        { "report_interval", reinterpret_cast<getter>(Geolocator_get_ReportInterval), reinterpret_cast<setter>(Geolocator_put_ReportInterval), nullptr, nullptr },
        { "movement_threshold", reinterpret_cast<getter>(Geolocator_get_MovementThreshold), reinterpret_cast<setter>(Geolocator_put_MovementThreshold), nullptr, nullptr },
        { "desired_accuracy", reinterpret_cast<getter>(Geolocator_get_DesiredAccuracy), reinterpret_cast<setter>(Geolocator_put_DesiredAccuracy), nullptr, nullptr },
        { "location_status", reinterpret_cast<getter>(Geolocator_get_LocationStatus), nullptr, nullptr, nullptr },
        { "desired_accuracy_in_meters", reinterpret_cast<getter>(Geolocator_get_DesiredAccuracyInMeters), reinterpret_cast<setter>(Geolocator_put_DesiredAccuracyInMeters), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Geolocator[] = 
    {
        { Py_tp_new, _new_Geolocator },
        { Py_tp_dealloc, _dealloc_Geolocator },
        { Py_tp_methods, _methods_Geolocator },
        { Py_tp_getset, _getset_Geolocator },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Geolocator =
    {
        "_winsdk_Windows_Devices_Geolocation.Geolocator",
        sizeof(py::wrapper::Windows::Devices::Geolocation::Geolocator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geolocator
    };

    // ----- Geopath class --------------------
    constexpr const char* const _type_name_Geopath = "Geopath";

    static PyObject* _new_Geopath(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);

                winrt::Windows::Devices::Geolocation::Geopath instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);

                winrt::Windows::Devices::Geolocation::Geopath instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Geolocation::BasicGeoposition>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                winrt::Windows::Devices::Geolocation::Geopath instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Geopath(py::wrapper::Windows::Devices::Geolocation::Geopath* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Geopath_get_Positions(py::wrapper::Windows::Devices::Geolocation::Geopath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Positions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geopath_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::Geopath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AltitudeReferenceSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geopath_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::Geopath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GeoshapeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geopath_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::Geopath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpatialReferenceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Geopath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geopath>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geopath[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_Geopath), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Geopath[] = {
        { "positions", reinterpret_cast<getter>(Geopath_get_Positions), nullptr, nullptr, nullptr },
        { "altitude_reference_system", reinterpret_cast<getter>(Geopath_get_AltitudeReferenceSystem), nullptr, nullptr, nullptr },
        { "geoshape_type", reinterpret_cast<getter>(Geopath_get_GeoshapeType), nullptr, nullptr, nullptr },
        { "spatial_reference_id", reinterpret_cast<getter>(Geopath_get_SpatialReferenceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Geopath[] = 
    {
        { Py_tp_new, _new_Geopath },
        { Py_tp_dealloc, _dealloc_Geopath },
        { Py_tp_methods, _methods_Geopath },
        { Py_tp_getset, _getset_Geopath },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Geopath =
    {
        "_winsdk_Windows_Devices_Geolocation.Geopath",
        sizeof(py::wrapper::Windows::Devices::Geolocation::Geopath),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geopath
    };

    // ----- Geopoint class --------------------
    constexpr const char* const _type_name_Geopoint = "Geopoint";

    static PyObject* _new_Geopoint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);

                winrt::Windows::Devices::Geolocation::Geopoint instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);

                winrt::Windows::Devices::Geolocation::Geopoint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Geolocation::AltitudeReferenceSystem>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                winrt::Windows::Devices::Geolocation::Geopoint instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Geopoint(py::wrapper::Windows::Devices::Geolocation::Geopoint* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Geopoint_get_Position(py::wrapper::Windows::Devices::Geolocation::Geopoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geopoint_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::Geopoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AltitudeReferenceSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geopoint_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::Geopoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GeoshapeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geopoint_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::Geopoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpatialReferenceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Geopoint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geopoint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geopoint[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_Geopoint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Geopoint[] = {
        { "position", reinterpret_cast<getter>(Geopoint_get_Position), nullptr, nullptr, nullptr },
        { "altitude_reference_system", reinterpret_cast<getter>(Geopoint_get_AltitudeReferenceSystem), nullptr, nullptr, nullptr },
        { "geoshape_type", reinterpret_cast<getter>(Geopoint_get_GeoshapeType), nullptr, nullptr, nullptr },
        { "spatial_reference_id", reinterpret_cast<getter>(Geopoint_get_SpatialReferenceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Geopoint[] = 
    {
        { Py_tp_new, _new_Geopoint },
        { Py_tp_dealloc, _dealloc_Geopoint },
        { Py_tp_methods, _methods_Geopoint },
        { Py_tp_getset, _getset_Geopoint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Geopoint =
    {
        "_winsdk_Windows_Devices_Geolocation.Geopoint",
        sizeof(py::wrapper::Windows::Devices::Geolocation::Geopoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geopoint
    };

    // ----- Geoposition class --------------------
    constexpr const char* const _type_name_Geoposition = "Geoposition";

    static PyObject* _new_Geoposition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Geoposition);
        return nullptr;
    }

    static void _dealloc_Geoposition(py::wrapper::Windows::Devices::Geolocation::Geoposition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Geoposition_get_CivicAddress(py::wrapper::Windows::Devices::Geolocation::Geoposition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CivicAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geoposition_get_Coordinate(py::wrapper::Windows::Devices::Geolocation::Geoposition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Coordinate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geoposition_get_VenueData(py::wrapper::Windows::Devices::Geolocation::Geoposition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VenueData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Geoposition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geoposition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geoposition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_Geoposition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Geoposition[] = {
        { "civic_address", reinterpret_cast<getter>(Geoposition_get_CivicAddress), nullptr, nullptr, nullptr },
        { "coordinate", reinterpret_cast<getter>(Geoposition_get_Coordinate), nullptr, nullptr, nullptr },
        { "venue_data", reinterpret_cast<getter>(Geoposition_get_VenueData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Geoposition[] = 
    {
        { Py_tp_new, _new_Geoposition },
        { Py_tp_dealloc, _dealloc_Geoposition },
        { Py_tp_methods, _methods_Geoposition },
        { Py_tp_getset, _getset_Geoposition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Geoposition =
    {
        "_winsdk_Windows_Devices_Geolocation.Geoposition",
        sizeof(py::wrapper::Windows::Devices::Geolocation::Geoposition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geoposition
    };

    // ----- Geovisit class --------------------
    constexpr const char* const _type_name_Geovisit = "Geovisit";

    static PyObject* _new_Geovisit(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Geovisit);
        return nullptr;
    }

    static void _dealloc_Geovisit(py::wrapper::Windows::Devices::Geolocation::Geovisit* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Geovisit_get_Position(py::wrapper::Windows::Devices::Geolocation::Geovisit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geovisit_get_StateChange(py::wrapper::Windows::Devices::Geolocation::Geovisit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StateChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Geovisit_get_Timestamp(py::wrapper::Windows::Devices::Geolocation::Geovisit* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Geovisit(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::Geovisit>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Geovisit[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_Geovisit), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Geovisit[] = {
        { "position", reinterpret_cast<getter>(Geovisit_get_Position), nullptr, nullptr, nullptr },
        { "state_change", reinterpret_cast<getter>(Geovisit_get_StateChange), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(Geovisit_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Geovisit[] = 
    {
        { Py_tp_new, _new_Geovisit },
        { Py_tp_dealloc, _dealloc_Geovisit },
        { Py_tp_methods, _methods_Geovisit },
        { Py_tp_getset, _getset_Geovisit },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Geovisit =
    {
        "_winsdk_Windows_Devices_Geolocation.Geovisit",
        sizeof(py::wrapper::Windows::Devices::Geolocation::Geovisit),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Geovisit
    };

    // ----- GeovisitMonitor class --------------------
    constexpr const char* const _type_name_GeovisitMonitor = "GeovisitMonitor";

    static PyObject* _new_GeovisitMonitor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Geolocation::GeovisitMonitor instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_GeovisitMonitor(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GeovisitMonitor_GetLastReportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Geolocation::GeovisitMonitor::GetLastReportAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeovisitMonitor_Start(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::VisitMonitoringScope>(args, 0);

                self->obj.Start(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeovisitMonitor_Stop(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GeovisitMonitor_get_MonitoringScope(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MonitoringScope());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeovisitMonitor_add_VisitStateChanged(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Geolocation::GeovisitMonitor, winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>>(arg);

            return py::convert(self->obj.VisitStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GeovisitMonitor_remove_VisitStateChanged(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VisitStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GeovisitMonitor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeovisitMonitor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeovisitMonitor[] = {
        { "get_last_report_async", reinterpret_cast<PyCFunction>(GeovisitMonitor_GetLastReportAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "start", reinterpret_cast<PyCFunction>(GeovisitMonitor_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(GeovisitMonitor_Stop), METH_VARARGS, nullptr },
        { "add_visit_state_changed", reinterpret_cast<PyCFunction>(GeovisitMonitor_add_VisitStateChanged), METH_O, nullptr },
        { "remove_visit_state_changed", reinterpret_cast<PyCFunction>(GeovisitMonitor_remove_VisitStateChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeovisitMonitor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeovisitMonitor[] = {
        { "monitoring_scope", reinterpret_cast<getter>(GeovisitMonitor_get_MonitoringScope), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GeovisitMonitor[] = 
    {
        { Py_tp_new, _new_GeovisitMonitor },
        { Py_tp_dealloc, _dealloc_GeovisitMonitor },
        { Py_tp_methods, _methods_GeovisitMonitor },
        { Py_tp_getset, _getset_GeovisitMonitor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GeovisitMonitor =
    {
        "_winsdk_Windows_Devices_Geolocation.GeovisitMonitor",
        sizeof(py::wrapper::Windows::Devices::Geolocation::GeovisitMonitor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeovisitMonitor
    };

    // ----- GeovisitStateChangedEventArgs class --------------------
    constexpr const char* const _type_name_GeovisitStateChangedEventArgs = "GeovisitStateChangedEventArgs";

    static PyObject* _new_GeovisitStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GeovisitStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_GeovisitStateChangedEventArgs(py::wrapper::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GeovisitStateChangedEventArgs_get_Visit(py::wrapper::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Visit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GeovisitStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeovisitStateChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_GeovisitStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeovisitStateChangedEventArgs[] = {
        { "visit", reinterpret_cast<getter>(GeovisitStateChangedEventArgs_get_Visit), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GeovisitStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_GeovisitStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_GeovisitStateChangedEventArgs },
        { Py_tp_methods, _methods_GeovisitStateChangedEventArgs },
        { Py_tp_getset, _getset_GeovisitStateChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GeovisitStateChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Geolocation.GeovisitStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeovisitStateChangedEventArgs
    };

    // ----- GeovisitTriggerDetails class --------------------
    constexpr const char* const _type_name_GeovisitTriggerDetails = "GeovisitTriggerDetails";

    static PyObject* _new_GeovisitTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GeovisitTriggerDetails);
        return nullptr;
    }

    static void _dealloc_GeovisitTriggerDetails(py::wrapper::Windows::Devices::Geolocation::GeovisitTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GeovisitTriggerDetails_ReadReports(py::wrapper::Windows::Devices::Geolocation::GeovisitTriggerDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadReports());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_GeovisitTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GeovisitTriggerDetails[] = {
        { "read_reports", reinterpret_cast<PyCFunction>(GeovisitTriggerDetails_ReadReports), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GeovisitTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GeovisitTriggerDetails[] = {
        { }
    };

    static PyType_Slot _type_slots_GeovisitTriggerDetails[] = 
    {
        { Py_tp_new, _new_GeovisitTriggerDetails },
        { Py_tp_dealloc, _dealloc_GeovisitTriggerDetails },
        { Py_tp_methods, _methods_GeovisitTriggerDetails },
        { Py_tp_getset, _getset_GeovisitTriggerDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GeovisitTriggerDetails =
    {
        "_winsdk_Windows_Devices_Geolocation.GeovisitTriggerDetails",
        sizeof(py::wrapper::Windows::Devices::Geolocation::GeovisitTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GeovisitTriggerDetails
    };

    // ----- PositionChangedEventArgs class --------------------
    constexpr const char* const _type_name_PositionChangedEventArgs = "PositionChangedEventArgs";

    static PyObject* _new_PositionChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PositionChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_PositionChangedEventArgs(py::wrapper::Windows::Devices::Geolocation::PositionChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PositionChangedEventArgs_get_Position(py::wrapper::Windows::Devices::Geolocation::PositionChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PositionChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PositionChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PositionChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PositionChangedEventArgs[] = {
        { "position", reinterpret_cast<getter>(PositionChangedEventArgs_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PositionChangedEventArgs[] = 
    {
        { Py_tp_new, _new_PositionChangedEventArgs },
        { Py_tp_dealloc, _dealloc_PositionChangedEventArgs },
        { Py_tp_methods, _methods_PositionChangedEventArgs },
        { Py_tp_getset, _getset_PositionChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PositionChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Geolocation.PositionChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Geolocation::PositionChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PositionChangedEventArgs
    };

    // ----- StatusChangedEventArgs class --------------------
    constexpr const char* const _type_name_StatusChangedEventArgs = "StatusChangedEventArgs";

    static PyObject* _new_StatusChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StatusChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_StatusChangedEventArgs(py::wrapper::Windows::Devices::Geolocation::StatusChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StatusChangedEventArgs_get_Status(py::wrapper::Windows::Devices::Geolocation::StatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StatusChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StatusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StatusChangedEventArgs[] = {
        { "status", reinterpret_cast<getter>(StatusChangedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StatusChangedEventArgs[] = 
    {
        { Py_tp_new, _new_StatusChangedEventArgs },
        { Py_tp_dealloc, _dealloc_StatusChangedEventArgs },
        { Py_tp_methods, _methods_StatusChangedEventArgs },
        { Py_tp_getset, _getset_StatusChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StatusChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Geolocation.StatusChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Geolocation::StatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StatusChangedEventArgs
    };

    // ----- VenueData class --------------------
    constexpr const char* const _type_name_VenueData = "VenueData";

    static PyObject* _new_VenueData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VenueData);
        return nullptr;
    }

    static void _dealloc_VenueData(py::wrapper::Windows::Devices::Geolocation::VenueData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VenueData_get_Id(py::wrapper::Windows::Devices::Geolocation::VenueData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VenueData_get_Level(py::wrapper::Windows::Devices::Geolocation::VenueData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Level());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VenueData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::VenueData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VenueData[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VenueData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VenueData[] = {
        { "id", reinterpret_cast<getter>(VenueData_get_Id), nullptr, nullptr, nullptr },
        { "level", reinterpret_cast<getter>(VenueData_get_Level), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VenueData[] = 
    {
        { Py_tp_new, _new_VenueData },
        { Py_tp_dealloc, _dealloc_VenueData },
        { Py_tp_methods, _methods_VenueData },
        { Py_tp_getset, _getset_VenueData },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VenueData =
    {
        "_winsdk_Windows_Devices_Geolocation.VenueData",
        sizeof(py::wrapper::Windows::Devices::Geolocation::VenueData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VenueData
    };

    // ----- IGeoshape interface --------------------
    constexpr const char* const _type_name_IGeoshape = "IGeoshape";

    static PyObject* _new_IGeoshape(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IGeoshape);
        return nullptr;
    }

    static void _dealloc_IGeoshape(py::wrapper::Windows::Devices::Geolocation::IGeoshape* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IGeoshape_get_AltitudeReferenceSystem(py::wrapper::Windows::Devices::Geolocation::IGeoshape* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AltitudeReferenceSystem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGeoshape_get_GeoshapeType(py::wrapper::Windows::Devices::Geolocation::IGeoshape* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GeoshapeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGeoshape_get_SpatialReferenceId(py::wrapper::Windows::Devices::Geolocation::IGeoshape* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SpatialReferenceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IGeoshape(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Geolocation::IGeoshape>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGeoshape[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IGeoshape), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGeoshape[] = {
        { "altitude_reference_system", reinterpret_cast<getter>(IGeoshape_get_AltitudeReferenceSystem), nullptr, nullptr, nullptr },
        { "geoshape_type", reinterpret_cast<getter>(IGeoshape_get_GeoshapeType), nullptr, nullptr, nullptr },
        { "spatial_reference_id", reinterpret_cast<getter>(IGeoshape_get_SpatialReferenceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IGeoshape[] = 
    {
        { Py_tp_new, _new_IGeoshape },
        { Py_tp_dealloc, _dealloc_IGeoshape },
        { Py_tp_methods, _methods_IGeoshape },
        { Py_tp_getset, _getset_IGeoshape },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IGeoshape =
    {
        "_winsdk_Windows_Devices_Geolocation.IGeoshape",
        sizeof(py::wrapper::Windows::Devices::Geolocation::IGeoshape),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGeoshape
    };

    // ----- BasicGeoposition struct --------------------
    constexpr const char* const _type_name_BasicGeoposition = "BasicGeoposition";

    PyObject* _new_BasicGeoposition(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::Geolocation::BasicGeoposition return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        double _Latitude{};
        double _Longitude{};
        double _Altitude{};

        static const char* kwlist[] = {"latitude", "longitude", "altitude", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddd", const_cast<char**>(kwlist), &_Latitude, &_Longitude, &_Altitude))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::Geolocation::BasicGeoposition return_value{ _Latitude, _Longitude, _Altitude };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BasicGeoposition(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self)
    {
    }

    static PyObject* BasicGeoposition_get_Latitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Latitude);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BasicGeoposition_set_Latitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Latitude = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BasicGeoposition_get_Longitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Longitude);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BasicGeoposition_set_Longitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Longitude = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BasicGeoposition_get_Altitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Altitude);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BasicGeoposition_set_Altitude(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Altitude = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BasicGeoposition[] = {
        { "latitude", reinterpret_cast<getter>(BasicGeoposition_get_Latitude), reinterpret_cast<setter>(BasicGeoposition_set_Latitude), nullptr, nullptr },
        { "longitude", reinterpret_cast<getter>(BasicGeoposition_get_Longitude), reinterpret_cast<setter>(BasicGeoposition_set_Longitude), nullptr, nullptr },
        { "altitude", reinterpret_cast<getter>(BasicGeoposition_get_Altitude), reinterpret_cast<setter>(BasicGeoposition_set_Altitude), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BasicGeoposition[] = 
    {
        { Py_tp_new, _new_BasicGeoposition },
        { Py_tp_dealloc, _dealloc_BasicGeoposition },
        { Py_tp_getset, _getset_BasicGeoposition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_BasicGeoposition =
    {
        "_winsdk_Windows_Devices_Geolocation.BasicGeoposition",
        sizeof(py::wrapper::Windows::Devices::Geolocation::BasicGeoposition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BasicGeoposition
    };

    // ----- Windows.Devices.Geolocation Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Devices::Geolocation::CivicAddress>::python_type = py::register_python_type(module, _type_name_CivicAddress, &_type_spec_CivicAddress, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::GeoboundingBox>::python_type = py::register_python_type(module, _type_name_GeoboundingBox, &_type_spec_GeoboundingBox, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::Geocircle>::python_type = py::register_python_type(module, _type_name_Geocircle, &_type_spec_Geocircle, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::Geocoordinate>::python_type = py::register_python_type(module, _type_name_Geocoordinate, &_type_spec_Geocoordinate, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::GeocoordinateSatelliteData>::python_type = py::register_python_type(module, _type_name_GeocoordinateSatelliteData, &_type_spec_GeocoordinateSatelliteData, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::Geolocator>::python_type = py::register_python_type(module, _type_name_Geolocator, &_type_spec_Geolocator, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::Geopath>::python_type = py::register_python_type(module, _type_name_Geopath, &_type_spec_Geopath, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::Geopoint>::python_type = py::register_python_type(module, _type_name_Geopoint, &_type_spec_Geopoint, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::Geoposition>::python_type = py::register_python_type(module, _type_name_Geoposition, &_type_spec_Geoposition, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::Geovisit>::python_type = py::register_python_type(module, _type_name_Geovisit, &_type_spec_Geovisit, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitMonitor>::python_type = py::register_python_type(module, _type_name_GeovisitMonitor, &_type_spec_GeovisitMonitor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitStateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_GeovisitStateChangedEventArgs, &_type_spec_GeovisitStateChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::GeovisitTriggerDetails>::python_type = py::register_python_type(module, _type_name_GeovisitTriggerDetails, &_type_spec_GeovisitTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::PositionChangedEventArgs>::python_type = py::register_python_type(module, _type_name_PositionChangedEventArgs, &_type_spec_PositionChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::StatusChangedEventArgs>::python_type = py::register_python_type(module, _type_name_StatusChangedEventArgs, &_type_spec_StatusChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::VenueData>::python_type = py::register_python_type(module, _type_name_VenueData, &_type_spec_VenueData, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::IGeoshape>::python_type = py::register_python_type(module, _type_name_IGeoshape, &_type_spec_IGeoshape, bases.get());
            py::winrt_type<winrt::Windows::Devices::Geolocation::BasicGeoposition>::python_type = py::register_python_type(module, _type_name_BasicGeoposition, &_type_spec_BasicGeoposition, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Devices.Geolocation");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Geolocation",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Devices::Geolocation

PyMODINIT_FUNC
PyInit__winsdk_Windows_Devices_Geolocation (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::Geolocation::module_def);
}
