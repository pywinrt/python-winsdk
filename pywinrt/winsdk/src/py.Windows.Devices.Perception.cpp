// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.6

#include "pybase.h"
#include "py.Windows.Devices.Perception.h"


namespace py::cpp::Windows::Devices::Perception
{
    struct module_state
    {
        PyObject* type_PerceptionFrameSourceAccessStatus;
        PyObject* type_PerceptionFrameSourcePropertyChangeStatus;
        PyTypeObject* type_KnownCameraIntrinsicsProperties;
        PyTypeObject* type_KnownPerceptionColorFrameSourceProperties;
        PyTypeObject* type_KnownPerceptionDepthFrameSourceProperties;
        PyTypeObject* type_KnownPerceptionFrameSourceProperties;
        PyTypeObject* type_KnownPerceptionInfraredFrameSourceProperties;
        PyTypeObject* type_KnownPerceptionVideoFrameSourceProperties;
        PyTypeObject* type_KnownPerceptionVideoProfileProperties;
        PyTypeObject* type_PerceptionColorFrame;
        PyTypeObject* type_PerceptionColorFrameArrivedEventArgs;
        PyTypeObject* type_PerceptionColorFrameReader;
        PyTypeObject* type_PerceptionColorFrameSource;
        PyTypeObject* type_PerceptionColorFrameSourceAddedEventArgs;
        PyTypeObject* type_PerceptionColorFrameSourceRemovedEventArgs;
        PyTypeObject* type_PerceptionColorFrameSourceWatcher;
        PyTypeObject* type_PerceptionControlSession;
        PyTypeObject* type_PerceptionDepthCorrelatedCameraIntrinsics;
        PyTypeObject* type_PerceptionDepthCorrelatedCoordinateMapper;
        PyTypeObject* type_PerceptionDepthFrame;
        PyTypeObject* type_PerceptionDepthFrameArrivedEventArgs;
        PyTypeObject* type_PerceptionDepthFrameReader;
        PyTypeObject* type_PerceptionDepthFrameSource;
        PyTypeObject* type_PerceptionDepthFrameSourceAddedEventArgs;
        PyTypeObject* type_PerceptionDepthFrameSourceRemovedEventArgs;
        PyTypeObject* type_PerceptionDepthFrameSourceWatcher;
        PyTypeObject* type_PerceptionFrameSourcePropertiesChangedEventArgs;
        PyTypeObject* type_PerceptionFrameSourcePropertyChangeResult;
        PyTypeObject* type_PerceptionInfraredFrame;
        PyTypeObject* type_PerceptionInfraredFrameArrivedEventArgs;
        PyTypeObject* type_PerceptionInfraredFrameReader;
        PyTypeObject* type_PerceptionInfraredFrameSource;
        PyTypeObject* type_PerceptionInfraredFrameSourceAddedEventArgs;
        PyTypeObject* type_PerceptionInfraredFrameSourceRemovedEventArgs;
        PyTypeObject* type_PerceptionInfraredFrameSourceWatcher;
        PyTypeObject* type_PerceptionVideoProfile;
    };

    static PyObject* register_PerceptionFrameSourceAccessStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PerceptionFrameSourceAccessStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PerceptionFrameSourceAccessStatus = type;
        Py_INCREF(state->type_PerceptionFrameSourceAccessStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_PerceptionFrameSourcePropertyChangeStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_PerceptionFrameSourcePropertyChangeStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_PerceptionFrameSourcePropertyChangeStatus = type;
        Py_INCREF(state->type_PerceptionFrameSourcePropertyChangeStatus);


        Py_RETURN_NONE;
    }

    // ----- KnownCameraIntrinsicsProperties class --------------------
    constexpr const char* const type_name_KnownCameraIntrinsicsProperties = "KnownCameraIntrinsicsProperties";

    static PyObject* _new_KnownCameraIntrinsicsProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownCameraIntrinsicsProperties);
        return nullptr;
    }

    static PyObject* KnownCameraIntrinsicsProperties_get_FocalLength(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties::FocalLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCameraIntrinsicsProperties_get_PrincipalPoint(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties::PrincipalPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCameraIntrinsicsProperties_get_RadialDistortion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties::RadialDistortion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCameraIntrinsicsProperties_get_TangentialDistortion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties::TangentialDistortion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownCameraIntrinsicsProperties[] = {
        { "get_focal_length", reinterpret_cast<PyCFunction>(KnownCameraIntrinsicsProperties_get_FocalLength), METH_NOARGS | METH_STATIC, nullptr },
        { "get_principal_point", reinterpret_cast<PyCFunction>(KnownCameraIntrinsicsProperties_get_PrincipalPoint), METH_NOARGS | METH_STATIC, nullptr },
        { "get_radial_distortion", reinterpret_cast<PyCFunction>(KnownCameraIntrinsicsProperties_get_RadialDistortion), METH_NOARGS | METH_STATIC, nullptr },
        { "get_tangential_distortion", reinterpret_cast<PyCFunction>(KnownCameraIntrinsicsProperties_get_TangentialDistortion), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KnownCameraIntrinsicsProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownCameraIntrinsicsProperties[] = 
    {
        { Py_tp_new, _new_KnownCameraIntrinsicsProperties },
        { Py_tp_methods, _methods_KnownCameraIntrinsicsProperties },
        { Py_tp_getset, _getset_KnownCameraIntrinsicsProperties },
        { },
    };

    static PyType_Spec type_spec_KnownCameraIntrinsicsProperties =
    {
        "_winsdk_Windows_Devices_Perception.KnownCameraIntrinsicsProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownCameraIntrinsicsProperties
    };

    // ----- KnownPerceptionColorFrameSourceProperties class --------------------
    constexpr const char* const type_name_KnownPerceptionColorFrameSourceProperties = "KnownPerceptionColorFrameSourceProperties";

    static PyObject* _new_KnownPerceptionColorFrameSourceProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownPerceptionColorFrameSourceProperties);
        return nullptr;
    }

    static PyObject* KnownPerceptionColorFrameSourceProperties_get_AutoExposureEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties::AutoExposureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionColorFrameSourceProperties_get_Exposure(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties::Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionColorFrameSourceProperties_get_ExposureCompensation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties::ExposureCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionColorFrameSourceProperties[] = {
        { "get_auto_exposure_enabled", reinterpret_cast<PyCFunction>(KnownPerceptionColorFrameSourceProperties_get_AutoExposureEnabled), METH_NOARGS | METH_STATIC, nullptr },
        { "get_exposure", reinterpret_cast<PyCFunction>(KnownPerceptionColorFrameSourceProperties_get_Exposure), METH_NOARGS | METH_STATIC, nullptr },
        { "get_exposure_compensation", reinterpret_cast<PyCFunction>(KnownPerceptionColorFrameSourceProperties_get_ExposureCompensation), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionColorFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionColorFrameSourceProperties[] = 
    {
        { Py_tp_new, _new_KnownPerceptionColorFrameSourceProperties },
        { Py_tp_methods, _methods_KnownPerceptionColorFrameSourceProperties },
        { Py_tp_getset, _getset_KnownPerceptionColorFrameSourceProperties },
        { },
    };

    static PyType_Spec type_spec_KnownPerceptionColorFrameSourceProperties =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionColorFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionColorFrameSourceProperties
    };

    // ----- KnownPerceptionDepthFrameSourceProperties class --------------------
    constexpr const char* const type_name_KnownPerceptionDepthFrameSourceProperties = "KnownPerceptionDepthFrameSourceProperties";

    static PyObject* _new_KnownPerceptionDepthFrameSourceProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownPerceptionDepthFrameSourceProperties);
        return nullptr;
    }

    static PyObject* KnownPerceptionDepthFrameSourceProperties_get_MaxDepth(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionDepthFrameSourceProperties::MaxDepth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionDepthFrameSourceProperties_get_MinDepth(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionDepthFrameSourceProperties::MinDepth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionDepthFrameSourceProperties[] = {
        { "get_max_depth", reinterpret_cast<PyCFunction>(KnownPerceptionDepthFrameSourceProperties_get_MaxDepth), METH_NOARGS | METH_STATIC, nullptr },
        { "get_min_depth", reinterpret_cast<PyCFunction>(KnownPerceptionDepthFrameSourceProperties_get_MinDepth), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionDepthFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionDepthFrameSourceProperties[] = 
    {
        { Py_tp_new, _new_KnownPerceptionDepthFrameSourceProperties },
        { Py_tp_methods, _methods_KnownPerceptionDepthFrameSourceProperties },
        { Py_tp_getset, _getset_KnownPerceptionDepthFrameSourceProperties },
        { },
    };

    static PyType_Spec type_spec_KnownPerceptionDepthFrameSourceProperties =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionDepthFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionDepthFrameSourceProperties
    };

    // ----- KnownPerceptionFrameSourceProperties class --------------------
    constexpr const char* const type_name_KnownPerceptionFrameSourceProperties = "KnownPerceptionFrameSourceProperties";

    static PyObject* _new_KnownPerceptionFrameSourceProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownPerceptionFrameSourceProperties);
        return nullptr;
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_DeviceModelVersion(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::DeviceModelVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_EnclosureLocation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::EnclosureLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_FrameKind(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::FrameKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_Id(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_PhysicalDeviceIds(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::PhysicalDeviceIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionFrameSourceProperties_get_DeviceId(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties::DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionFrameSourceProperties[] = {
        { "get_device_model_version", reinterpret_cast<PyCFunction>(KnownPerceptionFrameSourceProperties_get_DeviceModelVersion), METH_NOARGS | METH_STATIC, nullptr },
        { "get_enclosure_location", reinterpret_cast<PyCFunction>(KnownPerceptionFrameSourceProperties_get_EnclosureLocation), METH_NOARGS | METH_STATIC, nullptr },
        { "get_frame_kind", reinterpret_cast<PyCFunction>(KnownPerceptionFrameSourceProperties_get_FrameKind), METH_NOARGS | METH_STATIC, nullptr },
        { "get_id", reinterpret_cast<PyCFunction>(KnownPerceptionFrameSourceProperties_get_Id), METH_NOARGS | METH_STATIC, nullptr },
        { "get_physical_device_ids", reinterpret_cast<PyCFunction>(KnownPerceptionFrameSourceProperties_get_PhysicalDeviceIds), METH_NOARGS | METH_STATIC, nullptr },
        { "get_device_id", reinterpret_cast<PyCFunction>(KnownPerceptionFrameSourceProperties_get_DeviceId), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionFrameSourceProperties[] = 
    {
        { Py_tp_new, _new_KnownPerceptionFrameSourceProperties },
        { Py_tp_methods, _methods_KnownPerceptionFrameSourceProperties },
        { Py_tp_getset, _getset_KnownPerceptionFrameSourceProperties },
        { },
    };

    static PyType_Spec type_spec_KnownPerceptionFrameSourceProperties =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionFrameSourceProperties
    };

    // ----- KnownPerceptionInfraredFrameSourceProperties class --------------------
    constexpr const char* const type_name_KnownPerceptionInfraredFrameSourceProperties = "KnownPerceptionInfraredFrameSourceProperties";

    static PyObject* _new_KnownPerceptionInfraredFrameSourceProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownPerceptionInfraredFrameSourceProperties);
        return nullptr;
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_ActiveIlluminationEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::ActiveIlluminationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_AmbientSubtractionEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::AmbientSubtractionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_AutoExposureEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::AutoExposureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_Exposure(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_ExposureCompensation(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::ExposureCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_InterleavedIlluminationEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::InterleavedIlluminationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionInfraredFrameSourceProperties_get_StructureLightPatternEnabled(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties::StructureLightPatternEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionInfraredFrameSourceProperties[] = {
        { "get_active_illumination_enabled", reinterpret_cast<PyCFunction>(KnownPerceptionInfraredFrameSourceProperties_get_ActiveIlluminationEnabled), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ambient_subtraction_enabled", reinterpret_cast<PyCFunction>(KnownPerceptionInfraredFrameSourceProperties_get_AmbientSubtractionEnabled), METH_NOARGS | METH_STATIC, nullptr },
        { "get_auto_exposure_enabled", reinterpret_cast<PyCFunction>(KnownPerceptionInfraredFrameSourceProperties_get_AutoExposureEnabled), METH_NOARGS | METH_STATIC, nullptr },
        { "get_exposure", reinterpret_cast<PyCFunction>(KnownPerceptionInfraredFrameSourceProperties_get_Exposure), METH_NOARGS | METH_STATIC, nullptr },
        { "get_exposure_compensation", reinterpret_cast<PyCFunction>(KnownPerceptionInfraredFrameSourceProperties_get_ExposureCompensation), METH_NOARGS | METH_STATIC, nullptr },
        { "get_interleaved_illumination_enabled", reinterpret_cast<PyCFunction>(KnownPerceptionInfraredFrameSourceProperties_get_InterleavedIlluminationEnabled), METH_NOARGS | METH_STATIC, nullptr },
        { "get_structure_light_pattern_enabled", reinterpret_cast<PyCFunction>(KnownPerceptionInfraredFrameSourceProperties_get_StructureLightPatternEnabled), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionInfraredFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionInfraredFrameSourceProperties[] = 
    {
        { Py_tp_new, _new_KnownPerceptionInfraredFrameSourceProperties },
        { Py_tp_methods, _methods_KnownPerceptionInfraredFrameSourceProperties },
        { Py_tp_getset, _getset_KnownPerceptionInfraredFrameSourceProperties },
        { },
    };

    static PyType_Spec type_spec_KnownPerceptionInfraredFrameSourceProperties =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionInfraredFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionInfraredFrameSourceProperties
    };

    // ----- KnownPerceptionVideoFrameSourceProperties class --------------------
    constexpr const char* const type_name_KnownPerceptionVideoFrameSourceProperties = "KnownPerceptionVideoFrameSourceProperties";

    static PyObject* _new_KnownPerceptionVideoFrameSourceProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownPerceptionVideoFrameSourceProperties);
        return nullptr;
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_AvailableVideoProfiles(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::AvailableVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_CameraIntrinsics(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::CameraIntrinsics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_IsMirrored(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::IsMirrored());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_SupportedVideoProfiles(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::SupportedVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoFrameSourceProperties_get_VideoProfile(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties::VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionVideoFrameSourceProperties[] = {
        { "get_available_video_profiles", reinterpret_cast<PyCFunction>(KnownPerceptionVideoFrameSourceProperties_get_AvailableVideoProfiles), METH_NOARGS | METH_STATIC, nullptr },
        { "get_camera_intrinsics", reinterpret_cast<PyCFunction>(KnownPerceptionVideoFrameSourceProperties_get_CameraIntrinsics), METH_NOARGS | METH_STATIC, nullptr },
        { "get_is_mirrored", reinterpret_cast<PyCFunction>(KnownPerceptionVideoFrameSourceProperties_get_IsMirrored), METH_NOARGS | METH_STATIC, nullptr },
        { "get_supported_video_profiles", reinterpret_cast<PyCFunction>(KnownPerceptionVideoFrameSourceProperties_get_SupportedVideoProfiles), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_profile", reinterpret_cast<PyCFunction>(KnownPerceptionVideoFrameSourceProperties_get_VideoProfile), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionVideoFrameSourceProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionVideoFrameSourceProperties[] = 
    {
        { Py_tp_new, _new_KnownPerceptionVideoFrameSourceProperties },
        { Py_tp_methods, _methods_KnownPerceptionVideoFrameSourceProperties },
        { Py_tp_getset, _getset_KnownPerceptionVideoFrameSourceProperties },
        { },
    };

    static PyType_Spec type_spec_KnownPerceptionVideoFrameSourceProperties =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionVideoFrameSourceProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionVideoFrameSourceProperties
    };

    // ----- KnownPerceptionVideoProfileProperties class --------------------
    constexpr const char* const type_name_KnownPerceptionVideoProfileProperties = "KnownPerceptionVideoProfileProperties";

    static PyObject* _new_KnownPerceptionVideoProfileProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownPerceptionVideoProfileProperties);
        return nullptr;
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_BitmapAlphaMode(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_BitmapPixelFormat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_FrameDuration(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::FrameDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_Height(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownPerceptionVideoProfileProperties_get_Width(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties::Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownPerceptionVideoProfileProperties[] = {
        { "get_bitmap_alpha_mode", reinterpret_cast<PyCFunction>(KnownPerceptionVideoProfileProperties_get_BitmapAlphaMode), METH_NOARGS | METH_STATIC, nullptr },
        { "get_bitmap_pixel_format", reinterpret_cast<PyCFunction>(KnownPerceptionVideoProfileProperties_get_BitmapPixelFormat), METH_NOARGS | METH_STATIC, nullptr },
        { "get_frame_duration", reinterpret_cast<PyCFunction>(KnownPerceptionVideoProfileProperties_get_FrameDuration), METH_NOARGS | METH_STATIC, nullptr },
        { "get_height", reinterpret_cast<PyCFunction>(KnownPerceptionVideoProfileProperties_get_Height), METH_NOARGS | METH_STATIC, nullptr },
        { "get_width", reinterpret_cast<PyCFunction>(KnownPerceptionVideoProfileProperties_get_Width), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KnownPerceptionVideoProfileProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownPerceptionVideoProfileProperties[] = 
    {
        { Py_tp_new, _new_KnownPerceptionVideoProfileProperties },
        { Py_tp_methods, _methods_KnownPerceptionVideoProfileProperties },
        { Py_tp_getset, _getset_KnownPerceptionVideoProfileProperties },
        { },
    };

    static PyType_Spec type_spec_KnownPerceptionVideoProfileProperties =
    {
        "_winsdk_Windows_Devices_Perception.KnownPerceptionVideoProfileProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownPerceptionVideoProfileProperties
    };

    // ----- PerceptionColorFrame class --------------------
    constexpr const char* const type_name_PerceptionColorFrame = "PerceptionColorFrame";

    static PyObject* _new_PerceptionColorFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionColorFrame);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrame_Close(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrame_get_VideoFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionColorFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionColorFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PerceptionColorFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionColorFrame_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionColorFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PerceptionColorFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrame[] = {
        { "video_frame", reinterpret_cast<getter>(PerceptionColorFrame_get_VideoFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrame[] = 
    {
        { Py_tp_new, _new_PerceptionColorFrame },
        { Py_tp_dealloc, _dealloc_PerceptionColorFrame },
        { Py_tp_methods, _methods_PerceptionColorFrame },
        { Py_tp_getset, _getset_PerceptionColorFrame },
        { },
    };

    static PyType_Spec type_spec_PerceptionColorFrame =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionColorFrame",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrame
    };

    // ----- PerceptionColorFrameArrivedEventArgs class --------------------
    constexpr const char* const type_name_PerceptionColorFrameArrivedEventArgs = "PerceptionColorFrameArrivedEventArgs";

    static PyObject* _new_PerceptionColorFrameArrivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionColorFrameArrivedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameArrivedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameArrivedEventArgs_TryOpenFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryOpenFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameArrivedEventArgs_get_RelativeTime(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionColorFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameArrivedEventArgs[] = {
        { "try_open_frame", reinterpret_cast<PyCFunction>(PerceptionColorFrameArrivedEventArgs_TryOpenFrame), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameArrivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameArrivedEventArgs[] = {
        { "relative_time", reinterpret_cast<getter>(PerceptionColorFrameArrivedEventArgs_get_RelativeTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameArrivedEventArgs[] = 
    {
        { Py_tp_new, _new_PerceptionColorFrameArrivedEventArgs },
        { Py_tp_dealloc, _dealloc_PerceptionColorFrameArrivedEventArgs },
        { Py_tp_methods, _methods_PerceptionColorFrameArrivedEventArgs },
        { Py_tp_getset, _getset_PerceptionColorFrameArrivedEventArgs },
        { },
    };

    static PyType_Spec type_spec_PerceptionColorFrameArrivedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionColorFrameArrivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameArrivedEventArgs
    };

    // ----- PerceptionColorFrameReader class --------------------
    constexpr const char* const type_name_PerceptionColorFrameReader = "PerceptionColorFrameReader";

    static PyObject* _new_PerceptionColorFrameReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionColorFrameReader);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameReader_Close(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameReader_TryReadLatestFrame(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryReadLatestFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameReader_get_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PerceptionColorFrameReader_put_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPaused(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PerceptionColorFrameReader_get_Source(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameReader_add_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameReader, winrt::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs>>(arg);

            return py::convert(self->obj.FrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameReader_remove_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionColorFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionColorFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PerceptionColorFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameReader[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionColorFrameReader_Close), METH_VARARGS, nullptr },
        { "try_read_latest_frame", reinterpret_cast<PyCFunction>(PerceptionColorFrameReader_TryReadLatestFrame), METH_VARARGS, nullptr },
        { "add_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionColorFrameReader_add_FrameArrived), METH_O, nullptr },
        { "remove_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionColorFrameReader_remove_FrameArrived), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionColorFrameReader), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PerceptionColorFrameReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameReader[] = {
        { "is_paused", reinterpret_cast<getter>(PerceptionColorFrameReader_get_IsPaused), reinterpret_cast<setter>(PerceptionColorFrameReader_put_IsPaused), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(PerceptionColorFrameReader_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameReader[] = 
    {
        { Py_tp_new, _new_PerceptionColorFrameReader },
        { Py_tp_dealloc, _dealloc_PerceptionColorFrameReader },
        { Py_tp_methods, _methods_PerceptionColorFrameReader },
        { Py_tp_getset, _getset_PerceptionColorFrameReader },
        { },
    };

    static PyType_Spec type_spec_PerceptionColorFrameReader =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionColorFrameReader",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameReader
    };

    // ----- PerceptionColorFrameSource class --------------------
    constexpr const char* const type_name_PerceptionColorFrameSource = "PerceptionColorFrameSource";

    static PyObject* _new_PerceptionColorFrameSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionColorFrameSource);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameSource(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameSource_AcquireControlSession(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AcquireControlSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_CanControlIndependentlyFrom(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CanControlIndependentlyFrom(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionColorFrameSource::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionColorFrameSource::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Perception::PerceptionColorFrameSource::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_IsCorrelatedWith(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsCorrelatedWith(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_OpenReader(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionColorFrameSource::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 0);

                return py::convert(self->obj.TryGetDepthCorrelatedCameraIntrinsicsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 1);

                return py::convert(self->obj.TryGetDepthCorrelatedCoordinateMapperAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_TryGetTransformTo(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::float4x4 param1 {  };

                auto return_value = self->obj.TryGetTransformTo(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_TrySetVideoProfileAsync(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionControlSession>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionVideoProfile>(args, 1);

                return py::convert(self->obj.TrySetVideoProfileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_Active(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Active());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_Available(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Available());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_AvailableVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AvailableVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_CameraIntrinsics(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraIntrinsics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_DeviceKind(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_DisplayName(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_Id(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_IsControlled(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsControlled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_Properties(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_SupportedVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_VideoProfile(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_get_DeviceId(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ActiveChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActiveChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AvailableChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AvailableChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CameraIntrinsicsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraIntrinsicsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>>(arg);

            return py::convert(self->obj.PropertiesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PropertiesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_add_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoProfileChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSource_remove_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoProfileChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionColorFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameSource[] = {
        { "acquire_control_session", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_AcquireControlSession), METH_VARARGS, nullptr },
        { "can_control_independently_from", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_CanControlIndependentlyFrom), METH_VARARGS, nullptr },
        { "create_watcher", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_CreateWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_FindAllAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "is_correlated_with", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_IsCorrelatedWith), METH_VARARGS, nullptr },
        { "open_reader", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_OpenReader), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_RequestAccessAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_depth_correlated_camera_intrinsics_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync), METH_VARARGS, nullptr },
        { "try_get_depth_correlated_coordinate_mapper_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync), METH_VARARGS, nullptr },
        { "try_get_transform_to", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_TryGetTransformTo), METH_VARARGS, nullptr },
        { "try_set_video_profile_async", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_TrySetVideoProfileAsync), METH_VARARGS, nullptr },
        { "add_active_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_ActiveChanged), METH_O, nullptr },
        { "remove_active_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_ActiveChanged), METH_O, nullptr },
        { "add_available_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_AvailableChanged), METH_O, nullptr },
        { "remove_available_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_AvailableChanged), METH_O, nullptr },
        { "add_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_CameraIntrinsicsChanged), METH_O, nullptr },
        { "remove_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_CameraIntrinsicsChanged), METH_O, nullptr },
        { "add_properties_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_PropertiesChanged), METH_O, nullptr },
        { "remove_properties_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_PropertiesChanged), METH_O, nullptr },
        { "add_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_add_VideoProfileChanged), METH_O, nullptr },
        { "remove_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSource_remove_VideoProfileChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameSource[] = {
        { "active", reinterpret_cast<getter>(PerceptionColorFrameSource_get_Active), nullptr, nullptr, nullptr },
        { "available", reinterpret_cast<getter>(PerceptionColorFrameSource_get_Available), nullptr, nullptr, nullptr },
        { "available_video_profiles", reinterpret_cast<getter>(PerceptionColorFrameSource_get_AvailableVideoProfiles), nullptr, nullptr, nullptr },
        { "camera_intrinsics", reinterpret_cast<getter>(PerceptionColorFrameSource_get_CameraIntrinsics), nullptr, nullptr, nullptr },
        { "device_kind", reinterpret_cast<getter>(PerceptionColorFrameSource_get_DeviceKind), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PerceptionColorFrameSource_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PerceptionColorFrameSource_get_Id), nullptr, nullptr, nullptr },
        { "is_controlled", reinterpret_cast<getter>(PerceptionColorFrameSource_get_IsControlled), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PerceptionColorFrameSource_get_Properties), nullptr, nullptr, nullptr },
        { "supported_video_profiles", reinterpret_cast<getter>(PerceptionColorFrameSource_get_SupportedVideoProfiles), nullptr, nullptr, nullptr },
        { "video_profile", reinterpret_cast<getter>(PerceptionColorFrameSource_get_VideoProfile), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(PerceptionColorFrameSource_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameSource[] = 
    {
        { Py_tp_new, _new_PerceptionColorFrameSource },
        { Py_tp_dealloc, _dealloc_PerceptionColorFrameSource },
        { Py_tp_methods, _methods_PerceptionColorFrameSource },
        { Py_tp_getset, _getset_PerceptionColorFrameSource },
        { },
    };

    static PyType_Spec type_spec_PerceptionColorFrameSource =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionColorFrameSource",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameSource
    };

    // ----- PerceptionColorFrameSourceAddedEventArgs class --------------------
    constexpr const char* const type_name_PerceptionColorFrameSourceAddedEventArgs = "PerceptionColorFrameSourceAddedEventArgs";

    static PyObject* _new_PerceptionColorFrameSourceAddedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionColorFrameSourceAddedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameSourceAddedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameSourceAddedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionColorFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameSourceAddedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameSourceAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameSourceAddedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionColorFrameSourceAddedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameSourceAddedEventArgs[] = 
    {
        { Py_tp_new, _new_PerceptionColorFrameSourceAddedEventArgs },
        { Py_tp_dealloc, _dealloc_PerceptionColorFrameSourceAddedEventArgs },
        { Py_tp_methods, _methods_PerceptionColorFrameSourceAddedEventArgs },
        { Py_tp_getset, _getset_PerceptionColorFrameSourceAddedEventArgs },
        { },
    };

    static PyType_Spec type_spec_PerceptionColorFrameSourceAddedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionColorFrameSourceAddedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameSourceAddedEventArgs
    };

    // ----- PerceptionColorFrameSourceRemovedEventArgs class --------------------
    constexpr const char* const type_name_PerceptionColorFrameSourceRemovedEventArgs = "PerceptionColorFrameSourceRemovedEventArgs";

    static PyObject* _new_PerceptionColorFrameSourceRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionColorFrameSourceRemovedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameSourceRemovedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameSourceRemovedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionColorFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameSourceRemovedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameSourceRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameSourceRemovedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionColorFrameSourceRemovedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameSourceRemovedEventArgs[] = 
    {
        { Py_tp_new, _new_PerceptionColorFrameSourceRemovedEventArgs },
        { Py_tp_dealloc, _dealloc_PerceptionColorFrameSourceRemovedEventArgs },
        { Py_tp_methods, _methods_PerceptionColorFrameSourceRemovedEventArgs },
        { Py_tp_getset, _getset_PerceptionColorFrameSourceRemovedEventArgs },
        { },
    };

    static PyType_Spec type_spec_PerceptionColorFrameSourceRemovedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionColorFrameSourceRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameSourceRemovedEventArgs
    };

    // ----- PerceptionColorFrameSourceWatcher class --------------------
    constexpr const char* const type_name_PerceptionColorFrameSourceWatcher = "PerceptionColorFrameSourceWatcher";

    static PyObject* _new_PerceptionColorFrameSourceWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionColorFrameSourceWatcher);
        return nullptr;
    }

    static void _dealloc_PerceptionColorFrameSourceWatcher(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionColorFrameSourceWatcher_Start(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_Stop(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_get_Status(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_add_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_add_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs>>(arg);

            return py::convert(self->obj.SourceAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_remove_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_add_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs>>(arg);

            return py::convert(self->obj.SourceRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_remove_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_add_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionColorFrameSourceWatcher_remove_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionColorFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionColorFrameSourceWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_Stop), METH_VARARGS, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_source_added", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_add_SourceAdded), METH_O, nullptr },
        { "remove_source_added", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_remove_SourceAdded), METH_O, nullptr },
        { "add_source_removed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_add_SourceRemoved), METH_O, nullptr },
        { "remove_source_removed", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_remove_SourceRemoved), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(PerceptionColorFrameSourceWatcher_remove_Stopped), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionColorFrameSourceWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionColorFrameSourceWatcher[] = {
        { "status", reinterpret_cast<getter>(PerceptionColorFrameSourceWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionColorFrameSourceWatcher[] = 
    {
        { Py_tp_new, _new_PerceptionColorFrameSourceWatcher },
        { Py_tp_dealloc, _dealloc_PerceptionColorFrameSourceWatcher },
        { Py_tp_methods, _methods_PerceptionColorFrameSourceWatcher },
        { Py_tp_getset, _getset_PerceptionColorFrameSourceWatcher },
        { },
    };

    static PyType_Spec type_spec_PerceptionColorFrameSourceWatcher =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionColorFrameSourceWatcher",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionColorFrameSourceWatcher
    };

    // ----- PerceptionControlSession class --------------------
    constexpr const char* const type_name_PerceptionControlSession = "PerceptionControlSession";

    static PyObject* _new_PerceptionControlSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionControlSession);
        return nullptr;
    }

    static void _dealloc_PerceptionControlSession(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionControlSession_Close(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionControlSession_TrySetPropertyAsync(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.TrySetPropertyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionControlSession_add_ControlLost(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionControlSession, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ControlLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionControlSession_remove_ControlLost(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ControlLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionControlSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionControlSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionControlSession(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PerceptionControlSession(py::wrapper::Windows::Devices::Perception::PerceptionControlSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionControlSession[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionControlSession_Close), METH_VARARGS, nullptr },
        { "try_set_property_async", reinterpret_cast<PyCFunction>(PerceptionControlSession_TrySetPropertyAsync), METH_VARARGS, nullptr },
        { "add_control_lost", reinterpret_cast<PyCFunction>(PerceptionControlSession_add_ControlLost), METH_O, nullptr },
        { "remove_control_lost", reinterpret_cast<PyCFunction>(PerceptionControlSession_remove_ControlLost), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionControlSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionControlSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PerceptionControlSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionControlSession[] = {
        { }
    };

    static PyType_Slot _type_slots_PerceptionControlSession[] = 
    {
        { Py_tp_new, _new_PerceptionControlSession },
        { Py_tp_dealloc, _dealloc_PerceptionControlSession },
        { Py_tp_methods, _methods_PerceptionControlSession },
        { Py_tp_getset, _getset_PerceptionControlSession },
        { },
    };

    static PyType_Spec type_spec_PerceptionControlSession =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionControlSession",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionControlSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionControlSession
    };

    // ----- PerceptionDepthCorrelatedCameraIntrinsics class --------------------
    constexpr const char* const type_name_PerceptionDepthCorrelatedCameraIntrinsics = "PerceptionDepthCorrelatedCameraIntrinsics";

    static PyObject* _new_PerceptionDepthCorrelatedCameraIntrinsics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthCorrelatedCameraIntrinsics);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthCorrelatedCameraIntrinsics(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthCorrelatedCameraIntrinsics_UnprojectAllPixelsAtCorrelatedDepthAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Numerics::float3>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Foundation::Numerics::float3> param1 ( param1_count, py::empty_instance<winrt::Windows::Foundation::Numerics::float3>::get() );

                auto return_value = self->obj.UnprojectAllPixelsAtCorrelatedDepthAsync(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCameraIntrinsics_UnprojectPixelAtCorrelatedDepth(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);

                return py::convert(self->obj.UnprojectPixelAtCorrelatedDepth(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCameraIntrinsics_UnprojectPixelsAtCorrelatedDepth(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);
                auto param2_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Numerics::float3>::size_type>(args, 2);
                winrt::com_array<winrt::Windows::Foundation::Numerics::float3> param2 ( param2_count, py::empty_instance<winrt::Windows::Foundation::Numerics::float3>::get() );

                self->obj.UnprojectPixelsAtCorrelatedDepth(param0, param1, param2);

                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return out2.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCameraIntrinsics_UnprojectRegionPixelsAtCorrelatedDepthAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);
                auto param2_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Numerics::float3>::size_type>(args, 2);
                winrt::com_array<winrt::Windows::Foundation::Numerics::float3> param2 ( param2_count, py::empty_instance<winrt::Windows::Foundation::Numerics::float3>::get() );

                auto return_value = self->obj.UnprojectRegionPixelsAtCorrelatedDepthAsync(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionDepthCorrelatedCameraIntrinsics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthCorrelatedCameraIntrinsics[] = {
        { "unproject_all_pixels_at_correlated_depth_async", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCameraIntrinsics_UnprojectAllPixelsAtCorrelatedDepthAsync), METH_VARARGS, nullptr },
        { "unproject_pixel_at_correlated_depth", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCameraIntrinsics_UnprojectPixelAtCorrelatedDepth), METH_VARARGS, nullptr },
        { "unproject_pixels_at_correlated_depth", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCameraIntrinsics_UnprojectPixelsAtCorrelatedDepth), METH_VARARGS, nullptr },
        { "unproject_region_pixels_at_correlated_depth_async", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCameraIntrinsics_UnprojectRegionPixelsAtCorrelatedDepthAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthCorrelatedCameraIntrinsics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthCorrelatedCameraIntrinsics[] = {
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthCorrelatedCameraIntrinsics[] = 
    {
        { Py_tp_new, _new_PerceptionDepthCorrelatedCameraIntrinsics },
        { Py_tp_dealloc, _dealloc_PerceptionDepthCorrelatedCameraIntrinsics },
        { Py_tp_methods, _methods_PerceptionDepthCorrelatedCameraIntrinsics },
        { Py_tp_getset, _getset_PerceptionDepthCorrelatedCameraIntrinsics },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthCorrelatedCameraIntrinsics =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthCorrelatedCameraIntrinsics",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthCorrelatedCameraIntrinsics
    };

    // ----- PerceptionDepthCorrelatedCoordinateMapper class --------------------
    constexpr const char* const type_name_PerceptionDepthCorrelatedCoordinateMapper = "PerceptionDepthCorrelatedCoordinateMapper";

    static PyObject* _new_PerceptionDepthCorrelatedCoordinateMapper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthCorrelatedCoordinateMapper);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthCorrelatedCoordinateMapper(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthCorrelatedCoordinateMapper_MapAllPixelsToTargetAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Point>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Foundation::Point> param1 ( param1_count, py::empty_instance<winrt::Windows::Foundation::Point>::get() );

                auto return_value = self->obj.MapAllPixelsToTargetAsync(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCoordinateMapper_MapPixelToTarget(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);

                return py::convert(self->obj.MapPixelToTarget(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCoordinateMapper_MapPixelsToTarget(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);
                auto param2_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Point>::size_type>(args, 2);
                winrt::com_array<winrt::Windows::Foundation::Point> param2 ( param2_count, py::empty_instance<winrt::Windows::Foundation::Point>::get() );

                self->obj.MapPixelsToTarget(param0, param1, param2);

                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return out2.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthCorrelatedCoordinateMapper_MapRegionOfPixelsToTargetAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrame>(args, 1);
                auto param2_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Point>::size_type>(args, 2);
                winrt::com_array<winrt::Windows::Foundation::Point> param2 ( param2_count, py::empty_instance<winrt::Windows::Foundation::Point>::get() );

                auto return_value = self->obj.MapRegionOfPixelsToTargetAsync(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionDepthCorrelatedCoordinateMapper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthCorrelatedCoordinateMapper[] = {
        { "map_all_pixels_to_target_async", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCoordinateMapper_MapAllPixelsToTargetAsync), METH_VARARGS, nullptr },
        { "map_pixel_to_target", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCoordinateMapper_MapPixelToTarget), METH_VARARGS, nullptr },
        { "map_pixels_to_target", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCoordinateMapper_MapPixelsToTarget), METH_VARARGS, nullptr },
        { "map_region_of_pixels_to_target_async", reinterpret_cast<PyCFunction>(PerceptionDepthCorrelatedCoordinateMapper_MapRegionOfPixelsToTargetAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthCorrelatedCoordinateMapper), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthCorrelatedCoordinateMapper[] = {
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthCorrelatedCoordinateMapper[] = 
    {
        { Py_tp_new, _new_PerceptionDepthCorrelatedCoordinateMapper },
        { Py_tp_dealloc, _dealloc_PerceptionDepthCorrelatedCoordinateMapper },
        { Py_tp_methods, _methods_PerceptionDepthCorrelatedCoordinateMapper },
        { Py_tp_getset, _getset_PerceptionDepthCorrelatedCoordinateMapper },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthCorrelatedCoordinateMapper =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthCorrelatedCoordinateMapper",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthCorrelatedCoordinateMapper
    };

    // ----- PerceptionDepthFrame class --------------------
    constexpr const char* const type_name_PerceptionDepthFrame = "PerceptionDepthFrame";

    static PyObject* _new_PerceptionDepthFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthFrame);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrame_Close(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrame_get_VideoFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionDepthFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionDepthFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PerceptionDepthFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionDepthFrame_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionDepthFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PerceptionDepthFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrame[] = {
        { "video_frame", reinterpret_cast<getter>(PerceptionDepthFrame_get_VideoFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrame[] = 
    {
        { Py_tp_new, _new_PerceptionDepthFrame },
        { Py_tp_dealloc, _dealloc_PerceptionDepthFrame },
        { Py_tp_methods, _methods_PerceptionDepthFrame },
        { Py_tp_getset, _getset_PerceptionDepthFrame },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthFrame =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthFrame",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrame
    };

    // ----- PerceptionDepthFrameArrivedEventArgs class --------------------
    constexpr const char* const type_name_PerceptionDepthFrameArrivedEventArgs = "PerceptionDepthFrameArrivedEventArgs";

    static PyObject* _new_PerceptionDepthFrameArrivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthFrameArrivedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameArrivedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameArrivedEventArgs_TryOpenFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryOpenFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameArrivedEventArgs_get_RelativeTime(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionDepthFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameArrivedEventArgs[] = {
        { "try_open_frame", reinterpret_cast<PyCFunction>(PerceptionDepthFrameArrivedEventArgs_TryOpenFrame), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameArrivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameArrivedEventArgs[] = {
        { "relative_time", reinterpret_cast<getter>(PerceptionDepthFrameArrivedEventArgs_get_RelativeTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameArrivedEventArgs[] = 
    {
        { Py_tp_new, _new_PerceptionDepthFrameArrivedEventArgs },
        { Py_tp_dealloc, _dealloc_PerceptionDepthFrameArrivedEventArgs },
        { Py_tp_methods, _methods_PerceptionDepthFrameArrivedEventArgs },
        { Py_tp_getset, _getset_PerceptionDepthFrameArrivedEventArgs },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthFrameArrivedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthFrameArrivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameArrivedEventArgs
    };

    // ----- PerceptionDepthFrameReader class --------------------
    constexpr const char* const type_name_PerceptionDepthFrameReader = "PerceptionDepthFrameReader";

    static PyObject* _new_PerceptionDepthFrameReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthFrameReader);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameReader_Close(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameReader_TryReadLatestFrame(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryReadLatestFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameReader_get_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PerceptionDepthFrameReader_put_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPaused(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PerceptionDepthFrameReader_get_Source(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameReader_add_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameReader, winrt::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs>>(arg);

            return py::convert(self->obj.FrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameReader_remove_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionDepthFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionDepthFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PerceptionDepthFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameReader[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionDepthFrameReader_Close), METH_VARARGS, nullptr },
        { "try_read_latest_frame", reinterpret_cast<PyCFunction>(PerceptionDepthFrameReader_TryReadLatestFrame), METH_VARARGS, nullptr },
        { "add_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionDepthFrameReader_add_FrameArrived), METH_O, nullptr },
        { "remove_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionDepthFrameReader_remove_FrameArrived), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionDepthFrameReader), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PerceptionDepthFrameReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameReader[] = {
        { "is_paused", reinterpret_cast<getter>(PerceptionDepthFrameReader_get_IsPaused), reinterpret_cast<setter>(PerceptionDepthFrameReader_put_IsPaused), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(PerceptionDepthFrameReader_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameReader[] = 
    {
        { Py_tp_new, _new_PerceptionDepthFrameReader },
        { Py_tp_dealloc, _dealloc_PerceptionDepthFrameReader },
        { Py_tp_methods, _methods_PerceptionDepthFrameReader },
        { Py_tp_getset, _getset_PerceptionDepthFrameReader },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthFrameReader =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthFrameReader",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameReader
    };

    // ----- PerceptionDepthFrameSource class --------------------
    constexpr const char* const type_name_PerceptionDepthFrameSource = "PerceptionDepthFrameSource";

    static PyObject* _new_PerceptionDepthFrameSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthFrameSource);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameSource(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameSource_AcquireControlSession(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AcquireControlSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_CanControlIndependentlyFrom(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CanControlIndependentlyFrom(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionDepthFrameSource::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionDepthFrameSource::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Perception::PerceptionDepthFrameSource::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_IsCorrelatedWith(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsCorrelatedWith(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_OpenReader(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionDepthFrameSource::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 0);

                return py::convert(self->obj.TryGetDepthCorrelatedCameraIntrinsicsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 1);

                return py::convert(self->obj.TryGetDepthCorrelatedCoordinateMapperAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_TryGetTransformTo(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::float4x4 param1 {  };

                auto return_value = self->obj.TryGetTransformTo(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_TrySetVideoProfileAsync(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionControlSession>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionVideoProfile>(args, 1);

                return py::convert(self->obj.TrySetVideoProfileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_Active(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Active());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_Available(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Available());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_AvailableVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AvailableVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_CameraIntrinsics(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraIntrinsics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_DeviceKind(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_DisplayName(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_Id(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_IsControlled(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsControlled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_Properties(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_SupportedVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_VideoProfile(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_get_DeviceId(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ActiveChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActiveChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AvailableChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AvailableChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CameraIntrinsicsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraIntrinsicsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>>(arg);

            return py::convert(self->obj.PropertiesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PropertiesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_add_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoProfileChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSource_remove_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoProfileChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionDepthFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameSource[] = {
        { "acquire_control_session", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_AcquireControlSession), METH_VARARGS, nullptr },
        { "can_control_independently_from", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_CanControlIndependentlyFrom), METH_VARARGS, nullptr },
        { "create_watcher", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_CreateWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_FindAllAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "is_correlated_with", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_IsCorrelatedWith), METH_VARARGS, nullptr },
        { "open_reader", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_OpenReader), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_RequestAccessAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_depth_correlated_camera_intrinsics_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync), METH_VARARGS, nullptr },
        { "try_get_depth_correlated_coordinate_mapper_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync), METH_VARARGS, nullptr },
        { "try_get_transform_to", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_TryGetTransformTo), METH_VARARGS, nullptr },
        { "try_set_video_profile_async", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_TrySetVideoProfileAsync), METH_VARARGS, nullptr },
        { "add_active_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_ActiveChanged), METH_O, nullptr },
        { "remove_active_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_ActiveChanged), METH_O, nullptr },
        { "add_available_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_AvailableChanged), METH_O, nullptr },
        { "remove_available_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_AvailableChanged), METH_O, nullptr },
        { "add_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_CameraIntrinsicsChanged), METH_O, nullptr },
        { "remove_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_CameraIntrinsicsChanged), METH_O, nullptr },
        { "add_properties_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_PropertiesChanged), METH_O, nullptr },
        { "remove_properties_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_PropertiesChanged), METH_O, nullptr },
        { "add_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_add_VideoProfileChanged), METH_O, nullptr },
        { "remove_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSource_remove_VideoProfileChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameSource[] = {
        { "active", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_Active), nullptr, nullptr, nullptr },
        { "available", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_Available), nullptr, nullptr, nullptr },
        { "available_video_profiles", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_AvailableVideoProfiles), nullptr, nullptr, nullptr },
        { "camera_intrinsics", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_CameraIntrinsics), nullptr, nullptr, nullptr },
        { "device_kind", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_DeviceKind), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_Id), nullptr, nullptr, nullptr },
        { "is_controlled", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_IsControlled), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_Properties), nullptr, nullptr, nullptr },
        { "supported_video_profiles", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_SupportedVideoProfiles), nullptr, nullptr, nullptr },
        { "video_profile", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_VideoProfile), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(PerceptionDepthFrameSource_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameSource[] = 
    {
        { Py_tp_new, _new_PerceptionDepthFrameSource },
        { Py_tp_dealloc, _dealloc_PerceptionDepthFrameSource },
        { Py_tp_methods, _methods_PerceptionDepthFrameSource },
        { Py_tp_getset, _getset_PerceptionDepthFrameSource },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthFrameSource =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthFrameSource",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameSource
    };

    // ----- PerceptionDepthFrameSourceAddedEventArgs class --------------------
    constexpr const char* const type_name_PerceptionDepthFrameSourceAddedEventArgs = "PerceptionDepthFrameSourceAddedEventArgs";

    static PyObject* _new_PerceptionDepthFrameSourceAddedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthFrameSourceAddedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameSourceAddedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameSourceAddedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionDepthFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameSourceAddedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameSourceAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameSourceAddedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionDepthFrameSourceAddedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameSourceAddedEventArgs[] = 
    {
        { Py_tp_new, _new_PerceptionDepthFrameSourceAddedEventArgs },
        { Py_tp_dealloc, _dealloc_PerceptionDepthFrameSourceAddedEventArgs },
        { Py_tp_methods, _methods_PerceptionDepthFrameSourceAddedEventArgs },
        { Py_tp_getset, _getset_PerceptionDepthFrameSourceAddedEventArgs },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthFrameSourceAddedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthFrameSourceAddedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameSourceAddedEventArgs
    };

    // ----- PerceptionDepthFrameSourceRemovedEventArgs class --------------------
    constexpr const char* const type_name_PerceptionDepthFrameSourceRemovedEventArgs = "PerceptionDepthFrameSourceRemovedEventArgs";

    static PyObject* _new_PerceptionDepthFrameSourceRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthFrameSourceRemovedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameSourceRemovedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameSourceRemovedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionDepthFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameSourceRemovedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameSourceRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameSourceRemovedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionDepthFrameSourceRemovedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameSourceRemovedEventArgs[] = 
    {
        { Py_tp_new, _new_PerceptionDepthFrameSourceRemovedEventArgs },
        { Py_tp_dealloc, _dealloc_PerceptionDepthFrameSourceRemovedEventArgs },
        { Py_tp_methods, _methods_PerceptionDepthFrameSourceRemovedEventArgs },
        { Py_tp_getset, _getset_PerceptionDepthFrameSourceRemovedEventArgs },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthFrameSourceRemovedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthFrameSourceRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameSourceRemovedEventArgs
    };

    // ----- PerceptionDepthFrameSourceWatcher class --------------------
    constexpr const char* const type_name_PerceptionDepthFrameSourceWatcher = "PerceptionDepthFrameSourceWatcher";

    static PyObject* _new_PerceptionDepthFrameSourceWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionDepthFrameSourceWatcher);
        return nullptr;
    }

    static void _dealloc_PerceptionDepthFrameSourceWatcher(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_Start(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_Stop(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_get_Status(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_add_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_add_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs>>(arg);

            return py::convert(self->obj.SourceAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_remove_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_add_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs>>(arg);

            return py::convert(self->obj.SourceRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_remove_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_add_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionDepthFrameSourceWatcher_remove_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionDepthFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionDepthFrameSourceWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_Stop), METH_VARARGS, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_source_added", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_add_SourceAdded), METH_O, nullptr },
        { "remove_source_added", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_remove_SourceAdded), METH_O, nullptr },
        { "add_source_removed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_add_SourceRemoved), METH_O, nullptr },
        { "remove_source_removed", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_remove_SourceRemoved), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(PerceptionDepthFrameSourceWatcher_remove_Stopped), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionDepthFrameSourceWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionDepthFrameSourceWatcher[] = {
        { "status", reinterpret_cast<getter>(PerceptionDepthFrameSourceWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionDepthFrameSourceWatcher[] = 
    {
        { Py_tp_new, _new_PerceptionDepthFrameSourceWatcher },
        { Py_tp_dealloc, _dealloc_PerceptionDepthFrameSourceWatcher },
        { Py_tp_methods, _methods_PerceptionDepthFrameSourceWatcher },
        { Py_tp_getset, _getset_PerceptionDepthFrameSourceWatcher },
        { },
    };

    static PyType_Spec type_spec_PerceptionDepthFrameSourceWatcher =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionDepthFrameSourceWatcher",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionDepthFrameSourceWatcher
    };

    // ----- PerceptionFrameSourcePropertiesChangedEventArgs class --------------------
    constexpr const char* const type_name_PerceptionFrameSourcePropertiesChangedEventArgs = "PerceptionFrameSourcePropertiesChangedEventArgs";

    static PyObject* _new_PerceptionFrameSourcePropertiesChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionFrameSourcePropertiesChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionFrameSourcePropertiesChangedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionFrameSourcePropertiesChangedEventArgs_get_CollectionChange(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CollectionChange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionFrameSourcePropertiesChangedEventArgs_get_Key(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Key());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionFrameSourcePropertiesChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionFrameSourcePropertiesChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionFrameSourcePropertiesChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionFrameSourcePropertiesChangedEventArgs[] = {
        { "collection_change", reinterpret_cast<getter>(PerceptionFrameSourcePropertiesChangedEventArgs_get_CollectionChange), nullptr, nullptr, nullptr },
        { "key", reinterpret_cast<getter>(PerceptionFrameSourcePropertiesChangedEventArgs_get_Key), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionFrameSourcePropertiesChangedEventArgs[] = 
    {
        { Py_tp_new, _new_PerceptionFrameSourcePropertiesChangedEventArgs },
        { Py_tp_dealloc, _dealloc_PerceptionFrameSourcePropertiesChangedEventArgs },
        { Py_tp_methods, _methods_PerceptionFrameSourcePropertiesChangedEventArgs },
        { Py_tp_getset, _getset_PerceptionFrameSourcePropertiesChangedEventArgs },
        { },
    };

    static PyType_Spec type_spec_PerceptionFrameSourcePropertiesChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionFrameSourcePropertiesChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionFrameSourcePropertiesChangedEventArgs
    };

    // ----- PerceptionFrameSourcePropertyChangeResult class --------------------
    constexpr const char* const type_name_PerceptionFrameSourcePropertyChangeResult = "PerceptionFrameSourcePropertyChangeResult";

    static PyObject* _new_PerceptionFrameSourcePropertyChangeResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionFrameSourcePropertyChangeResult);
        return nullptr;
    }

    static void _dealloc_PerceptionFrameSourcePropertyChangeResult(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionFrameSourcePropertyChangeResult_get_NewValue(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionFrameSourcePropertyChangeResult_get_Status(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionFrameSourcePropertyChangeResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionFrameSourcePropertyChangeResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionFrameSourcePropertyChangeResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionFrameSourcePropertyChangeResult[] = {
        { "new_value", reinterpret_cast<getter>(PerceptionFrameSourcePropertyChangeResult_get_NewValue), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(PerceptionFrameSourcePropertyChangeResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionFrameSourcePropertyChangeResult[] = 
    {
        { Py_tp_new, _new_PerceptionFrameSourcePropertyChangeResult },
        { Py_tp_dealloc, _dealloc_PerceptionFrameSourcePropertyChangeResult },
        { Py_tp_methods, _methods_PerceptionFrameSourcePropertyChangeResult },
        { Py_tp_getset, _getset_PerceptionFrameSourcePropertyChangeResult },
        { },
    };

    static PyType_Spec type_spec_PerceptionFrameSourcePropertyChangeResult =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionFrameSourcePropertyChangeResult",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionFrameSourcePropertyChangeResult
    };

    // ----- PerceptionInfraredFrame class --------------------
    constexpr const char* const type_name_PerceptionInfraredFrame = "PerceptionInfraredFrame";

    static PyObject* _new_PerceptionInfraredFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionInfraredFrame);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrame_Close(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrame_get_VideoFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionInfraredFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionInfraredFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PerceptionInfraredFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionInfraredFrame_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionInfraredFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PerceptionInfraredFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrame[] = {
        { "video_frame", reinterpret_cast<getter>(PerceptionInfraredFrame_get_VideoFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrame[] = 
    {
        { Py_tp_new, _new_PerceptionInfraredFrame },
        { Py_tp_dealloc, _dealloc_PerceptionInfraredFrame },
        { Py_tp_methods, _methods_PerceptionInfraredFrame },
        { Py_tp_getset, _getset_PerceptionInfraredFrame },
        { },
    };

    static PyType_Spec type_spec_PerceptionInfraredFrame =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionInfraredFrame",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrame
    };

    // ----- PerceptionInfraredFrameArrivedEventArgs class --------------------
    constexpr const char* const type_name_PerceptionInfraredFrameArrivedEventArgs = "PerceptionInfraredFrameArrivedEventArgs";

    static PyObject* _new_PerceptionInfraredFrameArrivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionInfraredFrameArrivedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameArrivedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameArrivedEventArgs_TryOpenFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryOpenFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameArrivedEventArgs_get_RelativeTime(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionInfraredFrameArrivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameArrivedEventArgs[] = {
        { "try_open_frame", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameArrivedEventArgs_TryOpenFrame), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameArrivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameArrivedEventArgs[] = {
        { "relative_time", reinterpret_cast<getter>(PerceptionInfraredFrameArrivedEventArgs_get_RelativeTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameArrivedEventArgs[] = 
    {
        { Py_tp_new, _new_PerceptionInfraredFrameArrivedEventArgs },
        { Py_tp_dealloc, _dealloc_PerceptionInfraredFrameArrivedEventArgs },
        { Py_tp_methods, _methods_PerceptionInfraredFrameArrivedEventArgs },
        { Py_tp_getset, _getset_PerceptionInfraredFrameArrivedEventArgs },
        { },
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameArrivedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionInfraredFrameArrivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameArrivedEventArgs
    };

    // ----- PerceptionInfraredFrameReader class --------------------
    constexpr const char* const type_name_PerceptionInfraredFrameReader = "PerceptionInfraredFrameReader";

    static PyObject* _new_PerceptionInfraredFrameReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionInfraredFrameReader);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameReader_Close(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_TryReadLatestFrame(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryReadLatestFrame());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_get_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPaused());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PerceptionInfraredFrameReader_put_IsPaused(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsPaused(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_get_Source(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_add_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameReader, winrt::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs>>(arg);

            return py::convert(self->obj.FrameArrived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameReader_remove_FrameArrived(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FrameArrived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionInfraredFrameReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_PerceptionInfraredFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_PerceptionInfraredFrameReader(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameReader[] = {
        { "close", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameReader_Close), METH_VARARGS, nullptr },
        { "try_read_latest_frame", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameReader_TryReadLatestFrame), METH_VARARGS, nullptr },
        { "add_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameReader_add_FrameArrived), METH_O, nullptr },
        { "remove_frame_arrived", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameReader_remove_FrameArrived), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameReader), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_PerceptionInfraredFrameReader), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_PerceptionInfraredFrameReader), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameReader[] = {
        { "is_paused", reinterpret_cast<getter>(PerceptionInfraredFrameReader_get_IsPaused), reinterpret_cast<setter>(PerceptionInfraredFrameReader_put_IsPaused), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(PerceptionInfraredFrameReader_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameReader[] = 
    {
        { Py_tp_new, _new_PerceptionInfraredFrameReader },
        { Py_tp_dealloc, _dealloc_PerceptionInfraredFrameReader },
        { Py_tp_methods, _methods_PerceptionInfraredFrameReader },
        { Py_tp_getset, _getset_PerceptionInfraredFrameReader },
        { },
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameReader =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionInfraredFrameReader",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameReader
    };

    // ----- PerceptionInfraredFrameSource class --------------------
    constexpr const char* const type_name_PerceptionInfraredFrameSource = "PerceptionInfraredFrameSource";

    static PyObject* _new_PerceptionInfraredFrameSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionInfraredFrameSource);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameSource(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameSource_AcquireControlSession(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AcquireControlSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_CanControlIndependentlyFrom(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CanControlIndependentlyFrom(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_CreateWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource::CreateWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_FindAllAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource::FindAllAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_IsCorrelatedWith(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsCorrelatedWith(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_OpenReader(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_RequestAccessAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource::RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 0);

                return py::convert(self->obj.TryGetDepthCorrelatedCameraIntrinsicsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>(args, 1);

                return py::convert(self->obj.TryGetDepthCorrelatedCoordinateMapperAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_TryGetTransformTo(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Foundation::Numerics::float4x4 param1 {  };

                auto return_value = self->obj.TryGetTransformTo(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_TrySetVideoProfileAsync(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionControlSession>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionVideoProfile>(args, 1);

                return py::convert(self->obj.TrySetVideoProfileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_Active(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Active());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_Available(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Available());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_AvailableVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AvailableVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_CameraIntrinsics(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraIntrinsics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_DeviceKind(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_DisplayName(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_Id(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_IsControlled(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsControlled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_Properties(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_SupportedVideoProfiles(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedVideoProfiles());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_VideoProfile(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_get_DeviceId(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ActiveChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_ActiveChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ActiveChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AvailableChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_AvailableChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AvailableChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CameraIntrinsicsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_CameraIntrinsicsChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraIntrinsicsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>>(arg);

            return py::convert(self->obj.PropertiesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_PropertiesChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PropertiesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_add_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.VideoProfileChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSource_remove_VideoProfileChanged(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VideoProfileChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionInfraredFrameSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameSource[] = {
        { "acquire_control_session", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_AcquireControlSession), METH_VARARGS, nullptr },
        { "can_control_independently_from", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_CanControlIndependentlyFrom), METH_VARARGS, nullptr },
        { "create_watcher", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_CreateWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "find_all_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_FindAllAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "is_correlated_with", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_IsCorrelatedWith), METH_VARARGS, nullptr },
        { "open_reader", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_OpenReader), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_RequestAccessAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_depth_correlated_camera_intrinsics_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_TryGetDepthCorrelatedCameraIntrinsicsAsync), METH_VARARGS, nullptr },
        { "try_get_depth_correlated_coordinate_mapper_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_TryGetDepthCorrelatedCoordinateMapperAsync), METH_VARARGS, nullptr },
        { "try_get_transform_to", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_TryGetTransformTo), METH_VARARGS, nullptr },
        { "try_set_video_profile_async", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_TrySetVideoProfileAsync), METH_VARARGS, nullptr },
        { "add_active_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_ActiveChanged), METH_O, nullptr },
        { "remove_active_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_ActiveChanged), METH_O, nullptr },
        { "add_available_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_AvailableChanged), METH_O, nullptr },
        { "remove_available_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_AvailableChanged), METH_O, nullptr },
        { "add_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_CameraIntrinsicsChanged), METH_O, nullptr },
        { "remove_camera_intrinsics_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_CameraIntrinsicsChanged), METH_O, nullptr },
        { "add_properties_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_PropertiesChanged), METH_O, nullptr },
        { "remove_properties_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_PropertiesChanged), METH_O, nullptr },
        { "add_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_add_VideoProfileChanged), METH_O, nullptr },
        { "remove_video_profile_changed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSource_remove_VideoProfileChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameSource[] = {
        { "active", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_Active), nullptr, nullptr, nullptr },
        { "available", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_Available), nullptr, nullptr, nullptr },
        { "available_video_profiles", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_AvailableVideoProfiles), nullptr, nullptr, nullptr },
        { "camera_intrinsics", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_CameraIntrinsics), nullptr, nullptr, nullptr },
        { "device_kind", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_DeviceKind), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_Id), nullptr, nullptr, nullptr },
        { "is_controlled", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_IsControlled), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_Properties), nullptr, nullptr, nullptr },
        { "supported_video_profiles", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_SupportedVideoProfiles), nullptr, nullptr, nullptr },
        { "video_profile", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_VideoProfile), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(PerceptionInfraredFrameSource_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameSource[] = 
    {
        { Py_tp_new, _new_PerceptionInfraredFrameSource },
        { Py_tp_dealloc, _dealloc_PerceptionInfraredFrameSource },
        { Py_tp_methods, _methods_PerceptionInfraredFrameSource },
        { Py_tp_getset, _getset_PerceptionInfraredFrameSource },
        { },
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameSource =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionInfraredFrameSource",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameSource
    };

    // ----- PerceptionInfraredFrameSourceAddedEventArgs class --------------------
    constexpr const char* const type_name_PerceptionInfraredFrameSourceAddedEventArgs = "PerceptionInfraredFrameSourceAddedEventArgs";

    static PyObject* _new_PerceptionInfraredFrameSourceAddedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionInfraredFrameSourceAddedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameSourceAddedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameSourceAddedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionInfraredFrameSourceAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameSourceAddedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameSourceAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameSourceAddedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionInfraredFrameSourceAddedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameSourceAddedEventArgs[] = 
    {
        { Py_tp_new, _new_PerceptionInfraredFrameSourceAddedEventArgs },
        { Py_tp_dealloc, _dealloc_PerceptionInfraredFrameSourceAddedEventArgs },
        { Py_tp_methods, _methods_PerceptionInfraredFrameSourceAddedEventArgs },
        { Py_tp_getset, _getset_PerceptionInfraredFrameSourceAddedEventArgs },
        { },
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameSourceAddedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionInfraredFrameSourceAddedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameSourceAddedEventArgs
    };

    // ----- PerceptionInfraredFrameSourceRemovedEventArgs class --------------------
    constexpr const char* const type_name_PerceptionInfraredFrameSourceRemovedEventArgs = "PerceptionInfraredFrameSourceRemovedEventArgs";

    static PyObject* _new_PerceptionInfraredFrameSourceRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionInfraredFrameSourceRemovedEventArgs);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameSourceRemovedEventArgs(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameSourceRemovedEventArgs_get_FrameSource(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionInfraredFrameSourceRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameSourceRemovedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameSourceRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameSourceRemovedEventArgs[] = {
        { "frame_source", reinterpret_cast<getter>(PerceptionInfraredFrameSourceRemovedEventArgs_get_FrameSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameSourceRemovedEventArgs[] = 
    {
        { Py_tp_new, _new_PerceptionInfraredFrameSourceRemovedEventArgs },
        { Py_tp_dealloc, _dealloc_PerceptionInfraredFrameSourceRemovedEventArgs },
        { Py_tp_methods, _methods_PerceptionInfraredFrameSourceRemovedEventArgs },
        { Py_tp_getset, _getset_PerceptionInfraredFrameSourceRemovedEventArgs },
        { },
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameSourceRemovedEventArgs =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionInfraredFrameSourceRemovedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameSourceRemovedEventArgs
    };

    // ----- PerceptionInfraredFrameSourceWatcher class --------------------
    constexpr const char* const type_name_PerceptionInfraredFrameSourceWatcher = "PerceptionInfraredFrameSourceWatcher";

    static PyObject* _new_PerceptionInfraredFrameSourceWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionInfraredFrameSourceWatcher);
        return nullptr;
    }

    static void _dealloc_PerceptionInfraredFrameSourceWatcher(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_Start(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_Stop(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_get_Status(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_add_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_add_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs>>(arg);

            return py::convert(self->obj.SourceAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_remove_SourceAdded(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_add_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher, winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs>>(arg);

            return py::convert(self->obj.SourceRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_remove_SourceRemoved(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_add_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionInfraredFrameSourceWatcher_remove_Stopped(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionInfraredFrameSourceWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionInfraredFrameSourceWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_Stop), METH_VARARGS, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_source_added", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_add_SourceAdded), METH_O, nullptr },
        { "remove_source_added", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_remove_SourceAdded), METH_O, nullptr },
        { "add_source_removed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_add_SourceRemoved), METH_O, nullptr },
        { "remove_source_removed", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_remove_SourceRemoved), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(PerceptionInfraredFrameSourceWatcher_remove_Stopped), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionInfraredFrameSourceWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionInfraredFrameSourceWatcher[] = {
        { "status", reinterpret_cast<getter>(PerceptionInfraredFrameSourceWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionInfraredFrameSourceWatcher[] = 
    {
        { Py_tp_new, _new_PerceptionInfraredFrameSourceWatcher },
        { Py_tp_dealloc, _dealloc_PerceptionInfraredFrameSourceWatcher },
        { Py_tp_methods, _methods_PerceptionInfraredFrameSourceWatcher },
        { Py_tp_getset, _getset_PerceptionInfraredFrameSourceWatcher },
        { },
    };

    static PyType_Spec type_spec_PerceptionInfraredFrameSourceWatcher =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionInfraredFrameSourceWatcher",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionInfraredFrameSourceWatcher
    };

    // ----- PerceptionVideoProfile class --------------------
    constexpr const char* const type_name_PerceptionVideoProfile = "PerceptionVideoProfile";

    static PyObject* _new_PerceptionVideoProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PerceptionVideoProfile);
        return nullptr;
    }

    static void _dealloc_PerceptionVideoProfile(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PerceptionVideoProfile_IsEqual(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Perception::PerceptionVideoProfile>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_BitmapAlphaMode(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapAlphaMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_BitmapPixelFormat(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapPixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_FrameDuration(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_Height(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PerceptionVideoProfile_get_Width(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PerceptionVideoProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Perception::PerceptionVideoProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PerceptionVideoProfile[] = {
        { "is_equal", reinterpret_cast<PyCFunction>(PerceptionVideoProfile_IsEqual), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PerceptionVideoProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PerceptionVideoProfile[] = {
        { "bitmap_alpha_mode", reinterpret_cast<getter>(PerceptionVideoProfile_get_BitmapAlphaMode), nullptr, nullptr, nullptr },
        { "bitmap_pixel_format", reinterpret_cast<getter>(PerceptionVideoProfile_get_BitmapPixelFormat), nullptr, nullptr, nullptr },
        { "frame_duration", reinterpret_cast<getter>(PerceptionVideoProfile_get_FrameDuration), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(PerceptionVideoProfile_get_Height), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(PerceptionVideoProfile_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PerceptionVideoProfile[] = 
    {
        { Py_tp_new, _new_PerceptionVideoProfile },
        { Py_tp_dealloc, _dealloc_PerceptionVideoProfile },
        { Py_tp_methods, _methods_PerceptionVideoProfile },
        { Py_tp_getset, _getset_PerceptionVideoProfile },
        { },
    };

    static PyType_Spec type_spec_PerceptionVideoProfile =
    {
        "_winsdk_Windows_Devices_Perception.PerceptionVideoProfile",
        sizeof(py::wrapper::Windows::Devices::Perception::PerceptionVideoProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PerceptionVideoProfile
    };

    // ----- Windows.Devices.Perception Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Perception");

    static PyMethodDef module_methods[] = {
        {"_register_PerceptionFrameSourceAccessStatus", register_PerceptionFrameSourceAccessStatus, METH_O, "registers type"},
        {"_register_PerceptionFrameSourcePropertyChangeStatus", register_PerceptionFrameSourcePropertyChangeStatus, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_PerceptionFrameSourceAccessStatus);
        Py_VISIT(state->type_PerceptionFrameSourcePropertyChangeStatus);
        Py_VISIT(state->type_KnownCameraIntrinsicsProperties);
        Py_VISIT(state->type_KnownPerceptionColorFrameSourceProperties);
        Py_VISIT(state->type_KnownPerceptionDepthFrameSourceProperties);
        Py_VISIT(state->type_KnownPerceptionFrameSourceProperties);
        Py_VISIT(state->type_KnownPerceptionInfraredFrameSourceProperties);
        Py_VISIT(state->type_KnownPerceptionVideoFrameSourceProperties);
        Py_VISIT(state->type_KnownPerceptionVideoProfileProperties);
        Py_VISIT(state->type_PerceptionColorFrame);
        Py_VISIT(state->type_PerceptionColorFrameArrivedEventArgs);
        Py_VISIT(state->type_PerceptionColorFrameReader);
        Py_VISIT(state->type_PerceptionColorFrameSource);
        Py_VISIT(state->type_PerceptionColorFrameSourceAddedEventArgs);
        Py_VISIT(state->type_PerceptionColorFrameSourceRemovedEventArgs);
        Py_VISIT(state->type_PerceptionColorFrameSourceWatcher);
        Py_VISIT(state->type_PerceptionControlSession);
        Py_VISIT(state->type_PerceptionDepthCorrelatedCameraIntrinsics);
        Py_VISIT(state->type_PerceptionDepthCorrelatedCoordinateMapper);
        Py_VISIT(state->type_PerceptionDepthFrame);
        Py_VISIT(state->type_PerceptionDepthFrameArrivedEventArgs);
        Py_VISIT(state->type_PerceptionDepthFrameReader);
        Py_VISIT(state->type_PerceptionDepthFrameSource);
        Py_VISIT(state->type_PerceptionDepthFrameSourceAddedEventArgs);
        Py_VISIT(state->type_PerceptionDepthFrameSourceRemovedEventArgs);
        Py_VISIT(state->type_PerceptionDepthFrameSourceWatcher);
        Py_VISIT(state->type_PerceptionFrameSourcePropertiesChangedEventArgs);
        Py_VISIT(state->type_PerceptionFrameSourcePropertyChangeResult);
        Py_VISIT(state->type_PerceptionInfraredFrame);
        Py_VISIT(state->type_PerceptionInfraredFrameArrivedEventArgs);
        Py_VISIT(state->type_PerceptionInfraredFrameReader);
        Py_VISIT(state->type_PerceptionInfraredFrameSource);
        Py_VISIT(state->type_PerceptionInfraredFrameSourceAddedEventArgs);
        Py_VISIT(state->type_PerceptionInfraredFrameSourceRemovedEventArgs);
        Py_VISIT(state->type_PerceptionInfraredFrameSourceWatcher);
        Py_VISIT(state->type_PerceptionVideoProfile);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_PerceptionFrameSourceAccessStatus);
        Py_CLEAR(state->type_PerceptionFrameSourcePropertyChangeStatus);
        Py_CLEAR(state->type_KnownCameraIntrinsicsProperties);
        Py_CLEAR(state->type_KnownPerceptionColorFrameSourceProperties);
        Py_CLEAR(state->type_KnownPerceptionDepthFrameSourceProperties);
        Py_CLEAR(state->type_KnownPerceptionFrameSourceProperties);
        Py_CLEAR(state->type_KnownPerceptionInfraredFrameSourceProperties);
        Py_CLEAR(state->type_KnownPerceptionVideoFrameSourceProperties);
        Py_CLEAR(state->type_KnownPerceptionVideoProfileProperties);
        Py_CLEAR(state->type_PerceptionColorFrame);
        Py_CLEAR(state->type_PerceptionColorFrameArrivedEventArgs);
        Py_CLEAR(state->type_PerceptionColorFrameReader);
        Py_CLEAR(state->type_PerceptionColorFrameSource);
        Py_CLEAR(state->type_PerceptionColorFrameSourceAddedEventArgs);
        Py_CLEAR(state->type_PerceptionColorFrameSourceRemovedEventArgs);
        Py_CLEAR(state->type_PerceptionColorFrameSourceWatcher);
        Py_CLEAR(state->type_PerceptionControlSession);
        Py_CLEAR(state->type_PerceptionDepthCorrelatedCameraIntrinsics);
        Py_CLEAR(state->type_PerceptionDepthCorrelatedCoordinateMapper);
        Py_CLEAR(state->type_PerceptionDepthFrame);
        Py_CLEAR(state->type_PerceptionDepthFrameArrivedEventArgs);
        Py_CLEAR(state->type_PerceptionDepthFrameReader);
        Py_CLEAR(state->type_PerceptionDepthFrameSource);
        Py_CLEAR(state->type_PerceptionDepthFrameSourceAddedEventArgs);
        Py_CLEAR(state->type_PerceptionDepthFrameSourceRemovedEventArgs);
        Py_CLEAR(state->type_PerceptionDepthFrameSourceWatcher);
        Py_CLEAR(state->type_PerceptionFrameSourcePropertiesChangedEventArgs);
        Py_CLEAR(state->type_PerceptionFrameSourcePropertyChangeResult);
        Py_CLEAR(state->type_PerceptionInfraredFrame);
        Py_CLEAR(state->type_PerceptionInfraredFrameArrivedEventArgs);
        Py_CLEAR(state->type_PerceptionInfraredFrameReader);
        Py_CLEAR(state->type_PerceptionInfraredFrameSource);
        Py_CLEAR(state->type_PerceptionInfraredFrameSourceAddedEventArgs);
        Py_CLEAR(state->type_PerceptionInfraredFrameSourceRemovedEventArgs);
        Py_CLEAR(state->type_PerceptionInfraredFrameSourceWatcher);
        Py_CLEAR(state->type_PerceptionVideoProfile);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Perception",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::Perception

PyMODINIT_FUNC PyInit__winsdk_Windows_Devices_Perception(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Perception;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_KnownCameraIntrinsicsProperties = py::register_python_type(module.get(), type_name_KnownCameraIntrinsicsProperties, &type_spec_KnownCameraIntrinsicsProperties, nullptr);
    if (!state->type_KnownCameraIntrinsicsProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_KnownCameraIntrinsicsProperties);

    state->type_KnownPerceptionColorFrameSourceProperties = py::register_python_type(module.get(), type_name_KnownPerceptionColorFrameSourceProperties, &type_spec_KnownPerceptionColorFrameSourceProperties, nullptr);
    if (!state->type_KnownPerceptionColorFrameSourceProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_KnownPerceptionColorFrameSourceProperties);

    state->type_KnownPerceptionDepthFrameSourceProperties = py::register_python_type(module.get(), type_name_KnownPerceptionDepthFrameSourceProperties, &type_spec_KnownPerceptionDepthFrameSourceProperties, nullptr);
    if (!state->type_KnownPerceptionDepthFrameSourceProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_KnownPerceptionDepthFrameSourceProperties);

    state->type_KnownPerceptionFrameSourceProperties = py::register_python_type(module.get(), type_name_KnownPerceptionFrameSourceProperties, &type_spec_KnownPerceptionFrameSourceProperties, nullptr);
    if (!state->type_KnownPerceptionFrameSourceProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_KnownPerceptionFrameSourceProperties);

    state->type_KnownPerceptionInfraredFrameSourceProperties = py::register_python_type(module.get(), type_name_KnownPerceptionInfraredFrameSourceProperties, &type_spec_KnownPerceptionInfraredFrameSourceProperties, nullptr);
    if (!state->type_KnownPerceptionInfraredFrameSourceProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_KnownPerceptionInfraredFrameSourceProperties);

    state->type_KnownPerceptionVideoFrameSourceProperties = py::register_python_type(module.get(), type_name_KnownPerceptionVideoFrameSourceProperties, &type_spec_KnownPerceptionVideoFrameSourceProperties, nullptr);
    if (!state->type_KnownPerceptionVideoFrameSourceProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_KnownPerceptionVideoFrameSourceProperties);

    state->type_KnownPerceptionVideoProfileProperties = py::register_python_type(module.get(), type_name_KnownPerceptionVideoProfileProperties, &type_spec_KnownPerceptionVideoProfileProperties, nullptr);
    if (!state->type_KnownPerceptionVideoProfileProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_KnownPerceptionVideoProfileProperties);

    state->type_PerceptionColorFrame = py::register_python_type(module.get(), type_name_PerceptionColorFrame, &type_spec_PerceptionColorFrame, bases.get());
    if (!state->type_PerceptionColorFrame)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionColorFrame);

    state->type_PerceptionColorFrameArrivedEventArgs = py::register_python_type(module.get(), type_name_PerceptionColorFrameArrivedEventArgs, &type_spec_PerceptionColorFrameArrivedEventArgs, bases.get());
    if (!state->type_PerceptionColorFrameArrivedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionColorFrameArrivedEventArgs);

    state->type_PerceptionColorFrameReader = py::register_python_type(module.get(), type_name_PerceptionColorFrameReader, &type_spec_PerceptionColorFrameReader, bases.get());
    if (!state->type_PerceptionColorFrameReader)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionColorFrameReader);

    state->type_PerceptionColorFrameSource = py::register_python_type(module.get(), type_name_PerceptionColorFrameSource, &type_spec_PerceptionColorFrameSource, bases.get());
    if (!state->type_PerceptionColorFrameSource)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionColorFrameSource);

    state->type_PerceptionColorFrameSourceAddedEventArgs = py::register_python_type(module.get(), type_name_PerceptionColorFrameSourceAddedEventArgs, &type_spec_PerceptionColorFrameSourceAddedEventArgs, bases.get());
    if (!state->type_PerceptionColorFrameSourceAddedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionColorFrameSourceAddedEventArgs);

    state->type_PerceptionColorFrameSourceRemovedEventArgs = py::register_python_type(module.get(), type_name_PerceptionColorFrameSourceRemovedEventArgs, &type_spec_PerceptionColorFrameSourceRemovedEventArgs, bases.get());
    if (!state->type_PerceptionColorFrameSourceRemovedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionColorFrameSourceRemovedEventArgs);

    state->type_PerceptionColorFrameSourceWatcher = py::register_python_type(module.get(), type_name_PerceptionColorFrameSourceWatcher, &type_spec_PerceptionColorFrameSourceWatcher, bases.get());
    if (!state->type_PerceptionColorFrameSourceWatcher)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionColorFrameSourceWatcher);

    state->type_PerceptionControlSession = py::register_python_type(module.get(), type_name_PerceptionControlSession, &type_spec_PerceptionControlSession, bases.get());
    if (!state->type_PerceptionControlSession)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionControlSession);

    state->type_PerceptionDepthCorrelatedCameraIntrinsics = py::register_python_type(module.get(), type_name_PerceptionDepthCorrelatedCameraIntrinsics, &type_spec_PerceptionDepthCorrelatedCameraIntrinsics, bases.get());
    if (!state->type_PerceptionDepthCorrelatedCameraIntrinsics)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionDepthCorrelatedCameraIntrinsics);

    state->type_PerceptionDepthCorrelatedCoordinateMapper = py::register_python_type(module.get(), type_name_PerceptionDepthCorrelatedCoordinateMapper, &type_spec_PerceptionDepthCorrelatedCoordinateMapper, bases.get());
    if (!state->type_PerceptionDepthCorrelatedCoordinateMapper)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionDepthCorrelatedCoordinateMapper);

    state->type_PerceptionDepthFrame = py::register_python_type(module.get(), type_name_PerceptionDepthFrame, &type_spec_PerceptionDepthFrame, bases.get());
    if (!state->type_PerceptionDepthFrame)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionDepthFrame);

    state->type_PerceptionDepthFrameArrivedEventArgs = py::register_python_type(module.get(), type_name_PerceptionDepthFrameArrivedEventArgs, &type_spec_PerceptionDepthFrameArrivedEventArgs, bases.get());
    if (!state->type_PerceptionDepthFrameArrivedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionDepthFrameArrivedEventArgs);

    state->type_PerceptionDepthFrameReader = py::register_python_type(module.get(), type_name_PerceptionDepthFrameReader, &type_spec_PerceptionDepthFrameReader, bases.get());
    if (!state->type_PerceptionDepthFrameReader)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionDepthFrameReader);

    state->type_PerceptionDepthFrameSource = py::register_python_type(module.get(), type_name_PerceptionDepthFrameSource, &type_spec_PerceptionDepthFrameSource, bases.get());
    if (!state->type_PerceptionDepthFrameSource)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionDepthFrameSource);

    state->type_PerceptionDepthFrameSourceAddedEventArgs = py::register_python_type(module.get(), type_name_PerceptionDepthFrameSourceAddedEventArgs, &type_spec_PerceptionDepthFrameSourceAddedEventArgs, bases.get());
    if (!state->type_PerceptionDepthFrameSourceAddedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionDepthFrameSourceAddedEventArgs);

    state->type_PerceptionDepthFrameSourceRemovedEventArgs = py::register_python_type(module.get(), type_name_PerceptionDepthFrameSourceRemovedEventArgs, &type_spec_PerceptionDepthFrameSourceRemovedEventArgs, bases.get());
    if (!state->type_PerceptionDepthFrameSourceRemovedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionDepthFrameSourceRemovedEventArgs);

    state->type_PerceptionDepthFrameSourceWatcher = py::register_python_type(module.get(), type_name_PerceptionDepthFrameSourceWatcher, &type_spec_PerceptionDepthFrameSourceWatcher, bases.get());
    if (!state->type_PerceptionDepthFrameSourceWatcher)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionDepthFrameSourceWatcher);

    state->type_PerceptionFrameSourcePropertiesChangedEventArgs = py::register_python_type(module.get(), type_name_PerceptionFrameSourcePropertiesChangedEventArgs, &type_spec_PerceptionFrameSourcePropertiesChangedEventArgs, bases.get());
    if (!state->type_PerceptionFrameSourcePropertiesChangedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionFrameSourcePropertiesChangedEventArgs);

    state->type_PerceptionFrameSourcePropertyChangeResult = py::register_python_type(module.get(), type_name_PerceptionFrameSourcePropertyChangeResult, &type_spec_PerceptionFrameSourcePropertyChangeResult, bases.get());
    if (!state->type_PerceptionFrameSourcePropertyChangeResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionFrameSourcePropertyChangeResult);

    state->type_PerceptionInfraredFrame = py::register_python_type(module.get(), type_name_PerceptionInfraredFrame, &type_spec_PerceptionInfraredFrame, bases.get());
    if (!state->type_PerceptionInfraredFrame)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionInfraredFrame);

    state->type_PerceptionInfraredFrameArrivedEventArgs = py::register_python_type(module.get(), type_name_PerceptionInfraredFrameArrivedEventArgs, &type_spec_PerceptionInfraredFrameArrivedEventArgs, bases.get());
    if (!state->type_PerceptionInfraredFrameArrivedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionInfraredFrameArrivedEventArgs);

    state->type_PerceptionInfraredFrameReader = py::register_python_type(module.get(), type_name_PerceptionInfraredFrameReader, &type_spec_PerceptionInfraredFrameReader, bases.get());
    if (!state->type_PerceptionInfraredFrameReader)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionInfraredFrameReader);

    state->type_PerceptionInfraredFrameSource = py::register_python_type(module.get(), type_name_PerceptionInfraredFrameSource, &type_spec_PerceptionInfraredFrameSource, bases.get());
    if (!state->type_PerceptionInfraredFrameSource)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionInfraredFrameSource);

    state->type_PerceptionInfraredFrameSourceAddedEventArgs = py::register_python_type(module.get(), type_name_PerceptionInfraredFrameSourceAddedEventArgs, &type_spec_PerceptionInfraredFrameSourceAddedEventArgs, bases.get());
    if (!state->type_PerceptionInfraredFrameSourceAddedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionInfraredFrameSourceAddedEventArgs);

    state->type_PerceptionInfraredFrameSourceRemovedEventArgs = py::register_python_type(module.get(), type_name_PerceptionInfraredFrameSourceRemovedEventArgs, &type_spec_PerceptionInfraredFrameSourceRemovedEventArgs, bases.get());
    if (!state->type_PerceptionInfraredFrameSourceRemovedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionInfraredFrameSourceRemovedEventArgs);

    state->type_PerceptionInfraredFrameSourceWatcher = py::register_python_type(module.get(), type_name_PerceptionInfraredFrameSourceWatcher, &type_spec_PerceptionInfraredFrameSourceWatcher, bases.get());
    if (!state->type_PerceptionInfraredFrameSourceWatcher)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionInfraredFrameSourceWatcher);

    state->type_PerceptionVideoProfile = py::register_python_type(module.get(), type_name_PerceptionVideoProfile, &type_spec_PerceptionVideoProfile, bases.get());
    if (!state->type_PerceptionVideoProfile)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PerceptionVideoProfile);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Devices::Perception::PerceptionFrameSourceAccessStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionFrameSourceAccessStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionFrameSourceAccessStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionFrameSourcePropertyChangeStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownCameraIntrinsicsProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::KnownCameraIntrinsicsProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownPerceptionColorFrameSourceProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::KnownPerceptionColorFrameSourceProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::KnownPerceptionDepthFrameSourceProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownPerceptionDepthFrameSourceProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::KnownPerceptionDepthFrameSourceProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownPerceptionFrameSourceProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::KnownPerceptionFrameSourceProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownPerceptionInfraredFrameSourceProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::KnownPerceptionInfraredFrameSourceProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownPerceptionVideoFrameSourceProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::KnownPerceptionVideoFrameSourceProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownPerceptionVideoProfileProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::KnownPerceptionVideoProfileProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionColorFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionColorFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionColorFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionColorFrameArrivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionColorFrameArrivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionColorFrameReader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionColorFrameReader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionColorFrameReader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionColorFrameSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionColorFrameSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionColorFrameSourceAddedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionColorFrameSourceAddedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionColorFrameSourceRemovedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionColorFrameSourceRemovedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionColorFrameSourceWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionColorFrameSourceWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionControlSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionControlSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionControlSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthCorrelatedCameraIntrinsics;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCameraIntrinsics is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthCorrelatedCoordinateMapper;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthCorrelatedCoordinateMapper is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthFrameArrivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthFrameArrivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameReader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthFrameReader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthFrameReader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthFrameSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthFrameSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthFrameSourceAddedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceAddedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthFrameSourceRemovedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceRemovedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionDepthFrameSourceWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionDepthFrameSourceWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionFrameSourcePropertiesChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertiesChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionFrameSourcePropertyChangeResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionFrameSourcePropertyChangeResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionInfraredFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionInfraredFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionInfraredFrameArrivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionInfraredFrameArrivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameReader>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionInfraredFrameReader;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionInfraredFrameReader is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionInfraredFrameSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionInfraredFrameSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionInfraredFrameSourceAddedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceAddedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionInfraredFrameSourceRemovedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceRemovedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionInfraredFrameSourceWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionInfraredFrameSourceWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Perception::PerceptionVideoProfile>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Perception;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Perception");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PerceptionVideoProfile;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Perception::PerceptionVideoProfile is not registered");
        return nullptr;
    }

    return python_type;
}
