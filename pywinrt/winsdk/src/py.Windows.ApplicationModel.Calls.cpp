// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.ApplicationModel.Calls.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCall>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilitiesManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallsResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLine>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineCellularDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineDialResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneVoicemail>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall>::python_type;

namespace py::cpp::Windows::ApplicationModel::Calls
{
    // ----- CallAnswerEventArgs class --------------------
    constexpr const char* const _type_name_CallAnswerEventArgs = "CallAnswerEventArgs";

    static PyObject* _new_CallAnswerEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CallAnswerEventArgs);
        return nullptr;
    }

    static void _dealloc_CallAnswerEventArgs(py::wrapper::Windows::ApplicationModel::Calls::CallAnswerEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CallAnswerEventArgs_get_AcceptedMedia(py::wrapper::Windows::ApplicationModel::Calls::CallAnswerEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AcceptedMedia());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CallAnswerEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CallAnswerEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CallAnswerEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CallAnswerEventArgs[] = {
        { "accepted_media", reinterpret_cast<getter>(CallAnswerEventArgs_get_AcceptedMedia), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CallAnswerEventArgs[] = 
    {
        { Py_tp_new, _new_CallAnswerEventArgs },
        { Py_tp_dealloc, _dealloc_CallAnswerEventArgs },
        { Py_tp_methods, _methods_CallAnswerEventArgs },
        { Py_tp_getset, _getset_CallAnswerEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CallAnswerEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Calls.CallAnswerEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::CallAnswerEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CallAnswerEventArgs
    };

    // ----- CallRejectEventArgs class --------------------
    constexpr const char* const _type_name_CallRejectEventArgs = "CallRejectEventArgs";

    static PyObject* _new_CallRejectEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CallRejectEventArgs);
        return nullptr;
    }

    static void _dealloc_CallRejectEventArgs(py::wrapper::Windows::ApplicationModel::Calls::CallRejectEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CallRejectEventArgs_get_RejectReason(py::wrapper::Windows::ApplicationModel::Calls::CallRejectEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RejectReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CallRejectEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CallRejectEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CallRejectEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CallRejectEventArgs[] = {
        { "reject_reason", reinterpret_cast<getter>(CallRejectEventArgs_get_RejectReason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CallRejectEventArgs[] = 
    {
        { Py_tp_new, _new_CallRejectEventArgs },
        { Py_tp_dealloc, _dealloc_CallRejectEventArgs },
        { Py_tp_methods, _methods_CallRejectEventArgs },
        { Py_tp_getset, _getset_CallRejectEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CallRejectEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Calls.CallRejectEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::CallRejectEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CallRejectEventArgs
    };

    // ----- CallStateChangeEventArgs class --------------------
    constexpr const char* const _type_name_CallStateChangeEventArgs = "CallStateChangeEventArgs";

    static PyObject* _new_CallStateChangeEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CallStateChangeEventArgs);
        return nullptr;
    }

    static void _dealloc_CallStateChangeEventArgs(py::wrapper::Windows::ApplicationModel::Calls::CallStateChangeEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CallStateChangeEventArgs_get_State(py::wrapper::Windows::ApplicationModel::Calls::CallStateChangeEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CallStateChangeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CallStateChangeEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CallStateChangeEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CallStateChangeEventArgs[] = {
        { "state", reinterpret_cast<getter>(CallStateChangeEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CallStateChangeEventArgs[] = 
    {
        { Py_tp_new, _new_CallStateChangeEventArgs },
        { Py_tp_dealloc, _dealloc_CallStateChangeEventArgs },
        { Py_tp_methods, _methods_CallStateChangeEventArgs },
        { Py_tp_getset, _getset_CallStateChangeEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CallStateChangeEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Calls.CallStateChangeEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::CallStateChangeEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CallStateChangeEventArgs
    };

    // ----- MuteChangeEventArgs class --------------------
    constexpr const char* const _type_name_MuteChangeEventArgs = "MuteChangeEventArgs";

    static PyObject* _new_MuteChangeEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MuteChangeEventArgs);
        return nullptr;
    }

    static void _dealloc_MuteChangeEventArgs(py::wrapper::Windows::ApplicationModel::Calls::MuteChangeEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MuteChangeEventArgs_get_Muted(py::wrapper::Windows::ApplicationModel::Calls::MuteChangeEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Muted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MuteChangeEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MuteChangeEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MuteChangeEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MuteChangeEventArgs[] = {
        { "muted", reinterpret_cast<getter>(MuteChangeEventArgs_get_Muted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MuteChangeEventArgs[] = 
    {
        { Py_tp_new, _new_MuteChangeEventArgs },
        { Py_tp_dealloc, _dealloc_MuteChangeEventArgs },
        { Py_tp_methods, _methods_MuteChangeEventArgs },
        { Py_tp_getset, _getset_MuteChangeEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MuteChangeEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Calls.MuteChangeEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::MuteChangeEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MuteChangeEventArgs
    };

    // ----- PhoneCall class --------------------
    constexpr const char* const _type_name_PhoneCall = "PhoneCall";

    static PyObject* _new_PhoneCall(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCall);
        return nullptr;
    }

    static void _dealloc_PhoneCall(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCall_AcceptIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AcceptIncoming());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_AcceptIncomingAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.AcceptIncomingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ChangeAudioDevice(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallAudioDevice>(args, 0);

                return py::convert(self->obj.ChangeAudioDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ChangeAudioDeviceAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallAudioDevice>(args, 0);

                return py::convert(self->obj.ChangeAudioDeviceAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_End(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.End());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_EndAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.EndAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_GetFromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCall::GetFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_GetPhoneCallInfo(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPhoneCallInfo());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_GetPhoneCallInfoAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPhoneCallInfoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_Hold(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Hold());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_HoldAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.HoldAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_Mute(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Mute());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_MuteAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.MuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_RejectIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RejectIncoming());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_RejectIncomingAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RejectIncomingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ResumeFromHold(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ResumeFromHold());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_ResumeFromHoldAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ResumeFromHoldAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_SendDtmfKey(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfToneAudioPlayback>(args, 1);

                return py::convert(self->obj.SendDtmfKey(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_SendDtmfKeyAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfKey>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Calls::DtmfToneAudioPlayback>(args, 1);

                return py::convert(self->obj.SendDtmfKeyAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_Unmute(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Unmute());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_UnmuteAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.UnmuteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_AudioDevice(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_CallId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_IsMuted(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMuted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_get_Status(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_add_AudioDeviceChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneCall, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioDeviceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_remove_AudioDeviceChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioDeviceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_add_IsMutedChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneCall, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsMutedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_remove_IsMutedChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsMutedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_add_StatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneCall, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCall_remove_StatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCall(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCall>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCall[] = {
        { "accept_incoming", reinterpret_cast<PyCFunction>(PhoneCall_AcceptIncoming), METH_VARARGS, nullptr },
        { "accept_incoming_async", reinterpret_cast<PyCFunction>(PhoneCall_AcceptIncomingAsync), METH_VARARGS, nullptr },
        { "change_audio_device", reinterpret_cast<PyCFunction>(PhoneCall_ChangeAudioDevice), METH_VARARGS, nullptr },
        { "change_audio_device_async", reinterpret_cast<PyCFunction>(PhoneCall_ChangeAudioDeviceAsync), METH_VARARGS, nullptr },
        { "end", reinterpret_cast<PyCFunction>(PhoneCall_End), METH_VARARGS, nullptr },
        { "end_async", reinterpret_cast<PyCFunction>(PhoneCall_EndAsync), METH_VARARGS, nullptr },
        { "get_from_id", reinterpret_cast<PyCFunction>(PhoneCall_GetFromId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_phone_call_info", reinterpret_cast<PyCFunction>(PhoneCall_GetPhoneCallInfo), METH_VARARGS, nullptr },
        { "get_phone_call_info_async", reinterpret_cast<PyCFunction>(PhoneCall_GetPhoneCallInfoAsync), METH_VARARGS, nullptr },
        { "hold", reinterpret_cast<PyCFunction>(PhoneCall_Hold), METH_VARARGS, nullptr },
        { "hold_async", reinterpret_cast<PyCFunction>(PhoneCall_HoldAsync), METH_VARARGS, nullptr },
        { "mute", reinterpret_cast<PyCFunction>(PhoneCall_Mute), METH_VARARGS, nullptr },
        { "mute_async", reinterpret_cast<PyCFunction>(PhoneCall_MuteAsync), METH_VARARGS, nullptr },
        { "reject_incoming", reinterpret_cast<PyCFunction>(PhoneCall_RejectIncoming), METH_VARARGS, nullptr },
        { "reject_incoming_async", reinterpret_cast<PyCFunction>(PhoneCall_RejectIncomingAsync), METH_VARARGS, nullptr },
        { "resume_from_hold", reinterpret_cast<PyCFunction>(PhoneCall_ResumeFromHold), METH_VARARGS, nullptr },
        { "resume_from_hold_async", reinterpret_cast<PyCFunction>(PhoneCall_ResumeFromHoldAsync), METH_VARARGS, nullptr },
        { "send_dtmf_key", reinterpret_cast<PyCFunction>(PhoneCall_SendDtmfKey), METH_VARARGS, nullptr },
        { "send_dtmf_key_async", reinterpret_cast<PyCFunction>(PhoneCall_SendDtmfKeyAsync), METH_VARARGS, nullptr },
        { "unmute", reinterpret_cast<PyCFunction>(PhoneCall_Unmute), METH_VARARGS, nullptr },
        { "unmute_async", reinterpret_cast<PyCFunction>(PhoneCall_UnmuteAsync), METH_VARARGS, nullptr },
        { "add_audio_device_changed", reinterpret_cast<PyCFunction>(PhoneCall_add_AudioDeviceChanged), METH_O, nullptr },
        { "remove_audio_device_changed", reinterpret_cast<PyCFunction>(PhoneCall_remove_AudioDeviceChanged), METH_O, nullptr },
        { "add_is_muted_changed", reinterpret_cast<PyCFunction>(PhoneCall_add_IsMutedChanged), METH_O, nullptr },
        { "remove_is_muted_changed", reinterpret_cast<PyCFunction>(PhoneCall_remove_IsMutedChanged), METH_O, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(PhoneCall_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(PhoneCall_remove_StatusChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCall), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCall[] = {
        { "audio_device", reinterpret_cast<getter>(PhoneCall_get_AudioDevice), nullptr, nullptr, nullptr },
        { "call_id", reinterpret_cast<getter>(PhoneCall_get_CallId), nullptr, nullptr, nullptr },
        { "is_muted", reinterpret_cast<getter>(PhoneCall_get_IsMuted), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(PhoneCall_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCall[] = 
    {
        { Py_tp_new, _new_PhoneCall },
        { Py_tp_dealloc, _dealloc_PhoneCall },
        { Py_tp_methods, _methods_PhoneCall },
        { Py_tp_getset, _getset_PhoneCall },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCall =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCall",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCall),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCall
    };

    // ----- PhoneCallBlocking class --------------------
    constexpr const char* const _type_name_PhoneCallBlocking = "PhoneCallBlocking";

    static PyObject* _new_PhoneCallBlocking(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallBlocking);
        return nullptr;
    }

    static PyObject* PhoneCallBlocking_SetCallBlockingListAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::SetCallBlockingListAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_get_BlockUnknownNumbers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockUnknownNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_put_BlockUnknownNumbers(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockUnknownNumbers(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_get_BlockPrivateNumbers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockPrivateNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallBlocking_put_BlockPrivateNumbers(PyObject* /*unused*/, PyObject* arg, void* /*unused*/) noexcept
    {
        try
        {
            auto param0 = py::convert_to<bool>(arg);

            winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking::BlockPrivateNumbers(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallBlocking[] = {
        { "set_call_blocking_list_async", reinterpret_cast<PyCFunction>(PhoneCallBlocking_SetCallBlockingListAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_block_unknown_numbers", reinterpret_cast<PyCFunction>(PhoneCallBlocking_get_BlockUnknownNumbers), METH_NOARGS | METH_STATIC, nullptr },
        { "put_block_unknown_numbers", reinterpret_cast<PyCFunction>(PhoneCallBlocking_put_BlockUnknownNumbers), METH_O | METH_STATIC, nullptr },
        { "get_block_private_numbers", reinterpret_cast<PyCFunction>(PhoneCallBlocking_get_BlockPrivateNumbers), METH_NOARGS | METH_STATIC, nullptr },
        { "put_block_private_numbers", reinterpret_cast<PyCFunction>(PhoneCallBlocking_put_BlockPrivateNumbers), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallBlocking[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallBlocking[] = 
    {
        { Py_tp_new, _new_PhoneCallBlocking },
        { Py_tp_methods, _methods_PhoneCallBlocking },
        { Py_tp_getset, _getset_PhoneCallBlocking },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallBlocking =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallBlocking",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallBlocking
    };

    // ----- PhoneCallHistoryEntry class --------------------
    constexpr const char* const _type_name_PhoneCallHistoryEntry = "PhoneCallHistoryEntry";

    static PyObject* _new_PhoneCallHistoryEntry(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneCallHistoryEntry(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallHistoryEntry_get_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Media());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryMedia>(arg);

            self->obj.Media(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsMissed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMissed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsMissed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMissed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsIncoming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsIncoming(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsIncoming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsCallerIdBlocked(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCallerIdBlocked());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsCallerIdBlocked(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCallerIdBlocked(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsSeen(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSeen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsSeen(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSeen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_Duration(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_Duration(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsEmergency(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEmergency());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsEmergency(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEmergency(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsSuppressed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSuppressed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsSuppressed(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSuppressed(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_StartTime(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_StartTime(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_SourceIdKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceIdKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_SourceIdKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistorySourceIdKind>(arg);

            self->obj.SourceIdKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_Address(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_Address(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_SourceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_SourceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SourceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_RemoteId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_RemoteId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OtherAppReadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryOtherAppReadAccess>(arg);

            self->obj.OtherAppReadAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsRinging(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRinging());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsRinging(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRinging(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_IsVoicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVoicemail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntry_put_IsVoicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsVoicemail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_Id(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryEntry_get_SourceDisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallHistoryEntry(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntry[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryEntry), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntry[] = {
        { "media", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_Media), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_Media), nullptr, nullptr },
        { "is_missed", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsMissed), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsMissed), nullptr, nullptr },
        { "is_incoming", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsIncoming), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsIncoming), nullptr, nullptr },
        { "is_caller_id_blocked", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsCallerIdBlocked), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsCallerIdBlocked), nullptr, nullptr },
        { "is_seen", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsSeen), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsSeen), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_Duration), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_Duration), nullptr, nullptr },
        { "is_emergency", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsEmergency), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsEmergency), nullptr, nullptr },
        { "is_suppressed", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsSuppressed), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsSuppressed), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_StartTime), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_StartTime), nullptr, nullptr },
        { "source_id_kind", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_SourceIdKind), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_SourceIdKind), nullptr, nullptr },
        { "address", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_Address), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_Address), nullptr, nullptr },
        { "source_id", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_SourceId), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_SourceId), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_RemoteId), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_RemoteId), nullptr, nullptr },
        { "other_app_read_access", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_OtherAppReadAccess), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_OtherAppReadAccess), nullptr, nullptr },
        { "is_ringing", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsRinging), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsRinging), nullptr, nullptr },
        { "is_voicemail", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_IsVoicemail), reinterpret_cast<setter>(PhoneCallHistoryEntry_put_IsVoicemail), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_Id), nullptr, nullptr, nullptr },
        { "source_display_name", reinterpret_cast<getter>(PhoneCallHistoryEntry_get_SourceDisplayName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntry[] = 
    {
        { Py_tp_new, _new_PhoneCallHistoryEntry },
        { Py_tp_dealloc, _dealloc_PhoneCallHistoryEntry },
        { Py_tp_methods, _methods_PhoneCallHistoryEntry },
        { Py_tp_getset, _getset_PhoneCallHistoryEntry },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallHistoryEntry =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallHistoryEntry",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntry
    };

    // ----- PhoneCallHistoryEntryAddress class --------------------
    constexpr const char* const _type_name_PhoneCallHistoryEntryAddress = "PhoneCallHistoryEntryAddress";

    static PyObject* _new_PhoneCallHistoryEntryAddress(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryRawAddressKind>(args, 1);

                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneCallHistoryEntryAddress(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_RawAddressKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawAddressKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_RawAddressKind(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryRawAddressKind>(arg);

            self->obj.RawAddressKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_RawAddress(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_RawAddress(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RawAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryAddress_get_ContactId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryAddress_put_ContactId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_PhoneCallHistoryEntryAddress(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntryAddress[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryEntryAddress), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntryAddress[] = {
        { "raw_address_kind", reinterpret_cast<getter>(PhoneCallHistoryEntryAddress_get_RawAddressKind), reinterpret_cast<setter>(PhoneCallHistoryEntryAddress_put_RawAddressKind), nullptr, nullptr },
        { "raw_address", reinterpret_cast<getter>(PhoneCallHistoryEntryAddress_get_RawAddress), reinterpret_cast<setter>(PhoneCallHistoryEntryAddress_put_RawAddress), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneCallHistoryEntryAddress_get_DisplayName), reinterpret_cast<setter>(PhoneCallHistoryEntryAddress_put_DisplayName), nullptr, nullptr },
        { "contact_id", reinterpret_cast<getter>(PhoneCallHistoryEntryAddress_get_ContactId), reinterpret_cast<setter>(PhoneCallHistoryEntryAddress_put_ContactId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntryAddress[] = 
    {
        { Py_tp_new, _new_PhoneCallHistoryEntryAddress },
        { Py_tp_dealloc, _dealloc_PhoneCallHistoryEntryAddress },
        { Py_tp_methods, _methods_PhoneCallHistoryEntryAddress },
        { Py_tp_getset, _getset_PhoneCallHistoryEntryAddress },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallHistoryEntryAddress =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallHistoryEntryAddress",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntryAddress
    };

    // ----- PhoneCallHistoryEntryQueryOptions class --------------------
    constexpr const char* const _type_name_PhoneCallHistoryEntryQueryOptions = "PhoneCallHistoryEntryQueryOptions";

    static PyObject* _new_PhoneCallHistoryEntryQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneCallHistoryEntryQueryOptions(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallHistoryEntryQueryOptions_get_DesiredMedia(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredMedia());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneCallHistoryEntryQueryOptions_put_DesiredMedia(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryDesiredMedia>(arg);

            self->obj.DesiredMedia(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneCallHistoryEntryQueryOptions_get_SourceIds(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallHistoryEntryQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntryQueryOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryEntryQueryOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntryQueryOptions[] = {
        { "desired_media", reinterpret_cast<getter>(PhoneCallHistoryEntryQueryOptions_get_DesiredMedia), reinterpret_cast<setter>(PhoneCallHistoryEntryQueryOptions_put_DesiredMedia), nullptr, nullptr },
        { "source_ids", reinterpret_cast<getter>(PhoneCallHistoryEntryQueryOptions_get_SourceIds), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntryQueryOptions[] = 
    {
        { Py_tp_new, _new_PhoneCallHistoryEntryQueryOptions },
        { Py_tp_dealloc, _dealloc_PhoneCallHistoryEntryQueryOptions },
        { Py_tp_methods, _methods_PhoneCallHistoryEntryQueryOptions },
        { Py_tp_getset, _getset_PhoneCallHistoryEntryQueryOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallHistoryEntryQueryOptions =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallHistoryEntryQueryOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntryQueryOptions
    };

    // ----- PhoneCallHistoryEntryReader class --------------------
    constexpr const char* const _type_name_PhoneCallHistoryEntryReader = "PhoneCallHistoryEntryReader";

    static PyObject* _new_PhoneCallHistoryEntryReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallHistoryEntryReader);
        return nullptr;
    }

    static void _dealloc_PhoneCallHistoryEntryReader(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallHistoryEntryReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallHistoryEntryReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryEntryReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryEntryReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryEntryReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryEntryReader[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryEntryReader[] = 
    {
        { Py_tp_new, _new_PhoneCallHistoryEntryReader },
        { Py_tp_dealloc, _dealloc_PhoneCallHistoryEntryReader },
        { Py_tp_methods, _methods_PhoneCallHistoryEntryReader },
        { Py_tp_getset, _getset_PhoneCallHistoryEntryReader },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallHistoryEntryReader =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallHistoryEntryReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryEntryReader
    };

    // ----- PhoneCallHistoryManager class --------------------
    constexpr const char* const _type_name_PhoneCallHistoryManager = "PhoneCallHistoryManager";

    static PyObject* _new_PhoneCallHistoryManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallHistoryManager);
        return nullptr;
    }

    static PyObject* PhoneCallHistoryManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStoreAccessType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager::RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryManager[] = {
        { "get_for_user", reinterpret_cast<PyCFunction>(PhoneCallHistoryManager_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "request_store_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryManager_RequestStoreAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryManager[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryManager[] = 
    {
        { Py_tp_new, _new_PhoneCallHistoryManager },
        { Py_tp_methods, _methods_PhoneCallHistoryManager },
        { Py_tp_getset, _getset_PhoneCallHistoryManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallHistoryManager =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallHistoryManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryManager
    };

    // ----- PhoneCallHistoryManagerForUser class --------------------
    constexpr const char* const _type_name_PhoneCallHistoryManagerForUser = "PhoneCallHistoryManagerForUser";

    static PyObject* _new_PhoneCallHistoryManagerForUser(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallHistoryManagerForUser);
        return nullptr;
    }

    static void _dealloc_PhoneCallHistoryManagerForUser(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallHistoryManagerForUser_RequestStoreAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStoreAccessType>(args, 0);

                return py::convert(self->obj.RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryManagerForUser_get_User(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallHistoryManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryManagerForUser[] = {
        { "request_store_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryManagerForUser_RequestStoreAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryManagerForUser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryManagerForUser[] = {
        { "user", reinterpret_cast<getter>(PhoneCallHistoryManagerForUser_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryManagerForUser[] = 
    {
        { Py_tp_new, _new_PhoneCallHistoryManagerForUser },
        { Py_tp_dealloc, _dealloc_PhoneCallHistoryManagerForUser },
        { Py_tp_methods, _methods_PhoneCallHistoryManagerForUser },
        { Py_tp_getset, _getset_PhoneCallHistoryManagerForUser },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallHistoryManagerForUser =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallHistoryManagerForUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryManagerForUser
    };

    // ----- PhoneCallHistoryStore class --------------------
    constexpr const char* const _type_name_PhoneCallHistoryStore = "PhoneCallHistoryStore";

    static PyObject* _new_PhoneCallHistoryStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallHistoryStore);
        return nullptr;
    }

    static void _dealloc_PhoneCallHistoryStore(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallHistoryStore_DeleteEntriesAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>>(args, 0);

                return py::convert(self->obj.DeleteEntriesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_DeleteEntryAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>(args, 0);

                return py::convert(self->obj.DeleteEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetEntryAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetEntryReader(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetEntryReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>(args, 0);

                return py::convert(self->obj.GetEntryReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetSourcesUnseenCountAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetSourcesUnseenCountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_GetUnseenCountAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetUnseenCountAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkAllAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.MarkAllAsSeenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkEntriesAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>>(args, 0);

                return py::convert(self->obj.MarkEntriesAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkEntryAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>(args, 0);

                return py::convert(self->obj.MarkEntryAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_MarkSourcesAsSeenAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.MarkSourcesAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallHistoryStore_SaveEntryAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>(args, 0);

                return py::convert(self->obj.SaveEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallHistoryStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallHistoryStore[] = {
        { "delete_entries_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_DeleteEntriesAsync), METH_VARARGS, nullptr },
        { "delete_entry_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_DeleteEntryAsync), METH_VARARGS, nullptr },
        { "get_entry_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_GetEntryAsync), METH_VARARGS, nullptr },
        { "get_entry_reader", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_GetEntryReader), METH_VARARGS, nullptr },
        { "get_sources_unseen_count_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_GetSourcesUnseenCountAsync), METH_VARARGS, nullptr },
        { "get_unseen_count_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_GetUnseenCountAsync), METH_VARARGS, nullptr },
        { "mark_all_as_seen_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_MarkAllAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_entries_as_seen_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_MarkEntriesAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_entry_as_seen_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_MarkEntryAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_sources_as_seen_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_MarkSourcesAsSeenAsync), METH_VARARGS, nullptr },
        { "save_entry_async", reinterpret_cast<PyCFunction>(PhoneCallHistoryStore_SaveEntryAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallHistoryStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallHistoryStore[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallHistoryStore[] = 
    {
        { Py_tp_new, _new_PhoneCallHistoryStore },
        { Py_tp_dealloc, _dealloc_PhoneCallHistoryStore },
        { Py_tp_methods, _methods_PhoneCallHistoryStore },
        { Py_tp_getset, _getset_PhoneCallHistoryStore },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallHistoryStore =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallHistoryStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallHistoryStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallHistoryStore
    };

    // ----- PhoneCallInfo class --------------------
    constexpr const char* const _type_name_PhoneCallInfo = "PhoneCallInfo";

    static PyObject* _new_PhoneCallInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallInfo);
        return nullptr;
    }

    static void _dealloc_PhoneCallInfo(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallInfo_get_CallDirection(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_IsHoldSupported(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHoldSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_LineId(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_PhoneNumber(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhoneNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallInfo_get_StartTime(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallInfo[] = {
        { "call_direction", reinterpret_cast<getter>(PhoneCallInfo_get_CallDirection), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneCallInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_hold_supported", reinterpret_cast<getter>(PhoneCallInfo_get_IsHoldSupported), nullptr, nullptr, nullptr },
        { "line_id", reinterpret_cast<getter>(PhoneCallInfo_get_LineId), nullptr, nullptr, nullptr },
        { "phone_number", reinterpret_cast<getter>(PhoneCallInfo_get_PhoneNumber), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(PhoneCallInfo_get_StartTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallInfo[] = 
    {
        { Py_tp_new, _new_PhoneCallInfo },
        { Py_tp_dealloc, _dealloc_PhoneCallInfo },
        { Py_tp_methods, _methods_PhoneCallInfo },
        { Py_tp_getset, _getset_PhoneCallInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallInfo =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallInfo
    };

    // ----- PhoneCallManager class --------------------
    constexpr const char* const _type_name_PhoneCallManager = "PhoneCallManager";

    static PyObject* _new_PhoneCallManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallManager);
        return nullptr;
    }

    static PyObject* PhoneCallManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::RequestStoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_ShowPhoneCallSettingsUI(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneCallManager::ShowPhoneCallSettingsUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_ShowPhoneCallUI(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Calls::PhoneCallManager::ShowPhoneCallUI(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_get_IsCallActive(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::IsCallActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_get_IsCallIncoming(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::IsCallIncoming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_add_CallStateChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallManager::CallStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallManager_remove_CallStateChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::Calls::PhoneCallManager::CallStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallManager[] = {
        { "request_store_async", reinterpret_cast<PyCFunction>(PhoneCallManager_RequestStoreAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_phone_call_settings_u_i", reinterpret_cast<PyCFunction>(PhoneCallManager_ShowPhoneCallSettingsUI), METH_VARARGS | METH_STATIC, nullptr },
        { "show_phone_call_u_i", reinterpret_cast<PyCFunction>(PhoneCallManager_ShowPhoneCallUI), METH_VARARGS | METH_STATIC, nullptr },
        { "get_is_call_active", reinterpret_cast<PyCFunction>(PhoneCallManager_get_IsCallActive), METH_NOARGS | METH_STATIC, nullptr },
        { "get_is_call_incoming", reinterpret_cast<PyCFunction>(PhoneCallManager_get_IsCallIncoming), METH_NOARGS | METH_STATIC, nullptr },
        { "add_call_state_changed", reinterpret_cast<PyCFunction>(PhoneCallManager_add_CallStateChanged), METH_O | METH_STATIC, nullptr },
        { "remove_call_state_changed", reinterpret_cast<PyCFunction>(PhoneCallManager_remove_CallStateChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallManager[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallManager[] = 
    {
        { Py_tp_new, _new_PhoneCallManager },
        { Py_tp_methods, _methods_PhoneCallManager },
        { Py_tp_getset, _getset_PhoneCallManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallManager =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallManager
    };

    // ----- PhoneCallStore class --------------------
    constexpr const char* const _type_name_PhoneCallStore = "PhoneCallStore";

    static PyObject* _new_PhoneCallStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallStore);
        return nullptr;
    }

    static void _dealloc_PhoneCallStore(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallStore_GetDefaultLineAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDefaultLineAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallStore_IsEmergencyPhoneNumberAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsEmergencyPhoneNumberAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneCallStore_RequestLineWatcher(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestLineWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallStore[] = {
        { "get_default_line_async", reinterpret_cast<PyCFunction>(PhoneCallStore_GetDefaultLineAsync), METH_VARARGS, nullptr },
        { "is_emergency_phone_number_async", reinterpret_cast<PyCFunction>(PhoneCallStore_IsEmergencyPhoneNumberAsync), METH_VARARGS, nullptr },
        { "request_line_watcher", reinterpret_cast<PyCFunction>(PhoneCallStore_RequestLineWatcher), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallStore[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallStore[] = 
    {
        { Py_tp_new, _new_PhoneCallStore },
        { Py_tp_dealloc, _dealloc_PhoneCallStore },
        { Py_tp_methods, _methods_PhoneCallStore },
        { Py_tp_getset, _getset_PhoneCallStore },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallStore =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallStore
    };

    // ----- PhoneCallVideoCapabilities class --------------------
    constexpr const char* const _type_name_PhoneCallVideoCapabilities = "PhoneCallVideoCapabilities";

    static PyObject* _new_PhoneCallVideoCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallVideoCapabilities);
        return nullptr;
    }

    static void _dealloc_PhoneCallVideoCapabilities(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallVideoCapabilities_get_IsVideoCallingCapable(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVideoCallingCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallVideoCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallVideoCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallVideoCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallVideoCapabilities[] = {
        { "is_video_calling_capable", reinterpret_cast<getter>(PhoneCallVideoCapabilities_get_IsVideoCallingCapable), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallVideoCapabilities[] = 
    {
        { Py_tp_new, _new_PhoneCallVideoCapabilities },
        { Py_tp_dealloc, _dealloc_PhoneCallVideoCapabilities },
        { Py_tp_methods, _methods_PhoneCallVideoCapabilities },
        { Py_tp_getset, _getset_PhoneCallVideoCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallVideoCapabilities =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallVideoCapabilities",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallVideoCapabilities
    };

    // ----- PhoneCallVideoCapabilitiesManager class --------------------
    constexpr const char* const _type_name_PhoneCallVideoCapabilitiesManager = "PhoneCallVideoCapabilitiesManager";

    static PyObject* _new_PhoneCallVideoCapabilitiesManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallVideoCapabilitiesManager);
        return nullptr;
    }

    static PyObject* PhoneCallVideoCapabilitiesManager_GetCapabilitiesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilitiesManager::GetCapabilitiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallVideoCapabilitiesManager[] = {
        { "get_capabilities_async", reinterpret_cast<PyCFunction>(PhoneCallVideoCapabilitiesManager_GetCapabilitiesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallVideoCapabilitiesManager[] = {
        { }
    };

    static PyType_Slot _type_slots_PhoneCallVideoCapabilitiesManager[] = 
    {
        { Py_tp_new, _new_PhoneCallVideoCapabilitiesManager },
        { Py_tp_methods, _methods_PhoneCallVideoCapabilitiesManager },
        { Py_tp_getset, _getset_PhoneCallVideoCapabilitiesManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallVideoCapabilitiesManager =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallVideoCapabilitiesManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallVideoCapabilitiesManager
    };

    // ----- PhoneCallsResult class --------------------
    constexpr const char* const _type_name_PhoneCallsResult = "PhoneCallsResult";

    static PyObject* _new_PhoneCallsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneCallsResult);
        return nullptr;
    }

    static void _dealloc_PhoneCallsResult(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneCallsResult_get_AllActivePhoneCalls(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllActivePhoneCalls());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallsResult_get_OperationStatus(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OperationStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneCallsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallsResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallsResult[] = {
        { "all_active_phone_calls", reinterpret_cast<getter>(PhoneCallsResult_get_AllActivePhoneCalls), nullptr, nullptr, nullptr },
        { "operation_status", reinterpret_cast<getter>(PhoneCallsResult_get_OperationStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallsResult[] = 
    {
        { Py_tp_new, _new_PhoneCallsResult },
        { Py_tp_dealloc, _dealloc_PhoneCallsResult },
        { Py_tp_methods, _methods_PhoneCallsResult },
        { Py_tp_getset, _getset_PhoneCallsResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneCallsResult =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneCallsResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneCallsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallsResult
    };

    // ----- PhoneDialOptions class --------------------
    constexpr const char* const _type_name_PhoneDialOptions = "PhoneDialOptions";

    static PyObject* _new_PhoneDialOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Calls::PhoneDialOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PhoneDialOptions(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneDialOptions_get_Number(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Number());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_Number(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Number(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Media());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_Media(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneCallMedia>(arg);

            self->obj.Media(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_ContactPhone(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactPhone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_ContactPhone(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::ContactPhone>(arg);

            self->obj.ContactPhone(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_Contact(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_Contact(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Contacts::Contact>(arg);

            self->obj.Contact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhoneDialOptions_get_AudioEndpoint(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioEndpoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhoneDialOptions_put_AudioEndpoint(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneAudioRoutingEndpoint>(arg);

            self->obj.AudioEndpoint(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_PhoneDialOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneDialOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneDialOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneDialOptions[] = {
        { "number", reinterpret_cast<getter>(PhoneDialOptions_get_Number), reinterpret_cast<setter>(PhoneDialOptions_put_Number), nullptr, nullptr },
        { "media", reinterpret_cast<getter>(PhoneDialOptions_get_Media), reinterpret_cast<setter>(PhoneDialOptions_put_Media), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneDialOptions_get_DisplayName), reinterpret_cast<setter>(PhoneDialOptions_put_DisplayName), nullptr, nullptr },
        { "contact_phone", reinterpret_cast<getter>(PhoneDialOptions_get_ContactPhone), reinterpret_cast<setter>(PhoneDialOptions_put_ContactPhone), nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(PhoneDialOptions_get_Contact), reinterpret_cast<setter>(PhoneDialOptions_put_Contact), nullptr, nullptr },
        { "audio_endpoint", reinterpret_cast<getter>(PhoneDialOptions_get_AudioEndpoint), reinterpret_cast<setter>(PhoneDialOptions_put_AudioEndpoint), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneDialOptions[] = 
    {
        { Py_tp_new, _new_PhoneDialOptions },
        { Py_tp_dealloc, _dealloc_PhoneDialOptions },
        { Py_tp_methods, _methods_PhoneDialOptions },
        { Py_tp_getset, _getset_PhoneDialOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneDialOptions =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneDialOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneDialOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneDialOptions
    };

    // ----- PhoneLine class --------------------
    constexpr const char* const _type_name_PhoneLine = "PhoneLine";

    static PyObject* _new_PhoneLine(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneLine);
        return nullptr;
    }

    static void _dealloc_PhoneLine(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneLine_Dial(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Dial(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_DialWithOptions(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>(args, 0);

                self->obj.DialWithOptions(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_DialWithResult(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.DialWithResult(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_DialWithResultAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.DialWithResultAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_EnableTextReply(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.EnableTextReply(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLine::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_GetAllActivePhoneCalls(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAllActivePhoneCalls());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_GetAllActivePhoneCallsAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAllActivePhoneCallsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_IsImmediateDialNumberAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsImmediateDialNumberAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_CanDial(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanDial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_CellularDetails(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_DisplayColor(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_DisplayName(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_Id(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_LineConfiguration(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineConfiguration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_NetworkName(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_NetworkState(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_SupportsTile(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsTile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_Transport(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Transport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_VideoCallingCapabilities(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoCallingCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_Voicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Voicemail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_get_TransportDeviceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_add_LineChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLine, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LineChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLine_remove_LineChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneLine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLine>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLine[] = {
        { "dial", reinterpret_cast<PyCFunction>(PhoneLine_Dial), METH_VARARGS, nullptr },
        { "dial_with_options", reinterpret_cast<PyCFunction>(PhoneLine_DialWithOptions), METH_VARARGS, nullptr },
        { "dial_with_result", reinterpret_cast<PyCFunction>(PhoneLine_DialWithResult), METH_VARARGS, nullptr },
        { "dial_with_result_async", reinterpret_cast<PyCFunction>(PhoneLine_DialWithResultAsync), METH_VARARGS, nullptr },
        { "enable_text_reply", reinterpret_cast<PyCFunction>(PhoneLine_EnableTextReply), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(PhoneLine_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_all_active_phone_calls", reinterpret_cast<PyCFunction>(PhoneLine_GetAllActivePhoneCalls), METH_VARARGS, nullptr },
        { "get_all_active_phone_calls_async", reinterpret_cast<PyCFunction>(PhoneLine_GetAllActivePhoneCallsAsync), METH_VARARGS, nullptr },
        { "is_immediate_dial_number_async", reinterpret_cast<PyCFunction>(PhoneLine_IsImmediateDialNumberAsync), METH_VARARGS, nullptr },
        { "add_line_changed", reinterpret_cast<PyCFunction>(PhoneLine_add_LineChanged), METH_O, nullptr },
        { "remove_line_changed", reinterpret_cast<PyCFunction>(PhoneLine_remove_LineChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLine), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLine[] = {
        { "can_dial", reinterpret_cast<getter>(PhoneLine_get_CanDial), nullptr, nullptr, nullptr },
        { "cellular_details", reinterpret_cast<getter>(PhoneLine_get_CellularDetails), nullptr, nullptr, nullptr },
        { "display_color", reinterpret_cast<getter>(PhoneLine_get_DisplayColor), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(PhoneLine_get_DisplayName), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(PhoneLine_get_Id), nullptr, nullptr, nullptr },
        { "line_configuration", reinterpret_cast<getter>(PhoneLine_get_LineConfiguration), nullptr, nullptr, nullptr },
        { "network_name", reinterpret_cast<getter>(PhoneLine_get_NetworkName), nullptr, nullptr, nullptr },
        { "network_state", reinterpret_cast<getter>(PhoneLine_get_NetworkState), nullptr, nullptr, nullptr },
        { "supports_tile", reinterpret_cast<getter>(PhoneLine_get_SupportsTile), nullptr, nullptr, nullptr },
        { "transport", reinterpret_cast<getter>(PhoneLine_get_Transport), nullptr, nullptr, nullptr },
        { "video_calling_capabilities", reinterpret_cast<getter>(PhoneLine_get_VideoCallingCapabilities), nullptr, nullptr, nullptr },
        { "voicemail", reinterpret_cast<getter>(PhoneLine_get_Voicemail), nullptr, nullptr, nullptr },
        { "transport_device_id", reinterpret_cast<getter>(PhoneLine_get_TransportDeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLine[] = 
    {
        { Py_tp_new, _new_PhoneLine },
        { Py_tp_dealloc, _dealloc_PhoneLine },
        { Py_tp_methods, _methods_PhoneLine },
        { Py_tp_getset, _getset_PhoneLine },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneLine =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneLine",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLine),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLine
    };

    // ----- PhoneLineCellularDetails class --------------------
    constexpr const char* const _type_name_PhoneLineCellularDetails = "PhoneLineCellularDetails";

    static PyObject* _new_PhoneLineCellularDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneLineCellularDetails);
        return nullptr;
    }

    static void _dealloc_PhoneLineCellularDetails(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneLineCellularDetails_GetNetworkOperatorDisplayText(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneLineNetworkOperatorDisplayTextLocation>(args, 0);

                return py::convert(self->obj.GetNetworkOperatorDisplayText(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_IsModemOn(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsModemOn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_RegistrationRejectCode(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RegistrationRejectCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_SimSlotIndex(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimSlotIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineCellularDetails_get_SimState(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneLineCellularDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineCellularDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineCellularDetails[] = {
        { "get_network_operator_display_text", reinterpret_cast<PyCFunction>(PhoneLineCellularDetails_GetNetworkOperatorDisplayText), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineCellularDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineCellularDetails[] = {
        { "is_modem_on", reinterpret_cast<getter>(PhoneLineCellularDetails_get_IsModemOn), nullptr, nullptr, nullptr },
        { "registration_reject_code", reinterpret_cast<getter>(PhoneLineCellularDetails_get_RegistrationRejectCode), nullptr, nullptr, nullptr },
        { "sim_slot_index", reinterpret_cast<getter>(PhoneLineCellularDetails_get_SimSlotIndex), nullptr, nullptr, nullptr },
        { "sim_state", reinterpret_cast<getter>(PhoneLineCellularDetails_get_SimState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineCellularDetails[] = 
    {
        { Py_tp_new, _new_PhoneLineCellularDetails },
        { Py_tp_dealloc, _dealloc_PhoneLineCellularDetails },
        { Py_tp_methods, _methods_PhoneLineCellularDetails },
        { Py_tp_getset, _getset_PhoneLineCellularDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneLineCellularDetails =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneLineCellularDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineCellularDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineCellularDetails
    };

    // ----- PhoneLineConfiguration class --------------------
    constexpr const char* const _type_name_PhoneLineConfiguration = "PhoneLineConfiguration";

    static PyObject* _new_PhoneLineConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneLineConfiguration);
        return nullptr;
    }

    static void _dealloc_PhoneLineConfiguration(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneLineConfiguration_get_ExtendedProperties(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineConfiguration_get_IsVideoCallingEnabled(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVideoCallingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneLineConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineConfiguration[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineConfiguration[] = {
        { "extended_properties", reinterpret_cast<getter>(PhoneLineConfiguration_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_video_calling_enabled", reinterpret_cast<getter>(PhoneLineConfiguration_get_IsVideoCallingEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineConfiguration[] = 
    {
        { Py_tp_new, _new_PhoneLineConfiguration },
        { Py_tp_dealloc, _dealloc_PhoneLineConfiguration },
        { Py_tp_methods, _methods_PhoneLineConfiguration },
        { Py_tp_getset, _getset_PhoneLineConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneLineConfiguration =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneLineConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineConfiguration
    };

    // ----- PhoneLineDialResult class --------------------
    constexpr const char* const _type_name_PhoneLineDialResult = "PhoneLineDialResult";

    static PyObject* _new_PhoneLineDialResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneLineDialResult);
        return nullptr;
    }

    static void _dealloc_PhoneLineDialResult(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneLineDialResult_get_DialCallStatus(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DialCallStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineDialResult_get_DialedCall(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DialedCall());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneLineDialResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineDialResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineDialResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineDialResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineDialResult[] = {
        { "dial_call_status", reinterpret_cast<getter>(PhoneLineDialResult_get_DialCallStatus), nullptr, nullptr, nullptr },
        { "dialed_call", reinterpret_cast<getter>(PhoneLineDialResult_get_DialedCall), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineDialResult[] = 
    {
        { Py_tp_new, _new_PhoneLineDialResult },
        { Py_tp_dealloc, _dealloc_PhoneLineDialResult },
        { Py_tp_methods, _methods_PhoneLineDialResult },
        { Py_tp_getset, _getset_PhoneLineDialResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneLineDialResult =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneLineDialResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineDialResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineDialResult
    };

    // ----- PhoneLineTransportDevice class --------------------
    constexpr const char* const _type_name_PhoneLineTransportDevice = "PhoneLineTransportDevice";

    static PyObject* _new_PhoneLineTransportDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneLineTransportDevice);
        return nullptr;
    }

    static void _dealloc_PhoneLineTransportDevice(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneLineTransportDevice_Connect(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Connect());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_ConnectAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ConnectAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::PhoneLineTransport>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_IsRegistered(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.IsRegistered());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_RegisterApp(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.RegisterApp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_RegisterAppForUser(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                self->obj.RegisterAppForUser(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_RequestAccessAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_UnregisterApp(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.UnregisterApp();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_UnregisterAppForUser(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                self->obj.UnregisterAppForUser(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_DeviceId(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_Transport(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Transport());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_AudioRoutingStatus(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioRoutingStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_get_InBandRingingEnabled(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InBandRingingEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_add_AudioRoutingStatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioRoutingStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_remove_AudioRoutingStatusChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioRoutingStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_add_InBandRingingEnabledChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.InBandRingingEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineTransportDevice_remove_InBandRingingEnabledChanged(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InBandRingingEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneLineTransportDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineTransportDevice[] = {
        { "connect", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_Connect), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_ConnectAsync), METH_VARARGS, nullptr },
        { "from_id", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_FromId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "is_registered", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_IsRegistered), METH_VARARGS, nullptr },
        { "register_app", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_RegisterApp), METH_VARARGS, nullptr },
        { "register_app_for_user", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_RegisterAppForUser), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_RequestAccessAsync), METH_VARARGS, nullptr },
        { "unregister_app", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_UnregisterApp), METH_VARARGS, nullptr },
        { "unregister_app_for_user", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_UnregisterAppForUser), METH_VARARGS, nullptr },
        { "add_audio_routing_status_changed", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_add_AudioRoutingStatusChanged), METH_O, nullptr },
        { "remove_audio_routing_status_changed", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_remove_AudioRoutingStatusChanged), METH_O, nullptr },
        { "add_in_band_ringing_enabled_changed", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_add_InBandRingingEnabledChanged), METH_O, nullptr },
        { "remove_in_band_ringing_enabled_changed", reinterpret_cast<PyCFunction>(PhoneLineTransportDevice_remove_InBandRingingEnabledChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineTransportDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineTransportDevice[] = {
        { "device_id", reinterpret_cast<getter>(PhoneLineTransportDevice_get_DeviceId), nullptr, nullptr, nullptr },
        { "transport", reinterpret_cast<getter>(PhoneLineTransportDevice_get_Transport), nullptr, nullptr, nullptr },
        { "audio_routing_status", reinterpret_cast<getter>(PhoneLineTransportDevice_get_AudioRoutingStatus), nullptr, nullptr, nullptr },
        { "in_band_ringing_enabled", reinterpret_cast<getter>(PhoneLineTransportDevice_get_InBandRingingEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineTransportDevice[] = 
    {
        { Py_tp_new, _new_PhoneLineTransportDevice },
        { Py_tp_dealloc, _dealloc_PhoneLineTransportDevice },
        { Py_tp_methods, _methods_PhoneLineTransportDevice },
        { Py_tp_getset, _getset_PhoneLineTransportDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneLineTransportDevice =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneLineTransportDevice",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineTransportDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineTransportDevice
    };

    // ----- PhoneLineWatcher class --------------------
    constexpr const char* const _type_name_PhoneLineWatcher = "PhoneLineWatcher";

    static PyObject* _new_PhoneLineWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneLineWatcher);
        return nullptr;
    }

    static void _dealloc_PhoneLineWatcher(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneLineWatcher_Start(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_Stop(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_get_Status(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_EnumerationCompleted(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_EnumerationCompleted(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_LineAdded(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>>(arg);

            return py::convert(self->obj.LineAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_LineAdded(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_LineRemoved(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>>(arg);

            return py::convert(self->obj.LineRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_LineRemoved(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_LineUpdated(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>>(arg);

            return py::convert(self->obj.LineUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_LineUpdated(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LineUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_add_Stopped(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneLineWatcher_remove_Stopped(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneLineWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(PhoneLineWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(PhoneLineWatcher_Stop), METH_VARARGS, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_line_added", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_LineAdded), METH_O, nullptr },
        { "remove_line_added", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_LineAdded), METH_O, nullptr },
        { "add_line_removed", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_LineRemoved), METH_O, nullptr },
        { "remove_line_removed", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_LineRemoved), METH_O, nullptr },
        { "add_line_updated", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_LineUpdated), METH_O, nullptr },
        { "remove_line_updated", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_LineUpdated), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(PhoneLineWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(PhoneLineWatcher_remove_Stopped), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineWatcher[] = {
        { "status", reinterpret_cast<getter>(PhoneLineWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineWatcher[] = 
    {
        { Py_tp_new, _new_PhoneLineWatcher },
        { Py_tp_dealloc, _dealloc_PhoneLineWatcher },
        { Py_tp_methods, _methods_PhoneLineWatcher },
        { Py_tp_getset, _getset_PhoneLineWatcher },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneLineWatcher =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneLineWatcher",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineWatcher
    };

    // ----- PhoneLineWatcherEventArgs class --------------------
    constexpr const char* const _type_name_PhoneLineWatcherEventArgs = "PhoneLineWatcherEventArgs";

    static PyObject* _new_PhoneLineWatcherEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneLineWatcherEventArgs);
        return nullptr;
    }

    static void _dealloc_PhoneLineWatcherEventArgs(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneLineWatcherEventArgs_get_LineId(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneLineWatcherEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneLineWatcherEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneLineWatcherEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneLineWatcherEventArgs[] = {
        { "line_id", reinterpret_cast<getter>(PhoneLineWatcherEventArgs_get_LineId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneLineWatcherEventArgs[] = 
    {
        { Py_tp_new, _new_PhoneLineWatcherEventArgs },
        { Py_tp_dealloc, _dealloc_PhoneLineWatcherEventArgs },
        { Py_tp_methods, _methods_PhoneLineWatcherEventArgs },
        { Py_tp_getset, _getset_PhoneLineWatcherEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneLineWatcherEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneLineWatcherEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneLineWatcherEventArgs
    };

    // ----- PhoneVoicemail class --------------------
    constexpr const char* const _type_name_PhoneVoicemail = "PhoneVoicemail";

    static PyObject* _new_PhoneVoicemail(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhoneVoicemail);
        return nullptr;
    }

    static void _dealloc_PhoneVoicemail(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhoneVoicemail_DialVoicemailAsync(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DialVoicemailAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PhoneVoicemail_get_MessageCount(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneVoicemail_get_Number(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Number());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneVoicemail_get_Type(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneVoicemail(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::PhoneVoicemail>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneVoicemail[] = {
        { "dial_voicemail_async", reinterpret_cast<PyCFunction>(PhoneVoicemail_DialVoicemailAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneVoicemail), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneVoicemail[] = {
        { "message_count", reinterpret_cast<getter>(PhoneVoicemail_get_MessageCount), nullptr, nullptr, nullptr },
        { "number", reinterpret_cast<getter>(PhoneVoicemail_get_Number), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(PhoneVoicemail_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneVoicemail[] = 
    {
        { Py_tp_new, _new_PhoneVoicemail },
        { Py_tp_dealloc, _dealloc_PhoneVoicemail },
        { Py_tp_methods, _methods_PhoneVoicemail },
        { Py_tp_getset, _getset_PhoneVoicemail },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhoneVoicemail =
    {
        "_winsdk_Windows_ApplicationModel_Calls.PhoneVoicemail",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::PhoneVoicemail),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneVoicemail
    };

    // ----- VoipCallCoordinator class --------------------
    constexpr const char* const _type_name_VoipCallCoordinator = "VoipCallCoordinator";

    static PyObject* _new_VoipCallCoordinator(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VoipCallCoordinator);
        return nullptr;
    }

    static void _dealloc_VoipCallCoordinator(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VoipCallCoordinator_CancelUpgrade(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.CancelUpgrade(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_NotifyMuted(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyMuted();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_NotifyUnmuted(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyUnmuted();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestIncomingUpgradeToVideoCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 9)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 8);

                return py::convert(self->obj.RequestIncomingUpgradeToVideoCall(param0, param1, param2, param3, param4, param5, param6, param7, param8));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestNewAppInitiatedCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 4);

                return py::convert(self->obj.RequestNewAppInitiatedCall(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestNewIncomingCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 10)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 9);

                return py::convert(self->obj.RequestNewIncomingCall(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 11)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 5);
                auto param6 = py::convert_to<winrt::hstring>(args, 6);
                auto param7 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 7);
                auto param8 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 8);
                auto param9 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 9);
                auto param10 = py::convert_to<winrt::hstring>(args, 10);

                return py::convert(self->obj.RequestNewIncomingCall(param0, param1, param2, param3, param4, param5, param6, param7, param8, param9, param10));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestNewOutgoingCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 3);

                return py::convert(self->obj.RequestNewOutgoingCall(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_RequestOutgoingUpgradeToVideoCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.RequestOutgoingUpgradeToVideoCall(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_ReserveCallResourcesAsync(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReserveCallResourcesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ReserveCallResourcesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_SetupNewAcceptedCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 4);

                return py::convert(self->obj.SetupNewAcceptedCall(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_TerminateCellularCall(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.TerminateCellularCall(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_add_MuteStateChanged(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator, winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>>(arg);

            return py::convert(self->obj.MuteStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipCallCoordinator_remove_MuteStateChanged(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MuteStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VoipCallCoordinator(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoipCallCoordinator[] = {
        { "cancel_upgrade", reinterpret_cast<PyCFunction>(VoipCallCoordinator_CancelUpgrade), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(VoipCallCoordinator_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "notify_muted", reinterpret_cast<PyCFunction>(VoipCallCoordinator_NotifyMuted), METH_VARARGS, nullptr },
        { "notify_unmuted", reinterpret_cast<PyCFunction>(VoipCallCoordinator_NotifyUnmuted), METH_VARARGS, nullptr },
        { "request_incoming_upgrade_to_video_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestIncomingUpgradeToVideoCall), METH_VARARGS, nullptr },
        { "request_new_app_initiated_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestNewAppInitiatedCall), METH_VARARGS, nullptr },
        { "request_new_incoming_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestNewIncomingCall), METH_VARARGS, nullptr },
        { "request_new_outgoing_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestNewOutgoingCall), METH_VARARGS, nullptr },
        { "request_outgoing_upgrade_to_video_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_RequestOutgoingUpgradeToVideoCall), METH_VARARGS, nullptr },
        { "reserve_call_resources_async", reinterpret_cast<PyCFunction>(VoipCallCoordinator_ReserveCallResourcesAsync), METH_VARARGS, nullptr },
        { "setup_new_accepted_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_SetupNewAcceptedCall), METH_VARARGS, nullptr },
        { "terminate_cellular_call", reinterpret_cast<PyCFunction>(VoipCallCoordinator_TerminateCellularCall), METH_VARARGS, nullptr },
        { "add_mute_state_changed", reinterpret_cast<PyCFunction>(VoipCallCoordinator_add_MuteStateChanged), METH_O, nullptr },
        { "remove_mute_state_changed", reinterpret_cast<PyCFunction>(VoipCallCoordinator_remove_MuteStateChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VoipCallCoordinator), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VoipCallCoordinator[] = {
        { }
    };

    static PyType_Slot _type_slots_VoipCallCoordinator[] = 
    {
        { Py_tp_new, _new_VoipCallCoordinator },
        { Py_tp_dealloc, _dealloc_VoipCallCoordinator },
        { Py_tp_methods, _methods_VoipCallCoordinator },
        { Py_tp_getset, _getset_VoipCallCoordinator },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VoipCallCoordinator =
    {
        "_winsdk_Windows_ApplicationModel_Calls.VoipCallCoordinator",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::VoipCallCoordinator),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoipCallCoordinator
    };

    // ----- VoipPhoneCall class --------------------
    constexpr const char* const _type_name_VoipPhoneCall = "VoipPhoneCall";

    static PyObject* _new_VoipPhoneCall(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VoipPhoneCall);
        return nullptr;
    }

    static void _dealloc_VoipPhoneCall(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VoipPhoneCall_NotifyCallAccepted(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(args, 0);

                self->obj.NotifyCallAccepted(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallActive(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyCallActive();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallEnded(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyCallEnded();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallHeld(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyCallHeld();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_NotifyCallReady(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyCallReady();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_TryShowAppUI(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.TryShowAppUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_get_StartTime(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VoipPhoneCall_put_StartTime(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VoipPhoneCall_get_ContactName(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VoipPhoneCall_put_ContactName(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VoipPhoneCall_get_CallMedia(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallMedia());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VoipPhoneCall_put_CallMedia(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Calls::VoipPhoneCallMedia>(arg);

            self->obj.CallMedia(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VoipPhoneCall_add_AnswerRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>>(arg);

            return py::convert(self->obj.AnswerRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_AnswerRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AnswerRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_EndRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>>(arg);

            return py::convert(self->obj.EndRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_EndRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EndRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_HoldRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>>(arg);

            return py::convert(self->obj.HoldRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_HoldRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HoldRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_RejectRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>>(arg);

            return py::convert(self->obj.RejectRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_RejectRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RejectRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_add_ResumeRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall, winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>>(arg);

            return py::convert(self->obj.ResumeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoipPhoneCall_remove_ResumeRequested(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResumeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VoipPhoneCall(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoipPhoneCall[] = {
        { "notify_call_accepted", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallAccepted), METH_VARARGS, nullptr },
        { "notify_call_active", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallActive), METH_VARARGS, nullptr },
        { "notify_call_ended", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallEnded), METH_VARARGS, nullptr },
        { "notify_call_held", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallHeld), METH_VARARGS, nullptr },
        { "notify_call_ready", reinterpret_cast<PyCFunction>(VoipPhoneCall_NotifyCallReady), METH_VARARGS, nullptr },
        { "try_show_app_u_i", reinterpret_cast<PyCFunction>(VoipPhoneCall_TryShowAppUI), METH_VARARGS, nullptr },
        { "add_answer_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_AnswerRequested), METH_O, nullptr },
        { "remove_answer_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_AnswerRequested), METH_O, nullptr },
        { "add_end_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_EndRequested), METH_O, nullptr },
        { "remove_end_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_EndRequested), METH_O, nullptr },
        { "add_hold_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_HoldRequested), METH_O, nullptr },
        { "remove_hold_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_HoldRequested), METH_O, nullptr },
        { "add_reject_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_RejectRequested), METH_O, nullptr },
        { "remove_reject_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_RejectRequested), METH_O, nullptr },
        { "add_resume_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_add_ResumeRequested), METH_O, nullptr },
        { "remove_resume_requested", reinterpret_cast<PyCFunction>(VoipPhoneCall_remove_ResumeRequested), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VoipPhoneCall), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VoipPhoneCall[] = {
        { "start_time", reinterpret_cast<getter>(VoipPhoneCall_get_StartTime), reinterpret_cast<setter>(VoipPhoneCall_put_StartTime), nullptr, nullptr },
        { "contact_name", reinterpret_cast<getter>(VoipPhoneCall_get_ContactName), reinterpret_cast<setter>(VoipPhoneCall_put_ContactName), nullptr, nullptr },
        { "call_media", reinterpret_cast<getter>(VoipPhoneCall_get_CallMedia), reinterpret_cast<setter>(VoipPhoneCall_put_CallMedia), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VoipPhoneCall[] = 
    {
        { Py_tp_new, _new_VoipPhoneCall },
        { Py_tp_dealloc, _dealloc_VoipPhoneCall },
        { Py_tp_methods, _methods_VoipPhoneCall },
        { Py_tp_getset, _getset_VoipPhoneCall },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VoipPhoneCall =
    {
        "_winsdk_Windows_ApplicationModel_Calls.VoipPhoneCall",
        sizeof(py::wrapper::Windows::ApplicationModel::Calls::VoipPhoneCall),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoipPhoneCall
    };

    // ----- Windows.ApplicationModel.Calls Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallAnswerEventArgs>::python_type = py::register_python_type(module, _type_name_CallAnswerEventArgs, &_type_spec_CallAnswerEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallRejectEventArgs>::python_type = py::register_python_type(module, _type_name_CallRejectEventArgs, &_type_spec_CallRejectEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::CallStateChangeEventArgs>::python_type = py::register_python_type(module, _type_name_CallStateChangeEventArgs, &_type_spec_CallStateChangeEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::MuteChangeEventArgs>::python_type = py::register_python_type(module, _type_name_MuteChangeEventArgs, &_type_spec_MuteChangeEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCall>::python_type = py::register_python_type(module, _type_name_PhoneCall, &_type_spec_PhoneCall, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallBlocking>::python_type = py::register_python_type(module, _type_name_PhoneCallBlocking, &_type_spec_PhoneCallBlocking, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntry>::python_type = py::register_python_type(module, _type_name_PhoneCallHistoryEntry, &_type_spec_PhoneCallHistoryEntry, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryAddress>::python_type = py::register_python_type(module, _type_name_PhoneCallHistoryEntryAddress, &_type_spec_PhoneCallHistoryEntryAddress, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryQueryOptions>::python_type = py::register_python_type(module, _type_name_PhoneCallHistoryEntryQueryOptions, &_type_spec_PhoneCallHistoryEntryQueryOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryEntryReader>::python_type = py::register_python_type(module, _type_name_PhoneCallHistoryEntryReader, &_type_spec_PhoneCallHistoryEntryReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManager>::python_type = py::register_python_type(module, _type_name_PhoneCallHistoryManager, &_type_spec_PhoneCallHistoryManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryManagerForUser>::python_type = py::register_python_type(module, _type_name_PhoneCallHistoryManagerForUser, &_type_spec_PhoneCallHistoryManagerForUser, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallHistoryStore>::python_type = py::register_python_type(module, _type_name_PhoneCallHistoryStore, &_type_spec_PhoneCallHistoryStore, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallInfo>::python_type = py::register_python_type(module, _type_name_PhoneCallInfo, &_type_spec_PhoneCallInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallManager>::python_type = py::register_python_type(module, _type_name_PhoneCallManager, &_type_spec_PhoneCallManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallStore>::python_type = py::register_python_type(module, _type_name_PhoneCallStore, &_type_spec_PhoneCallStore, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilities>::python_type = py::register_python_type(module, _type_name_PhoneCallVideoCapabilities, &_type_spec_PhoneCallVideoCapabilities, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallVideoCapabilitiesManager>::python_type = py::register_python_type(module, _type_name_PhoneCallVideoCapabilitiesManager, &_type_spec_PhoneCallVideoCapabilitiesManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneCallsResult>::python_type = py::register_python_type(module, _type_name_PhoneCallsResult, &_type_spec_PhoneCallsResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneDialOptions>::python_type = py::register_python_type(module, _type_name_PhoneDialOptions, &_type_spec_PhoneDialOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLine>::python_type = py::register_python_type(module, _type_name_PhoneLine, &_type_spec_PhoneLine, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineCellularDetails>::python_type = py::register_python_type(module, _type_name_PhoneLineCellularDetails, &_type_spec_PhoneLineCellularDetails, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineConfiguration>::python_type = py::register_python_type(module, _type_name_PhoneLineConfiguration, &_type_spec_PhoneLineConfiguration, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineDialResult>::python_type = py::register_python_type(module, _type_name_PhoneLineDialResult, &_type_spec_PhoneLineDialResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineTransportDevice>::python_type = py::register_python_type(module, _type_name_PhoneLineTransportDevice, &_type_spec_PhoneLineTransportDevice, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcher>::python_type = py::register_python_type(module, _type_name_PhoneLineWatcher, &_type_spec_PhoneLineWatcher, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneLineWatcherEventArgs>::python_type = py::register_python_type(module, _type_name_PhoneLineWatcherEventArgs, &_type_spec_PhoneLineWatcherEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::PhoneVoicemail>::python_type = py::register_python_type(module, _type_name_PhoneVoicemail, &_type_spec_PhoneVoicemail, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::VoipCallCoordinator>::python_type = py::register_python_type(module, _type_name_VoipCallCoordinator, &_type_spec_VoipCallCoordinator, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Calls::VoipPhoneCall>::python_type = py::register_python_type(module, _type_name_VoipPhoneCall, &_type_spec_VoipPhoneCall, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Calls");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_Calls",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::ApplicationModel::Calls

PyMODINIT_FUNC
PyInit__winsdk_Windows_ApplicationModel_Calls (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::Calls::module_def);
}
