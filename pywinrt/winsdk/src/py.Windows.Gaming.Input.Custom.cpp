// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Gaming.Input.Custom.h"

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>::python_type;

PyObject* py::converter<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>::convert(winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>());
}
winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo py::converter<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo return_value{};

    PyObject* py_Major = PyDict_GetItemString(obj, "major");
    if (!py_Major) { throw winrt::hresult_invalid_argument(); }
    return_value.Major = converter<uint16_t>::convert_to(py_Major);

    PyObject* py_Minor = PyDict_GetItemString(obj, "minor");
    if (!py_Minor) { throw winrt::hresult_invalid_argument(); }
    return_value.Minor = converter<uint16_t>::convert_to(py_Minor);

    PyObject* py_Build = PyDict_GetItemString(obj, "build");
    if (!py_Build) { throw winrt::hresult_invalid_argument(); }
    return_value.Build = converter<uint16_t>::convert_to(py_Build);

    PyObject* py_Revision = PyDict_GetItemString(obj, "revision");
    if (!py_Revision) { throw winrt::hresult_invalid_argument(); }
    return_value.Revision = converter<uint16_t>::convert_to(py_Revision);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>::convert(winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>());
}
winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress py::converter<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress return_value{};

    PyObject* py_PercentCompleted = PyDict_GetItemString(obj, "percent_completed");
    if (!py_PercentCompleted) { throw winrt::hresult_invalid_argument(); }
    return_value.PercentCompleted = converter<double>::convert_to(py_PercentCompleted);

    PyObject* py_CurrentComponentId = PyDict_GetItemString(obj, "current_component_id");
    if (!py_CurrentComponentId) { throw winrt::hresult_invalid_argument(); }
    return_value.CurrentComponentId = converter<uint32_t>::convert_to(py_CurrentComponentId);

    return return_value;
}

namespace py::cpp::Windows::Gaming::Input::Custom
{
    // ----- GameControllerFactoryManager class --------------------
    constexpr const char* const _type_name_GameControllerFactoryManager = "GameControllerFactoryManager";

    static PyObject* _new_GameControllerFactoryManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GameControllerFactoryManager);
        return nullptr;
    }

    static PyObject* GameControllerFactoryManager_RegisterCustomFactoryForGipInterface(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::RegisterCustomFactoryForGipInterface(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameControllerFactoryManager_RegisterCustomFactoryForHardwareId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<uint16_t>(args, 2);

                winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::RegisterCustomFactoryForHardwareId(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameControllerFactoryManager_RegisterCustomFactoryForXusbType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Gaming::Input::Custom::XusbDeviceType>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Gaming::Input::Custom::XusbDeviceSubtype>(args, 2);

                winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::RegisterCustomFactoryForXusbType(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GameControllerFactoryManager_TryGetFactoryControllerFromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 1);

                return py::convert(winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager::TryGetFactoryControllerFromGameController(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_GameControllerFactoryManager[] = {
        { "register_custom_factory_for_gip_interface", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_RegisterCustomFactoryForGipInterface), METH_VARARGS | METH_STATIC, nullptr },
        { "register_custom_factory_for_hardware_id", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_RegisterCustomFactoryForHardwareId), METH_VARARGS | METH_STATIC, nullptr },
        { "register_custom_factory_for_xusb_type", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_RegisterCustomFactoryForXusbType), METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_factory_controller_from_game_controller", reinterpret_cast<PyCFunction>(GameControllerFactoryManager_TryGetFactoryControllerFromGameController), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GameControllerFactoryManager[] = {
        { }
    };

    static PyType_Slot _type_slots_GameControllerFactoryManager[] = 
    {
        { Py_tp_new, _new_GameControllerFactoryManager },
        { Py_tp_methods, _methods_GameControllerFactoryManager },
        { Py_tp_getset, _getset_GameControllerFactoryManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GameControllerFactoryManager =
    {
        "_winsdk_Windows_Gaming_Input_Custom.GameControllerFactoryManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameControllerFactoryManager
    };

    // ----- GipFirmwareUpdateResult class --------------------
    constexpr const char* const _type_name_GipFirmwareUpdateResult = "GipFirmwareUpdateResult";

    static PyObject* _new_GipFirmwareUpdateResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GipFirmwareUpdateResult);
        return nullptr;
    }

    static void _dealloc_GipFirmwareUpdateResult(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GipFirmwareUpdateResult_get_ExtendedErrorCode(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipFirmwareUpdateResult_get_FinalComponentId(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FinalComponentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipFirmwareUpdateResult_get_Status(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GipFirmwareUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GipFirmwareUpdateResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_GipFirmwareUpdateResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GipFirmwareUpdateResult[] = {
        { "extended_error_code", reinterpret_cast<getter>(GipFirmwareUpdateResult_get_ExtendedErrorCode), nullptr, nullptr, nullptr },
        { "final_component_id", reinterpret_cast<getter>(GipFirmwareUpdateResult_get_FinalComponentId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(GipFirmwareUpdateResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GipFirmwareUpdateResult[] = 
    {
        { Py_tp_new, _new_GipFirmwareUpdateResult },
        { Py_tp_dealloc, _dealloc_GipFirmwareUpdateResult },
        { Py_tp_methods, _methods_GipFirmwareUpdateResult },
        { Py_tp_getset, _getset_GipFirmwareUpdateResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GipFirmwareUpdateResult =
    {
        "_winsdk_Windows_Gaming_Input_Custom.GipFirmwareUpdateResult",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GipFirmwareUpdateResult
    };

    // ----- GipGameControllerProvider class --------------------
    constexpr const char* const _type_name_GipGameControllerProvider = "GipGameControllerProvider";

    static PyObject* _new_GipGameControllerProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_GipGameControllerProvider);
        return nullptr;
    }

    static void _dealloc_GipGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* GipGameControllerProvider_SendMessage(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::GipMessageClass>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<uint8_t>>(args, 2);

                self->obj.SendMessage(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_SendReceiveMessage(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::GipMessageClass>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<uint8_t>>(args, 2);
                auto param3_count = py::convert_to<winrt::com_array<uint8_t>::size_type>(args, 3);
                winrt::com_array<uint8_t> param3 ( param3_count, py::empty_instance<uint8_t>::get() );

                self->obj.SendReceiveMessage(param0, param1, param2, param3);

                py::pyobj_handle out3{ py::convert(param3) };
                if (!out3)
                {
                    return nullptr;
                }
                return out3.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_UpdateFirmwareAsync(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                return py::convert(self->obj.UpdateFirmwareAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FirmwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* GipGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_GipGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_GipGameControllerProvider[] = {
        { "send_message", reinterpret_cast<PyCFunction>(GipGameControllerProvider_SendMessage), METH_VARARGS, nullptr },
        { "send_receive_message", reinterpret_cast<PyCFunction>(GipGameControllerProvider_SendReceiveMessage), METH_VARARGS, nullptr },
        { "update_firmware_async", reinterpret_cast<PyCFunction>(GipGameControllerProvider_UpdateFirmwareAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_GipGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_GipGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(GipGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(GipGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(GipGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(GipGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(GipGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GipGameControllerProvider[] = 
    {
        { Py_tp_new, _new_GipGameControllerProvider },
        { Py_tp_dealloc, _dealloc_GipGameControllerProvider },
        { Py_tp_methods, _methods_GipGameControllerProvider },
        { Py_tp_getset, _getset_GipGameControllerProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GipGameControllerProvider =
    {
        "_winsdk_Windows_Gaming_Input_Custom.GipGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GipGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GipGameControllerProvider
    };

    // ----- HidGameControllerProvider class --------------------
    constexpr const char* const _type_name_HidGameControllerProvider = "HidGameControllerProvider";

    static PyObject* _new_HidGameControllerProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HidGameControllerProvider);
        return nullptr;
    }

    static void _dealloc_HidGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HidGameControllerProvider_GetFeatureReport(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<uint8_t>::size_type>(args, 1);
                winrt::com_array<uint8_t> param1 ( param1_count, py::empty_instance<uint8_t>::get() );

                self->obj.GetFeatureReport(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_SendFeatureReport(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                self->obj.SendFeatureReport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_SendOutputReport(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                self->obj.SendOutputReport(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FirmwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_UsageId(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HidGameControllerProvider_get_UsagePage(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsagePage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HidGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HidGameControllerProvider[] = {
        { "get_feature_report", reinterpret_cast<PyCFunction>(HidGameControllerProvider_GetFeatureReport), METH_VARARGS, nullptr },
        { "send_feature_report", reinterpret_cast<PyCFunction>(HidGameControllerProvider_SendFeatureReport), METH_VARARGS, nullptr },
        { "send_output_report", reinterpret_cast<PyCFunction>(HidGameControllerProvider_SendOutputReport), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HidGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HidGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(HidGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(HidGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(HidGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(HidGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(HidGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { "usage_id", reinterpret_cast<getter>(HidGameControllerProvider_get_UsageId), nullptr, nullptr, nullptr },
        { "usage_page", reinterpret_cast<getter>(HidGameControllerProvider_get_UsagePage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HidGameControllerProvider[] = 
    {
        { Py_tp_new, _new_HidGameControllerProvider },
        { Py_tp_dealloc, _dealloc_HidGameControllerProvider },
        { Py_tp_methods, _methods_HidGameControllerProvider },
        { Py_tp_getset, _getset_HidGameControllerProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HidGameControllerProvider =
    {
        "_winsdk_Windows_Gaming_Input_Custom.HidGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::HidGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HidGameControllerProvider
    };

    // ----- XusbGameControllerProvider class --------------------
    constexpr const char* const _type_name_XusbGameControllerProvider = "XusbGameControllerProvider";

    static PyObject* _new_XusbGameControllerProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_XusbGameControllerProvider);
        return nullptr;
    }

    static void _dealloc_XusbGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* XusbGameControllerProvider_SetVibration(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.SetVibration(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FirmwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* XusbGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_XusbGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_XusbGameControllerProvider[] = {
        { "set_vibration", reinterpret_cast<PyCFunction>(XusbGameControllerProvider_SetVibration), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_XusbGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_XusbGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(XusbGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(XusbGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(XusbGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(XusbGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(XusbGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_XusbGameControllerProvider[] = 
    {
        { Py_tp_new, _new_XusbGameControllerProvider },
        { Py_tp_dealloc, _dealloc_XusbGameControllerProvider },
        { Py_tp_methods, _methods_XusbGameControllerProvider },
        { Py_tp_getset, _getset_XusbGameControllerProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_XusbGameControllerProvider =
    {
        "_winsdk_Windows_Gaming_Input_Custom.XusbGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::XusbGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_XusbGameControllerProvider
    };

    // ----- ICustomGameControllerFactory interface --------------------
    constexpr const char* const _type_name_ICustomGameControllerFactory = "ICustomGameControllerFactory";

    static PyObject* _new_ICustomGameControllerFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ICustomGameControllerFactory);
        return nullptr;
    }

    static void _dealloc_ICustomGameControllerFactory(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ICustomGameControllerFactory_CreateGameController(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>(args, 0);

                return py::convert(self->obj.CreateGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomGameControllerFactory_OnGameControllerAdded(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                self->obj.OnGameControllerAdded(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICustomGameControllerFactory_OnGameControllerRemoved(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                self->obj.OnGameControllerRemoved(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ICustomGameControllerFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICustomGameControllerFactory[] = {
        { "create_game_controller", reinterpret_cast<PyCFunction>(ICustomGameControllerFactory_CreateGameController), METH_VARARGS, nullptr },
        { "on_game_controller_added", reinterpret_cast<PyCFunction>(ICustomGameControllerFactory_OnGameControllerAdded), METH_VARARGS, nullptr },
        { "on_game_controller_removed", reinterpret_cast<PyCFunction>(ICustomGameControllerFactory_OnGameControllerRemoved), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICustomGameControllerFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICustomGameControllerFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_ICustomGameControllerFactory[] = 
    {
        { Py_tp_new, _new_ICustomGameControllerFactory },
        { Py_tp_dealloc, _dealloc_ICustomGameControllerFactory },
        { Py_tp_methods, _methods_ICustomGameControllerFactory },
        { Py_tp_getset, _getset_ICustomGameControllerFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ICustomGameControllerFactory =
    {
        "_winsdk_Windows_Gaming_Input_Custom.ICustomGameControllerFactory",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::ICustomGameControllerFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICustomGameControllerFactory
    };

    // ----- IGameControllerInputSink interface --------------------
    constexpr const char* const _type_name_IGameControllerInputSink = "IGameControllerInputSink";

    static PyObject* _new_IGameControllerInputSink(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IGameControllerInputSink);
        return nullptr;
    }

    static void _dealloc_IGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputResumed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputSuspended(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameControllerInputSink[] = {
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGameControllerInputSink[] = {
        { }
    };

    static PyType_Slot _type_slots_IGameControllerInputSink[] = 
    {
        { Py_tp_new, _new_IGameControllerInputSink },
        { Py_tp_dealloc, _dealloc_IGameControllerInputSink },
        { Py_tp_methods, _methods_IGameControllerInputSink },
        { Py_tp_getset, _getset_IGameControllerInputSink },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IGameControllerInputSink =
    {
        "_winsdk_Windows_Gaming_Input_Custom.IGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameControllerInputSink
    };

    // ----- IGameControllerProvider interface --------------------
    constexpr const char* const _type_name_IGameControllerProvider = "IGameControllerProvider";

    static PyObject* _new_IGameControllerProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IGameControllerProvider);
        return nullptr;
    }

    static void _dealloc_IGameControllerProvider(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IGameControllerProvider_get_FirmwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FirmwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_HardwareVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareVersionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameControllerProvider_get_IsConnected(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IGameControllerProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameControllerProvider[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameControllerProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGameControllerProvider[] = {
        { "firmware_version_info", reinterpret_cast<getter>(IGameControllerProvider_get_FirmwareVersionInfo), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(IGameControllerProvider_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(IGameControllerProvider_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "hardware_version_info", reinterpret_cast<getter>(IGameControllerProvider_get_HardwareVersionInfo), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(IGameControllerProvider_get_IsConnected), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IGameControllerProvider[] = 
    {
        { Py_tp_new, _new_IGameControllerProvider },
        { Py_tp_dealloc, _dealloc_IGameControllerProvider },
        { Py_tp_methods, _methods_IGameControllerProvider },
        { Py_tp_getset, _getset_IGameControllerProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IGameControllerProvider =
    {
        "_winsdk_Windows_Gaming_Input_Custom.IGameControllerProvider",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IGameControllerProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameControllerProvider
    };

    // ----- IGipGameControllerInputSink interface --------------------
    constexpr const char* const _type_name_IGipGameControllerInputSink = "IGipGameControllerInputSink";

    static PyObject* _new_IGipGameControllerInputSink(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IGipGameControllerInputSink);
        return nullptr;
    }

    static void _dealloc_IGipGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IGipGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputResumed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGipGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputSuspended(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGipGameControllerInputSink_OnKeyReceived(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.OnKeyReceived(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IGipGameControllerInputSink_OnMessageReceived(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Gaming::Input::Custom::GipMessageClass>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);
                auto param3 = py::convert_to<uint8_t>(args, 3);
                auto param4 = py::convert_to<winrt::array_view<uint8_t>>(args, 4);

                self->obj.OnMessageReceived(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IGipGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGipGameControllerInputSink[] = {
        { "on_key_received", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnKeyReceived), METH_VARARGS, nullptr },
        { "on_message_received", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnMessageReceived), METH_VARARGS, nullptr },
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IGipGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGipGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGipGameControllerInputSink[] = {
        { }
    };

    static PyType_Slot _type_slots_IGipGameControllerInputSink[] = 
    {
        { Py_tp_new, _new_IGipGameControllerInputSink },
        { Py_tp_dealloc, _dealloc_IGipGameControllerInputSink },
        { Py_tp_methods, _methods_IGipGameControllerInputSink },
        { Py_tp_getset, _getset_IGipGameControllerInputSink },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IGipGameControllerInputSink =
    {
        "_winsdk_Windows_Gaming_Input_Custom.IGipGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IGipGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGipGameControllerInputSink
    };

    // ----- IHidGameControllerInputSink interface --------------------
    constexpr const char* const _type_name_IHidGameControllerInputSink = "IHidGameControllerInputSink";

    static PyObject* _new_IHidGameControllerInputSink(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IHidGameControllerInputSink);
        return nullptr;
    }

    static void _dealloc_IHidGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IHidGameControllerInputSink_OnInputReportReceived(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<uint8_t>>(args, 2);

                self->obj.OnInputReportReceived(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHidGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputResumed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IHidGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputSuspended(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IHidGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IHidGameControllerInputSink[] = {
        { "on_input_report_received", reinterpret_cast<PyCFunction>(IHidGameControllerInputSink_OnInputReportReceived), METH_VARARGS, nullptr },
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IHidGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IHidGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IHidGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IHidGameControllerInputSink[] = {
        { }
    };

    static PyType_Slot _type_slots_IHidGameControllerInputSink[] = 
    {
        { Py_tp_new, _new_IHidGameControllerInputSink },
        { Py_tp_dealloc, _dealloc_IHidGameControllerInputSink },
        { Py_tp_methods, _methods_IHidGameControllerInputSink },
        { Py_tp_getset, _getset_IHidGameControllerInputSink },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IHidGameControllerInputSink =
    {
        "_winsdk_Windows_Gaming_Input_Custom.IHidGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IHidGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IHidGameControllerInputSink
    };

    // ----- IXusbGameControllerInputSink interface --------------------
    constexpr const char* const _type_name_IXusbGameControllerInputSink = "IXusbGameControllerInputSink";

    static PyObject* _new_IXusbGameControllerInputSink(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IXusbGameControllerInputSink);
        return nullptr;
    }

    static void _dealloc_IXusbGameControllerInputSink(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IXusbGameControllerInputSink_OnInputReceived(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<uint8_t>>(args, 2);

                self->obj.OnInputReceived(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXusbGameControllerInputSink_OnInputResumed(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputResumed(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IXusbGameControllerInputSink_OnInputSuspended(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.OnInputSuspended(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IXusbGameControllerInputSink(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IXusbGameControllerInputSink[] = {
        { "on_input_received", reinterpret_cast<PyCFunction>(IXusbGameControllerInputSink_OnInputReceived), METH_VARARGS, nullptr },
        { "on_input_resumed", reinterpret_cast<PyCFunction>(IXusbGameControllerInputSink_OnInputResumed), METH_VARARGS, nullptr },
        { "on_input_suspended", reinterpret_cast<PyCFunction>(IXusbGameControllerInputSink_OnInputSuspended), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IXusbGameControllerInputSink), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IXusbGameControllerInputSink[] = {
        { }
    };

    static PyType_Slot _type_slots_IXusbGameControllerInputSink[] = 
    {
        { Py_tp_new, _new_IXusbGameControllerInputSink },
        { Py_tp_dealloc, _dealloc_IXusbGameControllerInputSink },
        { Py_tp_methods, _methods_IXusbGameControllerInputSink },
        { Py_tp_getset, _getset_IXusbGameControllerInputSink },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IXusbGameControllerInputSink =
    {
        "_winsdk_Windows_Gaming_Input_Custom.IXusbGameControllerInputSink",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IXusbGameControllerInputSink
    };

    // ----- GameControllerVersionInfo struct --------------------
    constexpr const char* const _type_name_GameControllerVersionInfo = "GameControllerVersionInfo";

    PyObject* _new_GameControllerVersionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint16_t _Major{};
        uint16_t _Minor{};
        uint16_t _Build{};
        uint16_t _Revision{};

        static const char* kwlist[] = {"major", "minor", "build", "revision", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "HHHH", const_cast<char**>(kwlist), &_Major, &_Minor, &_Build, &_Revision))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo return_value{ _Major, _Minor, _Build, _Revision };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_GameControllerVersionInfo(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self)
    {
    }

    static PyObject* GameControllerVersionInfo_get_Major(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Major);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Major(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Major = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GameControllerVersionInfo_get_Minor(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Minor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Minor(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Minor = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GameControllerVersionInfo_get_Build(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Build);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Build(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Build = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GameControllerVersionInfo_get_Revision(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Revision);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GameControllerVersionInfo_set_Revision(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Revision = py::converter<uint16_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GameControllerVersionInfo[] = {
        { "major", reinterpret_cast<getter>(GameControllerVersionInfo_get_Major), reinterpret_cast<setter>(GameControllerVersionInfo_set_Major), nullptr, nullptr },
        { "minor", reinterpret_cast<getter>(GameControllerVersionInfo_get_Minor), reinterpret_cast<setter>(GameControllerVersionInfo_set_Minor), nullptr, nullptr },
        { "build", reinterpret_cast<getter>(GameControllerVersionInfo_get_Build), reinterpret_cast<setter>(GameControllerVersionInfo_set_Build), nullptr, nullptr },
        { "revision", reinterpret_cast<getter>(GameControllerVersionInfo_get_Revision), reinterpret_cast<setter>(GameControllerVersionInfo_set_Revision), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GameControllerVersionInfo[] = 
    {
        { Py_tp_new, _new_GameControllerVersionInfo },
        { Py_tp_dealloc, _dealloc_GameControllerVersionInfo },
        { Py_tp_getset, _getset_GameControllerVersionInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GameControllerVersionInfo =
    {
        "_winsdk_Windows_Gaming_Input_Custom.GameControllerVersionInfo",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GameControllerVersionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GameControllerVersionInfo
    };

    // ----- GipFirmwareUpdateProgress struct --------------------
    constexpr const char* const _type_name_GipFirmwareUpdateProgress = "GipFirmwareUpdateProgress";

    PyObject* _new_GipFirmwareUpdateProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        double _PercentCompleted{};
        uint32_t _CurrentComponentId{};

        static const char* kwlist[] = {"percent_completed", "current_component_id", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dI", const_cast<char**>(kwlist), &_PercentCompleted, &_CurrentComponentId))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress return_value{ _PercentCompleted, _CurrentComponentId };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_GipFirmwareUpdateProgress(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self)
    {
    }

    static PyObject* GipFirmwareUpdateProgress_get_PercentCompleted(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PercentCompleted);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GipFirmwareUpdateProgress_set_PercentCompleted(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PercentCompleted = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GipFirmwareUpdateProgress_get_CurrentComponentId(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentComponentId);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GipFirmwareUpdateProgress_set_CurrentComponentId(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.CurrentComponentId = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GipFirmwareUpdateProgress[] = {
        { "percent_completed", reinterpret_cast<getter>(GipFirmwareUpdateProgress_get_PercentCompleted), reinterpret_cast<setter>(GipFirmwareUpdateProgress_set_PercentCompleted), nullptr, nullptr },
        { "current_component_id", reinterpret_cast<getter>(GipFirmwareUpdateProgress_get_CurrentComponentId), reinterpret_cast<setter>(GipFirmwareUpdateProgress_set_CurrentComponentId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GipFirmwareUpdateProgress[] = 
    {
        { Py_tp_new, _new_GipFirmwareUpdateProgress },
        { Py_tp_dealloc, _dealloc_GipFirmwareUpdateProgress },
        { Py_tp_getset, _getset_GipFirmwareUpdateProgress },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GipFirmwareUpdateProgress =
    {
        "_winsdk_Windows_Gaming_Input_Custom.GipFirmwareUpdateProgress",
        sizeof(py::wrapper::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GipFirmwareUpdateProgress
    };

    // ----- Windows.Gaming.Input.Custom Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Gaming::Input::Custom::GameControllerFactoryManager>::python_type = py::register_python_type(module, _type_name_GameControllerFactoryManager, &_type_spec_GameControllerFactoryManager, nullptr);
            py::winrt_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateResult>::python_type = py::register_python_type(module, _type_name_GipFirmwareUpdateResult, &_type_spec_GipFirmwareUpdateResult, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::Custom::GipGameControllerProvider>::python_type = py::register_python_type(module, _type_name_GipGameControllerProvider, &_type_spec_GipGameControllerProvider, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::Custom::HidGameControllerProvider>::python_type = py::register_python_type(module, _type_name_HidGameControllerProvider, &_type_spec_HidGameControllerProvider, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::Custom::XusbGameControllerProvider>::python_type = py::register_python_type(module, _type_name_XusbGameControllerProvider, &_type_spec_XusbGameControllerProvider, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::Custom::ICustomGameControllerFactory>::python_type = py::register_python_type(module, _type_name_ICustomGameControllerFactory, &_type_spec_ICustomGameControllerFactory, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::Custom::IGameControllerInputSink>::python_type = py::register_python_type(module, _type_name_IGameControllerInputSink, &_type_spec_IGameControllerInputSink, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::Custom::IGameControllerProvider>::python_type = py::register_python_type(module, _type_name_IGameControllerProvider, &_type_spec_IGameControllerProvider, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::Custom::IGipGameControllerInputSink>::python_type = py::register_python_type(module, _type_name_IGipGameControllerInputSink, &_type_spec_IGipGameControllerInputSink, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::Custom::IHidGameControllerInputSink>::python_type = py::register_python_type(module, _type_name_IHidGameControllerInputSink, &_type_spec_IHidGameControllerInputSink, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::Custom::IXusbGameControllerInputSink>::python_type = py::register_python_type(module, _type_name_IXusbGameControllerInputSink, &_type_spec_IXusbGameControllerInputSink, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::Custom::GameControllerVersionInfo>::python_type = py::register_python_type(module, _type_name_GameControllerVersionInfo, &_type_spec_GameControllerVersionInfo, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::Custom::GipFirmwareUpdateProgress>::python_type = py::register_python_type(module, _type_name_GipFirmwareUpdateProgress, &_type_spec_GipFirmwareUpdateProgress, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Gaming.Input.Custom");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Gaming_Input_Custom",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Gaming::Input::Custom

PyMODINIT_FUNC
PyInit__winsdk_Windows_Gaming_Input_Custom (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Gaming::Input::Custom::module_def);
}
