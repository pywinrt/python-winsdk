// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.6

#include "pybase.h"
#include "py.Windows.Media.Core.h"


PyObject* py::converter<winrt::Windows::Media::Core::MseTimeRange>::convert(winrt::Windows::Media::Core::MseTimeRange instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Media::Core::MseTimeRange>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Media::Core::MseTimeRange py::converter<winrt::Windows::Media::Core::MseTimeRange>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Media::Core::MseTimeRange>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::MseTimeRange>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Media::Core::MseTimeRange");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Media::Core::TimedTextDouble>::convert(winrt::Windows::Media::Core::TimedTextDouble instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Media::Core::TimedTextDouble>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Media::Core::TimedTextDouble py::converter<winrt::Windows::Media::Core::TimedTextDouble>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Media::Core::TimedTextDouble>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextDouble>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Media::Core::TimedTextDouble");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Media::Core::TimedTextPadding>::convert(winrt::Windows::Media::Core::TimedTextPadding instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Media::Core::TimedTextPadding>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Media::Core::TimedTextPadding py::converter<winrt::Windows::Media::Core::TimedTextPadding>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Media::Core::TimedTextPadding>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextPadding>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Media::Core::TimedTextPadding");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Media::Core::TimedTextPoint>::convert(winrt::Windows::Media::Core::TimedTextPoint instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Media::Core::TimedTextPoint>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Media::Core::TimedTextPoint py::converter<winrt::Windows::Media::Core::TimedTextPoint>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Media::Core::TimedTextPoint>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextPoint>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Media::Core::TimedTextPoint");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Media::Core::TimedTextSize>::convert(winrt::Windows::Media::Core::TimedTextSize instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Media::Core::TimedTextSize>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Media::Core::TimedTextSize py::converter<winrt::Windows::Media::Core::TimedTextSize>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Media::Core::TimedTextSize>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Core::TimedTextSize>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Media::Core::TimedTextSize");
    throw python_exception();
}

namespace py::cpp::Windows::Media::Core
{
    struct module_state
    {
        PyObject* type_AudioDecoderDegradation;
        PyObject* type_AudioDecoderDegradationReason;
        PyObject* type_CodecCategory;
        PyObject* type_CodecKind;
        PyObject* type_FaceDetectionMode;
        PyObject* type_MediaDecoderStatus;
        PyObject* type_MediaSourceState;
        PyObject* type_MediaSourceStatus;
        PyObject* type_MediaStreamSourceClosedReason;
        PyObject* type_MediaStreamSourceErrorStatus;
        PyObject* type_MediaTrackKind;
        PyObject* type_MseAppendMode;
        PyObject* type_MseEndOfStreamStatus;
        PyObject* type_MseReadyState;
        PyObject* type_SceneAnalysisRecommendation;
        PyObject* type_TimedMetadataKind;
        PyObject* type_TimedMetadataTrackErrorCode;
        PyObject* type_TimedTextBoutenPosition;
        PyObject* type_TimedTextBoutenType;
        PyObject* type_TimedTextDisplayAlignment;
        PyObject* type_TimedTextFlowDirection;
        PyObject* type_TimedTextFontStyle;
        PyObject* type_TimedTextLineAlignment;
        PyObject* type_TimedTextRubyAlign;
        PyObject* type_TimedTextRubyPosition;
        PyObject* type_TimedTextRubyReserve;
        PyObject* type_TimedTextScrollMode;
        PyObject* type_TimedTextUnit;
        PyObject* type_TimedTextWeight;
        PyObject* type_TimedTextWrapping;
        PyObject* type_TimedTextWritingMode;
        PyObject* type_VideoStabilizationEffectEnabledChangedReason;
        PyTypeObject* type_AudioStreamDescriptor;
        PyTypeObject* type_AudioTrack;
        PyTypeObject* type_AudioTrackOpenFailedEventArgs;
        PyTypeObject* type_AudioTrackSupportInfo;
        PyTypeObject* type_ChapterCue;
        PyTypeObject* type_CodecInfo;
        PyTypeObject* type_CodecQuery;
        PyTypeObject* type_CodecSubtypes;
        PyTypeObject* type_DataCue;
        PyTypeObject* type_FaceDetectedEventArgs;
        PyTypeObject* type_FaceDetectionEffect;
        PyTypeObject* type_FaceDetectionEffectDefinition;
        PyTypeObject* type_FaceDetectionEffectFrame;
        PyTypeObject* type_HighDynamicRangeControl;
        PyTypeObject* type_HighDynamicRangeOutput;
        PyTypeObject* type_ImageCue;
        PyTypeObject* type_InitializeMediaStreamSourceRequestedEventArgs;
        PyTypeObject* type_LowLightFusion;
        PyTypeObject* type_LowLightFusionResult;
        PyTypeObject* type_MediaBinder;
        PyTypeObject* type_MediaBindingEventArgs;
        PyTypeObject* type_MediaCueEventArgs;
        PyTypeObject* type_MediaSource;
        PyTypeObject* type_MediaSourceAppServiceConnection;
        PyTypeObject* type_MediaSourceError;
        PyTypeObject* type_MediaSourceOpenOperationCompletedEventArgs;
        PyTypeObject* type_MediaSourceStateChangedEventArgs;
        PyTypeObject* type_MediaStreamSample;
        PyTypeObject* type_MediaStreamSamplePropertySet;
        PyTypeObject* type_MediaStreamSampleProtectionProperties;
        PyTypeObject* type_MediaStreamSource;
        PyTypeObject* type_MediaStreamSourceClosedEventArgs;
        PyTypeObject* type_MediaStreamSourceClosedRequest;
        PyTypeObject* type_MediaStreamSourceSampleRenderedEventArgs;
        PyTypeObject* type_MediaStreamSourceSampleRequest;
        PyTypeObject* type_MediaStreamSourceSampleRequestDeferral;
        PyTypeObject* type_MediaStreamSourceSampleRequestedEventArgs;
        PyTypeObject* type_MediaStreamSourceStartingEventArgs;
        PyTypeObject* type_MediaStreamSourceStartingRequest;
        PyTypeObject* type_MediaStreamSourceStartingRequestDeferral;
        PyTypeObject* type_MediaStreamSourceSwitchStreamsRequest;
        PyTypeObject* type_MediaStreamSourceSwitchStreamsRequestDeferral;
        PyTypeObject* type_MediaStreamSourceSwitchStreamsRequestedEventArgs;
        PyTypeObject* type_MseSourceBuffer;
        PyTypeObject* type_MseSourceBufferList;
        PyTypeObject* type_MseStreamSource;
        PyTypeObject* type_SceneAnalysisEffect;
        PyTypeObject* type_SceneAnalysisEffectDefinition;
        PyTypeObject* type_SceneAnalysisEffectFrame;
        PyTypeObject* type_SceneAnalyzedEventArgs;
        PyTypeObject* type_SpeechCue;
        PyTypeObject* type_TimedMetadataStreamDescriptor;
        PyTypeObject* type_TimedMetadataTrack;
        PyTypeObject* type_TimedMetadataTrackError;
        PyTypeObject* type_TimedMetadataTrackFailedEventArgs;
        PyTypeObject* type_TimedTextBouten;
        PyTypeObject* type_TimedTextCue;
        PyTypeObject* type_TimedTextLine;
        PyTypeObject* type_TimedTextRegion;
        PyTypeObject* type_TimedTextRuby;
        PyTypeObject* type_TimedTextSource;
        PyTypeObject* type_TimedTextSourceResolveResultEventArgs;
        PyTypeObject* type_TimedTextStyle;
        PyTypeObject* type_TimedTextSubformat;
        PyTypeObject* type_VideoStabilizationEffect;
        PyTypeObject* type_VideoStabilizationEffectDefinition;
        PyTypeObject* type_VideoStabilizationEffectEnabledChangedEventArgs;
        PyTypeObject* type_VideoStreamDescriptor;
        PyTypeObject* type_VideoTrack;
        PyTypeObject* type_VideoTrackOpenFailedEventArgs;
        PyTypeObject* type_VideoTrackSupportInfo;
        PyTypeObject* type_IMediaCue;
        PyTypeObject* type_IMediaSource;
        PyTypeObject* type_IMediaStreamDescriptor;
        PyTypeObject* type_IMediaStreamDescriptor2;
        PyTypeObject* type_IMediaTrack;
        PyTypeObject* type_ISingleSelectMediaTrackList;
        PyTypeObject* type_ITimedMetadataTrackProvider;
        PyTypeObject* type_MseTimeRange;
        PyTypeObject* type_TimedTextDouble;
        PyTypeObject* type_TimedTextPadding;
        PyTypeObject* type_TimedTextPoint;
        PyTypeObject* type_TimedTextSize;
    };

    static PyObject* register_AudioDecoderDegradation(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioDecoderDegradation)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioDecoderDegradation = type;
        Py_INCREF(state->type_AudioDecoderDegradation);


        Py_RETURN_NONE;
    }

    static PyObject* register_AudioDecoderDegradationReason(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioDecoderDegradationReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioDecoderDegradationReason = type;
        Py_INCREF(state->type_AudioDecoderDegradationReason);


        Py_RETURN_NONE;
    }

    static PyObject* register_CodecCategory(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CodecCategory)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CodecCategory = type;
        Py_INCREF(state->type_CodecCategory);


        Py_RETURN_NONE;
    }

    static PyObject* register_CodecKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CodecKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CodecKind = type;
        Py_INCREF(state->type_CodecKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_FaceDetectionMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_FaceDetectionMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FaceDetectionMode = type;
        Py_INCREF(state->type_FaceDetectionMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaDecoderStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaDecoderStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaDecoderStatus = type;
        Py_INCREF(state->type_MediaDecoderStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaSourceState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaSourceState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaSourceState = type;
        Py_INCREF(state->type_MediaSourceState);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaSourceStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaSourceStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaSourceStatus = type;
        Py_INCREF(state->type_MediaSourceStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaStreamSourceClosedReason(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaStreamSourceClosedReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaStreamSourceClosedReason = type;
        Py_INCREF(state->type_MediaStreamSourceClosedReason);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaStreamSourceErrorStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaStreamSourceErrorStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaStreamSourceErrorStatus = type;
        Py_INCREF(state->type_MediaStreamSourceErrorStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaTrackKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaTrackKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaTrackKind = type;
        Py_INCREF(state->type_MediaTrackKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_MseAppendMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MseAppendMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MseAppendMode = type;
        Py_INCREF(state->type_MseAppendMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_MseEndOfStreamStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MseEndOfStreamStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MseEndOfStreamStatus = type;
        Py_INCREF(state->type_MseEndOfStreamStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MseReadyState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MseReadyState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MseReadyState = type;
        Py_INCREF(state->type_MseReadyState);


        Py_RETURN_NONE;
    }

    static PyObject* register_SceneAnalysisRecommendation(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SceneAnalysisRecommendation)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SceneAnalysisRecommendation = type;
        Py_INCREF(state->type_SceneAnalysisRecommendation);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedMetadataKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedMetadataKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedMetadataKind = type;
        Py_INCREF(state->type_TimedMetadataKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedMetadataTrackErrorCode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedMetadataTrackErrorCode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedMetadataTrackErrorCode = type;
        Py_INCREF(state->type_TimedMetadataTrackErrorCode);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedTextBoutenPosition(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedTextBoutenPosition)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedTextBoutenPosition = type;
        Py_INCREF(state->type_TimedTextBoutenPosition);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedTextBoutenType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedTextBoutenType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedTextBoutenType = type;
        Py_INCREF(state->type_TimedTextBoutenType);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedTextDisplayAlignment(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedTextDisplayAlignment)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedTextDisplayAlignment = type;
        Py_INCREF(state->type_TimedTextDisplayAlignment);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedTextFlowDirection(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedTextFlowDirection)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedTextFlowDirection = type;
        Py_INCREF(state->type_TimedTextFlowDirection);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedTextFontStyle(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedTextFontStyle)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedTextFontStyle = type;
        Py_INCREF(state->type_TimedTextFontStyle);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedTextLineAlignment(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedTextLineAlignment)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedTextLineAlignment = type;
        Py_INCREF(state->type_TimedTextLineAlignment);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedTextRubyAlign(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedTextRubyAlign)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedTextRubyAlign = type;
        Py_INCREF(state->type_TimedTextRubyAlign);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedTextRubyPosition(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedTextRubyPosition)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedTextRubyPosition = type;
        Py_INCREF(state->type_TimedTextRubyPosition);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedTextRubyReserve(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedTextRubyReserve)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedTextRubyReserve = type;
        Py_INCREF(state->type_TimedTextRubyReserve);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedTextScrollMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedTextScrollMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedTextScrollMode = type;
        Py_INCREF(state->type_TimedTextScrollMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedTextUnit(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedTextUnit)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedTextUnit = type;
        Py_INCREF(state->type_TimedTextUnit);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedTextWeight(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedTextWeight)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedTextWeight = type;
        Py_INCREF(state->type_TimedTextWeight);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedTextWrapping(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedTextWrapping)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedTextWrapping = type;
        Py_INCREF(state->type_TimedTextWrapping);


        Py_RETURN_NONE;
    }

    static PyObject* register_TimedTextWritingMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TimedTextWritingMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TimedTextWritingMode = type;
        Py_INCREF(state->type_TimedTextWritingMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_VideoStabilizationEffectEnabledChangedReason(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_VideoStabilizationEffectEnabledChangedReason)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_VideoStabilizationEffectEnabledChangedReason = type;
        Py_INCREF(state->type_VideoStabilizationEffectEnabledChangedReason);


        Py_RETURN_NONE;
    }

    // ----- AudioStreamDescriptor class --------------------
    constexpr const char* const type_name_AudioStreamDescriptor = "AudioStreamDescriptor";

    static PyObject* _new_AudioStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::AudioStreamDescriptor instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioStreamDescriptor(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_TrailingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrailingEncoderPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_TrailingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.TrailingEncoderPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_LeadingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeadingEncoderPadding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_LeadingEncoderPadding(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.LeadingEncoderPadding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::AudioStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AudioStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioStreamDescriptor[] = {
        { "copy", reinterpret_cast<PyCFunction>(AudioStreamDescriptor_Copy), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioStreamDescriptor[] = {
        { "encoding_properties", reinterpret_cast<getter>(AudioStreamDescriptor_get_EncodingProperties), nullptr, nullptr, nullptr },
        { "trailing_encoder_padding", reinterpret_cast<getter>(AudioStreamDescriptor_get_TrailingEncoderPadding), reinterpret_cast<setter>(AudioStreamDescriptor_put_TrailingEncoderPadding), nullptr, nullptr },
        { "leading_encoder_padding", reinterpret_cast<getter>(AudioStreamDescriptor_get_LeadingEncoderPadding), reinterpret_cast<setter>(AudioStreamDescriptor_put_LeadingEncoderPadding), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(AudioStreamDescriptor_get_Name), reinterpret_cast<setter>(AudioStreamDescriptor_put_Name), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(AudioStreamDescriptor_get_Language), reinterpret_cast<setter>(AudioStreamDescriptor_put_Language), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(AudioStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(AudioStreamDescriptor_get_Label), reinterpret_cast<setter>(AudioStreamDescriptor_put_Label), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioStreamDescriptor[] = 
    {
        { Py_tp_new, _new_AudioStreamDescriptor },
        { Py_tp_dealloc, _dealloc_AudioStreamDescriptor },
        { Py_tp_methods, _methods_AudioStreamDescriptor },
        { Py_tp_getset, _getset_AudioStreamDescriptor },
        { },
    };

    static PyType_Spec type_spec_AudioStreamDescriptor =
    {
        "_winsdk_Windows_Media_Core.AudioStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::AudioStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioStreamDescriptor
    };

    // ----- AudioTrack class --------------------
    constexpr const char* const type_name_AudioTrack = "AudioTrack";

    static PyObject* _new_AudioTrack(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioTrack);
        return nullptr;
    }

    static void _dealloc_AudioTrack(py::wrapper::Windows::Media::Core::AudioTrack* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioTrack_GetEncodingProperties(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetEncodingProperties());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Name(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_SupportInfo(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Label(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioTrack_put_Label(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioTrack_get_Id(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_Language(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_get_TrackKind(py::wrapper::Windows::Media::Core::AudioTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_add_OpenFailed(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::AudioTrack, winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>>(arg);

            return py::convert(self->obj.OpenFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrack_remove_OpenFailed(py::wrapper::Windows::Media::Core::AudioTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrack[] = {
        { "get_encoding_properties", reinterpret_cast<PyCFunction>(AudioTrack_GetEncodingProperties), METH_VARARGS, nullptr },
        { "add_open_failed", reinterpret_cast<PyCFunction>(AudioTrack_add_OpenFailed), METH_O, nullptr },
        { "remove_open_failed", reinterpret_cast<PyCFunction>(AudioTrack_remove_OpenFailed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioTrack[] = {
        { "name", reinterpret_cast<getter>(AudioTrack_get_Name), nullptr, nullptr, nullptr },
        { "playback_item", reinterpret_cast<getter>(AudioTrack_get_PlaybackItem), nullptr, nullptr, nullptr },
        { "support_info", reinterpret_cast<getter>(AudioTrack_get_SupportInfo), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(AudioTrack_get_Label), reinterpret_cast<setter>(AudioTrack_put_Label), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(AudioTrack_get_Id), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(AudioTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(AudioTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioTrack[] = 
    {
        { Py_tp_new, _new_AudioTrack },
        { Py_tp_dealloc, _dealloc_AudioTrack },
        { Py_tp_methods, _methods_AudioTrack },
        { Py_tp_getset, _getset_AudioTrack },
        { },
    };

    static PyType_Spec type_spec_AudioTrack =
    {
        "_winsdk_Windows_Media_Core.AudioTrack",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrack
    };

    // ----- AudioTrackOpenFailedEventArgs class --------------------
    constexpr const char* const type_name_AudioTrackOpenFailedEventArgs = "AudioTrackOpenFailedEventArgs";

    static PyObject* _new_AudioTrackOpenFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioTrackOpenFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_AudioTrackOpenFailedEventArgs(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioTrackOpenFailedEventArgs_get_ExtendedError(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioTrackOpenFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrackOpenFailedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioTrackOpenFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioTrackOpenFailedEventArgs[] = {
        { "extended_error", reinterpret_cast<getter>(AudioTrackOpenFailedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioTrackOpenFailedEventArgs[] = 
    {
        { Py_tp_new, _new_AudioTrackOpenFailedEventArgs },
        { Py_tp_dealloc, _dealloc_AudioTrackOpenFailedEventArgs },
        { Py_tp_methods, _methods_AudioTrackOpenFailedEventArgs },
        { Py_tp_getset, _getset_AudioTrackOpenFailedEventArgs },
        { },
    };

    static PyType_Spec type_spec_AudioTrackOpenFailedEventArgs =
    {
        "_winsdk_Windows_Media_Core.AudioTrackOpenFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrackOpenFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrackOpenFailedEventArgs
    };

    // ----- AudioTrackSupportInfo class --------------------
    constexpr const char* const type_name_AudioTrackSupportInfo = "AudioTrackSupportInfo";

    static PyObject* _new_AudioTrackSupportInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AudioTrackSupportInfo);
        return nullptr;
    }

    static void _dealloc_AudioTrackSupportInfo(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioTrackSupportInfo_get_DecoderStatus(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecoderStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_Degradation(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Degradation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_DegradationReason(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DegradationReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioTrackSupportInfo_get_MediaSourceStatus(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaSourceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioTrackSupportInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::AudioTrackSupportInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioTrackSupportInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioTrackSupportInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioTrackSupportInfo[] = {
        { "decoder_status", reinterpret_cast<getter>(AudioTrackSupportInfo_get_DecoderStatus), nullptr, nullptr, nullptr },
        { "degradation", reinterpret_cast<getter>(AudioTrackSupportInfo_get_Degradation), nullptr, nullptr, nullptr },
        { "degradation_reason", reinterpret_cast<getter>(AudioTrackSupportInfo_get_DegradationReason), nullptr, nullptr, nullptr },
        { "media_source_status", reinterpret_cast<getter>(AudioTrackSupportInfo_get_MediaSourceStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioTrackSupportInfo[] = 
    {
        { Py_tp_new, _new_AudioTrackSupportInfo },
        { Py_tp_dealloc, _dealloc_AudioTrackSupportInfo },
        { Py_tp_methods, _methods_AudioTrackSupportInfo },
        { Py_tp_getset, _getset_AudioTrackSupportInfo },
        { },
    };

    static PyType_Spec type_spec_AudioTrackSupportInfo =
    {
        "_winsdk_Windows_Media_Core.AudioTrackSupportInfo",
        sizeof(py::wrapper::Windows::Media::Core::AudioTrackSupportInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioTrackSupportInfo
    };

    // ----- ChapterCue class --------------------
    constexpr const char* const type_name_ChapterCue = "ChapterCue";

    static PyObject* _new_ChapterCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::ChapterCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChapterCue(py::wrapper::Windows::Media::Core::ChapterCue* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ChapterCue_get_Title(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Title(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_StartTime(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_StartTime(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_Id(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Id(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChapterCue_get_Duration(py::wrapper::Windows::Media::Core::ChapterCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChapterCue_put_Duration(py::wrapper::Windows::Media::Core::ChapterCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ChapterCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ChapterCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChapterCue[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChapterCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChapterCue[] = {
        { "title", reinterpret_cast<getter>(ChapterCue_get_Title), reinterpret_cast<setter>(ChapterCue_put_Title), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(ChapterCue_get_StartTime), reinterpret_cast<setter>(ChapterCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ChapterCue_get_Id), reinterpret_cast<setter>(ChapterCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(ChapterCue_get_Duration), reinterpret_cast<setter>(ChapterCue_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChapterCue[] = 
    {
        { Py_tp_new, _new_ChapterCue },
        { Py_tp_dealloc, _dealloc_ChapterCue },
        { Py_tp_methods, _methods_ChapterCue },
        { Py_tp_getset, _getset_ChapterCue },
        { },
    };

    static PyType_Spec type_spec_ChapterCue =
    {
        "_winsdk_Windows_Media_Core.ChapterCue",
        sizeof(py::wrapper::Windows::Media::Core::ChapterCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChapterCue
    };

    // ----- CodecInfo class --------------------
    constexpr const char* const type_name_CodecInfo = "CodecInfo";

    static PyObject* _new_CodecInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CodecInfo);
        return nullptr;
    }

    static void _dealloc_CodecInfo(py::wrapper::Windows::Media::Core::CodecInfo* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CodecInfo_get_Category(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Category());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_DisplayName(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_IsTrusted(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTrusted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_Kind(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecInfo_get_Subtypes(py::wrapper::Windows::Media::Core::CodecInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CodecInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::CodecInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CodecInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CodecInfo[] = {
        { "category", reinterpret_cast<getter>(CodecInfo_get_Category), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(CodecInfo_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_trusted", reinterpret_cast<getter>(CodecInfo_get_IsTrusted), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(CodecInfo_get_Kind), nullptr, nullptr, nullptr },
        { "subtypes", reinterpret_cast<getter>(CodecInfo_get_Subtypes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CodecInfo[] = 
    {
        { Py_tp_new, _new_CodecInfo },
        { Py_tp_dealloc, _dealloc_CodecInfo },
        { Py_tp_methods, _methods_CodecInfo },
        { Py_tp_getset, _getset_CodecInfo },
        { },
    };

    static PyType_Spec type_spec_CodecInfo =
    {
        "_winsdk_Windows_Media_Core.CodecInfo",
        sizeof(py::wrapper::Windows::Media::Core::CodecInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecInfo
    };

    // ----- CodecQuery class --------------------
    constexpr const char* const type_name_CodecQuery = "CodecQuery";

    static PyObject* _new_CodecQuery(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::CodecQuery instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CodecQuery(py::wrapper::Windows::Media::Core::CodecQuery* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CodecQuery_FindAllAsync(py::wrapper::Windows::Media::Core::CodecQuery* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::CodecKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Core::CodecCategory>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindAllAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_CodecQuery(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::CodecQuery>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecQuery[] = {
        { "find_all_async", reinterpret_cast<PyCFunction>(CodecQuery_FindAllAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CodecQuery), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CodecQuery[] = {
        { }
    };

    static PyType_Slot _type_slots_CodecQuery[] = 
    {
        { Py_tp_new, _new_CodecQuery },
        { Py_tp_dealloc, _dealloc_CodecQuery },
        { Py_tp_methods, _methods_CodecQuery },
        { Py_tp_getset, _getset_CodecQuery },
        { },
    };

    static PyType_Spec type_spec_CodecQuery =
    {
        "_winsdk_Windows_Media_Core.CodecQuery",
        sizeof(py::wrapper::Windows::Media::Core::CodecQuery),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecQuery
    };

    // ----- CodecSubtypes class --------------------
    constexpr const char* const type_name_CodecSubtypes = "CodecSubtypes";

    static PyObject* _new_CodecSubtypes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CodecSubtypes);
        return nullptr;
    }

    static PyObject* CodecSubtypes_get_AudioFormatAac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAdts(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAdts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAlac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAlac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrNB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrNB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrWB(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrWB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatAmrWP(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatAmrWP());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyAC3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyAC3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyAC3Spdif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyAC3Spdif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDolbyDDPlus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDolbyDDPlus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDrm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDrm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatDts(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatDts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatFlac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatFlac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatFloat(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatFloat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMP3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMP3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMPeg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMPeg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatMsp1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatMsp1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatOpus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatOpus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatPcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatPcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioLossless(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioLossless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioV8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioV8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWMAudioV9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWMAudioV9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_AudioFormatWmaSpdif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::AudioFormatWmaSpdif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormat420O(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormat420O());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDV25(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDV25());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDV50(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDV50());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvh1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvh1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvhD(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvhD());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvsd(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvsd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatDvsl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatDvsl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH263(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH263());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH264(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH264());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH264ES(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH264ES());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatH265(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatH265());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatHevc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatHevc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatHevcES(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatHevcES());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatM4S2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatM4S2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP43(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP43());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP4S(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP4S());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMP4V(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMP4V());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMjpg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMjpg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMpeg2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMpeg2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMpg1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMpg1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMss1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMss1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatMss2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatMss2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatVP80(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatVP80());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatVP90(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatVP90());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWmv3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWmv3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CodecSubtypes_get_VideoFormatWvc1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::CodecSubtypes::VideoFormatWvc1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CodecSubtypes[] = {
        { "get_audio_format_aac", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatAac), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_adts", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatAdts), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_alac", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatAlac), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_amr_n_b", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatAmrNB), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_amr_w_b", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatAmrWB), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_amr_w_p", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatAmrWP), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_dolby_a_c3", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatDolbyAC3), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_dolby_a_c3_spdif", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatDolbyAC3Spdif), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_dolby_d_d_plus", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatDolbyDDPlus), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_drm", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatDrm), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_dts", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatDts), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_flac", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatFlac), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_float", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatFloat), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_m_p3", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatMP3), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_m_peg", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatMPeg), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_msp1", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatMsp1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_opus", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatOpus), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_pcm", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatPcm), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_w_m_audio_lossless", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatWMAudioLossless), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_w_m_audio_v8", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatWMAudioV8), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_w_m_audio_v9", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatWMAudioV9), METH_NOARGS | METH_STATIC, nullptr },
        { "get_audio_format_wma_spdif", reinterpret_cast<PyCFunction>(CodecSubtypes_get_AudioFormatWmaSpdif), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format420_o", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormat420O), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_d_v25", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatDV25), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_d_v50", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatDV50), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvc", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatDvc), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvh1", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatDvh1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvh_d", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatDvhD), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvsd", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatDvsd), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_dvsl", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatDvsl), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_h263", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatH263), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_h264", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatH264), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_h264_e_s", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatH264ES), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_h265", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatH265), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_hevc", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatHevc), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_hevc_e_s", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatHevcES), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_m4_s2", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatM4S2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_m_p43", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMP43), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_m_p4_s", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMP4S), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_m_p4_v", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMP4V), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mjpg", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMjpg), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mpeg2", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMpeg2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mpg1", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMpg1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mss1", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMss1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_mss2", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatMss2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_v_p80", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatVP80), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_v_p90", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatVP90), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_wmv1", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatWmv1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_wmv2", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatWmv2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_wmv3", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatWmv3), METH_NOARGS | METH_STATIC, nullptr },
        { "get_video_format_wvc1", reinterpret_cast<PyCFunction>(CodecSubtypes_get_VideoFormatWvc1), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CodecSubtypes[] = {
        { }
    };

    static PyType_Slot _type_slots_CodecSubtypes[] = 
    {
        { Py_tp_new, _new_CodecSubtypes },
        { Py_tp_methods, _methods_CodecSubtypes },
        { Py_tp_getset, _getset_CodecSubtypes },
        { },
    };

    static PyType_Spec type_spec_CodecSubtypes =
    {
        "_winsdk_Windows_Media_Core.CodecSubtypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CodecSubtypes
    };

    // ----- DataCue class --------------------
    constexpr const char* const type_name_DataCue = "DataCue";

    static PyObject* _new_DataCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::DataCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DataCue(py::wrapper::Windows::Media::Core::DataCue* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DataCue_get_Data(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Data(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Properties(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataCue_get_StartTime(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_StartTime(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Id(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Id(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataCue_get_Duration(py::wrapper::Windows::Media::Core::DataCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataCue_put_Duration(py::wrapper::Windows::Media::Core::DataCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DataCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::DataCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataCue[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DataCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataCue[] = {
        { "data", reinterpret_cast<getter>(DataCue_get_Data), reinterpret_cast<setter>(DataCue_put_Data), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DataCue_get_Properties), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(DataCue_get_StartTime), reinterpret_cast<setter>(DataCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DataCue_get_Id), reinterpret_cast<setter>(DataCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(DataCue_get_Duration), reinterpret_cast<setter>(DataCue_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataCue[] = 
    {
        { Py_tp_new, _new_DataCue },
        { Py_tp_dealloc, _dealloc_DataCue },
        { Py_tp_methods, _methods_DataCue },
        { Py_tp_getset, _getset_DataCue },
        { },
    };

    static PyType_Spec type_spec_DataCue =
    {
        "_winsdk_Windows_Media_Core.DataCue",
        sizeof(py::wrapper::Windows::Media::Core::DataCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataCue
    };

    // ----- FaceDetectedEventArgs class --------------------
    constexpr const char* const type_name_FaceDetectedEventArgs = "FaceDetectedEventArgs";

    static PyObject* _new_FaceDetectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FaceDetectedEventArgs);
        return nullptr;
    }

    static void _dealloc_FaceDetectedEventArgs(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FaceDetectedEventArgs_get_ResultFrame(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResultFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FaceDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectedEventArgs[] = {
        { "result_frame", reinterpret_cast<getter>(FaceDetectedEventArgs_get_ResultFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectedEventArgs[] = 
    {
        { Py_tp_new, _new_FaceDetectedEventArgs },
        { Py_tp_dealloc, _dealloc_FaceDetectedEventArgs },
        { Py_tp_methods, _methods_FaceDetectedEventArgs },
        { Py_tp_getset, _getset_FaceDetectedEventArgs },
        { },
    };

    static PyType_Spec type_spec_FaceDetectedEventArgs =
    {
        "_winsdk_Windows_Media_Core.FaceDetectedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectedEventArgs
    };

    // ----- FaceDetectionEffect class --------------------
    constexpr const char* const type_name_FaceDetectionEffect = "FaceDetectionEffect";

    static PyObject* _new_FaceDetectionEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FaceDetectionEffect);
        return nullptr;
    }

    static void _dealloc_FaceDetectionEffect(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FaceDetectionEffect_SetProperties(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffect_get_Enabled(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffect_put_Enabled(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffect_get_DesiredDetectionInterval(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredDetectionInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffect_put_DesiredDetectionInterval(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredDetectionInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffect_add_FaceDetected(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::FaceDetectionEffect, winrt::Windows::Media::Core::FaceDetectedEventArgs>>(arg);

            return py::convert(self->obj.FaceDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffect_remove_FaceDetected(py::wrapper::Windows::Media::Core::FaceDetectionEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FaceDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FaceDetectionEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffect[] = {
        { "set_properties", reinterpret_cast<PyCFunction>(FaceDetectionEffect_SetProperties), METH_VARARGS, nullptr },
        { "add_face_detected", reinterpret_cast<PyCFunction>(FaceDetectionEffect_add_FaceDetected), METH_O, nullptr },
        { "remove_face_detected", reinterpret_cast<PyCFunction>(FaceDetectionEffect_remove_FaceDetected), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectionEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectionEffect[] = {
        { "enabled", reinterpret_cast<getter>(FaceDetectionEffect_get_Enabled), reinterpret_cast<setter>(FaceDetectionEffect_put_Enabled), nullptr, nullptr },
        { "desired_detection_interval", reinterpret_cast<getter>(FaceDetectionEffect_get_DesiredDetectionInterval), reinterpret_cast<setter>(FaceDetectionEffect_put_DesiredDetectionInterval), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectionEffect[] = 
    {
        { Py_tp_new, _new_FaceDetectionEffect },
        { Py_tp_dealloc, _dealloc_FaceDetectionEffect },
        { Py_tp_methods, _methods_FaceDetectionEffect },
        { Py_tp_getset, _getset_FaceDetectionEffect },
        { },
    };

    static PyType_Spec type_spec_FaceDetectionEffect =
    {
        "_winsdk_Windows_Media_Core.FaceDetectionEffect",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffect
    };

    // ----- FaceDetectionEffectDefinition class --------------------
    constexpr const char* const type_name_FaceDetectionEffectDefinition = "FaceDetectionEffectDefinition";

    static PyObject* _new_FaceDetectionEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::FaceDetectionEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FaceDetectionEffectDefinition(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FaceDetectionEffectDefinition_get_SynchronousDetectionEnabled(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SynchronousDetectionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectDefinition_put_SynchronousDetectionEnabled(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SynchronousDetectionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_DetectionMode(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectDefinition_put_DetectionMode(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::FaceDetectionMode>(arg);

            self->obj.DetectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FaceDetectionEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectionEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectionEffectDefinition[] = {
        { "synchronous_detection_enabled", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_SynchronousDetectionEnabled), reinterpret_cast<setter>(FaceDetectionEffectDefinition_put_SynchronousDetectionEnabled), nullptr, nullptr },
        { "detection_mode", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_DetectionMode), reinterpret_cast<setter>(FaceDetectionEffectDefinition_put_DetectionMode), nullptr, nullptr },
        { "activatable_class_id", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(FaceDetectionEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectionEffectDefinition[] = 
    {
        { Py_tp_new, _new_FaceDetectionEffectDefinition },
        { Py_tp_dealloc, _dealloc_FaceDetectionEffectDefinition },
        { Py_tp_methods, _methods_FaceDetectionEffectDefinition },
        { Py_tp_getset, _getset_FaceDetectionEffectDefinition },
        { },
    };

    static PyType_Spec type_spec_FaceDetectionEffectDefinition =
    {
        "_winsdk_Windows_Media_Core.FaceDetectionEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffectDefinition
    };

    // ----- FaceDetectionEffectFrame class --------------------
    constexpr const char* const type_name_FaceDetectionEffectFrame = "FaceDetectionEffectFrame";

    static PyObject* _new_FaceDetectionEffectFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FaceDetectionEffectFrame);
        return nullptr;
    }

    static void _dealloc_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FaceDetectionEffectFrame_Close(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_DetectedFaces(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectedFaces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_RelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_RelativeTime(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_Duration(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FaceDetectionEffectFrame_put_Duration(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_ExtendedProperties(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_IsReadOnly(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FaceDetectionEffectFrame_get_Type(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FaceDetectionEffectFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::FaceDetectionEffectFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_FaceDetectionEffectFrame(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FaceDetectionEffectFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(FaceDetectionEffectFrame_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FaceDetectionEffectFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_FaceDetectionEffectFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_FaceDetectionEffectFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_FaceDetectionEffectFrame[] = {
        { "detected_faces", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_DetectedFaces), nullptr, nullptr, nullptr },
        { "system_relative_time", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_SystemRelativeTime), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_SystemRelativeTime), nullptr, nullptr },
        { "relative_time", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_RelativeTime), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_RelativeTime), nullptr, nullptr },
        { "is_discontinuous", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_IsDiscontinuous), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_IsDiscontinuous), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_Duration), reinterpret_cast<setter>(FaceDetectionEffectFrame_put_Duration), nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(FaceDetectionEffectFrame_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FaceDetectionEffectFrame[] = 
    {
        { Py_tp_new, _new_FaceDetectionEffectFrame },
        { Py_tp_dealloc, _dealloc_FaceDetectionEffectFrame },
        { Py_tp_methods, _methods_FaceDetectionEffectFrame },
        { Py_tp_getset, _getset_FaceDetectionEffectFrame },
        { },
    };

    static PyType_Spec type_spec_FaceDetectionEffectFrame =
    {
        "_winsdk_Windows_Media_Core.FaceDetectionEffectFrame",
        sizeof(py::wrapper::Windows::Media::Core::FaceDetectionEffectFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FaceDetectionEffectFrame
    };

    // ----- HighDynamicRangeControl class --------------------
    constexpr const char* const type_name_HighDynamicRangeControl = "HighDynamicRangeControl";

    static PyObject* _new_HighDynamicRangeControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HighDynamicRangeControl);
        return nullptr;
    }

    static void _dealloc_HighDynamicRangeControl(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HighDynamicRangeControl_get_Enabled(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HighDynamicRangeControl_put_Enabled(py::wrapper::Windows::Media::Core::HighDynamicRangeControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_HighDynamicRangeControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::HighDynamicRangeControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HighDynamicRangeControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_HighDynamicRangeControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HighDynamicRangeControl[] = {
        { "enabled", reinterpret_cast<getter>(HighDynamicRangeControl_get_Enabled), reinterpret_cast<setter>(HighDynamicRangeControl_put_Enabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HighDynamicRangeControl[] = 
    {
        { Py_tp_new, _new_HighDynamicRangeControl },
        { Py_tp_dealloc, _dealloc_HighDynamicRangeControl },
        { Py_tp_methods, _methods_HighDynamicRangeControl },
        { Py_tp_getset, _getset_HighDynamicRangeControl },
        { },
    };

    static PyType_Spec type_spec_HighDynamicRangeControl =
    {
        "_winsdk_Windows_Media_Core.HighDynamicRangeControl",
        sizeof(py::wrapper::Windows::Media::Core::HighDynamicRangeControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HighDynamicRangeControl
    };

    // ----- HighDynamicRangeOutput class --------------------
    constexpr const char* const type_name_HighDynamicRangeOutput = "HighDynamicRangeOutput";

    static PyObject* _new_HighDynamicRangeOutput(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HighDynamicRangeOutput);
        return nullptr;
    }

    static void _dealloc_HighDynamicRangeOutput(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HighDynamicRangeOutput_get_Certainty(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Certainty());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HighDynamicRangeOutput_get_FrameControllers(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HighDynamicRangeOutput(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::HighDynamicRangeOutput>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HighDynamicRangeOutput[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_HighDynamicRangeOutput), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HighDynamicRangeOutput[] = {
        { "certainty", reinterpret_cast<getter>(HighDynamicRangeOutput_get_Certainty), nullptr, nullptr, nullptr },
        { "frame_controllers", reinterpret_cast<getter>(HighDynamicRangeOutput_get_FrameControllers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HighDynamicRangeOutput[] = 
    {
        { Py_tp_new, _new_HighDynamicRangeOutput },
        { Py_tp_dealloc, _dealloc_HighDynamicRangeOutput },
        { Py_tp_methods, _methods_HighDynamicRangeOutput },
        { Py_tp_getset, _getset_HighDynamicRangeOutput },
        { },
    };

    static PyType_Spec type_spec_HighDynamicRangeOutput =
    {
        "_winsdk_Windows_Media_Core.HighDynamicRangeOutput",
        sizeof(py::wrapper::Windows::Media::Core::HighDynamicRangeOutput),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HighDynamicRangeOutput
    };

    // ----- ImageCue class --------------------
    constexpr const char* const type_name_ImageCue = "ImageCue";

    static PyObject* _new_ImageCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::ImageCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageCue(py::wrapper::Windows::Media::Core::ImageCue* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageCue_get_SoftwareBitmap(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SoftwareBitmap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_SoftwareBitmap(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(arg);

            self->obj.SoftwareBitmap(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Position(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Position(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPoint>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Extent(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Extent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Extent(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextSize>(arg);

            self->obj.Extent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_StartTime(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_StartTime(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Id(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Id(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageCue_get_Duration(py::wrapper::Windows::Media::Core::ImageCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageCue_put_Duration(py::wrapper::Windows::Media::Core::ImageCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ImageCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ImageCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageCue[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageCue[] = {
        { "software_bitmap", reinterpret_cast<getter>(ImageCue_get_SoftwareBitmap), reinterpret_cast<setter>(ImageCue_put_SoftwareBitmap), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(ImageCue_get_Position), reinterpret_cast<setter>(ImageCue_put_Position), nullptr, nullptr },
        { "extent", reinterpret_cast<getter>(ImageCue_get_Extent), reinterpret_cast<setter>(ImageCue_put_Extent), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(ImageCue_get_StartTime), reinterpret_cast<setter>(ImageCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ImageCue_get_Id), reinterpret_cast<setter>(ImageCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(ImageCue_get_Duration), reinterpret_cast<setter>(ImageCue_put_Duration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageCue[] = 
    {
        { Py_tp_new, _new_ImageCue },
        { Py_tp_dealloc, _dealloc_ImageCue },
        { Py_tp_methods, _methods_ImageCue },
        { Py_tp_getset, _getset_ImageCue },
        { },
    };

    static PyType_Spec type_spec_ImageCue =
    {
        "_winsdk_Windows_Media_Core.ImageCue",
        sizeof(py::wrapper::Windows::Media::Core::ImageCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageCue
    };

    // ----- InitializeMediaStreamSourceRequestedEventArgs class --------------------
    constexpr const char* const type_name_InitializeMediaStreamSourceRequestedEventArgs = "InitializeMediaStreamSourceRequestedEventArgs";

    static PyObject* _new_InitializeMediaStreamSourceRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_InitializeMediaStreamSourceRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_InitializeMediaStreamSourceRequestedEventArgs(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_GetDeferral(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_get_RandomAccessStream(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RandomAccessStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InitializeMediaStreamSourceRequestedEventArgs_get_Source(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InitializeMediaStreamSourceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InitializeMediaStreamSourceRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(InitializeMediaStreamSourceRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InitializeMediaStreamSourceRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InitializeMediaStreamSourceRequestedEventArgs[] = {
        { "random_access_stream", reinterpret_cast<getter>(InitializeMediaStreamSourceRequestedEventArgs_get_RandomAccessStream), nullptr, nullptr, nullptr },
        { "source", reinterpret_cast<getter>(InitializeMediaStreamSourceRequestedEventArgs_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InitializeMediaStreamSourceRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_InitializeMediaStreamSourceRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_InitializeMediaStreamSourceRequestedEventArgs },
        { Py_tp_methods, _methods_InitializeMediaStreamSourceRequestedEventArgs },
        { Py_tp_getset, _getset_InitializeMediaStreamSourceRequestedEventArgs },
        { },
    };

    static PyType_Spec type_spec_InitializeMediaStreamSourceRequestedEventArgs =
    {
        "_winsdk_Windows_Media_Core.InitializeMediaStreamSourceRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InitializeMediaStreamSourceRequestedEventArgs
    };

    // ----- LowLightFusion class --------------------
    constexpr const char* const type_name_LowLightFusion = "LowLightFusion";

    static PyObject* _new_LowLightFusion(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LowLightFusion);
        return nullptr;
    }

    static PyObject* LowLightFusion_FuseAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Graphics::Imaging::SoftwareBitmap>>(args, 0);

                return py::convert(winrt::Windows::Media::Core::LowLightFusion::FuseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLightFusion_get_MaxSupportedFrameCount(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::LowLightFusion::MaxSupportedFrameCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLightFusion_get_SupportedBitmapPixelFormats(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::Core::LowLightFusion::SupportedBitmapPixelFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLightFusion[] = {
        { "fuse_async", reinterpret_cast<PyCFunction>(LowLightFusion_FuseAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_max_supported_frame_count", reinterpret_cast<PyCFunction>(LowLightFusion_get_MaxSupportedFrameCount), METH_NOARGS | METH_STATIC, nullptr },
        { "get_supported_bitmap_pixel_formats", reinterpret_cast<PyCFunction>(LowLightFusion_get_SupportedBitmapPixelFormats), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLightFusion[] = {
        { }
    };

    static PyType_Slot _type_slots_LowLightFusion[] = 
    {
        { Py_tp_new, _new_LowLightFusion },
        { Py_tp_methods, _methods_LowLightFusion },
        { Py_tp_getset, _getset_LowLightFusion },
        { },
    };

    static PyType_Spec type_spec_LowLightFusion =
    {
        "_winsdk_Windows_Media_Core.LowLightFusion",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLightFusion
    };

    // ----- LowLightFusionResult class --------------------
    constexpr const char* const type_name_LowLightFusionResult = "LowLightFusionResult";

    static PyObject* _new_LowLightFusionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LowLightFusionResult);
        return nullptr;
    }

    static void _dealloc_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LowLightFusionResult_Close(py::wrapper::Windows::Media::Core::LowLightFusionResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLightFusionResult_get_Frame(py::wrapper::Windows::Media::Core::LowLightFusionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LowLightFusionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::LowLightFusionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_LowLightFusionResult(py::wrapper::Windows::Media::Core::LowLightFusionResult* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLightFusionResult[] = {
        { "close", reinterpret_cast<PyCFunction>(LowLightFusionResult_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLightFusionResult), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LowLightFusionResult), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LowLightFusionResult), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLightFusionResult[] = {
        { "frame", reinterpret_cast<getter>(LowLightFusionResult_get_Frame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LowLightFusionResult[] = 
    {
        { Py_tp_new, _new_LowLightFusionResult },
        { Py_tp_dealloc, _dealloc_LowLightFusionResult },
        { Py_tp_methods, _methods_LowLightFusionResult },
        { Py_tp_getset, _getset_LowLightFusionResult },
        { },
    };

    static PyType_Spec type_spec_LowLightFusionResult =
    {
        "_winsdk_Windows_Media_Core.LowLightFusionResult",
        sizeof(py::wrapper::Windows::Media::Core::LowLightFusionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLightFusionResult
    };

    // ----- MediaBinder class --------------------
    constexpr const char* const type_name_MediaBinder = "MediaBinder";

    static PyObject* _new_MediaBinder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::MediaBinder instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaBinder(py::wrapper::Windows::Media::Core::MediaBinder* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaBinder_get_Token(py::wrapper::Windows::Media::Core::MediaBinder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Token());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaBinder_put_Token(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Token(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaBinder_get_Source(py::wrapper::Windows::Media::Core::MediaBinder* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Source());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBinder_add_Binding(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaBinder, winrt::Windows::Media::Core::MediaBindingEventArgs>>(arg);

            return py::convert(self->obj.Binding(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBinder_remove_Binding(py::wrapper::Windows::Media::Core::MediaBinder* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Binding(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaBinder(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaBinder>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBinder[] = {
        { "add_binding", reinterpret_cast<PyCFunction>(MediaBinder_add_Binding), METH_O, nullptr },
        { "remove_binding", reinterpret_cast<PyCFunction>(MediaBinder_remove_Binding), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBinder), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBinder[] = {
        { "token", reinterpret_cast<getter>(MediaBinder_get_Token), reinterpret_cast<setter>(MediaBinder_put_Token), nullptr, nullptr },
        { "source", reinterpret_cast<getter>(MediaBinder_get_Source), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBinder[] = 
    {
        { Py_tp_new, _new_MediaBinder },
        { Py_tp_dealloc, _dealloc_MediaBinder },
        { Py_tp_methods, _methods_MediaBinder },
        { Py_tp_getset, _getset_MediaBinder },
        { },
    };

    static PyType_Spec type_spec_MediaBinder =
    {
        "_winsdk_Windows_Media_Core.MediaBinder",
        sizeof(py::wrapper::Windows::Media::Core::MediaBinder),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBinder
    };

    // ----- MediaBindingEventArgs class --------------------
    constexpr const char* const type_name_MediaBindingEventArgs = "MediaBindingEventArgs";

    static PyObject* _new_MediaBindingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaBindingEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaBindingEventArgs(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaBindingEventArgs_GetDeferral(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetAdaptiveMediaSource(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>(args, 0);

                self->obj.SetAdaptiveMediaSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetDownloadOperation(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>(args, 0);

                self->obj.SetDownloadOperation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStorageFile(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.SetStorageFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStream(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetStreamReference(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetStreamReference(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_SetUri(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.SetUri(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_get_MediaBinder(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaBinder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_add_Canceled(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaBindingEventArgs, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Canceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaBindingEventArgs_remove_Canceled(py::wrapper::Windows::Media::Core::MediaBindingEventArgs* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Canceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaBindingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaBindingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaBindingEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "set_adaptive_media_source", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetAdaptiveMediaSource), METH_VARARGS, nullptr },
        { "set_download_operation", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetDownloadOperation), METH_VARARGS, nullptr },
        { "set_storage_file", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetStorageFile), METH_VARARGS, nullptr },
        { "set_stream", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetStream), METH_VARARGS, nullptr },
        { "set_stream_reference", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetStreamReference), METH_VARARGS, nullptr },
        { "set_uri", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_SetUri), METH_VARARGS, nullptr },
        { "add_canceled", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_add_Canceled), METH_O, nullptr },
        { "remove_canceled", reinterpret_cast<PyCFunction>(MediaBindingEventArgs_remove_Canceled), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaBindingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaBindingEventArgs[] = {
        { "media_binder", reinterpret_cast<getter>(MediaBindingEventArgs_get_MediaBinder), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaBindingEventArgs[] = 
    {
        { Py_tp_new, _new_MediaBindingEventArgs },
        { Py_tp_dealloc, _dealloc_MediaBindingEventArgs },
        { Py_tp_methods, _methods_MediaBindingEventArgs },
        { Py_tp_getset, _getset_MediaBindingEventArgs },
        { },
    };

    static PyType_Spec type_spec_MediaBindingEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaBindingEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaBindingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaBindingEventArgs
    };

    // ----- MediaCueEventArgs class --------------------
    constexpr const char* const type_name_MediaCueEventArgs = "MediaCueEventArgs";

    static PyObject* _new_MediaCueEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaCueEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaCueEventArgs(py::wrapper::Windows::Media::Core::MediaCueEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaCueEventArgs_get_Cue(py::wrapper::Windows::Media::Core::MediaCueEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCueEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaCueEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCueEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCueEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCueEventArgs[] = {
        { "cue", reinterpret_cast<getter>(MediaCueEventArgs_get_Cue), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCueEventArgs[] = 
    {
        { Py_tp_new, _new_MediaCueEventArgs },
        { Py_tp_dealloc, _dealloc_MediaCueEventArgs },
        { Py_tp_methods, _methods_MediaCueEventArgs },
        { Py_tp_getset, _getset_MediaCueEventArgs },
        { },
    };

    static PyType_Spec type_spec_MediaCueEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaCueEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaCueEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCueEventArgs
    };

    // ----- MediaSource class --------------------
    constexpr const char* const type_name_MediaSource = "MediaSource";

    static PyObject* _new_MediaSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaSource);
        return nullptr;
    }

    static void _dealloc_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSource_Close(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromAdaptiveMediaSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Streaming::Adaptive::AdaptiveMediaSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromAdaptiveMediaSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromDownloadOperation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::BackgroundTransfer::DownloadOperation>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromDownloadOperation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromIMediaSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromIMediaSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaBinder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaBinder>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaBinder(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaFrameSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaFrameSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMediaStreamSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMediaStreamSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromMseStreamSource(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseStreamSource>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromMseStreamSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStorageFile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStorageFile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromStreamReference(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromStreamReference(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_CreateFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MediaSource::CreateFromUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_OpenAsync(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_Reset(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_CustomProperties(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_Duration(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_ExternalTimedMetadataTracks(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExternalTimedMetadataTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_ExternalTimedTextSources(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExternalTimedTextSources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_IsOpen(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOpen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_State(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_AdaptiveMediaSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdaptiveMediaSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_MediaStreamSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaStreamSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_MseStreamSource(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MseStreamSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_Uri(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_get_DownloadOperation(py::wrapper::Windows::Media::Core::MediaSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DownloadOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_add_OpenOperationCompleted(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSource, winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>>(arg);

            return py::convert(self->obj.OpenOperationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_remove_OpenOperationCompleted(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenOperationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_add_StateChanged(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSource, winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSource_remove_StateChanged(py::wrapper::Windows::Media::Core::MediaSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MediaSource(py::wrapper::Windows::Media::Core::MediaSource* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSource[] = {
        { "close", reinterpret_cast<PyCFunction>(MediaSource_Close), METH_VARARGS, nullptr },
        { "create_from_adaptive_media_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromAdaptiveMediaSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_download_operation", reinterpret_cast<PyCFunction>(MediaSource_CreateFromDownloadOperation), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_i_media_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromIMediaSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_media_binder", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMediaBinder), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_media_frame_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMediaFrameSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_media_stream_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMediaStreamSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_mse_stream_source", reinterpret_cast<PyCFunction>(MediaSource_CreateFromMseStreamSource), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_storage_file", reinterpret_cast<PyCFunction>(MediaSource_CreateFromStorageFile), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream", reinterpret_cast<PyCFunction>(MediaSource_CreateFromStream), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_reference", reinterpret_cast<PyCFunction>(MediaSource_CreateFromStreamReference), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_uri", reinterpret_cast<PyCFunction>(MediaSource_CreateFromUri), METH_VARARGS | METH_STATIC, nullptr },
        { "open_async", reinterpret_cast<PyCFunction>(MediaSource_OpenAsync), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(MediaSource_Reset), METH_VARARGS, nullptr },
        { "add_open_operation_completed", reinterpret_cast<PyCFunction>(MediaSource_add_OpenOperationCompleted), METH_O, nullptr },
        { "remove_open_operation_completed", reinterpret_cast<PyCFunction>(MediaSource_remove_OpenOperationCompleted), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(MediaSource_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(MediaSource_remove_StateChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSource), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaSource), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaSource), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSource[] = {
        { "custom_properties", reinterpret_cast<getter>(MediaSource_get_CustomProperties), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaSource_get_Duration), nullptr, nullptr, nullptr },
        { "external_timed_metadata_tracks", reinterpret_cast<getter>(MediaSource_get_ExternalTimedMetadataTracks), nullptr, nullptr, nullptr },
        { "external_timed_text_sources", reinterpret_cast<getter>(MediaSource_get_ExternalTimedTextSources), nullptr, nullptr, nullptr },
        { "is_open", reinterpret_cast<getter>(MediaSource_get_IsOpen), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(MediaSource_get_State), nullptr, nullptr, nullptr },
        { "adaptive_media_source", reinterpret_cast<getter>(MediaSource_get_AdaptiveMediaSource), nullptr, nullptr, nullptr },
        { "media_stream_source", reinterpret_cast<getter>(MediaSource_get_MediaStreamSource), nullptr, nullptr, nullptr },
        { "mse_stream_source", reinterpret_cast<getter>(MediaSource_get_MseStreamSource), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(MediaSource_get_Uri), nullptr, nullptr, nullptr },
        { "download_operation", reinterpret_cast<getter>(MediaSource_get_DownloadOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSource[] = 
    {
        { Py_tp_new, _new_MediaSource },
        { Py_tp_dealloc, _dealloc_MediaSource },
        { Py_tp_methods, _methods_MediaSource },
        { Py_tp_getset, _getset_MediaSource },
        { },
    };

    static PyType_Spec type_spec_MediaSource =
    {
        "_winsdk_Windows_Media_Core.MediaSource",
        sizeof(py::wrapper::Windows::Media::Core::MediaSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSource
    };

    // ----- MediaSourceAppServiceConnection class --------------------
    constexpr const char* const type_name_MediaSourceAppServiceConnection = "MediaSourceAppServiceConnection";

    static PyObject* _new_MediaSourceAppServiceConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::AppService::AppServiceConnection>(args, 0);

                winrt::Windows::Media::Core::MediaSourceAppServiceConnection instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaSourceAppServiceConnection(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceAppServiceConnection_Start(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaSourceAppServiceConnection_add_InitializeMediaStreamSourceRequested(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaSourceAppServiceConnection, winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>>(arg);

            return py::convert(self->obj.InitializeMediaStreamSourceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceAppServiceConnection_remove_InitializeMediaStreamSourceRequested(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.InitializeMediaStreamSourceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSourceAppServiceConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceAppServiceConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceAppServiceConnection[] = {
        { "start", reinterpret_cast<PyCFunction>(MediaSourceAppServiceConnection_Start), METH_VARARGS, nullptr },
        { "add_initialize_media_stream_source_requested", reinterpret_cast<PyCFunction>(MediaSourceAppServiceConnection_add_InitializeMediaStreamSourceRequested), METH_O, nullptr },
        { "remove_initialize_media_stream_source_requested", reinterpret_cast<PyCFunction>(MediaSourceAppServiceConnection_remove_InitializeMediaStreamSourceRequested), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceAppServiceConnection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceAppServiceConnection[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaSourceAppServiceConnection[] = 
    {
        { Py_tp_new, _new_MediaSourceAppServiceConnection },
        { Py_tp_dealloc, _dealloc_MediaSourceAppServiceConnection },
        { Py_tp_methods, _methods_MediaSourceAppServiceConnection },
        { Py_tp_getset, _getset_MediaSourceAppServiceConnection },
        { },
    };

    static PyType_Spec type_spec_MediaSourceAppServiceConnection =
    {
        "_winsdk_Windows_Media_Core.MediaSourceAppServiceConnection",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceAppServiceConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceAppServiceConnection
    };

    // ----- MediaSourceError class --------------------
    constexpr const char* const type_name_MediaSourceError = "MediaSourceError";

    static PyObject* _new_MediaSourceError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaSourceError);
        return nullptr;
    }

    static void _dealloc_MediaSourceError(py::wrapper::Windows::Media::Core::MediaSourceError* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceError_get_ExtendedError(py::wrapper::Windows::Media::Core::MediaSourceError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSourceError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceError>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceError[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceError), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceError[] = {
        { "extended_error", reinterpret_cast<getter>(MediaSourceError_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceError[] = 
    {
        { Py_tp_new, _new_MediaSourceError },
        { Py_tp_dealloc, _dealloc_MediaSourceError },
        { Py_tp_methods, _methods_MediaSourceError },
        { Py_tp_getset, _getset_MediaSourceError },
        { },
    };

    static PyType_Spec type_spec_MediaSourceError =
    {
        "_winsdk_Windows_Media_Core.MediaSourceError",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceError),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceError
    };

    // ----- MediaSourceOpenOperationCompletedEventArgs class --------------------
    constexpr const char* const type_name_MediaSourceOpenOperationCompletedEventArgs = "MediaSourceOpenOperationCompletedEventArgs";

    static PyObject* _new_MediaSourceOpenOperationCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaSourceOpenOperationCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaSourceOpenOperationCompletedEventArgs(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceOpenOperationCompletedEventArgs_get_Error(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSourceOpenOperationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceOpenOperationCompletedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceOpenOperationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceOpenOperationCompletedEventArgs[] = {
        { "error", reinterpret_cast<getter>(MediaSourceOpenOperationCompletedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceOpenOperationCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaSourceOpenOperationCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaSourceOpenOperationCompletedEventArgs },
        { Py_tp_methods, _methods_MediaSourceOpenOperationCompletedEventArgs },
        { Py_tp_getset, _getset_MediaSourceOpenOperationCompletedEventArgs },
        { },
    };

    static PyType_Spec type_spec_MediaSourceOpenOperationCompletedEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaSourceOpenOperationCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceOpenOperationCompletedEventArgs
    };

    // ----- MediaSourceStateChangedEventArgs class --------------------
    constexpr const char* const type_name_MediaSourceStateChangedEventArgs = "MediaSourceStateChangedEventArgs";

    static PyObject* _new_MediaSourceStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaSourceStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaSourceStateChangedEventArgs(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaSourceStateChangedEventArgs_get_NewState(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaSourceStateChangedEventArgs_get_OldState(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaSourceStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaSourceStateChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaSourceStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaSourceStateChangedEventArgs[] = {
        { "new_state", reinterpret_cast<getter>(MediaSourceStateChangedEventArgs_get_NewState), nullptr, nullptr, nullptr },
        { "old_state", reinterpret_cast<getter>(MediaSourceStateChangedEventArgs_get_OldState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaSourceStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaSourceStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaSourceStateChangedEventArgs },
        { Py_tp_methods, _methods_MediaSourceStateChangedEventArgs },
        { Py_tp_getset, _getset_MediaSourceStateChangedEventArgs },
        { },
    };

    static PyType_Spec type_spec_MediaSourceStateChangedEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaSourceStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaSourceStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaSourceStateChangedEventArgs
    };

    // ----- MediaStreamSample class --------------------
    constexpr const char* const type_name_MediaStreamSample = "MediaStreamSample";

    static PyObject* _new_MediaStreamSample(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSample);
        return nullptr;
    }

    static void _dealloc_MediaStreamSample(py::wrapper::Windows::Media::Core::MediaStreamSample* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSample_CreateFromBuffer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromBuffer(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_CreateFromDirect3D11Surface(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromDirect3D11Surface(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_CreateFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                return py::convert(winrt::Windows::Media::Core::MediaStreamSample::CreateFromStreamAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_KeyFrame(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_KeyFrame(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeyFrame(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Duration(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_Duration(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Discontinuous(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Discontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_Discontinuous(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Discontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_DecodeTimestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecodeTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSample_put_DecodeTimestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DecodeTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSample_get_Buffer(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buffer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_ExtendedProperties(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Protection(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Timestamp(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_get_Direct3D11Surface(py::wrapper::Windows::Media::Core::MediaStreamSample* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Direct3D11Surface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_add_Processed(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSample, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Processed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSample_remove_Processed(py::wrapper::Windows::Media::Core::MediaStreamSample* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Processed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSample(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSample>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSample[] = {
        { "create_from_buffer", reinterpret_cast<PyCFunction>(MediaStreamSample_CreateFromBuffer), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_direct3_d11_surface", reinterpret_cast<PyCFunction>(MediaStreamSample_CreateFromDirect3D11Surface), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_async", reinterpret_cast<PyCFunction>(MediaStreamSample_CreateFromStreamAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_processed", reinterpret_cast<PyCFunction>(MediaStreamSample_add_Processed), METH_O, nullptr },
        { "remove_processed", reinterpret_cast<PyCFunction>(MediaStreamSample_remove_Processed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSample), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSample[] = {
        { "key_frame", reinterpret_cast<getter>(MediaStreamSample_get_KeyFrame), reinterpret_cast<setter>(MediaStreamSample_put_KeyFrame), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaStreamSample_get_Duration), reinterpret_cast<setter>(MediaStreamSample_put_Duration), nullptr, nullptr },
        { "discontinuous", reinterpret_cast<getter>(MediaStreamSample_get_Discontinuous), reinterpret_cast<setter>(MediaStreamSample_put_Discontinuous), nullptr, nullptr },
        { "decode_timestamp", reinterpret_cast<getter>(MediaStreamSample_get_DecodeTimestamp), reinterpret_cast<setter>(MediaStreamSample_put_DecodeTimestamp), nullptr, nullptr },
        { "buffer", reinterpret_cast<getter>(MediaStreamSample_get_Buffer), nullptr, nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(MediaStreamSample_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "protection", reinterpret_cast<getter>(MediaStreamSample_get_Protection), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MediaStreamSample_get_Timestamp), nullptr, nullptr, nullptr },
        { "direct3_d11_surface", reinterpret_cast<getter>(MediaStreamSample_get_Direct3D11Surface), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSample[] = 
    {
        { Py_tp_new, _new_MediaStreamSample },
        { Py_tp_dealloc, _dealloc_MediaStreamSample },
        { Py_tp_methods, _methods_MediaStreamSample },
        { Py_tp_getset, _getset_MediaStreamSample },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSample =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSample",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSample),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSample
    };

    // ----- MediaStreamSamplePropertySet class --------------------
    constexpr const char* const type_name_MediaStreamSamplePropertySet = "MediaStreamSamplePropertySet";

    static PyObject* _new_MediaStreamSamplePropertySet(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSamplePropertySet);
        return nullptr;
    }

    static void _dealloc_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSamplePropertySet_Clear(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_First(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_GetView(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_HasKey(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Insert(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Lookup(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_Remove(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSamplePropertySet_get_Size(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSamplePropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSamplePropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};
            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::guid>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* key) noexcept
    {
        try
        {
            auto value = self->obj.TryLookup(py::convert_to<winrt::guid>(key));

            if (!value) {
                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_MediaStreamSamplePropertySet(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::guid>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_MediaStreamSamplePropertySet[] = {
        { "clear", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(MediaStreamSamplePropertySet_Remove), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSamplePropertySet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSamplePropertySet[] = {
        { "size", reinterpret_cast<getter>(MediaStreamSamplePropertySet_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSamplePropertySet[] = 
    {
        { Py_tp_new, _new_MediaStreamSamplePropertySet },
        { Py_tp_dealloc, _dealloc_MediaStreamSamplePropertySet },
        { Py_tp_methods, _methods_MediaStreamSamplePropertySet },
        { Py_tp_getset, _getset_MediaStreamSamplePropertySet },
        { Py_tp_iter, _iterator_MediaStreamSamplePropertySet },
        { Py_sq_contains, _map_contains_MediaStreamSamplePropertySet },
        { Py_mp_length, _map_length_MediaStreamSamplePropertySet },
        { Py_mp_subscript, _map_subscript_MediaStreamSamplePropertySet },
        { Py_mp_ass_subscript, _map_assign_MediaStreamSamplePropertySet },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSamplePropertySet =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSamplePropertySet",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSamplePropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSamplePropertySet
    };

    // ----- MediaStreamSampleProtectionProperties class --------------------
    constexpr const char* const type_name_MediaStreamSampleProtectionProperties = "MediaStreamSampleProtectionProperties";

    static PyObject* _new_MediaStreamSampleProtectionProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSampleProtectionProperties);
        return nullptr;
    }

    static void _dealloc_MediaStreamSampleProtectionProperties(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetInitializationVector(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetInitializationVector(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetKeyIdentifier(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetKeyIdentifier(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_GetSubSampleMapping(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetSubSampleMapping(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetInitializationVector(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetInitializationVector(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetKeyIdentifier(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetKeyIdentifier(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSampleProtectionProperties_SetSubSampleMapping(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetSubSampleMapping(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSampleProtectionProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSampleProtectionProperties[] = {
        { "get_initialization_vector", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_GetInitializationVector), METH_VARARGS, nullptr },
        { "get_key_identifier", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_GetKeyIdentifier), METH_VARARGS, nullptr },
        { "get_sub_sample_mapping", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_GetSubSampleMapping), METH_VARARGS, nullptr },
        { "set_initialization_vector", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_SetInitializationVector), METH_VARARGS, nullptr },
        { "set_key_identifier", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_SetKeyIdentifier), METH_VARARGS, nullptr },
        { "set_sub_sample_mapping", reinterpret_cast<PyCFunction>(MediaStreamSampleProtectionProperties_SetSubSampleMapping), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSampleProtectionProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSampleProtectionProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSampleProtectionProperties[] = 
    {
        { Py_tp_new, _new_MediaStreamSampleProtectionProperties },
        { Py_tp_dealloc, _dealloc_MediaStreamSampleProtectionProperties },
        { Py_tp_methods, _methods_MediaStreamSampleProtectionProperties },
        { Py_tp_getset, _getset_MediaStreamSampleProtectionProperties },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSampleProtectionProperties =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSampleProtectionProperties",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSampleProtectionProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSampleProtectionProperties
    };

    // ----- MediaStreamSource class --------------------
    constexpr const char* const type_name_MediaStreamSource = "MediaStreamSource";

    static PyObject* _new_MediaStreamSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);

                winrt::Windows::Media::Core::MediaStreamSource instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 1);

                winrt::Windows::Media::Core::MediaStreamSource instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaStreamSource(py::wrapper::Windows::Media::Core::MediaStreamSource* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSource_AddProtectionKey(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<uint8_t>>(args, 2);

                self->obj.AddProtectionKey(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_AddStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaStreamDescriptor>(args, 0);

                self->obj.AddStreamDescriptor(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_NotifyError(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSourceErrorStatus>(args, 0);

                self->obj.NotifyError(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_SetBufferedRange(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                self->obj.SetBufferedRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_Thumbnail(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_Thumbnail(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_MediaProtectionManager(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaProtectionManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_MediaProtectionManager(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Protection::MediaProtectionManager>(arg);

            self->obj.MediaProtectionManager(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_Duration(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_Duration(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_CanSeek(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanSeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_CanSeek(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanSeek(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_BufferTime(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BufferTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_BufferTime(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BufferTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_MusicProperties(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MusicProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_VideoProperties(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_get_MaxSupportedPlaybackRate(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxSupportedPlaybackRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_MaxSupportedPlaybackRate(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<double>>(arg);

            self->obj.MaxSupportedPlaybackRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_get_IsLive(py::wrapper::Windows::Media::Core::MediaStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSource_put_IsLive(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSource_add_Closed(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Closed(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_Paused(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Paused(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Paused(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Paused(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SampleRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>>(arg);

            return py::convert(self->obj.SampleRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SampleRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SampleRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_Starting(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>>(arg);

            return py::convert(self->obj.Starting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_Starting(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Starting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SwitchStreamsRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>>(arg);

            return py::convert(self->obj.SwitchStreamsRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SwitchStreamsRequested(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SwitchStreamsRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_add_SampleRendered(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MediaStreamSource, winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>>(arg);

            return py::convert(self->obj.SampleRendered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSource_remove_SampleRendered(py::wrapper::Windows::Media::Core::MediaStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SampleRendered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSource[] = {
        { "add_protection_key", reinterpret_cast<PyCFunction>(MediaStreamSource_AddProtectionKey), METH_VARARGS, nullptr },
        { "add_stream_descriptor", reinterpret_cast<PyCFunction>(MediaStreamSource_AddStreamDescriptor), METH_VARARGS, nullptr },
        { "notify_error", reinterpret_cast<PyCFunction>(MediaStreamSource_NotifyError), METH_VARARGS, nullptr },
        { "set_buffered_range", reinterpret_cast<PyCFunction>(MediaStreamSource_SetBufferedRange), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(MediaStreamSource_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_Closed), METH_O, nullptr },
        { "add_paused", reinterpret_cast<PyCFunction>(MediaStreamSource_add_Paused), METH_O, nullptr },
        { "remove_paused", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_Paused), METH_O, nullptr },
        { "add_sample_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_add_SampleRequested), METH_O, nullptr },
        { "remove_sample_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_SampleRequested), METH_O, nullptr },
        { "add_starting", reinterpret_cast<PyCFunction>(MediaStreamSource_add_Starting), METH_O, nullptr },
        { "remove_starting", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_Starting), METH_O, nullptr },
        { "add_switch_streams_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_add_SwitchStreamsRequested), METH_O, nullptr },
        { "remove_switch_streams_requested", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_SwitchStreamsRequested), METH_O, nullptr },
        { "add_sample_rendered", reinterpret_cast<PyCFunction>(MediaStreamSource_add_SampleRendered), METH_O, nullptr },
        { "remove_sample_rendered", reinterpret_cast<PyCFunction>(MediaStreamSource_remove_SampleRendered), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSource[] = {
        { "thumbnail", reinterpret_cast<getter>(MediaStreamSource_get_Thumbnail), reinterpret_cast<setter>(MediaStreamSource_put_Thumbnail), nullptr, nullptr },
        { "media_protection_manager", reinterpret_cast<getter>(MediaStreamSource_get_MediaProtectionManager), reinterpret_cast<setter>(MediaStreamSource_put_MediaProtectionManager), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(MediaStreamSource_get_Duration), reinterpret_cast<setter>(MediaStreamSource_put_Duration), nullptr, nullptr },
        { "can_seek", reinterpret_cast<getter>(MediaStreamSource_get_CanSeek), reinterpret_cast<setter>(MediaStreamSource_put_CanSeek), nullptr, nullptr },
        { "buffer_time", reinterpret_cast<getter>(MediaStreamSource_get_BufferTime), reinterpret_cast<setter>(MediaStreamSource_put_BufferTime), nullptr, nullptr },
        { "music_properties", reinterpret_cast<getter>(MediaStreamSource_get_MusicProperties), nullptr, nullptr, nullptr },
        { "video_properties", reinterpret_cast<getter>(MediaStreamSource_get_VideoProperties), nullptr, nullptr, nullptr },
        { "max_supported_playback_rate", reinterpret_cast<getter>(MediaStreamSource_get_MaxSupportedPlaybackRate), reinterpret_cast<setter>(MediaStreamSource_put_MaxSupportedPlaybackRate), nullptr, nullptr },
        { "is_live", reinterpret_cast<getter>(MediaStreamSource_get_IsLive), reinterpret_cast<setter>(MediaStreamSource_put_IsLive), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSource[] = 
    {
        { Py_tp_new, _new_MediaStreamSource },
        { Py_tp_dealloc, _dealloc_MediaStreamSource },
        { Py_tp_methods, _methods_MediaStreamSource },
        { Py_tp_getset, _getset_MediaStreamSource },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSource =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSource",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSource
    };

    // ----- MediaStreamSourceClosedEventArgs class --------------------
    constexpr const char* const type_name_MediaStreamSourceClosedEventArgs = "MediaStreamSourceClosedEventArgs";

    static PyObject* _new_MediaStreamSourceClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceClosedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceClosedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceClosedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceClosedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceClosedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceClosedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceClosedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceClosedEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceClosedEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceClosedEventArgs },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceClosedEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceClosedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceClosedEventArgs
    };

    // ----- MediaStreamSourceClosedRequest class --------------------
    constexpr const char* const type_name_MediaStreamSourceClosedRequest = "MediaStreamSourceClosedRequest";

    static PyObject* _new_MediaStreamSourceClosedRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceClosedRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceClosedRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceClosedRequest_get_Reason(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceClosedRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceClosedRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceClosedRequest[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceClosedRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceClosedRequest[] = {
        { "reason", reinterpret_cast<getter>(MediaStreamSourceClosedRequest_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceClosedRequest[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceClosedRequest },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceClosedRequest },
        { Py_tp_methods, _methods_MediaStreamSourceClosedRequest },
        { Py_tp_getset, _getset_MediaStreamSourceClosedRequest },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceClosedRequest =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceClosedRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceClosedRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceClosedRequest
    };

    // ----- MediaStreamSourceSampleRenderedEventArgs class --------------------
    constexpr const char* const type_name_MediaStreamSourceSampleRenderedEventArgs = "MediaStreamSourceSampleRenderedEventArgs";

    static PyObject* _new_MediaStreamSourceSampleRenderedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceSampleRenderedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRenderedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSampleRenderedEventArgs_get_SampleLag(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SampleLag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSampleRenderedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRenderedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRenderedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRenderedEventArgs[] = {
        { "sample_lag", reinterpret_cast<getter>(MediaStreamSourceSampleRenderedEventArgs_get_SampleLag), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRenderedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSampleRenderedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSampleRenderedEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceSampleRenderedEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceSampleRenderedEventArgs },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceSampleRenderedEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceSampleRenderedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRenderedEventArgs
    };

    // ----- MediaStreamSourceSampleRequest class --------------------
    constexpr const char* const type_name_MediaStreamSourceSampleRequest = "MediaStreamSourceSampleRequest";

    static PyObject* _new_MediaStreamSourceSampleRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceSampleRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSampleRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_ReportSampleProgress(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                self->obj.ReportSampleProgress(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_get_Sample(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Sample());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaStreamSourceSampleRequest_put_Sample(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::MediaStreamSample>(arg);

            self->obj.Sample(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaStreamSourceSampleRequest_get_StreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSampleRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaStreamSourceSampleRequest_GetDeferral), METH_VARARGS, nullptr },
        { "report_sample_progress", reinterpret_cast<PyCFunction>(MediaStreamSourceSampleRequest_ReportSampleProgress), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequest[] = {
        { "sample", reinterpret_cast<getter>(MediaStreamSourceSampleRequest_get_Sample), reinterpret_cast<setter>(MediaStreamSourceSampleRequest_put_Sample), nullptr, nullptr },
        { "stream_descriptor", reinterpret_cast<getter>(MediaStreamSourceSampleRequest_get_StreamDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequest[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSampleRequest },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSampleRequest },
        { Py_tp_methods, _methods_MediaStreamSourceSampleRequest },
        { Py_tp_getset, _getset_MediaStreamSourceSampleRequest },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceSampleRequest =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceSampleRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequest
    };

    // ----- MediaStreamSourceSampleRequestDeferral class --------------------
    constexpr const char* const type_name_MediaStreamSourceSampleRequestDeferral = "MediaStreamSourceSampleRequestDeferral";

    static PyObject* _new_MediaStreamSourceSampleRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceSampleRequestDeferral);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSampleRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSampleRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MediaStreamSourceSampleRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequestDeferral[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSampleRequestDeferral },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSampleRequestDeferral },
        { Py_tp_methods, _methods_MediaStreamSourceSampleRequestDeferral },
        { Py_tp_getset, _getset_MediaStreamSourceSampleRequestDeferral },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceSampleRequestDeferral =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceSampleRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequestDeferral
    };

    // ----- MediaStreamSourceSampleRequestedEventArgs class --------------------
    constexpr const char* const type_name_MediaStreamSourceSampleRequestedEventArgs = "MediaStreamSourceSampleRequestedEventArgs";

    static PyObject* _new_MediaStreamSourceSampleRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceSampleRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSampleRequestedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSampleRequestedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSampleRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSampleRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSampleRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSampleRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceSampleRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSampleRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSampleRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSampleRequestedEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceSampleRequestedEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceSampleRequestedEventArgs },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceSampleRequestedEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceSampleRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSampleRequestedEventArgs
    };

    // ----- MediaStreamSourceStartingEventArgs class --------------------
    constexpr const char* const type_name_MediaStreamSourceStartingEventArgs = "MediaStreamSourceStartingEventArgs";

    static PyObject* _new_MediaStreamSourceStartingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceStartingEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceStartingEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceStartingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceStartingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceStartingEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceStartingEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceStartingEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceStartingEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceStartingEventArgs },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceStartingEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceStartingEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingEventArgs
    };

    // ----- MediaStreamSourceStartingRequest class --------------------
    constexpr const char* const type_name_MediaStreamSourceStartingRequest = "MediaStreamSourceStartingRequest";

    static PyObject* _new_MediaStreamSourceStartingRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceStartingRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceStartingRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceStartingRequest_SetActualStartPosition(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.SetActualStartPosition(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceStartingRequest_get_StartPosition(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceStartingRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaStreamSourceStartingRequest_GetDeferral), METH_VARARGS, nullptr },
        { "set_actual_start_position", reinterpret_cast<PyCFunction>(MediaStreamSourceStartingRequest_SetActualStartPosition), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceStartingRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingRequest[] = {
        { "start_position", reinterpret_cast<getter>(MediaStreamSourceStartingRequest_get_StartPosition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingRequest[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceStartingRequest },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceStartingRequest },
        { Py_tp_methods, _methods_MediaStreamSourceStartingRequest },
        { Py_tp_getset, _getset_MediaStreamSourceStartingRequest },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceStartingRequest =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceStartingRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingRequest
    };

    // ----- MediaStreamSourceStartingRequestDeferral class --------------------
    constexpr const char* const type_name_MediaStreamSourceStartingRequestDeferral = "MediaStreamSourceStartingRequestDeferral";

    static PyObject* _new_MediaStreamSourceStartingRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceStartingRequestDeferral);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceStartingRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceStartingRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceStartingRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceStartingRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MediaStreamSourceStartingRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceStartingRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceStartingRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceStartingRequestDeferral[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceStartingRequestDeferral },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceStartingRequestDeferral },
        { Py_tp_methods, _methods_MediaStreamSourceStartingRequestDeferral },
        { Py_tp_getset, _getset_MediaStreamSourceStartingRequestDeferral },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceStartingRequestDeferral =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceStartingRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceStartingRequestDeferral
    };

    // ----- MediaStreamSourceSwitchStreamsRequest class --------------------
    constexpr const char* const type_name_MediaStreamSourceSwitchStreamsRequest = "MediaStreamSourceSwitchStreamsRequest";

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceSwitchStreamsRequest);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequest(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_GetDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_get_NewStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NewStreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequest_get_OldStreamDescriptor(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OldStreamDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(MediaStreamSourceSwitchStreamsRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSwitchStreamsRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequest[] = {
        { "new_stream_descriptor", reinterpret_cast<getter>(MediaStreamSourceSwitchStreamsRequest_get_NewStreamDescriptor), nullptr, nullptr, nullptr },
        { "old_stream_descriptor", reinterpret_cast<getter>(MediaStreamSourceSwitchStreamsRequest_get_OldStreamDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequest[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSwitchStreamsRequest },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSwitchStreamsRequest },
        { Py_tp_methods, _methods_MediaStreamSourceSwitchStreamsRequest },
        { Py_tp_getset, _getset_MediaStreamSourceSwitchStreamsRequest },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceSwitchStreamsRequest =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceSwitchStreamsRequest",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequest
    };

    // ----- MediaStreamSourceSwitchStreamsRequestDeferral class --------------------
    constexpr const char* const type_name_MediaStreamSourceSwitchStreamsRequestDeferral = "MediaStreamSourceSwitchStreamsRequestDeferral";

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceSwitchStreamsRequestDeferral);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequestDeferral(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequestDeferral_Complete(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(MediaStreamSourceSwitchStreamsRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSwitchStreamsRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequestDeferral[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSwitchStreamsRequestDeferral },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSwitchStreamsRequestDeferral },
        { Py_tp_methods, _methods_MediaStreamSourceSwitchStreamsRequestDeferral },
        { Py_tp_getset, _getset_MediaStreamSourceSwitchStreamsRequestDeferral },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceSwitchStreamsRequestDeferral =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceSwitchStreamsRequestDeferral",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequestDeferral
    };

    // ----- MediaStreamSourceSwitchStreamsRequestedEventArgs class --------------------
    constexpr const char* const type_name_MediaStreamSourceSwitchStreamsRequestedEventArgs = "MediaStreamSourceSwitchStreamsRequestedEventArgs";

    static PyObject* _new_MediaStreamSourceSwitchStreamsRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaStreamSourceSwitchStreamsRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaStreamSourceSwitchStreamsRequestedEventArgs(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaStreamSourceSwitchStreamsRequestedEventArgs_get_Request(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaStreamSourceSwitchStreamsRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaStreamSourceSwitchStreamsRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(MediaStreamSourceSwitchStreamsRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaStreamSourceSwitchStreamsRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaStreamSourceSwitchStreamsRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaStreamSourceSwitchStreamsRequestedEventArgs },
        { Py_tp_methods, _methods_MediaStreamSourceSwitchStreamsRequestedEventArgs },
        { Py_tp_getset, _getset_MediaStreamSourceSwitchStreamsRequestedEventArgs },
        { },
    };

    static PyType_Spec type_spec_MediaStreamSourceSwitchStreamsRequestedEventArgs =
    {
        "_winsdk_Windows_Media_Core.MediaStreamSourceSwitchStreamsRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaStreamSourceSwitchStreamsRequestedEventArgs
    };

    // ----- MseSourceBuffer class --------------------
    constexpr const char* const type_name_MseSourceBuffer = "MseSourceBuffer";

    static PyObject* _new_MseSourceBuffer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MseSourceBuffer);
        return nullptr;
    }

    static void _dealloc_MseSourceBuffer(py::wrapper::Windows::Media::Core::MseSourceBuffer* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MseSourceBuffer_Abort(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Abort();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_AppendBuffer(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.AppendBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_AppendStream(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);

                self->obj.AppendStream(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);

                self->obj.AppendStream(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_Remove(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(args, 1);

                self->obj.Remove(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_get_TimestampOffset(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimestampOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_TimestampOffset(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.TimestampOffset(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_Mode(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_Mode(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::MseAppendMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_AppendWindowStart(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppendWindowStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_AppendWindowStart(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AppendWindowStart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_AppendWindowEnd(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppendWindowEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseSourceBuffer_put_AppendWindowEnd(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.AppendWindowEnd(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseSourceBuffer_get_Buffered(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buffered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_get_IsUpdating(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUpdating());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_Aborted(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Aborted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_Aborted(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Aborted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_ErrorOccurred(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ErrorOccurred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_ErrorOccurred(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ErrorOccurred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_UpdateEnded(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UpdateEnded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_UpdateEnded(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateEnded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_UpdateStarting(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UpdateStarting(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_UpdateStarting(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateStarting(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_add_Updated(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBuffer, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBuffer_remove_Updated(py::wrapper::Windows::Media::Core::MseSourceBuffer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MseSourceBuffer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseSourceBuffer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseSourceBuffer[] = {
        { "abort", reinterpret_cast<PyCFunction>(MseSourceBuffer_Abort), METH_VARARGS, nullptr },
        { "append_buffer", reinterpret_cast<PyCFunction>(MseSourceBuffer_AppendBuffer), METH_VARARGS, nullptr },
        { "append_stream", reinterpret_cast<PyCFunction>(MseSourceBuffer_AppendStream), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(MseSourceBuffer_Remove), METH_VARARGS, nullptr },
        { "add_aborted", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_Aborted), METH_O, nullptr },
        { "remove_aborted", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_Aborted), METH_O, nullptr },
        { "add_error_occurred", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_ErrorOccurred), METH_O, nullptr },
        { "remove_error_occurred", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_ErrorOccurred), METH_O, nullptr },
        { "add_update_ended", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_UpdateEnded), METH_O, nullptr },
        { "remove_update_ended", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_UpdateEnded), METH_O, nullptr },
        { "add_update_starting", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_UpdateStarting), METH_O, nullptr },
        { "remove_update_starting", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_UpdateStarting), METH_O, nullptr },
        { "add_updated", reinterpret_cast<PyCFunction>(MseSourceBuffer_add_Updated), METH_O, nullptr },
        { "remove_updated", reinterpret_cast<PyCFunction>(MseSourceBuffer_remove_Updated), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MseSourceBuffer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MseSourceBuffer[] = {
        { "timestamp_offset", reinterpret_cast<getter>(MseSourceBuffer_get_TimestampOffset), reinterpret_cast<setter>(MseSourceBuffer_put_TimestampOffset), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(MseSourceBuffer_get_Mode), reinterpret_cast<setter>(MseSourceBuffer_put_Mode), nullptr, nullptr },
        { "append_window_start", reinterpret_cast<getter>(MseSourceBuffer_get_AppendWindowStart), reinterpret_cast<setter>(MseSourceBuffer_put_AppendWindowStart), nullptr, nullptr },
        { "append_window_end", reinterpret_cast<getter>(MseSourceBuffer_get_AppendWindowEnd), reinterpret_cast<setter>(MseSourceBuffer_put_AppendWindowEnd), nullptr, nullptr },
        { "buffered", reinterpret_cast<getter>(MseSourceBuffer_get_Buffered), nullptr, nullptr, nullptr },
        { "is_updating", reinterpret_cast<getter>(MseSourceBuffer_get_IsUpdating), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseSourceBuffer[] = 
    {
        { Py_tp_new, _new_MseSourceBuffer },
        { Py_tp_dealloc, _dealloc_MseSourceBuffer },
        { Py_tp_methods, _methods_MseSourceBuffer },
        { Py_tp_getset, _getset_MseSourceBuffer },
        { },
    };

    static PyType_Spec type_spec_MseSourceBuffer =
    {
        "_winsdk_Windows_Media_Core.MseSourceBuffer",
        sizeof(py::wrapper::Windows::Media::Core::MseSourceBuffer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseSourceBuffer
    };

    // ----- MseSourceBufferList class --------------------
    constexpr const char* const type_name_MseSourceBufferList = "MseSourceBufferList";

    static PyObject* _new_MseSourceBufferList(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MseSourceBufferList);
        return nullptr;
    }

    static void _dealloc_MseSourceBufferList(py::wrapper::Windows::Media::Core::MseSourceBufferList* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MseSourceBufferList_get_Buffers(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_add_SourceBufferAdded(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBufferList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SourceBufferAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_remove_SourceBufferAdded(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceBufferAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_add_SourceBufferRemoved(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseSourceBufferList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SourceBufferRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseSourceBufferList_remove_SourceBufferRemoved(py::wrapper::Windows::Media::Core::MseSourceBufferList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceBufferRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MseSourceBufferList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseSourceBufferList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseSourceBufferList[] = {
        { "add_source_buffer_added", reinterpret_cast<PyCFunction>(MseSourceBufferList_add_SourceBufferAdded), METH_O, nullptr },
        { "remove_source_buffer_added", reinterpret_cast<PyCFunction>(MseSourceBufferList_remove_SourceBufferAdded), METH_O, nullptr },
        { "add_source_buffer_removed", reinterpret_cast<PyCFunction>(MseSourceBufferList_add_SourceBufferRemoved), METH_O, nullptr },
        { "remove_source_buffer_removed", reinterpret_cast<PyCFunction>(MseSourceBufferList_remove_SourceBufferRemoved), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MseSourceBufferList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MseSourceBufferList[] = {
        { "buffers", reinterpret_cast<getter>(MseSourceBufferList_get_Buffers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseSourceBufferList[] = 
    {
        { Py_tp_new, _new_MseSourceBufferList },
        { Py_tp_dealloc, _dealloc_MseSourceBufferList },
        { Py_tp_methods, _methods_MseSourceBufferList },
        { Py_tp_getset, _getset_MseSourceBufferList },
        { },
    };

    static PyType_Spec type_spec_MseSourceBufferList =
    {
        "_winsdk_Windows_Media_Core.MseSourceBufferList",
        sizeof(py::wrapper::Windows::Media::Core::MseSourceBufferList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseSourceBufferList
    };

    // ----- MseStreamSource class --------------------
    constexpr const char* const type_name_MseStreamSource = "MseStreamSource";

    static PyObject* _new_MseStreamSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::MseStreamSource instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MseStreamSource(py::wrapper::Windows::Media::Core::MseStreamSource* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MseStreamSource_AddSourceBuffer(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddSourceBuffer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_EndOfStream(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseEndOfStreamStatus>(args, 0);

                self->obj.EndOfStream(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_IsContentTypeSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Core::MseStreamSource::IsContentTypeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_RemoveSourceBuffer(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::MseSourceBuffer>(args, 0);

                self->obj.RemoveSourceBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_Duration(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseStreamSource_put_Duration(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseStreamSource_get_ActiveSourceBuffers(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActiveSourceBuffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_ReadyState(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadyState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_SourceBuffers(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceBuffers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_get_LiveSeekableRange(py::wrapper::Windows::Media::Core::MseStreamSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LiveSeekableRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseStreamSource_put_LiveSeekableRange(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Media::Core::MseTimeRange>>(arg);

            self->obj.LiveSeekableRange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseStreamSource_add_Closed(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Closed(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_add_Ended(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Ended(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Ended(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Ended(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_add_Opened(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::MseStreamSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Opened(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MseStreamSource_remove_Opened(py::wrapper::Windows::Media::Core::MseStreamSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Opened(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MseStreamSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::MseStreamSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MseStreamSource[] = {
        { "add_source_buffer", reinterpret_cast<PyCFunction>(MseStreamSource_AddSourceBuffer), METH_VARARGS, nullptr },
        { "end_of_stream", reinterpret_cast<PyCFunction>(MseStreamSource_EndOfStream), METH_VARARGS, nullptr },
        { "is_content_type_supported", reinterpret_cast<PyCFunction>(MseStreamSource_IsContentTypeSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "remove_source_buffer", reinterpret_cast<PyCFunction>(MseStreamSource_RemoveSourceBuffer), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(MseStreamSource_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(MseStreamSource_remove_Closed), METH_O, nullptr },
        { "add_ended", reinterpret_cast<PyCFunction>(MseStreamSource_add_Ended), METH_O, nullptr },
        { "remove_ended", reinterpret_cast<PyCFunction>(MseStreamSource_remove_Ended), METH_O, nullptr },
        { "add_opened", reinterpret_cast<PyCFunction>(MseStreamSource_add_Opened), METH_O, nullptr },
        { "remove_opened", reinterpret_cast<PyCFunction>(MseStreamSource_remove_Opened), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MseStreamSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MseStreamSource[] = {
        { "duration", reinterpret_cast<getter>(MseStreamSource_get_Duration), reinterpret_cast<setter>(MseStreamSource_put_Duration), nullptr, nullptr },
        { "active_source_buffers", reinterpret_cast<getter>(MseStreamSource_get_ActiveSourceBuffers), nullptr, nullptr, nullptr },
        { "ready_state", reinterpret_cast<getter>(MseStreamSource_get_ReadyState), nullptr, nullptr, nullptr },
        { "source_buffers", reinterpret_cast<getter>(MseStreamSource_get_SourceBuffers), nullptr, nullptr, nullptr },
        { "live_seekable_range", reinterpret_cast<getter>(MseStreamSource_get_LiveSeekableRange), reinterpret_cast<setter>(MseStreamSource_put_LiveSeekableRange), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseStreamSource[] = 
    {
        { Py_tp_new, _new_MseStreamSource },
        { Py_tp_dealloc, _dealloc_MseStreamSource },
        { Py_tp_methods, _methods_MseStreamSource },
        { Py_tp_getset, _getset_MseStreamSource },
        { },
    };

    static PyType_Spec type_spec_MseStreamSource =
    {
        "_winsdk_Windows_Media_Core.MseStreamSource",
        sizeof(py::wrapper::Windows::Media::Core::MseStreamSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseStreamSource
    };

    // ----- SceneAnalysisEffect class --------------------
    constexpr const char* const type_name_SceneAnalysisEffect = "SceneAnalysisEffect";

    static PyObject* _new_SceneAnalysisEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SceneAnalysisEffect);
        return nullptr;
    }

    static void _dealloc_SceneAnalysisEffect(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneAnalysisEffect_SetProperties(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_get_DesiredAnalysisInterval(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredAnalysisInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffect_put_DesiredAnalysisInterval(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredAnalysisInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffect_get_HighDynamicRangeAnalyzer(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighDynamicRangeAnalyzer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_add_SceneAnalyzed(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::SceneAnalysisEffect, winrt::Windows::Media::Core::SceneAnalyzedEventArgs>>(arg);

            return py::convert(self->obj.SceneAnalyzed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffect_remove_SceneAnalyzed(py::wrapper::Windows::Media::Core::SceneAnalysisEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SceneAnalyzed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SceneAnalysisEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffect[] = {
        { "set_properties", reinterpret_cast<PyCFunction>(SceneAnalysisEffect_SetProperties), METH_VARARGS, nullptr },
        { "add_scene_analyzed", reinterpret_cast<PyCFunction>(SceneAnalysisEffect_add_SceneAnalyzed), METH_O, nullptr },
        { "remove_scene_analyzed", reinterpret_cast<PyCFunction>(SceneAnalysisEffect_remove_SceneAnalyzed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalysisEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalysisEffect[] = {
        { "desired_analysis_interval", reinterpret_cast<getter>(SceneAnalysisEffect_get_DesiredAnalysisInterval), reinterpret_cast<setter>(SceneAnalysisEffect_put_DesiredAnalysisInterval), nullptr, nullptr },
        { "high_dynamic_range_analyzer", reinterpret_cast<getter>(SceneAnalysisEffect_get_HighDynamicRangeAnalyzer), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffect[] = 
    {
        { Py_tp_new, _new_SceneAnalysisEffect },
        { Py_tp_dealloc, _dealloc_SceneAnalysisEffect },
        { Py_tp_methods, _methods_SceneAnalysisEffect },
        { Py_tp_getset, _getset_SceneAnalysisEffect },
        { },
    };

    static PyType_Spec type_spec_SceneAnalysisEffect =
    {
        "_winsdk_Windows_Media_Core.SceneAnalysisEffect",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffect
    };

    // ----- SceneAnalysisEffectDefinition class --------------------
    constexpr const char* const type_name_SceneAnalysisEffectDefinition = "SceneAnalysisEffectDefinition";

    static PyObject* _new_SceneAnalysisEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::SceneAnalysisEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SceneAnalysisEffectDefinition(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneAnalysisEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SceneAnalysisEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalysisEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalysisEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(SceneAnalysisEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(SceneAnalysisEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffectDefinition[] = 
    {
        { Py_tp_new, _new_SceneAnalysisEffectDefinition },
        { Py_tp_dealloc, _dealloc_SceneAnalysisEffectDefinition },
        { Py_tp_methods, _methods_SceneAnalysisEffectDefinition },
        { Py_tp_getset, _getset_SceneAnalysisEffectDefinition },
        { },
    };

    static PyType_Spec type_spec_SceneAnalysisEffectDefinition =
    {
        "_winsdk_Windows_Media_Core.SceneAnalysisEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffectDefinition
    };

    // ----- SceneAnalysisEffectFrame class --------------------
    constexpr const char* const type_name_SceneAnalysisEffectFrame = "SceneAnalysisEffectFrame";

    static PyObject* _new_SceneAnalysisEffectFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SceneAnalysisEffectFrame);
        return nullptr;
    }

    static void _dealloc_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneAnalysisEffectFrame_Close(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_FrameControlValues(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameControlValues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_HighDynamicRange(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighDynamicRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_AnalysisRecommendation(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AnalysisRecommendation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_SystemRelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemRelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_SystemRelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.SystemRelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_RelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativeTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_RelativeTime(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.RelativeTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_IsDiscontinuous(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDiscontinuous());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_IsDiscontinuous(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDiscontinuous(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_Duration(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SceneAnalysisEffectFrame_put_Duration(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_ExtendedProperties(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_IsReadOnly(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneAnalysisEffectFrame_get_Type(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SceneAnalysisEffectFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalysisEffectFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_SceneAnalysisEffectFrame(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalysisEffectFrame[] = {
        { "close", reinterpret_cast<PyCFunction>(SceneAnalysisEffectFrame_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalysisEffectFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SceneAnalysisEffectFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_SceneAnalysisEffectFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalysisEffectFrame[] = {
        { "frame_control_values", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_FrameControlValues), nullptr, nullptr, nullptr },
        { "high_dynamic_range", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_HighDynamicRange), nullptr, nullptr, nullptr },
        { "analysis_recommendation", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_AnalysisRecommendation), nullptr, nullptr, nullptr },
        { "system_relative_time", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_SystemRelativeTime), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_SystemRelativeTime), nullptr, nullptr },
        { "relative_time", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_RelativeTime), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_RelativeTime), nullptr, nullptr },
        { "is_discontinuous", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_IsDiscontinuous), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_IsDiscontinuous), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_Duration), reinterpret_cast<setter>(SceneAnalysisEffectFrame_put_Duration), nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_read_only", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SceneAnalysisEffectFrame_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalysisEffectFrame[] = 
    {
        { Py_tp_new, _new_SceneAnalysisEffectFrame },
        { Py_tp_dealloc, _dealloc_SceneAnalysisEffectFrame },
        { Py_tp_methods, _methods_SceneAnalysisEffectFrame },
        { Py_tp_getset, _getset_SceneAnalysisEffectFrame },
        { },
    };

    static PyType_Spec type_spec_SceneAnalysisEffectFrame =
    {
        "_winsdk_Windows_Media_Core.SceneAnalysisEffectFrame",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalysisEffectFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalysisEffectFrame
    };

    // ----- SceneAnalyzedEventArgs class --------------------
    constexpr const char* const type_name_SceneAnalyzedEventArgs = "SceneAnalyzedEventArgs";

    static PyObject* _new_SceneAnalyzedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SceneAnalyzedEventArgs);
        return nullptr;
    }

    static void _dealloc_SceneAnalyzedEventArgs(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SceneAnalyzedEventArgs_get_ResultFrame(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResultFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SceneAnalyzedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SceneAnalyzedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneAnalyzedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneAnalyzedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneAnalyzedEventArgs[] = {
        { "result_frame", reinterpret_cast<getter>(SceneAnalyzedEventArgs_get_ResultFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneAnalyzedEventArgs[] = 
    {
        { Py_tp_new, _new_SceneAnalyzedEventArgs },
        { Py_tp_dealloc, _dealloc_SceneAnalyzedEventArgs },
        { Py_tp_methods, _methods_SceneAnalyzedEventArgs },
        { Py_tp_getset, _getset_SceneAnalyzedEventArgs },
        { },
    };

    static PyType_Spec type_spec_SceneAnalyzedEventArgs =
    {
        "_winsdk_Windows_Media_Core.SceneAnalyzedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::SceneAnalyzedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneAnalyzedEventArgs
    };

    // ----- SpeechCue class --------------------
    constexpr const char* const type_name_SpeechCue = "SpeechCue";

    static PyObject* _new_SpeechCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::SpeechCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechCue(py::wrapper::Windows::Media::Core::SpeechCue* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SpeechCue_get_StartTime(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_StartTime(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Id(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Id(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Duration(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Duration(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_Text(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_Text(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_StartPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartPositionInInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_StartPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.StartPositionInInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechCue_get_EndPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndPositionInInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechCue_put_EndPositionInInput(py::wrapper::Windows::Media::Core::SpeechCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<int32_t>>(arg);

            self->obj.EndPositionInInput(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_SpeechCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::SpeechCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechCue[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechCue[] = {
        { "start_time", reinterpret_cast<getter>(SpeechCue_get_StartTime), reinterpret_cast<setter>(SpeechCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(SpeechCue_get_Id), reinterpret_cast<setter>(SpeechCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(SpeechCue_get_Duration), reinterpret_cast<setter>(SpeechCue_put_Duration), nullptr, nullptr },
        { "text", reinterpret_cast<getter>(SpeechCue_get_Text), reinterpret_cast<setter>(SpeechCue_put_Text), nullptr, nullptr },
        { "start_position_in_input", reinterpret_cast<getter>(SpeechCue_get_StartPositionInInput), reinterpret_cast<setter>(SpeechCue_put_StartPositionInInput), nullptr, nullptr },
        { "end_position_in_input", reinterpret_cast<getter>(SpeechCue_get_EndPositionInInput), reinterpret_cast<setter>(SpeechCue_put_EndPositionInInput), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechCue[] = 
    {
        { Py_tp_new, _new_SpeechCue },
        { Py_tp_dealloc, _dealloc_SpeechCue },
        { Py_tp_methods, _methods_SpeechCue },
        { Py_tp_getset, _getset_SpeechCue },
        { },
    };

    static PyType_Spec type_spec_SpeechCue =
    {
        "_winsdk_Windows_Media_Core.SpeechCue",
        sizeof(py::wrapper::Windows::Media::Core::SpeechCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechCue
    };

    // ----- TimedMetadataStreamDescriptor class --------------------
    constexpr const char* const type_name_TimedMetadataStreamDescriptor = "TimedMetadataStreamDescriptor";

    static PyObject* _new_TimedMetadataStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::TimedMetadataStreamDescriptor instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedMetadataStreamDescriptor(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataStreamDescriptor[] = {
        { "copy", reinterpret_cast<PyCFunction>(TimedMetadataStreamDescriptor_Copy), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataStreamDescriptor[] = {
        { "name", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_Name), reinterpret_cast<setter>(TimedMetadataStreamDescriptor_put_Name), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_Language), reinterpret_cast<setter>(TimedMetadataStreamDescriptor_put_Language), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_Label), reinterpret_cast<setter>(TimedMetadataStreamDescriptor_put_Label), nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(TimedMetadataStreamDescriptor_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataStreamDescriptor[] = 
    {
        { Py_tp_new, _new_TimedMetadataStreamDescriptor },
        { Py_tp_dealloc, _dealloc_TimedMetadataStreamDescriptor },
        { Py_tp_methods, _methods_TimedMetadataStreamDescriptor },
        { Py_tp_getset, _getset_TimedMetadataStreamDescriptor },
        { },
    };

    static PyType_Spec type_spec_TimedMetadataStreamDescriptor =
    {
        "_winsdk_Windows_Media_Core.TimedMetadataStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataStreamDescriptor
    };

    // ----- TimedMetadataTrack class --------------------
    constexpr const char* const type_name_TimedMetadataTrack = "TimedMetadataTrack";

    static PyObject* _new_TimedMetadataTrack(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Core::TimedMetadataKind>(args, 2);

                winrt::Windows::Media::Core::TimedMetadataTrack instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedMetadataTrack(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataTrack_AddCue(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaCue>(args, 0);

                self->obj.AddCue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_RemoveCue(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaCue>(args, 0);

                self->obj.RemoveCue(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Label(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataTrack_put_Label(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataTrack_get_Id(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Language(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_TrackKind(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_ActiveCues(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActiveCues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Cues(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Cues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_DispatchType(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DispatchType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_TimedMetadataKind(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimedMetadataKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_Name(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_CueEntered(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::MediaCueEventArgs>>(arg);

            return py::convert(self->obj.CueEntered(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_CueEntered(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CueEntered(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_CueExited(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::MediaCueEventArgs>>(arg);

            return py::convert(self->obj.CueExited(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_CueExited(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CueExited(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_add_TrackFailed(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedMetadataTrack, winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>>(arg);

            return py::convert(self->obj.TrackFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrack_remove_TrackFailed(py::wrapper::Windows::Media::Core::TimedMetadataTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TrackFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrack[] = {
        { "add_cue", reinterpret_cast<PyCFunction>(TimedMetadataTrack_AddCue), METH_VARARGS, nullptr },
        { "remove_cue", reinterpret_cast<PyCFunction>(TimedMetadataTrack_RemoveCue), METH_VARARGS, nullptr },
        { "add_cue_entered", reinterpret_cast<PyCFunction>(TimedMetadataTrack_add_CueEntered), METH_O, nullptr },
        { "remove_cue_entered", reinterpret_cast<PyCFunction>(TimedMetadataTrack_remove_CueEntered), METH_O, nullptr },
        { "add_cue_exited", reinterpret_cast<PyCFunction>(TimedMetadataTrack_add_CueExited), METH_O, nullptr },
        { "remove_cue_exited", reinterpret_cast<PyCFunction>(TimedMetadataTrack_remove_CueExited), METH_O, nullptr },
        { "add_track_failed", reinterpret_cast<PyCFunction>(TimedMetadataTrack_add_TrackFailed), METH_O, nullptr },
        { "remove_track_failed", reinterpret_cast<PyCFunction>(TimedMetadataTrack_remove_TrackFailed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataTrack[] = {
        { "label", reinterpret_cast<getter>(TimedMetadataTrack_get_Label), reinterpret_cast<setter>(TimedMetadataTrack_put_Label), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(TimedMetadataTrack_get_Id), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(TimedMetadataTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(TimedMetadataTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { "active_cues", reinterpret_cast<getter>(TimedMetadataTrack_get_ActiveCues), nullptr, nullptr, nullptr },
        { "cues", reinterpret_cast<getter>(TimedMetadataTrack_get_Cues), nullptr, nullptr, nullptr },
        { "dispatch_type", reinterpret_cast<getter>(TimedMetadataTrack_get_DispatchType), nullptr, nullptr, nullptr },
        { "timed_metadata_kind", reinterpret_cast<getter>(TimedMetadataTrack_get_TimedMetadataKind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(TimedMetadataTrack_get_Name), nullptr, nullptr, nullptr },
        { "playback_item", reinterpret_cast<getter>(TimedMetadataTrack_get_PlaybackItem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataTrack[] = 
    {
        { Py_tp_new, _new_TimedMetadataTrack },
        { Py_tp_dealloc, _dealloc_TimedMetadataTrack },
        { Py_tp_methods, _methods_TimedMetadataTrack },
        { Py_tp_getset, _getset_TimedMetadataTrack },
        { },
    };

    static PyType_Spec type_spec_TimedMetadataTrack =
    {
        "_winsdk_Windows_Media_Core.TimedMetadataTrack",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrack
    };

    // ----- TimedMetadataTrackError class --------------------
    constexpr const char* const type_name_TimedMetadataTrackError = "TimedMetadataTrackError";

    static PyObject* _new_TimedMetadataTrackError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TimedMetadataTrackError);
        return nullptr;
    }

    static void _dealloc_TimedMetadataTrackError(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataTrackError_get_ErrorCode(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataTrackError_get_ExtendedError(py::wrapper::Windows::Media::Core::TimedMetadataTrackError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataTrackError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrackError>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrackError[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataTrackError), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataTrackError[] = {
        { "error_code", reinterpret_cast<getter>(TimedMetadataTrackError_get_ErrorCode), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(TimedMetadataTrackError_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataTrackError[] = 
    {
        { Py_tp_new, _new_TimedMetadataTrackError },
        { Py_tp_dealloc, _dealloc_TimedMetadataTrackError },
        { Py_tp_methods, _methods_TimedMetadataTrackError },
        { Py_tp_getset, _getset_TimedMetadataTrackError },
        { },
    };

    static PyType_Spec type_spec_TimedMetadataTrackError =
    {
        "_winsdk_Windows_Media_Core.TimedMetadataTrackError",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrackError),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrackError
    };

    // ----- TimedMetadataTrackFailedEventArgs class --------------------
    constexpr const char* const type_name_TimedMetadataTrackFailedEventArgs = "TimedMetadataTrackFailedEventArgs";

    static PyObject* _new_TimedMetadataTrackFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TimedMetadataTrackFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_TimedMetadataTrackFailedEventArgs(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataTrackFailedEventArgs_get_Error(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataTrackFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataTrackFailedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataTrackFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataTrackFailedEventArgs[] = {
        { "error", reinterpret_cast<getter>(TimedMetadataTrackFailedEventArgs_get_Error), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataTrackFailedEventArgs[] = 
    {
        { Py_tp_new, _new_TimedMetadataTrackFailedEventArgs },
        { Py_tp_dealloc, _dealloc_TimedMetadataTrackFailedEventArgs },
        { Py_tp_methods, _methods_TimedMetadataTrackFailedEventArgs },
        { Py_tp_getset, _getset_TimedMetadataTrackFailedEventArgs },
        { },
    };

    static PyType_Spec type_spec_TimedMetadataTrackFailedEventArgs =
    {
        "_winsdk_Windows_Media_Core.TimedMetadataTrackFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::TimedMetadataTrackFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataTrackFailedEventArgs
    };

    // ----- TimedTextBouten class --------------------
    constexpr const char* const type_name_TimedTextBouten = "TimedTextBouten";

    static PyObject* _new_TimedTextBouten(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TimedTextBouten);
        return nullptr;
    }

    static void _dealloc_TimedTextBouten(py::wrapper::Windows::Media::Core::TimedTextBouten* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextBouten_get_Type(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Type(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextBoutenType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextBouten_get_Position(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Position(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextBoutenPosition>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextBouten_get_Color(py::wrapper::Windows::Media::Core::TimedTextBouten* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextBouten_put_Color(py::wrapper::Windows::Media::Core::TimedTextBouten* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_TimedTextBouten(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextBouten>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextBouten[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextBouten), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextBouten[] = {
        { "type", reinterpret_cast<getter>(TimedTextBouten_get_Type), reinterpret_cast<setter>(TimedTextBouten_put_Type), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(TimedTextBouten_get_Position), reinterpret_cast<setter>(TimedTextBouten_put_Position), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(TimedTextBouten_get_Color), reinterpret_cast<setter>(TimedTextBouten_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextBouten[] = 
    {
        { Py_tp_new, _new_TimedTextBouten },
        { Py_tp_dealloc, _dealloc_TimedTextBouten },
        { Py_tp_methods, _methods_TimedTextBouten },
        { Py_tp_getset, _getset_TimedTextBouten },
        { },
    };

    static PyType_Spec type_spec_TimedTextBouten =
    {
        "_winsdk_Windows_Media_Core.TimedTextBouten",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextBouten),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextBouten
    };

    // ----- TimedTextCue class --------------------
    constexpr const char* const type_name_TimedTextCue = "TimedTextCue";

    static PyObject* _new_TimedTextCue(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextCue instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextCue(py::wrapper::Windows::Media::Core::TimedTextCue* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextCue_get_StartTime(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_StartTime(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Id(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_Id(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Duration(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_Duration(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_CueStyle(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CueStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_CueStyle(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextStyle>(arg);

            self->obj.CueStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_CueRegion(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CueRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextCue_put_CueRegion(py::wrapper::Windows::Media::Core::TimedTextCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRegion>(arg);

            self->obj.CueRegion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextCue_get_Lines(py::wrapper::Windows::Media::Core::TimedTextCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Lines());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextCue[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextCue[] = {
        { "start_time", reinterpret_cast<getter>(TimedTextCue_get_StartTime), reinterpret_cast<setter>(TimedTextCue_put_StartTime), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(TimedTextCue_get_Id), reinterpret_cast<setter>(TimedTextCue_put_Id), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(TimedTextCue_get_Duration), reinterpret_cast<setter>(TimedTextCue_put_Duration), nullptr, nullptr },
        { "cue_style", reinterpret_cast<getter>(TimedTextCue_get_CueStyle), reinterpret_cast<setter>(TimedTextCue_put_CueStyle), nullptr, nullptr },
        { "cue_region", reinterpret_cast<getter>(TimedTextCue_get_CueRegion), reinterpret_cast<setter>(TimedTextCue_put_CueRegion), nullptr, nullptr },
        { "lines", reinterpret_cast<getter>(TimedTextCue_get_Lines), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextCue[] = 
    {
        { Py_tp_new, _new_TimedTextCue },
        { Py_tp_dealloc, _dealloc_TimedTextCue },
        { Py_tp_methods, _methods_TimedTextCue },
        { Py_tp_getset, _getset_TimedTextCue },
        { },
    };

    static PyType_Spec type_spec_TimedTextCue =
    {
        "_winsdk_Windows_Media_Core.TimedTextCue",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextCue
    };

    // ----- TimedTextLine class --------------------
    constexpr const char* const type_name_TimedTextLine = "TimedTextLine";

    static PyObject* _new_TimedTextLine(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextLine instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextLine(py::wrapper::Windows::Media::Core::TimedTextLine* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextLine_get_Text(py::wrapper::Windows::Media::Core::TimedTextLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextLine_put_Text(py::wrapper::Windows::Media::Core::TimedTextLine* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextLine_get_Subformats(py::wrapper::Windows::Media::Core::TimedTextLine* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subformats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextLine(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextLine>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextLine[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextLine), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextLine[] = {
        { "text", reinterpret_cast<getter>(TimedTextLine_get_Text), reinterpret_cast<setter>(TimedTextLine_put_Text), nullptr, nullptr },
        { "subformats", reinterpret_cast<getter>(TimedTextLine_get_Subformats), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextLine[] = 
    {
        { Py_tp_new, _new_TimedTextLine },
        { Py_tp_dealloc, _dealloc_TimedTextLine },
        { Py_tp_methods, _methods_TimedTextLine },
        { Py_tp_getset, _getset_TimedTextLine },
        { },
    };

    static PyType_Spec type_spec_TimedTextLine =
    {
        "_winsdk_Windows_Media_Core.TimedTextLine",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextLine),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextLine
    };

    // ----- TimedTextRegion class --------------------
    constexpr const char* const type_name_TimedTextRegion = "TimedTextRegion";

    static PyObject* _new_TimedTextRegion(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextRegion instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextRegion(py::wrapper::Windows::Media::Core::TimedTextRegion* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextRegion_get_Name(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Name(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_LineHeight(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_LineHeight(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.LineHeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_IsOverflowClipped(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOverflowClipped());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_IsOverflowClipped(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOverflowClipped(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Extent(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Extent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Extent(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextSize>(arg);

            self->obj.Extent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_DisplayAlignment(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_DisplayAlignment(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDisplayAlignment>(arg);

            self->obj.DisplayAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Padding(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Padding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Padding(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPadding>(arg);

            self->obj.Padding(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Background(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Background());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Background(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Background(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_ZIndex(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_ZIndex(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_WritingMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WritingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_WritingMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWritingMode>(arg);

            self->obj.WritingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_TextWrapping(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TextWrapping());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_TextWrapping(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWrapping>(arg);

            self->obj.TextWrapping(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_ScrollMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScrollMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_ScrollMode(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextScrollMode>(arg);

            self->obj.ScrollMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRegion_get_Position(py::wrapper::Windows::Media::Core::TimedTextRegion* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRegion_put_Position(py::wrapper::Windows::Media::Core::TimedTextRegion* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextPoint>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_TimedTextRegion(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextRegion>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextRegion[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextRegion), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextRegion[] = {
        { "name", reinterpret_cast<getter>(TimedTextRegion_get_Name), reinterpret_cast<setter>(TimedTextRegion_put_Name), nullptr, nullptr },
        { "line_height", reinterpret_cast<getter>(TimedTextRegion_get_LineHeight), reinterpret_cast<setter>(TimedTextRegion_put_LineHeight), nullptr, nullptr },
        { "is_overflow_clipped", reinterpret_cast<getter>(TimedTextRegion_get_IsOverflowClipped), reinterpret_cast<setter>(TimedTextRegion_put_IsOverflowClipped), nullptr, nullptr },
        { "extent", reinterpret_cast<getter>(TimedTextRegion_get_Extent), reinterpret_cast<setter>(TimedTextRegion_put_Extent), nullptr, nullptr },
        { "display_alignment", reinterpret_cast<getter>(TimedTextRegion_get_DisplayAlignment), reinterpret_cast<setter>(TimedTextRegion_put_DisplayAlignment), nullptr, nullptr },
        { "padding", reinterpret_cast<getter>(TimedTextRegion_get_Padding), reinterpret_cast<setter>(TimedTextRegion_put_Padding), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(TimedTextRegion_get_Background), reinterpret_cast<setter>(TimedTextRegion_put_Background), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(TimedTextRegion_get_ZIndex), reinterpret_cast<setter>(TimedTextRegion_put_ZIndex), nullptr, nullptr },
        { "writing_mode", reinterpret_cast<getter>(TimedTextRegion_get_WritingMode), reinterpret_cast<setter>(TimedTextRegion_put_WritingMode), nullptr, nullptr },
        { "text_wrapping", reinterpret_cast<getter>(TimedTextRegion_get_TextWrapping), reinterpret_cast<setter>(TimedTextRegion_put_TextWrapping), nullptr, nullptr },
        { "scroll_mode", reinterpret_cast<getter>(TimedTextRegion_get_ScrollMode), reinterpret_cast<setter>(TimedTextRegion_put_ScrollMode), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(TimedTextRegion_get_Position), reinterpret_cast<setter>(TimedTextRegion_put_Position), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextRegion[] = 
    {
        { Py_tp_new, _new_TimedTextRegion },
        { Py_tp_dealloc, _dealloc_TimedTextRegion },
        { Py_tp_methods, _methods_TimedTextRegion },
        { Py_tp_getset, _getset_TimedTextRegion },
        { },
    };

    static PyType_Spec type_spec_TimedTextRegion =
    {
        "_winsdk_Windows_Media_Core.TimedTextRegion",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextRegion),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextRegion
    };

    // ----- TimedTextRuby class --------------------
    constexpr const char* const type_name_TimedTextRuby = "TimedTextRuby";

    static PyObject* _new_TimedTextRuby(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TimedTextRuby);
        return nullptr;
    }

    static void _dealloc_TimedTextRuby(py::wrapper::Windows::Media::Core::TimedTextRuby* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextRuby_get_Text(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Text(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Reserve(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reserve());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Reserve(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyReserve>(arg);

            self->obj.Reserve(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Position(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Position(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyPosition>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextRuby_get_Align(py::wrapper::Windows::Media::Core::TimedTextRuby* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Align());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextRuby_put_Align(py::wrapper::Windows::Media::Core::TimedTextRuby* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextRubyAlign>(arg);

            self->obj.Align(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_TimedTextRuby(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextRuby>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextRuby[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextRuby), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextRuby[] = {
        { "text", reinterpret_cast<getter>(TimedTextRuby_get_Text), reinterpret_cast<setter>(TimedTextRuby_put_Text), nullptr, nullptr },
        { "reserve", reinterpret_cast<getter>(TimedTextRuby_get_Reserve), reinterpret_cast<setter>(TimedTextRuby_put_Reserve), nullptr, nullptr },
        { "position", reinterpret_cast<getter>(TimedTextRuby_get_Position), reinterpret_cast<setter>(TimedTextRuby_put_Position), nullptr, nullptr },
        { "align", reinterpret_cast<getter>(TimedTextRuby_get_Align), reinterpret_cast<setter>(TimedTextRuby_put_Align), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextRuby[] = 
    {
        { Py_tp_new, _new_TimedTextRuby },
        { Py_tp_dealloc, _dealloc_TimedTextRuby },
        { Py_tp_methods, _methods_TimedTextRuby },
        { Py_tp_getset, _getset_TimedTextRuby },
        { },
    };

    static PyType_Spec type_spec_TimedTextRuby =
    {
        "_winsdk_Windows_Media_Core.TimedTextRuby",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextRuby),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextRuby
    };

    // ----- TimedTextSource class --------------------
    constexpr const char* const type_name_TimedTextSource = "TimedTextSource";

    static PyObject* _new_TimedTextSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TimedTextSource);
        return nullptr;
    }

    static void _dealloc_TimedTextSource(py::wrapper::Windows::Media::Core::TimedTextSource* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextSource_CreateFromStream(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStream(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStream(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromStreamWithIndex(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStreamWithIndex(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromStreamWithIndex(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromUri(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUri(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUri(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_CreateFromUriWithIndex(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUriWithIndex(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Media::Core::TimedTextSource::CreateFromUriWithIndex(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_add_Resolved(py::wrapper::Windows::Media::Core::TimedTextSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::TimedTextSource, winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>>(arg);

            return py::convert(self->obj.Resolved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextSource_remove_Resolved(py::wrapper::Windows::Media::Core::TimedTextSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Resolved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSource[] = {
        { "create_from_stream", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromStream), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_with_index", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromStreamWithIndex), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_uri", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromUri), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_uri_with_index", reinterpret_cast<PyCFunction>(TimedTextSource_CreateFromUriWithIndex), METH_VARARGS | METH_STATIC, nullptr },
        { "add_resolved", reinterpret_cast<PyCFunction>(TimedTextSource_add_Resolved), METH_O, nullptr },
        { "remove_resolved", reinterpret_cast<PyCFunction>(TimedTextSource_remove_Resolved), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextSource[] = {
        { }
    };

    static PyType_Slot _type_slots_TimedTextSource[] = 
    {
        { Py_tp_new, _new_TimedTextSource },
        { Py_tp_dealloc, _dealloc_TimedTextSource },
        { Py_tp_methods, _methods_TimedTextSource },
        { Py_tp_getset, _getset_TimedTextSource },
        { },
    };

    static PyType_Spec type_spec_TimedTextSource =
    {
        "_winsdk_Windows_Media_Core.TimedTextSource",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSource
    };

    // ----- TimedTextSourceResolveResultEventArgs class --------------------
    constexpr const char* const type_name_TimedTextSourceResolveResultEventArgs = "TimedTextSourceResolveResultEventArgs";

    static PyObject* _new_TimedTextSourceResolveResultEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TimedTextSourceResolveResultEventArgs);
        return nullptr;
    }

    static void _dealloc_TimedTextSourceResolveResultEventArgs(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextSourceResolveResultEventArgs_get_Error(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Error());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextSourceResolveResultEventArgs_get_Tracks(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextSourceResolveResultEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSourceResolveResultEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextSourceResolveResultEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextSourceResolveResultEventArgs[] = {
        { "error", reinterpret_cast<getter>(TimedTextSourceResolveResultEventArgs_get_Error), nullptr, nullptr, nullptr },
        { "tracks", reinterpret_cast<getter>(TimedTextSourceResolveResultEventArgs_get_Tracks), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextSourceResolveResultEventArgs[] = 
    {
        { Py_tp_new, _new_TimedTextSourceResolveResultEventArgs },
        { Py_tp_dealloc, _dealloc_TimedTextSourceResolveResultEventArgs },
        { Py_tp_methods, _methods_TimedTextSourceResolveResultEventArgs },
        { Py_tp_getset, _getset_TimedTextSourceResolveResultEventArgs },
        { },
    };

    static PyType_Spec type_spec_TimedTextSourceResolveResultEventArgs =
    {
        "_winsdk_Windows_Media_Core.TimedTextSourceResolveResultEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSourceResolveResultEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSourceResolveResultEventArgs
    };

    // ----- TimedTextStyle class --------------------
    constexpr const char* const type_name_TimedTextStyle = "TimedTextStyle";

    static PyObject* _new_TimedTextStyle(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextStyle instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextStyle_get_LineAlignment(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineAlignment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_LineAlignment(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextLineAlignment>(arg);

            self->obj.LineAlignment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsBackgroundAlwaysShown(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBackgroundAlwaysShown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsBackgroundAlwaysShown(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsBackgroundAlwaysShown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineColor(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutlineColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineColor(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.OutlineColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Foreground(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Foreground());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Foreground(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Foreground(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontWeight(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontWeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontWeight(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextWeight>(arg);

            self->obj.FontWeight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Background(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Background());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Background(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Background(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontSize(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontSize(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.FontSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontFamily(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontFamily());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontFamily(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FontFamily(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FlowDirection(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FlowDirection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FlowDirection(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextFlowDirection>(arg);

            self->obj.FlowDirection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineThickness(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutlineThickness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineThickness(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.OutlineThickness(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_OutlineRadius(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutlineRadius());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_OutlineRadius(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextDouble>(arg);

            self->obj.OutlineRadius(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Name(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_Name(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsUnderlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUnderlineEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsUnderlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsUnderlineEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsOverlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOverlineEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsOverlineEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOverlineEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsLineThroughEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLineThroughEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsLineThroughEnabled(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLineThroughEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontStyle(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextFontStyle>(arg);

            self->obj.FontStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_IsTextCombined(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTextCombined());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_IsTextCombined(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsTextCombined(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_FontAngleInDegrees(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FontAngleInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextStyle_put_FontAngleInDegrees(py::wrapper::Windows::Media::Core::TimedTextStyle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.FontAngleInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextStyle_get_Bouten(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bouten());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedTextStyle_get_Ruby(py::wrapper::Windows::Media::Core::TimedTextStyle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Ruby());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedTextStyle(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextStyle>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextStyle[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextStyle), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextStyle[] = {
        { "line_alignment", reinterpret_cast<getter>(TimedTextStyle_get_LineAlignment), reinterpret_cast<setter>(TimedTextStyle_put_LineAlignment), nullptr, nullptr },
        { "is_background_always_shown", reinterpret_cast<getter>(TimedTextStyle_get_IsBackgroundAlwaysShown), reinterpret_cast<setter>(TimedTextStyle_put_IsBackgroundAlwaysShown), nullptr, nullptr },
        { "outline_color", reinterpret_cast<getter>(TimedTextStyle_get_OutlineColor), reinterpret_cast<setter>(TimedTextStyle_put_OutlineColor), nullptr, nullptr },
        { "foreground", reinterpret_cast<getter>(TimedTextStyle_get_Foreground), reinterpret_cast<setter>(TimedTextStyle_put_Foreground), nullptr, nullptr },
        { "font_weight", reinterpret_cast<getter>(TimedTextStyle_get_FontWeight), reinterpret_cast<setter>(TimedTextStyle_put_FontWeight), nullptr, nullptr },
        { "background", reinterpret_cast<getter>(TimedTextStyle_get_Background), reinterpret_cast<setter>(TimedTextStyle_put_Background), nullptr, nullptr },
        { "font_size", reinterpret_cast<getter>(TimedTextStyle_get_FontSize), reinterpret_cast<setter>(TimedTextStyle_put_FontSize), nullptr, nullptr },
        { "font_family", reinterpret_cast<getter>(TimedTextStyle_get_FontFamily), reinterpret_cast<setter>(TimedTextStyle_put_FontFamily), nullptr, nullptr },
        { "flow_direction", reinterpret_cast<getter>(TimedTextStyle_get_FlowDirection), reinterpret_cast<setter>(TimedTextStyle_put_FlowDirection), nullptr, nullptr },
        { "outline_thickness", reinterpret_cast<getter>(TimedTextStyle_get_OutlineThickness), reinterpret_cast<setter>(TimedTextStyle_put_OutlineThickness), nullptr, nullptr },
        { "outline_radius", reinterpret_cast<getter>(TimedTextStyle_get_OutlineRadius), reinterpret_cast<setter>(TimedTextStyle_put_OutlineRadius), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(TimedTextStyle_get_Name), reinterpret_cast<setter>(TimedTextStyle_put_Name), nullptr, nullptr },
        { "is_underline_enabled", reinterpret_cast<getter>(TimedTextStyle_get_IsUnderlineEnabled), reinterpret_cast<setter>(TimedTextStyle_put_IsUnderlineEnabled), nullptr, nullptr },
        { "is_overline_enabled", reinterpret_cast<getter>(TimedTextStyle_get_IsOverlineEnabled), reinterpret_cast<setter>(TimedTextStyle_put_IsOverlineEnabled), nullptr, nullptr },
        { "is_line_through_enabled", reinterpret_cast<getter>(TimedTextStyle_get_IsLineThroughEnabled), reinterpret_cast<setter>(TimedTextStyle_put_IsLineThroughEnabled), nullptr, nullptr },
        { "font_style", reinterpret_cast<getter>(TimedTextStyle_get_FontStyle), reinterpret_cast<setter>(TimedTextStyle_put_FontStyle), nullptr, nullptr },
        { "is_text_combined", reinterpret_cast<getter>(TimedTextStyle_get_IsTextCombined), reinterpret_cast<setter>(TimedTextStyle_put_IsTextCombined), nullptr, nullptr },
        { "font_angle_in_degrees", reinterpret_cast<getter>(TimedTextStyle_get_FontAngleInDegrees), reinterpret_cast<setter>(TimedTextStyle_put_FontAngleInDegrees), nullptr, nullptr },
        { "bouten", reinterpret_cast<getter>(TimedTextStyle_get_Bouten), nullptr, nullptr, nullptr },
        { "ruby", reinterpret_cast<getter>(TimedTextStyle_get_Ruby), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextStyle[] = 
    {
        { Py_tp_new, _new_TimedTextStyle },
        { Py_tp_dealloc, _dealloc_TimedTextStyle },
        { Py_tp_methods, _methods_TimedTextStyle },
        { Py_tp_getset, _getset_TimedTextStyle },
        { },
    };

    static PyType_Spec type_spec_TimedTextStyle =
    {
        "_winsdk_Windows_Media_Core.TimedTextStyle",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextStyle),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextStyle
    };

    // ----- TimedTextSubformat class --------------------
    constexpr const char* const type_name_TimedTextSubformat = "TimedTextSubformat";

    static PyObject* _new_TimedTextSubformat(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextSubformat instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedTextSubformat(py::wrapper::Windows::Media::Core::TimedTextSubformat* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedTextSubformat_get_SubformatStyle(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubformatStyle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_SubformatStyle(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::TimedTextStyle>(arg);

            self->obj.SubformatStyle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSubformat_get_StartIndex(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_StartIndex(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.StartIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSubformat_get_Length(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSubformat_put_Length(py::wrapper::Windows::Media::Core::TimedTextSubformat* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_TimedTextSubformat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::TimedTextSubformat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedTextSubformat[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedTextSubformat), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedTextSubformat[] = {
        { "subformat_style", reinterpret_cast<getter>(TimedTextSubformat_get_SubformatStyle), reinterpret_cast<setter>(TimedTextSubformat_put_SubformatStyle), nullptr, nullptr },
        { "start_index", reinterpret_cast<getter>(TimedTextSubformat_get_StartIndex), reinterpret_cast<setter>(TimedTextSubformat_put_StartIndex), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(TimedTextSubformat_get_Length), reinterpret_cast<setter>(TimedTextSubformat_put_Length), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextSubformat[] = 
    {
        { Py_tp_new, _new_TimedTextSubformat },
        { Py_tp_dealloc, _dealloc_TimedTextSubformat },
        { Py_tp_methods, _methods_TimedTextSubformat },
        { Py_tp_getset, _getset_TimedTextSubformat },
        { },
    };

    static PyType_Spec type_spec_TimedTextSubformat =
    {
        "_winsdk_Windows_Media_Core.TimedTextSubformat",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSubformat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSubformat
    };

    // ----- VideoStabilizationEffect class --------------------
    constexpr const char* const type_name_VideoStabilizationEffect = "VideoStabilizationEffect";

    static PyObject* _new_VideoStabilizationEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VideoStabilizationEffect);
        return nullptr;
    }

    static void _dealloc_VideoStabilizationEffect(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoStabilizationEffect_GetRecommendedStreamConfiguration(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::VideoDeviceController>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 1);

                return py::convert(self->obj.GetRecommendedStreamConfiguration(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_SetProperties(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_get_Enabled(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStabilizationEffect_put_Enabled(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStabilizationEffect_add_EnabledChanged(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::VideoStabilizationEffect, winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>>(arg);

            return py::convert(self->obj.EnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffect_remove_EnabledChanged(py::wrapper::Windows::Media::Core::VideoStabilizationEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoStabilizationEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffect[] = {
        { "get_recommended_stream_configuration", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_GetRecommendedStreamConfiguration), METH_VARARGS, nullptr },
        { "set_properties", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_SetProperties), METH_VARARGS, nullptr },
        { "add_enabled_changed", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_add_EnabledChanged), METH_O, nullptr },
        { "remove_enabled_changed", reinterpret_cast<PyCFunction>(VideoStabilizationEffect_remove_EnabledChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStabilizationEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStabilizationEffect[] = {
        { "enabled", reinterpret_cast<getter>(VideoStabilizationEffect_get_Enabled), reinterpret_cast<setter>(VideoStabilizationEffect_put_Enabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffect[] = 
    {
        { Py_tp_new, _new_VideoStabilizationEffect },
        { Py_tp_dealloc, _dealloc_VideoStabilizationEffect },
        { Py_tp_methods, _methods_VideoStabilizationEffect },
        { Py_tp_getset, _getset_VideoStabilizationEffect },
        { },
    };

    static PyType_Spec type_spec_VideoStabilizationEffect =
    {
        "_winsdk_Windows_Media_Core.VideoStabilizationEffect",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffect
    };

    // ----- VideoStabilizationEffectDefinition class --------------------
    constexpr const char* const type_name_VideoStabilizationEffectDefinition = "VideoStabilizationEffectDefinition";

    static PyObject* _new_VideoStabilizationEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Core::VideoStabilizationEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoStabilizationEffectDefinition(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoStabilizationEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStabilizationEffectDefinition_get_Properties(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoStabilizationEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStabilizationEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStabilizationEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(VideoStabilizationEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoStabilizationEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffectDefinition[] = 
    {
        { Py_tp_new, _new_VideoStabilizationEffectDefinition },
        { Py_tp_dealloc, _dealloc_VideoStabilizationEffectDefinition },
        { Py_tp_methods, _methods_VideoStabilizationEffectDefinition },
        { Py_tp_getset, _getset_VideoStabilizationEffectDefinition },
        { },
    };

    static PyType_Spec type_spec_VideoStabilizationEffectDefinition =
    {
        "_winsdk_Windows_Media_Core.VideoStabilizationEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffectDefinition
    };

    // ----- VideoStabilizationEffectEnabledChangedEventArgs class --------------------
    constexpr const char* const type_name_VideoStabilizationEffectEnabledChangedEventArgs = "VideoStabilizationEffectEnabledChangedEventArgs";

    static PyObject* _new_VideoStabilizationEffectEnabledChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VideoStabilizationEffectEnabledChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_VideoStabilizationEffectEnabledChangedEventArgs(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoStabilizationEffectEnabledChangedEventArgs_get_Reason(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoStabilizationEffectEnabledChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStabilizationEffectEnabledChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStabilizationEffectEnabledChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStabilizationEffectEnabledChangedEventArgs[] = {
        { "reason", reinterpret_cast<getter>(VideoStabilizationEffectEnabledChangedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStabilizationEffectEnabledChangedEventArgs[] = 
    {
        { Py_tp_new, _new_VideoStabilizationEffectEnabledChangedEventArgs },
        { Py_tp_dealloc, _dealloc_VideoStabilizationEffectEnabledChangedEventArgs },
        { Py_tp_methods, _methods_VideoStabilizationEffectEnabledChangedEventArgs },
        { Py_tp_getset, _getset_VideoStabilizationEffectEnabledChangedEventArgs },
        { },
    };

    static PyType_Spec type_spec_VideoStabilizationEffectEnabledChangedEventArgs =
    {
        "_winsdk_Windows_Media_Core.VideoStabilizationEffectEnabledChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStabilizationEffectEnabledChangedEventArgs
    };

    // ----- VideoStreamDescriptor class --------------------
    constexpr const char* const type_name_VideoStreamDescriptor = "VideoStreamDescriptor";

    static PyObject* _new_VideoStreamDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 0);

                winrt::Windows::Media::Core::VideoStreamDescriptor instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoStreamDescriptor(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoStreamDescriptor_Copy(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStreamDescriptor_get_Label(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoStreamDescriptor_put_Label(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoStreamDescriptor_get_EncodingProperties(py::wrapper::Windows::Media::Core::VideoStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStreamDescriptor[] = {
        { "copy", reinterpret_cast<PyCFunction>(VideoStreamDescriptor_Copy), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStreamDescriptor[] = {
        { "name", reinterpret_cast<getter>(VideoStreamDescriptor_get_Name), reinterpret_cast<setter>(VideoStreamDescriptor_put_Name), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(VideoStreamDescriptor_get_Language), reinterpret_cast<setter>(VideoStreamDescriptor_put_Language), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(VideoStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(VideoStreamDescriptor_get_Label), reinterpret_cast<setter>(VideoStreamDescriptor_put_Label), nullptr, nullptr },
        { "encoding_properties", reinterpret_cast<getter>(VideoStreamDescriptor_get_EncodingProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStreamDescriptor[] = 
    {
        { Py_tp_new, _new_VideoStreamDescriptor },
        { Py_tp_dealloc, _dealloc_VideoStreamDescriptor },
        { Py_tp_methods, _methods_VideoStreamDescriptor },
        { Py_tp_getset, _getset_VideoStreamDescriptor },
        { },
    };

    static PyType_Spec type_spec_VideoStreamDescriptor =
    {
        "_winsdk_Windows_Media_Core.VideoStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::VideoStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStreamDescriptor
    };

    // ----- VideoTrack class --------------------
    constexpr const char* const type_name_VideoTrack = "VideoTrack";

    static PyObject* _new_VideoTrack(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VideoTrack);
        return nullptr;
    }

    static void _dealloc_VideoTrack(py::wrapper::Windows::Media::Core::VideoTrack* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoTrack_GetEncodingProperties(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetEncodingProperties());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Label(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTrack_put_Label(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTrack_get_Id(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Language(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_TrackKind(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_Name(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_PlaybackItem(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PlaybackItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_get_SupportInfo(py::wrapper::Windows::Media::Core::VideoTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_add_OpenFailed(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::VideoTrack, winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>>(arg);

            return py::convert(self->obj.OpenFailed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrack_remove_OpenFailed(py::wrapper::Windows::Media::Core::VideoTrack* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OpenFailed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrack[] = {
        { "get_encoding_properties", reinterpret_cast<PyCFunction>(VideoTrack_GetEncodingProperties), METH_VARARGS, nullptr },
        { "add_open_failed", reinterpret_cast<PyCFunction>(VideoTrack_add_OpenFailed), METH_O, nullptr },
        { "remove_open_failed", reinterpret_cast<PyCFunction>(VideoTrack_remove_OpenFailed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTrack[] = {
        { "label", reinterpret_cast<getter>(VideoTrack_get_Label), reinterpret_cast<setter>(VideoTrack_put_Label), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(VideoTrack_get_Id), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(VideoTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(VideoTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(VideoTrack_get_Name), nullptr, nullptr, nullptr },
        { "playback_item", reinterpret_cast<getter>(VideoTrack_get_PlaybackItem), nullptr, nullptr, nullptr },
        { "support_info", reinterpret_cast<getter>(VideoTrack_get_SupportInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTrack[] = 
    {
        { Py_tp_new, _new_VideoTrack },
        { Py_tp_dealloc, _dealloc_VideoTrack },
        { Py_tp_methods, _methods_VideoTrack },
        { Py_tp_getset, _getset_VideoTrack },
        { },
    };

    static PyType_Spec type_spec_VideoTrack =
    {
        "_winsdk_Windows_Media_Core.VideoTrack",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrack
    };

    // ----- VideoTrackOpenFailedEventArgs class --------------------
    constexpr const char* const type_name_VideoTrackOpenFailedEventArgs = "VideoTrackOpenFailedEventArgs";

    static PyObject* _new_VideoTrackOpenFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VideoTrackOpenFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_VideoTrackOpenFailedEventArgs(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoTrackOpenFailedEventArgs_get_ExtendedError(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoTrackOpenFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrackOpenFailedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTrackOpenFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTrackOpenFailedEventArgs[] = {
        { "extended_error", reinterpret_cast<getter>(VideoTrackOpenFailedEventArgs_get_ExtendedError), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTrackOpenFailedEventArgs[] = 
    {
        { Py_tp_new, _new_VideoTrackOpenFailedEventArgs },
        { Py_tp_dealloc, _dealloc_VideoTrackOpenFailedEventArgs },
        { Py_tp_methods, _methods_VideoTrackOpenFailedEventArgs },
        { Py_tp_getset, _getset_VideoTrackOpenFailedEventArgs },
        { },
    };

    static PyType_Spec type_spec_VideoTrackOpenFailedEventArgs =
    {
        "_winsdk_Windows_Media_Core.VideoTrackOpenFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrackOpenFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrackOpenFailedEventArgs
    };

    // ----- VideoTrackSupportInfo class --------------------
    constexpr const char* const type_name_VideoTrackSupportInfo = "VideoTrackSupportInfo";

    static PyObject* _new_VideoTrackSupportInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VideoTrackSupportInfo);
        return nullptr;
    }

    static void _dealloc_VideoTrackSupportInfo(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoTrackSupportInfo_get_DecoderStatus(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecoderStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTrackSupportInfo_get_MediaSourceStatus(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaSourceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoTrackSupportInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::VideoTrackSupportInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTrackSupportInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTrackSupportInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTrackSupportInfo[] = {
        { "decoder_status", reinterpret_cast<getter>(VideoTrackSupportInfo_get_DecoderStatus), nullptr, nullptr, nullptr },
        { "media_source_status", reinterpret_cast<getter>(VideoTrackSupportInfo_get_MediaSourceStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTrackSupportInfo[] = 
    {
        { Py_tp_new, _new_VideoTrackSupportInfo },
        { Py_tp_dealloc, _dealloc_VideoTrackSupportInfo },
        { Py_tp_methods, _methods_VideoTrackSupportInfo },
        { Py_tp_getset, _getset_VideoTrackSupportInfo },
        { },
    };

    static PyType_Spec type_spec_VideoTrackSupportInfo =
    {
        "_winsdk_Windows_Media_Core.VideoTrackSupportInfo",
        sizeof(py::wrapper::Windows::Media::Core::VideoTrackSupportInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTrackSupportInfo
    };

    // ----- IMediaCue interface --------------------
    constexpr const char* const type_name_IMediaCue = "IMediaCue";

    static PyObject* _new_IMediaCue(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IMediaCue);
        return nullptr;
    }

    static void _dealloc_IMediaCue(py::wrapper::Windows::Media::Core::IMediaCue* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaCue_get_Duration(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_Duration(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaCue_get_Id(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_Id(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaCue_get_StartTime(py::wrapper::Windows::Media::Core::IMediaCue* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaCue_put_StartTime(py::wrapper::Windows::Media::Core::IMediaCue* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IMediaCue(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaCue>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaCue[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaCue), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaCue[] = {
        { "duration", reinterpret_cast<getter>(IMediaCue_get_Duration), reinterpret_cast<setter>(IMediaCue_put_Duration), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(IMediaCue_get_Id), reinterpret_cast<setter>(IMediaCue_put_Id), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(IMediaCue_get_StartTime), reinterpret_cast<setter>(IMediaCue_put_StartTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaCue[] = 
    {
        { Py_tp_new, _new_IMediaCue },
        { Py_tp_dealloc, _dealloc_IMediaCue },
        { Py_tp_methods, _methods_IMediaCue },
        { Py_tp_getset, _getset_IMediaCue },
        { },
    };

    static PyType_Spec type_spec_IMediaCue =
    {
        "_winsdk_Windows_Media_Core.IMediaCue",
        sizeof(py::wrapper::Windows::Media::Core::IMediaCue),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaCue
    };

    // ----- IMediaSource interface --------------------
    constexpr const char* const type_name_IMediaSource = "IMediaSource";

    static PyObject* _new_IMediaSource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IMediaSource);
        return nullptr;
    }

    static void _dealloc_IMediaSource(py::wrapper::Windows::Media::Core::IMediaSource* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* _from_IMediaSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaSource[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaSource[] = {
        { }
    };

    static PyType_Slot _type_slots_IMediaSource[] = 
    {
        { Py_tp_new, _new_IMediaSource },
        { Py_tp_dealloc, _dealloc_IMediaSource },
        { Py_tp_methods, _methods_IMediaSource },
        { Py_tp_getset, _getset_IMediaSource },
        { },
    };

    static PyType_Spec type_spec_IMediaSource =
    {
        "_winsdk_Windows_Media_Core.IMediaSource",
        sizeof(py::wrapper::Windows::Media::Core::IMediaSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaSource
    };

    // ----- IMediaStreamDescriptor interface --------------------
    constexpr const char* const type_name_IMediaStreamDescriptor = "IMediaStreamDescriptor";

    static PyObject* _new_IMediaStreamDescriptor(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IMediaStreamDescriptor);
        return nullptr;
    }

    static void _dealloc_IMediaStreamDescriptor(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaStreamDescriptor_get_IsSelected(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaStreamDescriptor_get_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor_put_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor_get_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor_put_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IMediaStreamDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaStreamDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaStreamDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaStreamDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaStreamDescriptor[] = {
        { "is_selected", reinterpret_cast<getter>(IMediaStreamDescriptor_get_IsSelected), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(IMediaStreamDescriptor_get_Language), reinterpret_cast<setter>(IMediaStreamDescriptor_put_Language), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IMediaStreamDescriptor_get_Name), reinterpret_cast<setter>(IMediaStreamDescriptor_put_Name), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaStreamDescriptor[] = 
    {
        { Py_tp_new, _new_IMediaStreamDescriptor },
        { Py_tp_dealloc, _dealloc_IMediaStreamDescriptor },
        { Py_tp_methods, _methods_IMediaStreamDescriptor },
        { Py_tp_getset, _getset_IMediaStreamDescriptor },
        { },
    };

    static PyType_Spec type_spec_IMediaStreamDescriptor =
    {
        "_winsdk_Windows_Media_Core.IMediaStreamDescriptor",
        sizeof(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaStreamDescriptor
    };

    // ----- IMediaStreamDescriptor2 interface --------------------
    constexpr const char* const type_name_IMediaStreamDescriptor2 = "IMediaStreamDescriptor2";

    static PyObject* _new_IMediaStreamDescriptor2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IMediaStreamDescriptor2);
        return nullptr;
    }

    static void _dealloc_IMediaStreamDescriptor2(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaStreamDescriptor2_get_Label(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Label(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_IsSelected(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSelected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Language(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Language(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaStreamDescriptor2_get_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaStreamDescriptor2_put_Name(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IMediaStreamDescriptor2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaStreamDescriptor2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaStreamDescriptor2[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaStreamDescriptor2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaStreamDescriptor2[] = {
        { "label", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_Label), reinterpret_cast<setter>(IMediaStreamDescriptor2_put_Label), nullptr, nullptr },
        { "is_selected", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_IsSelected), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_Language), reinterpret_cast<setter>(IMediaStreamDescriptor2_put_Language), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(IMediaStreamDescriptor2_get_Name), reinterpret_cast<setter>(IMediaStreamDescriptor2_put_Name), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaStreamDescriptor2[] = 
    {
        { Py_tp_new, _new_IMediaStreamDescriptor2 },
        { Py_tp_dealloc, _dealloc_IMediaStreamDescriptor2 },
        { Py_tp_methods, _methods_IMediaStreamDescriptor2 },
        { Py_tp_getset, _getset_IMediaStreamDescriptor2 },
        { },
    };

    static PyType_Spec type_spec_IMediaStreamDescriptor2 =
    {
        "_winsdk_Windows_Media_Core.IMediaStreamDescriptor2",
        sizeof(py::wrapper::Windows::Media::Core::IMediaStreamDescriptor2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaStreamDescriptor2
    };

    // ----- IMediaTrack interface --------------------
    constexpr const char* const type_name_IMediaTrack = "IMediaTrack";

    static PyObject* _new_IMediaTrack(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IMediaTrack);
        return nullptr;
    }

    static void _dealloc_IMediaTrack(py::wrapper::Windows::Media::Core::IMediaTrack* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaTrack_get_Id(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaTrack_get_Label(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaTrack_put_Label(py::wrapper::Windows::Media::Core::IMediaTrack* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Label(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaTrack_get_Language(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaTrack_get_TrackKind(py::wrapper::Windows::Media::Core::IMediaTrack* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IMediaTrack(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::IMediaTrack>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaTrack[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaTrack), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaTrack[] = {
        { "id", reinterpret_cast<getter>(IMediaTrack_get_Id), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(IMediaTrack_get_Label), reinterpret_cast<setter>(IMediaTrack_put_Label), nullptr, nullptr },
        { "language", reinterpret_cast<getter>(IMediaTrack_get_Language), nullptr, nullptr, nullptr },
        { "track_kind", reinterpret_cast<getter>(IMediaTrack_get_TrackKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaTrack[] = 
    {
        { Py_tp_new, _new_IMediaTrack },
        { Py_tp_dealloc, _dealloc_IMediaTrack },
        { Py_tp_methods, _methods_IMediaTrack },
        { Py_tp_getset, _getset_IMediaTrack },
        { },
    };

    static PyType_Spec type_spec_IMediaTrack =
    {
        "_winsdk_Windows_Media_Core.IMediaTrack",
        sizeof(py::wrapper::Windows::Media::Core::IMediaTrack),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaTrack
    };

    // ----- ISingleSelectMediaTrackList interface --------------------
    constexpr const char* const type_name_ISingleSelectMediaTrackList = "ISingleSelectMediaTrackList";

    static PyObject* _new_ISingleSelectMediaTrackList(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_ISingleSelectMediaTrackList);
        return nullptr;
    }

    static void _dealloc_ISingleSelectMediaTrackList(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISingleSelectMediaTrackList_get_SelectedIndex(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectedIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISingleSelectMediaTrackList_put_SelectedIndex(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.SelectedIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISingleSelectMediaTrackList_add_SelectedIndexChanged(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Core::ISingleSelectMediaTrackList, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SelectedIndexChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISingleSelectMediaTrackList_remove_SelectedIndexChanged(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SelectedIndexChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ISingleSelectMediaTrackList(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ISingleSelectMediaTrackList>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISingleSelectMediaTrackList[] = {
        { "add_selected_index_changed", reinterpret_cast<PyCFunction>(ISingleSelectMediaTrackList_add_SelectedIndexChanged), METH_O, nullptr },
        { "remove_selected_index_changed", reinterpret_cast<PyCFunction>(ISingleSelectMediaTrackList_remove_SelectedIndexChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ISingleSelectMediaTrackList), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISingleSelectMediaTrackList[] = {
        { "selected_index", reinterpret_cast<getter>(ISingleSelectMediaTrackList_get_SelectedIndex), reinterpret_cast<setter>(ISingleSelectMediaTrackList_put_SelectedIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISingleSelectMediaTrackList[] = 
    {
        { Py_tp_new, _new_ISingleSelectMediaTrackList },
        { Py_tp_dealloc, _dealloc_ISingleSelectMediaTrackList },
        { Py_tp_methods, _methods_ISingleSelectMediaTrackList },
        { Py_tp_getset, _getset_ISingleSelectMediaTrackList },
        { },
    };

    static PyType_Spec type_spec_ISingleSelectMediaTrackList =
    {
        "_winsdk_Windows_Media_Core.ISingleSelectMediaTrackList",
        sizeof(py::wrapper::Windows::Media::Core::ISingleSelectMediaTrackList),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISingleSelectMediaTrackList
    };

    // ----- ITimedMetadataTrackProvider interface --------------------
    constexpr const char* const type_name_ITimedMetadataTrackProvider = "ITimedMetadataTrackProvider";

    static PyObject* _new_ITimedMetadataTrackProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_ITimedMetadataTrackProvider);
        return nullptr;
    }

    static void _dealloc_ITimedMetadataTrackProvider(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ITimedMetadataTrackProvider_get_TimedMetadataTracks(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimedMetadataTracks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ITimedMetadataTrackProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Core::ITimedMetadataTrackProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ITimedMetadataTrackProvider[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ITimedMetadataTrackProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ITimedMetadataTrackProvider[] = {
        { "timed_metadata_tracks", reinterpret_cast<getter>(ITimedMetadataTrackProvider_get_TimedMetadataTracks), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ITimedMetadataTrackProvider[] = 
    {
        { Py_tp_new, _new_ITimedMetadataTrackProvider },
        { Py_tp_dealloc, _dealloc_ITimedMetadataTrackProvider },
        { Py_tp_methods, _methods_ITimedMetadataTrackProvider },
        { Py_tp_getset, _getset_ITimedMetadataTrackProvider },
        { },
    };

    static PyType_Spec type_spec_ITimedMetadataTrackProvider =
    {
        "_winsdk_Windows_Media_Core.ITimedMetadataTrackProvider",
        sizeof(py::wrapper::Windows::Media::Core::ITimedMetadataTrackProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ITimedMetadataTrackProvider
    };

    // ----- MseTimeRange struct --------------------
    constexpr const char* const type_name_MseTimeRange = "MseTimeRange";

    PyObject* _new_MseTimeRange(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::MseTimeRange return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        PyObject* _Start{};
        PyObject* _End{};

        static const char* kwlist[] = {"start", "end", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "OO", const_cast<char**>(kwlist), &_Start, &_End))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::MseTimeRange return_value{ py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_Start), py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(_End) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_MseTimeRange(py::wrapper::Windows::Media::Core::MseTimeRange* self)
    {
    }

    static PyObject* MseTimeRange_get_Start(py::wrapper::Windows::Media::Core::MseTimeRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Start);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseTimeRange_set_Start(py::wrapper::Windows::Media::Core::MseTimeRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Start = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MseTimeRange_get_End(py::wrapper::Windows::Media::Core::MseTimeRange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.End);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MseTimeRange_set_End(py::wrapper::Windows::Media::Core::MseTimeRange* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.End = py::converter<winrt::Windows::Foundation::TimeSpan>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_MseTimeRange[] = {
        { "start", reinterpret_cast<getter>(MseTimeRange_get_Start), reinterpret_cast<setter>(MseTimeRange_set_Start), nullptr, nullptr },
        { "end", reinterpret_cast<getter>(MseTimeRange_get_End), reinterpret_cast<setter>(MseTimeRange_set_End), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MseTimeRange[] = 
    {
        { Py_tp_new, _new_MseTimeRange },
        { Py_tp_dealloc, _dealloc_MseTimeRange },
        { Py_tp_getset, _getset_MseTimeRange },
        { },
    };

    static PyType_Spec type_spec_MseTimeRange =
    {
        "_winsdk_Windows_Media_Core.MseTimeRange",
        sizeof(py::wrapper::Windows::Media::Core::MseTimeRange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MseTimeRange
    };

    // ----- TimedTextDouble struct --------------------
    constexpr const char* const type_name_TimedTextDouble = "TimedTextDouble";

    PyObject* _new_TimedTextDouble(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextDouble return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        double _Value{};
        int32_t _Unit{};

        static const char* kwlist[] = {"value", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "di", const_cast<char**>(kwlist), &_Value, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextDouble return_value{ _Value, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextDouble(py::wrapper::Windows::Media::Core::TimedTextDouble* self)
    {
    }

    static PyObject* TimedTextDouble_get_Value(py::wrapper::Windows::Media::Core::TimedTextDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextDouble_set_Value(py::wrapper::Windows::Media::Core::TimedTextDouble* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Value = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextDouble_get_Unit(py::wrapper::Windows::Media::Core::TimedTextDouble* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextDouble_set_Unit(py::wrapper::Windows::Media::Core::TimedTextDouble* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextDouble[] = {
        { "value", reinterpret_cast<getter>(TimedTextDouble_get_Value), reinterpret_cast<setter>(TimedTextDouble_set_Value), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextDouble_get_Unit), reinterpret_cast<setter>(TimedTextDouble_set_Unit), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextDouble[] = 
    {
        { Py_tp_new, _new_TimedTextDouble },
        { Py_tp_dealloc, _dealloc_TimedTextDouble },
        { Py_tp_getset, _getset_TimedTextDouble },
        { },
    };

    static PyType_Spec type_spec_TimedTextDouble =
    {
        "_winsdk_Windows_Media_Core.TimedTextDouble",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextDouble),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextDouble
    };

    // ----- TimedTextPadding struct --------------------
    constexpr const char* const type_name_TimedTextPadding = "TimedTextPadding";

    PyObject* _new_TimedTextPadding(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextPadding return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        double _Before{};
        double _After{};
        double _Start{};
        double _End{};
        int32_t _Unit{};

        static const char* kwlist[] = {"before", "after", "start", "end", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddddi", const_cast<char**>(kwlist), &_Before, &_After, &_Start, &_End, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextPadding return_value{ _Before, _After, _Start, _End, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextPadding(py::wrapper::Windows::Media::Core::TimedTextPadding* self)
    {
    }

    static PyObject* TimedTextPadding_get_Before(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Before);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Before(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Before = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_After(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.After);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_After(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.After = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_Start(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Start);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Start(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Start = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_End(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.End);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_End(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.End = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPadding_get_Unit(py::wrapper::Windows::Media::Core::TimedTextPadding* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPadding_set_Unit(py::wrapper::Windows::Media::Core::TimedTextPadding* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextPadding[] = {
        { "before", reinterpret_cast<getter>(TimedTextPadding_get_Before), reinterpret_cast<setter>(TimedTextPadding_set_Before), nullptr, nullptr },
        { "after", reinterpret_cast<getter>(TimedTextPadding_get_After), reinterpret_cast<setter>(TimedTextPadding_set_After), nullptr, nullptr },
        { "start", reinterpret_cast<getter>(TimedTextPadding_get_Start), reinterpret_cast<setter>(TimedTextPadding_set_Start), nullptr, nullptr },
        { "end", reinterpret_cast<getter>(TimedTextPadding_get_End), reinterpret_cast<setter>(TimedTextPadding_set_End), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextPadding_get_Unit), reinterpret_cast<setter>(TimedTextPadding_set_Unit), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextPadding[] = 
    {
        { Py_tp_new, _new_TimedTextPadding },
        { Py_tp_dealloc, _dealloc_TimedTextPadding },
        { Py_tp_getset, _getset_TimedTextPadding },
        { },
    };

    static PyType_Spec type_spec_TimedTextPadding =
    {
        "_winsdk_Windows_Media_Core.TimedTextPadding",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextPadding),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextPadding
    };

    // ----- TimedTextPoint struct --------------------
    constexpr const char* const type_name_TimedTextPoint = "TimedTextPoint";

    PyObject* _new_TimedTextPoint(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextPoint return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        double _X{};
        double _Y{};
        int32_t _Unit{};

        static const char* kwlist[] = {"x", "y", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddi", const_cast<char**>(kwlist), &_X, &_Y, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextPoint return_value{ _X, _Y, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextPoint(py::wrapper::Windows::Media::Core::TimedTextPoint* self)
    {
    }

    static PyObject* TimedTextPoint_get_X(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_X(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPoint_get_Y(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_Y(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextPoint_get_Unit(py::wrapper::Windows::Media::Core::TimedTextPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextPoint_set_Unit(py::wrapper::Windows::Media::Core::TimedTextPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextPoint[] = {
        { "x", reinterpret_cast<getter>(TimedTextPoint_get_X), reinterpret_cast<setter>(TimedTextPoint_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(TimedTextPoint_get_Y), reinterpret_cast<setter>(TimedTextPoint_set_Y), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextPoint_get_Unit), reinterpret_cast<setter>(TimedTextPoint_set_Unit), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextPoint[] = 
    {
        { Py_tp_new, _new_TimedTextPoint },
        { Py_tp_dealloc, _dealloc_TimedTextPoint },
        { Py_tp_getset, _getset_TimedTextPoint },
        { },
    };

    static PyType_Spec type_spec_TimedTextPoint =
    {
        "_winsdk_Windows_Media_Core.TimedTextPoint",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextPoint
    };

    // ----- TimedTextSize struct --------------------
    constexpr const char* const type_name_TimedTextSize = "TimedTextSize";

    PyObject* _new_TimedTextSize(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Core::TimedTextSize return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        double _Height{};
        double _Width{};
        int32_t _Unit{};

        static const char* kwlist[] = {"height", "width", "unit", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddi", const_cast<char**>(kwlist), &_Height, &_Width, &_Unit))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Core::TimedTextSize return_value{ _Height, _Width, static_cast<winrt::Windows::Media::Core::TimedTextUnit>(_Unit) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_TimedTextSize(py::wrapper::Windows::Media::Core::TimedTextSize* self)
    {
    }

    static PyObject* TimedTextSize_get_Height(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Height(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSize_get_Width(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Width(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedTextSize_get_Unit(py::wrapper::Windows::Media::Core::TimedTextSize* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedTextSize_set_Unit(py::wrapper::Windows::Media::Core::TimedTextSize* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Unit = py::converter<winrt::Windows::Media::Core::TimedTextUnit>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_TimedTextSize[] = {
        { "height", reinterpret_cast<getter>(TimedTextSize_get_Height), reinterpret_cast<setter>(TimedTextSize_set_Height), nullptr, nullptr },
        { "width", reinterpret_cast<getter>(TimedTextSize_get_Width), reinterpret_cast<setter>(TimedTextSize_set_Width), nullptr, nullptr },
        { "unit", reinterpret_cast<getter>(TimedTextSize_get_Unit), reinterpret_cast<setter>(TimedTextSize_set_Unit), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedTextSize[] = 
    {
        { Py_tp_new, _new_TimedTextSize },
        { Py_tp_dealloc, _dealloc_TimedTextSize },
        { Py_tp_getset, _getset_TimedTextSize },
        { },
    };

    static PyType_Spec type_spec_TimedTextSize =
    {
        "_winsdk_Windows_Media_Core.TimedTextSize",
        sizeof(py::wrapper::Windows::Media::Core::TimedTextSize),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedTextSize
    };

    // ----- Windows.Media.Core Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::Core");

    static PyMethodDef module_methods[] = {
        {"_register_AudioDecoderDegradation", register_AudioDecoderDegradation, METH_O, "registers type"},
        {"_register_AudioDecoderDegradationReason", register_AudioDecoderDegradationReason, METH_O, "registers type"},
        {"_register_CodecCategory", register_CodecCategory, METH_O, "registers type"},
        {"_register_CodecKind", register_CodecKind, METH_O, "registers type"},
        {"_register_FaceDetectionMode", register_FaceDetectionMode, METH_O, "registers type"},
        {"_register_MediaDecoderStatus", register_MediaDecoderStatus, METH_O, "registers type"},
        {"_register_MediaSourceState", register_MediaSourceState, METH_O, "registers type"},
        {"_register_MediaSourceStatus", register_MediaSourceStatus, METH_O, "registers type"},
        {"_register_MediaStreamSourceClosedReason", register_MediaStreamSourceClosedReason, METH_O, "registers type"},
        {"_register_MediaStreamSourceErrorStatus", register_MediaStreamSourceErrorStatus, METH_O, "registers type"},
        {"_register_MediaTrackKind", register_MediaTrackKind, METH_O, "registers type"},
        {"_register_MseAppendMode", register_MseAppendMode, METH_O, "registers type"},
        {"_register_MseEndOfStreamStatus", register_MseEndOfStreamStatus, METH_O, "registers type"},
        {"_register_MseReadyState", register_MseReadyState, METH_O, "registers type"},
        {"_register_SceneAnalysisRecommendation", register_SceneAnalysisRecommendation, METH_O, "registers type"},
        {"_register_TimedMetadataKind", register_TimedMetadataKind, METH_O, "registers type"},
        {"_register_TimedMetadataTrackErrorCode", register_TimedMetadataTrackErrorCode, METH_O, "registers type"},
        {"_register_TimedTextBoutenPosition", register_TimedTextBoutenPosition, METH_O, "registers type"},
        {"_register_TimedTextBoutenType", register_TimedTextBoutenType, METH_O, "registers type"},
        {"_register_TimedTextDisplayAlignment", register_TimedTextDisplayAlignment, METH_O, "registers type"},
        {"_register_TimedTextFlowDirection", register_TimedTextFlowDirection, METH_O, "registers type"},
        {"_register_TimedTextFontStyle", register_TimedTextFontStyle, METH_O, "registers type"},
        {"_register_TimedTextLineAlignment", register_TimedTextLineAlignment, METH_O, "registers type"},
        {"_register_TimedTextRubyAlign", register_TimedTextRubyAlign, METH_O, "registers type"},
        {"_register_TimedTextRubyPosition", register_TimedTextRubyPosition, METH_O, "registers type"},
        {"_register_TimedTextRubyReserve", register_TimedTextRubyReserve, METH_O, "registers type"},
        {"_register_TimedTextScrollMode", register_TimedTextScrollMode, METH_O, "registers type"},
        {"_register_TimedTextUnit", register_TimedTextUnit, METH_O, "registers type"},
        {"_register_TimedTextWeight", register_TimedTextWeight, METH_O, "registers type"},
        {"_register_TimedTextWrapping", register_TimedTextWrapping, METH_O, "registers type"},
        {"_register_TimedTextWritingMode", register_TimedTextWritingMode, METH_O, "registers type"},
        {"_register_VideoStabilizationEffectEnabledChangedReason", register_VideoStabilizationEffectEnabledChangedReason, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AudioDecoderDegradation);
        Py_VISIT(state->type_AudioDecoderDegradationReason);
        Py_VISIT(state->type_CodecCategory);
        Py_VISIT(state->type_CodecKind);
        Py_VISIT(state->type_FaceDetectionMode);
        Py_VISIT(state->type_MediaDecoderStatus);
        Py_VISIT(state->type_MediaSourceState);
        Py_VISIT(state->type_MediaSourceStatus);
        Py_VISIT(state->type_MediaStreamSourceClosedReason);
        Py_VISIT(state->type_MediaStreamSourceErrorStatus);
        Py_VISIT(state->type_MediaTrackKind);
        Py_VISIT(state->type_MseAppendMode);
        Py_VISIT(state->type_MseEndOfStreamStatus);
        Py_VISIT(state->type_MseReadyState);
        Py_VISIT(state->type_SceneAnalysisRecommendation);
        Py_VISIT(state->type_TimedMetadataKind);
        Py_VISIT(state->type_TimedMetadataTrackErrorCode);
        Py_VISIT(state->type_TimedTextBoutenPosition);
        Py_VISIT(state->type_TimedTextBoutenType);
        Py_VISIT(state->type_TimedTextDisplayAlignment);
        Py_VISIT(state->type_TimedTextFlowDirection);
        Py_VISIT(state->type_TimedTextFontStyle);
        Py_VISIT(state->type_TimedTextLineAlignment);
        Py_VISIT(state->type_TimedTextRubyAlign);
        Py_VISIT(state->type_TimedTextRubyPosition);
        Py_VISIT(state->type_TimedTextRubyReserve);
        Py_VISIT(state->type_TimedTextScrollMode);
        Py_VISIT(state->type_TimedTextUnit);
        Py_VISIT(state->type_TimedTextWeight);
        Py_VISIT(state->type_TimedTextWrapping);
        Py_VISIT(state->type_TimedTextWritingMode);
        Py_VISIT(state->type_VideoStabilizationEffectEnabledChangedReason);
        Py_VISIT(state->type_AudioStreamDescriptor);
        Py_VISIT(state->type_AudioTrack);
        Py_VISIT(state->type_AudioTrackOpenFailedEventArgs);
        Py_VISIT(state->type_AudioTrackSupportInfo);
        Py_VISIT(state->type_ChapterCue);
        Py_VISIT(state->type_CodecInfo);
        Py_VISIT(state->type_CodecQuery);
        Py_VISIT(state->type_CodecSubtypes);
        Py_VISIT(state->type_DataCue);
        Py_VISIT(state->type_FaceDetectedEventArgs);
        Py_VISIT(state->type_FaceDetectionEffect);
        Py_VISIT(state->type_FaceDetectionEffectDefinition);
        Py_VISIT(state->type_FaceDetectionEffectFrame);
        Py_VISIT(state->type_HighDynamicRangeControl);
        Py_VISIT(state->type_HighDynamicRangeOutput);
        Py_VISIT(state->type_ImageCue);
        Py_VISIT(state->type_InitializeMediaStreamSourceRequestedEventArgs);
        Py_VISIT(state->type_LowLightFusion);
        Py_VISIT(state->type_LowLightFusionResult);
        Py_VISIT(state->type_MediaBinder);
        Py_VISIT(state->type_MediaBindingEventArgs);
        Py_VISIT(state->type_MediaCueEventArgs);
        Py_VISIT(state->type_MediaSource);
        Py_VISIT(state->type_MediaSourceAppServiceConnection);
        Py_VISIT(state->type_MediaSourceError);
        Py_VISIT(state->type_MediaSourceOpenOperationCompletedEventArgs);
        Py_VISIT(state->type_MediaSourceStateChangedEventArgs);
        Py_VISIT(state->type_MediaStreamSample);
        Py_VISIT(state->type_MediaStreamSamplePropertySet);
        Py_VISIT(state->type_MediaStreamSampleProtectionProperties);
        Py_VISIT(state->type_MediaStreamSource);
        Py_VISIT(state->type_MediaStreamSourceClosedEventArgs);
        Py_VISIT(state->type_MediaStreamSourceClosedRequest);
        Py_VISIT(state->type_MediaStreamSourceSampleRenderedEventArgs);
        Py_VISIT(state->type_MediaStreamSourceSampleRequest);
        Py_VISIT(state->type_MediaStreamSourceSampleRequestDeferral);
        Py_VISIT(state->type_MediaStreamSourceSampleRequestedEventArgs);
        Py_VISIT(state->type_MediaStreamSourceStartingEventArgs);
        Py_VISIT(state->type_MediaStreamSourceStartingRequest);
        Py_VISIT(state->type_MediaStreamSourceStartingRequestDeferral);
        Py_VISIT(state->type_MediaStreamSourceSwitchStreamsRequest);
        Py_VISIT(state->type_MediaStreamSourceSwitchStreamsRequestDeferral);
        Py_VISIT(state->type_MediaStreamSourceSwitchStreamsRequestedEventArgs);
        Py_VISIT(state->type_MseSourceBuffer);
        Py_VISIT(state->type_MseSourceBufferList);
        Py_VISIT(state->type_MseStreamSource);
        Py_VISIT(state->type_SceneAnalysisEffect);
        Py_VISIT(state->type_SceneAnalysisEffectDefinition);
        Py_VISIT(state->type_SceneAnalysisEffectFrame);
        Py_VISIT(state->type_SceneAnalyzedEventArgs);
        Py_VISIT(state->type_SpeechCue);
        Py_VISIT(state->type_TimedMetadataStreamDescriptor);
        Py_VISIT(state->type_TimedMetadataTrack);
        Py_VISIT(state->type_TimedMetadataTrackError);
        Py_VISIT(state->type_TimedMetadataTrackFailedEventArgs);
        Py_VISIT(state->type_TimedTextBouten);
        Py_VISIT(state->type_TimedTextCue);
        Py_VISIT(state->type_TimedTextLine);
        Py_VISIT(state->type_TimedTextRegion);
        Py_VISIT(state->type_TimedTextRuby);
        Py_VISIT(state->type_TimedTextSource);
        Py_VISIT(state->type_TimedTextSourceResolveResultEventArgs);
        Py_VISIT(state->type_TimedTextStyle);
        Py_VISIT(state->type_TimedTextSubformat);
        Py_VISIT(state->type_VideoStabilizationEffect);
        Py_VISIT(state->type_VideoStabilizationEffectDefinition);
        Py_VISIT(state->type_VideoStabilizationEffectEnabledChangedEventArgs);
        Py_VISIT(state->type_VideoStreamDescriptor);
        Py_VISIT(state->type_VideoTrack);
        Py_VISIT(state->type_VideoTrackOpenFailedEventArgs);
        Py_VISIT(state->type_VideoTrackSupportInfo);
        Py_VISIT(state->type_IMediaCue);
        Py_VISIT(state->type_IMediaSource);
        Py_VISIT(state->type_IMediaStreamDescriptor);
        Py_VISIT(state->type_IMediaStreamDescriptor2);
        Py_VISIT(state->type_IMediaTrack);
        Py_VISIT(state->type_ISingleSelectMediaTrackList);
        Py_VISIT(state->type_ITimedMetadataTrackProvider);
        Py_VISIT(state->type_MseTimeRange);
        Py_VISIT(state->type_TimedTextDouble);
        Py_VISIT(state->type_TimedTextPadding);
        Py_VISIT(state->type_TimedTextPoint);
        Py_VISIT(state->type_TimedTextSize);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AudioDecoderDegradation);
        Py_CLEAR(state->type_AudioDecoderDegradationReason);
        Py_CLEAR(state->type_CodecCategory);
        Py_CLEAR(state->type_CodecKind);
        Py_CLEAR(state->type_FaceDetectionMode);
        Py_CLEAR(state->type_MediaDecoderStatus);
        Py_CLEAR(state->type_MediaSourceState);
        Py_CLEAR(state->type_MediaSourceStatus);
        Py_CLEAR(state->type_MediaStreamSourceClosedReason);
        Py_CLEAR(state->type_MediaStreamSourceErrorStatus);
        Py_CLEAR(state->type_MediaTrackKind);
        Py_CLEAR(state->type_MseAppendMode);
        Py_CLEAR(state->type_MseEndOfStreamStatus);
        Py_CLEAR(state->type_MseReadyState);
        Py_CLEAR(state->type_SceneAnalysisRecommendation);
        Py_CLEAR(state->type_TimedMetadataKind);
        Py_CLEAR(state->type_TimedMetadataTrackErrorCode);
        Py_CLEAR(state->type_TimedTextBoutenPosition);
        Py_CLEAR(state->type_TimedTextBoutenType);
        Py_CLEAR(state->type_TimedTextDisplayAlignment);
        Py_CLEAR(state->type_TimedTextFlowDirection);
        Py_CLEAR(state->type_TimedTextFontStyle);
        Py_CLEAR(state->type_TimedTextLineAlignment);
        Py_CLEAR(state->type_TimedTextRubyAlign);
        Py_CLEAR(state->type_TimedTextRubyPosition);
        Py_CLEAR(state->type_TimedTextRubyReserve);
        Py_CLEAR(state->type_TimedTextScrollMode);
        Py_CLEAR(state->type_TimedTextUnit);
        Py_CLEAR(state->type_TimedTextWeight);
        Py_CLEAR(state->type_TimedTextWrapping);
        Py_CLEAR(state->type_TimedTextWritingMode);
        Py_CLEAR(state->type_VideoStabilizationEffectEnabledChangedReason);
        Py_CLEAR(state->type_AudioStreamDescriptor);
        Py_CLEAR(state->type_AudioTrack);
        Py_CLEAR(state->type_AudioTrackOpenFailedEventArgs);
        Py_CLEAR(state->type_AudioTrackSupportInfo);
        Py_CLEAR(state->type_ChapterCue);
        Py_CLEAR(state->type_CodecInfo);
        Py_CLEAR(state->type_CodecQuery);
        Py_CLEAR(state->type_CodecSubtypes);
        Py_CLEAR(state->type_DataCue);
        Py_CLEAR(state->type_FaceDetectedEventArgs);
        Py_CLEAR(state->type_FaceDetectionEffect);
        Py_CLEAR(state->type_FaceDetectionEffectDefinition);
        Py_CLEAR(state->type_FaceDetectionEffectFrame);
        Py_CLEAR(state->type_HighDynamicRangeControl);
        Py_CLEAR(state->type_HighDynamicRangeOutput);
        Py_CLEAR(state->type_ImageCue);
        Py_CLEAR(state->type_InitializeMediaStreamSourceRequestedEventArgs);
        Py_CLEAR(state->type_LowLightFusion);
        Py_CLEAR(state->type_LowLightFusionResult);
        Py_CLEAR(state->type_MediaBinder);
        Py_CLEAR(state->type_MediaBindingEventArgs);
        Py_CLEAR(state->type_MediaCueEventArgs);
        Py_CLEAR(state->type_MediaSource);
        Py_CLEAR(state->type_MediaSourceAppServiceConnection);
        Py_CLEAR(state->type_MediaSourceError);
        Py_CLEAR(state->type_MediaSourceOpenOperationCompletedEventArgs);
        Py_CLEAR(state->type_MediaSourceStateChangedEventArgs);
        Py_CLEAR(state->type_MediaStreamSample);
        Py_CLEAR(state->type_MediaStreamSamplePropertySet);
        Py_CLEAR(state->type_MediaStreamSampleProtectionProperties);
        Py_CLEAR(state->type_MediaStreamSource);
        Py_CLEAR(state->type_MediaStreamSourceClosedEventArgs);
        Py_CLEAR(state->type_MediaStreamSourceClosedRequest);
        Py_CLEAR(state->type_MediaStreamSourceSampleRenderedEventArgs);
        Py_CLEAR(state->type_MediaStreamSourceSampleRequest);
        Py_CLEAR(state->type_MediaStreamSourceSampleRequestDeferral);
        Py_CLEAR(state->type_MediaStreamSourceSampleRequestedEventArgs);
        Py_CLEAR(state->type_MediaStreamSourceStartingEventArgs);
        Py_CLEAR(state->type_MediaStreamSourceStartingRequest);
        Py_CLEAR(state->type_MediaStreamSourceStartingRequestDeferral);
        Py_CLEAR(state->type_MediaStreamSourceSwitchStreamsRequest);
        Py_CLEAR(state->type_MediaStreamSourceSwitchStreamsRequestDeferral);
        Py_CLEAR(state->type_MediaStreamSourceSwitchStreamsRequestedEventArgs);
        Py_CLEAR(state->type_MseSourceBuffer);
        Py_CLEAR(state->type_MseSourceBufferList);
        Py_CLEAR(state->type_MseStreamSource);
        Py_CLEAR(state->type_SceneAnalysisEffect);
        Py_CLEAR(state->type_SceneAnalysisEffectDefinition);
        Py_CLEAR(state->type_SceneAnalysisEffectFrame);
        Py_CLEAR(state->type_SceneAnalyzedEventArgs);
        Py_CLEAR(state->type_SpeechCue);
        Py_CLEAR(state->type_TimedMetadataStreamDescriptor);
        Py_CLEAR(state->type_TimedMetadataTrack);
        Py_CLEAR(state->type_TimedMetadataTrackError);
        Py_CLEAR(state->type_TimedMetadataTrackFailedEventArgs);
        Py_CLEAR(state->type_TimedTextBouten);
        Py_CLEAR(state->type_TimedTextCue);
        Py_CLEAR(state->type_TimedTextLine);
        Py_CLEAR(state->type_TimedTextRegion);
        Py_CLEAR(state->type_TimedTextRuby);
        Py_CLEAR(state->type_TimedTextSource);
        Py_CLEAR(state->type_TimedTextSourceResolveResultEventArgs);
        Py_CLEAR(state->type_TimedTextStyle);
        Py_CLEAR(state->type_TimedTextSubformat);
        Py_CLEAR(state->type_VideoStabilizationEffect);
        Py_CLEAR(state->type_VideoStabilizationEffectDefinition);
        Py_CLEAR(state->type_VideoStabilizationEffectEnabledChangedEventArgs);
        Py_CLEAR(state->type_VideoStreamDescriptor);
        Py_CLEAR(state->type_VideoTrack);
        Py_CLEAR(state->type_VideoTrackOpenFailedEventArgs);
        Py_CLEAR(state->type_VideoTrackSupportInfo);
        Py_CLEAR(state->type_IMediaCue);
        Py_CLEAR(state->type_IMediaSource);
        Py_CLEAR(state->type_IMediaStreamDescriptor);
        Py_CLEAR(state->type_IMediaStreamDescriptor2);
        Py_CLEAR(state->type_IMediaTrack);
        Py_CLEAR(state->type_ISingleSelectMediaTrackList);
        Py_CLEAR(state->type_ITimedMetadataTrackProvider);
        Py_CLEAR(state->type_MseTimeRange);
        Py_CLEAR(state->type_TimedTextDouble);
        Py_CLEAR(state->type_TimedTextPadding);
        Py_CLEAR(state->type_TimedTextPoint);
        Py_CLEAR(state->type_TimedTextSize);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_Core",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Media::Core

PyMODINIT_FUNC PyInit__winsdk_Windows_Media_Core(void) noexcept
{
    using namespace py::cpp::Windows::Media::Core;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AudioStreamDescriptor = py::register_python_type(module.get(), type_name_AudioStreamDescriptor, &type_spec_AudioStreamDescriptor, bases.get());
    if (!state->type_AudioStreamDescriptor)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AudioStreamDescriptor);

    state->type_AudioTrack = py::register_python_type(module.get(), type_name_AudioTrack, &type_spec_AudioTrack, bases.get());
    if (!state->type_AudioTrack)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AudioTrack);

    state->type_AudioTrackOpenFailedEventArgs = py::register_python_type(module.get(), type_name_AudioTrackOpenFailedEventArgs, &type_spec_AudioTrackOpenFailedEventArgs, bases.get());
    if (!state->type_AudioTrackOpenFailedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AudioTrackOpenFailedEventArgs);

    state->type_AudioTrackSupportInfo = py::register_python_type(module.get(), type_name_AudioTrackSupportInfo, &type_spec_AudioTrackSupportInfo, bases.get());
    if (!state->type_AudioTrackSupportInfo)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AudioTrackSupportInfo);

    state->type_ChapterCue = py::register_python_type(module.get(), type_name_ChapterCue, &type_spec_ChapterCue, bases.get());
    if (!state->type_ChapterCue)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ChapterCue);

    state->type_CodecInfo = py::register_python_type(module.get(), type_name_CodecInfo, &type_spec_CodecInfo, bases.get());
    if (!state->type_CodecInfo)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CodecInfo);

    state->type_CodecQuery = py::register_python_type(module.get(), type_name_CodecQuery, &type_spec_CodecQuery, bases.get());
    if (!state->type_CodecQuery)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CodecQuery);

    state->type_CodecSubtypes = py::register_python_type(module.get(), type_name_CodecSubtypes, &type_spec_CodecSubtypes, nullptr);
    if (!state->type_CodecSubtypes)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CodecSubtypes);

    state->type_DataCue = py::register_python_type(module.get(), type_name_DataCue, &type_spec_DataCue, bases.get());
    if (!state->type_DataCue)
    {
        return nullptr;
    }

    Py_INCREF(state->type_DataCue);

    state->type_FaceDetectedEventArgs = py::register_python_type(module.get(), type_name_FaceDetectedEventArgs, &type_spec_FaceDetectedEventArgs, bases.get());
    if (!state->type_FaceDetectedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FaceDetectedEventArgs);

    state->type_FaceDetectionEffect = py::register_python_type(module.get(), type_name_FaceDetectionEffect, &type_spec_FaceDetectionEffect, bases.get());
    if (!state->type_FaceDetectionEffect)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FaceDetectionEffect);

    state->type_FaceDetectionEffectDefinition = py::register_python_type(module.get(), type_name_FaceDetectionEffectDefinition, &type_spec_FaceDetectionEffectDefinition, bases.get());
    if (!state->type_FaceDetectionEffectDefinition)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FaceDetectionEffectDefinition);

    state->type_FaceDetectionEffectFrame = py::register_python_type(module.get(), type_name_FaceDetectionEffectFrame, &type_spec_FaceDetectionEffectFrame, bases.get());
    if (!state->type_FaceDetectionEffectFrame)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FaceDetectionEffectFrame);

    state->type_HighDynamicRangeControl = py::register_python_type(module.get(), type_name_HighDynamicRangeControl, &type_spec_HighDynamicRangeControl, bases.get());
    if (!state->type_HighDynamicRangeControl)
    {
        return nullptr;
    }

    Py_INCREF(state->type_HighDynamicRangeControl);

    state->type_HighDynamicRangeOutput = py::register_python_type(module.get(), type_name_HighDynamicRangeOutput, &type_spec_HighDynamicRangeOutput, bases.get());
    if (!state->type_HighDynamicRangeOutput)
    {
        return nullptr;
    }

    Py_INCREF(state->type_HighDynamicRangeOutput);

    state->type_ImageCue = py::register_python_type(module.get(), type_name_ImageCue, &type_spec_ImageCue, bases.get());
    if (!state->type_ImageCue)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ImageCue);

    state->type_InitializeMediaStreamSourceRequestedEventArgs = py::register_python_type(module.get(), type_name_InitializeMediaStreamSourceRequestedEventArgs, &type_spec_InitializeMediaStreamSourceRequestedEventArgs, bases.get());
    if (!state->type_InitializeMediaStreamSourceRequestedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_InitializeMediaStreamSourceRequestedEventArgs);

    state->type_LowLightFusion = py::register_python_type(module.get(), type_name_LowLightFusion, &type_spec_LowLightFusion, nullptr);
    if (!state->type_LowLightFusion)
    {
        return nullptr;
    }

    Py_INCREF(state->type_LowLightFusion);

    state->type_LowLightFusionResult = py::register_python_type(module.get(), type_name_LowLightFusionResult, &type_spec_LowLightFusionResult, bases.get());
    if (!state->type_LowLightFusionResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_LowLightFusionResult);

    state->type_MediaBinder = py::register_python_type(module.get(), type_name_MediaBinder, &type_spec_MediaBinder, bases.get());
    if (!state->type_MediaBinder)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaBinder);

    state->type_MediaBindingEventArgs = py::register_python_type(module.get(), type_name_MediaBindingEventArgs, &type_spec_MediaBindingEventArgs, bases.get());
    if (!state->type_MediaBindingEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaBindingEventArgs);

    state->type_MediaCueEventArgs = py::register_python_type(module.get(), type_name_MediaCueEventArgs, &type_spec_MediaCueEventArgs, bases.get());
    if (!state->type_MediaCueEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaCueEventArgs);

    state->type_MediaSource = py::register_python_type(module.get(), type_name_MediaSource, &type_spec_MediaSource, bases.get());
    if (!state->type_MediaSource)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaSource);

    state->type_MediaSourceAppServiceConnection = py::register_python_type(module.get(), type_name_MediaSourceAppServiceConnection, &type_spec_MediaSourceAppServiceConnection, bases.get());
    if (!state->type_MediaSourceAppServiceConnection)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaSourceAppServiceConnection);

    state->type_MediaSourceError = py::register_python_type(module.get(), type_name_MediaSourceError, &type_spec_MediaSourceError, bases.get());
    if (!state->type_MediaSourceError)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaSourceError);

    state->type_MediaSourceOpenOperationCompletedEventArgs = py::register_python_type(module.get(), type_name_MediaSourceOpenOperationCompletedEventArgs, &type_spec_MediaSourceOpenOperationCompletedEventArgs, bases.get());
    if (!state->type_MediaSourceOpenOperationCompletedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaSourceOpenOperationCompletedEventArgs);

    state->type_MediaSourceStateChangedEventArgs = py::register_python_type(module.get(), type_name_MediaSourceStateChangedEventArgs, &type_spec_MediaSourceStateChangedEventArgs, bases.get());
    if (!state->type_MediaSourceStateChangedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaSourceStateChangedEventArgs);

    state->type_MediaStreamSample = py::register_python_type(module.get(), type_name_MediaStreamSample, &type_spec_MediaStreamSample, bases.get());
    if (!state->type_MediaStreamSample)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSample);

    state->type_MediaStreamSamplePropertySet = py::register_python_type(module.get(), type_name_MediaStreamSamplePropertySet, &type_spec_MediaStreamSamplePropertySet, mutable_mapping_bases.get());
    if (!state->type_MediaStreamSamplePropertySet)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSamplePropertySet);

    state->type_MediaStreamSampleProtectionProperties = py::register_python_type(module.get(), type_name_MediaStreamSampleProtectionProperties, &type_spec_MediaStreamSampleProtectionProperties, bases.get());
    if (!state->type_MediaStreamSampleProtectionProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSampleProtectionProperties);

    state->type_MediaStreamSource = py::register_python_type(module.get(), type_name_MediaStreamSource, &type_spec_MediaStreamSource, bases.get());
    if (!state->type_MediaStreamSource)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSource);

    state->type_MediaStreamSourceClosedEventArgs = py::register_python_type(module.get(), type_name_MediaStreamSourceClosedEventArgs, &type_spec_MediaStreamSourceClosedEventArgs, bases.get());
    if (!state->type_MediaStreamSourceClosedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSourceClosedEventArgs);

    state->type_MediaStreamSourceClosedRequest = py::register_python_type(module.get(), type_name_MediaStreamSourceClosedRequest, &type_spec_MediaStreamSourceClosedRequest, bases.get());
    if (!state->type_MediaStreamSourceClosedRequest)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSourceClosedRequest);

    state->type_MediaStreamSourceSampleRenderedEventArgs = py::register_python_type(module.get(), type_name_MediaStreamSourceSampleRenderedEventArgs, &type_spec_MediaStreamSourceSampleRenderedEventArgs, bases.get());
    if (!state->type_MediaStreamSourceSampleRenderedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSourceSampleRenderedEventArgs);

    state->type_MediaStreamSourceSampleRequest = py::register_python_type(module.get(), type_name_MediaStreamSourceSampleRequest, &type_spec_MediaStreamSourceSampleRequest, bases.get());
    if (!state->type_MediaStreamSourceSampleRequest)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSourceSampleRequest);

    state->type_MediaStreamSourceSampleRequestDeferral = py::register_python_type(module.get(), type_name_MediaStreamSourceSampleRequestDeferral, &type_spec_MediaStreamSourceSampleRequestDeferral, bases.get());
    if (!state->type_MediaStreamSourceSampleRequestDeferral)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSourceSampleRequestDeferral);

    state->type_MediaStreamSourceSampleRequestedEventArgs = py::register_python_type(module.get(), type_name_MediaStreamSourceSampleRequestedEventArgs, &type_spec_MediaStreamSourceSampleRequestedEventArgs, bases.get());
    if (!state->type_MediaStreamSourceSampleRequestedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSourceSampleRequestedEventArgs);

    state->type_MediaStreamSourceStartingEventArgs = py::register_python_type(module.get(), type_name_MediaStreamSourceStartingEventArgs, &type_spec_MediaStreamSourceStartingEventArgs, bases.get());
    if (!state->type_MediaStreamSourceStartingEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSourceStartingEventArgs);

    state->type_MediaStreamSourceStartingRequest = py::register_python_type(module.get(), type_name_MediaStreamSourceStartingRequest, &type_spec_MediaStreamSourceStartingRequest, bases.get());
    if (!state->type_MediaStreamSourceStartingRequest)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSourceStartingRequest);

    state->type_MediaStreamSourceStartingRequestDeferral = py::register_python_type(module.get(), type_name_MediaStreamSourceStartingRequestDeferral, &type_spec_MediaStreamSourceStartingRequestDeferral, bases.get());
    if (!state->type_MediaStreamSourceStartingRequestDeferral)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSourceStartingRequestDeferral);

    state->type_MediaStreamSourceSwitchStreamsRequest = py::register_python_type(module.get(), type_name_MediaStreamSourceSwitchStreamsRequest, &type_spec_MediaStreamSourceSwitchStreamsRequest, bases.get());
    if (!state->type_MediaStreamSourceSwitchStreamsRequest)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSourceSwitchStreamsRequest);

    state->type_MediaStreamSourceSwitchStreamsRequestDeferral = py::register_python_type(module.get(), type_name_MediaStreamSourceSwitchStreamsRequestDeferral, &type_spec_MediaStreamSourceSwitchStreamsRequestDeferral, bases.get());
    if (!state->type_MediaStreamSourceSwitchStreamsRequestDeferral)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSourceSwitchStreamsRequestDeferral);

    state->type_MediaStreamSourceSwitchStreamsRequestedEventArgs = py::register_python_type(module.get(), type_name_MediaStreamSourceSwitchStreamsRequestedEventArgs, &type_spec_MediaStreamSourceSwitchStreamsRequestedEventArgs, bases.get());
    if (!state->type_MediaStreamSourceSwitchStreamsRequestedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaStreamSourceSwitchStreamsRequestedEventArgs);

    state->type_MseSourceBuffer = py::register_python_type(module.get(), type_name_MseSourceBuffer, &type_spec_MseSourceBuffer, bases.get());
    if (!state->type_MseSourceBuffer)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MseSourceBuffer);

    state->type_MseSourceBufferList = py::register_python_type(module.get(), type_name_MseSourceBufferList, &type_spec_MseSourceBufferList, bases.get());
    if (!state->type_MseSourceBufferList)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MseSourceBufferList);

    state->type_MseStreamSource = py::register_python_type(module.get(), type_name_MseStreamSource, &type_spec_MseStreamSource, bases.get());
    if (!state->type_MseStreamSource)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MseStreamSource);

    state->type_SceneAnalysisEffect = py::register_python_type(module.get(), type_name_SceneAnalysisEffect, &type_spec_SceneAnalysisEffect, bases.get());
    if (!state->type_SceneAnalysisEffect)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SceneAnalysisEffect);

    state->type_SceneAnalysisEffectDefinition = py::register_python_type(module.get(), type_name_SceneAnalysisEffectDefinition, &type_spec_SceneAnalysisEffectDefinition, bases.get());
    if (!state->type_SceneAnalysisEffectDefinition)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SceneAnalysisEffectDefinition);

    state->type_SceneAnalysisEffectFrame = py::register_python_type(module.get(), type_name_SceneAnalysisEffectFrame, &type_spec_SceneAnalysisEffectFrame, bases.get());
    if (!state->type_SceneAnalysisEffectFrame)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SceneAnalysisEffectFrame);

    state->type_SceneAnalyzedEventArgs = py::register_python_type(module.get(), type_name_SceneAnalyzedEventArgs, &type_spec_SceneAnalyzedEventArgs, bases.get());
    if (!state->type_SceneAnalyzedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SceneAnalyzedEventArgs);

    state->type_SpeechCue = py::register_python_type(module.get(), type_name_SpeechCue, &type_spec_SpeechCue, bases.get());
    if (!state->type_SpeechCue)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SpeechCue);

    state->type_TimedMetadataStreamDescriptor = py::register_python_type(module.get(), type_name_TimedMetadataStreamDescriptor, &type_spec_TimedMetadataStreamDescriptor, bases.get());
    if (!state->type_TimedMetadataStreamDescriptor)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedMetadataStreamDescriptor);

    state->type_TimedMetadataTrack = py::register_python_type(module.get(), type_name_TimedMetadataTrack, &type_spec_TimedMetadataTrack, bases.get());
    if (!state->type_TimedMetadataTrack)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedMetadataTrack);

    state->type_TimedMetadataTrackError = py::register_python_type(module.get(), type_name_TimedMetadataTrackError, &type_spec_TimedMetadataTrackError, bases.get());
    if (!state->type_TimedMetadataTrackError)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedMetadataTrackError);

    state->type_TimedMetadataTrackFailedEventArgs = py::register_python_type(module.get(), type_name_TimedMetadataTrackFailedEventArgs, &type_spec_TimedMetadataTrackFailedEventArgs, bases.get());
    if (!state->type_TimedMetadataTrackFailedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedMetadataTrackFailedEventArgs);

    state->type_TimedTextBouten = py::register_python_type(module.get(), type_name_TimedTextBouten, &type_spec_TimedTextBouten, bases.get());
    if (!state->type_TimedTextBouten)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedTextBouten);

    state->type_TimedTextCue = py::register_python_type(module.get(), type_name_TimedTextCue, &type_spec_TimedTextCue, bases.get());
    if (!state->type_TimedTextCue)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedTextCue);

    state->type_TimedTextLine = py::register_python_type(module.get(), type_name_TimedTextLine, &type_spec_TimedTextLine, bases.get());
    if (!state->type_TimedTextLine)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedTextLine);

    state->type_TimedTextRegion = py::register_python_type(module.get(), type_name_TimedTextRegion, &type_spec_TimedTextRegion, bases.get());
    if (!state->type_TimedTextRegion)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedTextRegion);

    state->type_TimedTextRuby = py::register_python_type(module.get(), type_name_TimedTextRuby, &type_spec_TimedTextRuby, bases.get());
    if (!state->type_TimedTextRuby)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedTextRuby);

    state->type_TimedTextSource = py::register_python_type(module.get(), type_name_TimedTextSource, &type_spec_TimedTextSource, bases.get());
    if (!state->type_TimedTextSource)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedTextSource);

    state->type_TimedTextSourceResolveResultEventArgs = py::register_python_type(module.get(), type_name_TimedTextSourceResolveResultEventArgs, &type_spec_TimedTextSourceResolveResultEventArgs, bases.get());
    if (!state->type_TimedTextSourceResolveResultEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedTextSourceResolveResultEventArgs);

    state->type_TimedTextStyle = py::register_python_type(module.get(), type_name_TimedTextStyle, &type_spec_TimedTextStyle, bases.get());
    if (!state->type_TimedTextStyle)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedTextStyle);

    state->type_TimedTextSubformat = py::register_python_type(module.get(), type_name_TimedTextSubformat, &type_spec_TimedTextSubformat, bases.get());
    if (!state->type_TimedTextSubformat)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedTextSubformat);

    state->type_VideoStabilizationEffect = py::register_python_type(module.get(), type_name_VideoStabilizationEffect, &type_spec_VideoStabilizationEffect, bases.get());
    if (!state->type_VideoStabilizationEffect)
    {
        return nullptr;
    }

    Py_INCREF(state->type_VideoStabilizationEffect);

    state->type_VideoStabilizationEffectDefinition = py::register_python_type(module.get(), type_name_VideoStabilizationEffectDefinition, &type_spec_VideoStabilizationEffectDefinition, bases.get());
    if (!state->type_VideoStabilizationEffectDefinition)
    {
        return nullptr;
    }

    Py_INCREF(state->type_VideoStabilizationEffectDefinition);

    state->type_VideoStabilizationEffectEnabledChangedEventArgs = py::register_python_type(module.get(), type_name_VideoStabilizationEffectEnabledChangedEventArgs, &type_spec_VideoStabilizationEffectEnabledChangedEventArgs, bases.get());
    if (!state->type_VideoStabilizationEffectEnabledChangedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_VideoStabilizationEffectEnabledChangedEventArgs);

    state->type_VideoStreamDescriptor = py::register_python_type(module.get(), type_name_VideoStreamDescriptor, &type_spec_VideoStreamDescriptor, bases.get());
    if (!state->type_VideoStreamDescriptor)
    {
        return nullptr;
    }

    Py_INCREF(state->type_VideoStreamDescriptor);

    state->type_VideoTrack = py::register_python_type(module.get(), type_name_VideoTrack, &type_spec_VideoTrack, bases.get());
    if (!state->type_VideoTrack)
    {
        return nullptr;
    }

    Py_INCREF(state->type_VideoTrack);

    state->type_VideoTrackOpenFailedEventArgs = py::register_python_type(module.get(), type_name_VideoTrackOpenFailedEventArgs, &type_spec_VideoTrackOpenFailedEventArgs, bases.get());
    if (!state->type_VideoTrackOpenFailedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_VideoTrackOpenFailedEventArgs);

    state->type_VideoTrackSupportInfo = py::register_python_type(module.get(), type_name_VideoTrackSupportInfo, &type_spec_VideoTrackSupportInfo, bases.get());
    if (!state->type_VideoTrackSupportInfo)
    {
        return nullptr;
    }

    Py_INCREF(state->type_VideoTrackSupportInfo);

    state->type_IMediaCue = py::register_python_type(module.get(), type_name_IMediaCue, &type_spec_IMediaCue, bases.get());
    if (!state->type_IMediaCue)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IMediaCue);

    state->type_IMediaSource = py::register_python_type(module.get(), type_name_IMediaSource, &type_spec_IMediaSource, bases.get());
    if (!state->type_IMediaSource)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IMediaSource);

    state->type_IMediaStreamDescriptor = py::register_python_type(module.get(), type_name_IMediaStreamDescriptor, &type_spec_IMediaStreamDescriptor, bases.get());
    if (!state->type_IMediaStreamDescriptor)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IMediaStreamDescriptor);

    state->type_IMediaStreamDescriptor2 = py::register_python_type(module.get(), type_name_IMediaStreamDescriptor2, &type_spec_IMediaStreamDescriptor2, bases.get());
    if (!state->type_IMediaStreamDescriptor2)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IMediaStreamDescriptor2);

    state->type_IMediaTrack = py::register_python_type(module.get(), type_name_IMediaTrack, &type_spec_IMediaTrack, bases.get());
    if (!state->type_IMediaTrack)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IMediaTrack);

    state->type_ISingleSelectMediaTrackList = py::register_python_type(module.get(), type_name_ISingleSelectMediaTrackList, &type_spec_ISingleSelectMediaTrackList, bases.get());
    if (!state->type_ISingleSelectMediaTrackList)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ISingleSelectMediaTrackList);

    state->type_ITimedMetadataTrackProvider = py::register_python_type(module.get(), type_name_ITimedMetadataTrackProvider, &type_spec_ITimedMetadataTrackProvider, bases.get());
    if (!state->type_ITimedMetadataTrackProvider)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ITimedMetadataTrackProvider);

    state->type_MseTimeRange = py::register_python_type(module.get(), type_name_MseTimeRange, &type_spec_MseTimeRange, bases.get());
    if (!state->type_MseTimeRange)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MseTimeRange);

    state->type_TimedTextDouble = py::register_python_type(module.get(), type_name_TimedTextDouble, &type_spec_TimedTextDouble, bases.get());
    if (!state->type_TimedTextDouble)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedTextDouble);

    state->type_TimedTextPadding = py::register_python_type(module.get(), type_name_TimedTextPadding, &type_spec_TimedTextPadding, bases.get());
    if (!state->type_TimedTextPadding)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedTextPadding);

    state->type_TimedTextPoint = py::register_python_type(module.get(), type_name_TimedTextPoint, &type_spec_TimedTextPoint, bases.get());
    if (!state->type_TimedTextPoint)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedTextPoint);

    state->type_TimedTextSize = py::register_python_type(module.get(), type_name_TimedTextSize, &type_spec_TimedTextSize, bases.get());
    if (!state->type_TimedTextSize)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedTextSize);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Media::Core::AudioDecoderDegradation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioDecoderDegradation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::AudioDecoderDegradation is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::AudioDecoderDegradationReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioDecoderDegradationReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::AudioDecoderDegradationReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::CodecCategory>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CodecCategory;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::CodecCategory is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::CodecKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CodecKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::CodecKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::FaceDetectionMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FaceDetectionMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::FaceDetectionMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::MediaDecoderStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaDecoderStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaDecoderStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::MediaSourceState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaSourceState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaSourceState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::MediaSourceStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaSourceStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaSourceStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::MediaStreamSourceClosedReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSourceClosedReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSourceClosedReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::MediaStreamSourceErrorStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSourceErrorStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSourceErrorStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::MediaTrackKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaTrackKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaTrackKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::MseAppendMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MseAppendMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MseAppendMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::MseEndOfStreamStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MseEndOfStreamStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MseEndOfStreamStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::MseReadyState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MseReadyState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MseReadyState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::SceneAnalysisRecommendation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SceneAnalysisRecommendation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::SceneAnalysisRecommendation is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedMetadataKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedMetadataKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedMetadataKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedMetadataTrackErrorCode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedMetadataTrackErrorCode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedMetadataTrackErrorCode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedTextBoutenPosition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextBoutenPosition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextBoutenPosition is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedTextBoutenType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextBoutenType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextBoutenType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedTextDisplayAlignment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextDisplayAlignment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextDisplayAlignment is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedTextFlowDirection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextFlowDirection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextFlowDirection is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedTextFontStyle>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextFontStyle;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextFontStyle is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedTextLineAlignment>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextLineAlignment;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextLineAlignment is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedTextRubyAlign>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextRubyAlign;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextRubyAlign is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedTextRubyPosition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextRubyPosition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextRubyPosition is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedTextRubyReserve>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextRubyReserve;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextRubyReserve is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedTextScrollMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextScrollMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextScrollMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedTextUnit>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextUnit;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextUnit is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedTextWeight>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextWeight;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextWeight is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedTextWrapping>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextWrapping;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextWrapping is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::TimedTextWritingMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextWritingMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextWritingMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedReason>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoStabilizationEffectEnabledChangedReason;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedReason is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::AudioStreamDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioStreamDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::AudioStreamDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::AudioTrack>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioTrack;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::AudioTrack is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioTrackOpenFailedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::AudioTrackOpenFailedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::AudioTrackSupportInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioTrackSupportInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::AudioTrackSupportInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::ChapterCue>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ChapterCue;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::ChapterCue is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::CodecInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CodecInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::CodecInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::CodecQuery>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CodecQuery;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::CodecQuery is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::CodecSubtypes>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CodecSubtypes;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::CodecSubtypes is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::DataCue>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DataCue;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::DataCue is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::FaceDetectedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FaceDetectedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::FaceDetectedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffect>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FaceDetectionEffect;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::FaceDetectionEffect is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffectDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FaceDetectionEffectDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::FaceDetectionEffectDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::FaceDetectionEffectFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FaceDetectionEffectFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::FaceDetectionEffectFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::HighDynamicRangeControl>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HighDynamicRangeControl;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::HighDynamicRangeControl is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::HighDynamicRangeOutput>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HighDynamicRangeOutput;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::HighDynamicRangeOutput is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::ImageCue>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageCue;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::ImageCue is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_InitializeMediaStreamSourceRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::InitializeMediaStreamSourceRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::LowLightFusion>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LowLightFusion;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::LowLightFusion is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::LowLightFusionResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LowLightFusionResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::LowLightFusionResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaBinder>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaBinder;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaBinder is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaBindingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaBindingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaBindingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaCueEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaCueEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaCueEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSourceAppServiceConnection>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaSourceAppServiceConnection;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaSourceAppServiceConnection is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSourceError>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaSourceError;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaSourceError is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaSourceOpenOperationCompletedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaSourceOpenOperationCompletedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaSourceStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaSourceStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSample>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSample;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSample is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSamplePropertySet>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSamplePropertySet;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSamplePropertySet is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSampleProtectionProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSampleProtectionProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSourceClosedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSourceClosedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceClosedRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSourceClosedRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSourceClosedRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSourceSampleRenderedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSourceSampleRenderedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSourceSampleRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSourceSampleRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSourceSampleRequestDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSourceSampleRequestDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSourceSampleRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSourceSampleRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSourceStartingEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSourceStartingEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSourceStartingRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSourceStartingRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSourceStartingRequestDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSourceStartingRequestDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSourceSwitchStreamsRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSourceSwitchStreamsRequestDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaStreamSourceSwitchStreamsRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MediaStreamSourceSwitchStreamsRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MseSourceBuffer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MseSourceBuffer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MseSourceBuffer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MseSourceBufferList>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MseSourceBufferList;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MseSourceBufferList is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MseStreamSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MseStreamSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MseStreamSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffect>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SceneAnalysisEffect;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::SceneAnalysisEffect is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffectDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SceneAnalysisEffectDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::SceneAnalysisEffectDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SceneAnalysisEffectFrame>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SceneAnalysisEffectFrame;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::SceneAnalysisEffectFrame is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SceneAnalyzedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SceneAnalyzedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::SceneAnalyzedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::SpeechCue>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SpeechCue;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::SpeechCue is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedMetadataStreamDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedMetadataStreamDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrack>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedMetadataTrack;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedMetadataTrack is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrackError>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedMetadataTrackError;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedMetadataTrackError is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedMetadataTrackFailedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedMetadataTrackFailedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextBouten>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextBouten;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextBouten is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextCue>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextCue;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextCue is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextLine>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextLine;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextLine is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextRegion>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextRegion;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextRegion is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextRuby>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextRuby;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextRuby is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextSourceResolveResultEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextSourceResolveResultEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextStyle>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextStyle;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextStyle is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextSubformat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextSubformat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextSubformat is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffect>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoStabilizationEffect;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::VideoStabilizationEffect is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffectDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoStabilizationEffectDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::VideoStabilizationEffectDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoStabilizationEffectEnabledChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::VideoStabilizationEffectEnabledChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoStreamDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoStreamDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::VideoStreamDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoTrack>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoTrack;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::VideoTrack is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoTrackOpenFailedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::VideoTrackOpenFailedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::VideoTrackSupportInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoTrackSupportInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::VideoTrackSupportInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaCue>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMediaCue;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::IMediaCue is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMediaSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::IMediaSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaStreamDescriptor>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMediaStreamDescriptor;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::IMediaStreamDescriptor is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaStreamDescriptor2>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMediaStreamDescriptor2;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::IMediaStreamDescriptor2 is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::IMediaTrack>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMediaTrack;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::IMediaTrack is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::ISingleSelectMediaTrackList>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ISingleSelectMediaTrackList;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::ISingleSelectMediaTrackList is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::ITimedMetadataTrackProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ITimedMetadataTrackProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::ITimedMetadataTrackProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::MseTimeRange>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MseTimeRange;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::MseTimeRange is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextDouble>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextDouble;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextDouble is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextPadding>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextPadding;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextPadding is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextPoint>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextPoint;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextPoint is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::Core::TimedTextSize>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedTextSize;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::Core::TimedTextSize is not registered");
        return nullptr;
    }

    return python_type;
}
