// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.5

#include "pybase.h"
#include "py.Windows.UI.Shell.h"


namespace py::cpp::Windows::UI::Shell
{
    struct module_state
    {
        PyObject* type_SecurityAppKind;
        PyObject* type_SecurityAppState;
        PyObject* type_SecurityAppSubstatus;
        PyObject* type_ShareWindowCommand;
        PyTypeObject* type_AdaptiveCardBuilder;
        PyTypeObject* type_FocusSession;
        PyTypeObject* type_FocusSessionManager;
        PyTypeObject* type_SecurityAppManager;
        PyTypeObject* type_ShareWindowCommandEventArgs;
        PyTypeObject* type_ShareWindowCommandSource;
        PyTypeObject* type_TaskbarManager;
        PyTypeObject* type_IAdaptiveCard;
        PyTypeObject* type_IAdaptiveCardBuilderStatics;
    };

    static PyObject* register_SecurityAppKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SecurityAppKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SecurityAppKind = type;
        Py_INCREF(state->type_SecurityAppKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_SecurityAppState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SecurityAppState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SecurityAppState = type;
        Py_INCREF(state->type_SecurityAppState);


        Py_RETURN_NONE;
    }

    static PyObject* register_SecurityAppSubstatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SecurityAppSubstatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SecurityAppSubstatus = type;
        Py_INCREF(state->type_SecurityAppSubstatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_ShareWindowCommand(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ShareWindowCommand)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ShareWindowCommand = type;
        Py_INCREF(state->type_ShareWindowCommand);


        Py_RETURN_NONE;
    }

    // ----- AdaptiveCardBuilder class --------------------
    constexpr const char* const type_name_AdaptiveCardBuilder = "AdaptiveCardBuilder";

    static PyObject* _new_AdaptiveCardBuilder(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AdaptiveCardBuilder);
        return nullptr;
    }

    static PyObject* AdaptiveCardBuilder_CreateAdaptiveCardFromJson(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::UI::Shell::AdaptiveCardBuilder::CreateAdaptiveCardFromJson(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdaptiveCardBuilder[] = {
        { "create_adaptive_card_from_json", reinterpret_cast<PyCFunction>(AdaptiveCardBuilder_CreateAdaptiveCardFromJson), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdaptiveCardBuilder[] = {
        { }
    };

    static PyType_Slot _type_slots_AdaptiveCardBuilder[] = 
    {
        { Py_tp_new, _new_AdaptiveCardBuilder },
        { Py_tp_methods, _methods_AdaptiveCardBuilder },
        { Py_tp_getset, _getset_AdaptiveCardBuilder },
        { },
    };

    static PyType_Spec type_spec_AdaptiveCardBuilder =
    {
        "_winsdk_Windows_UI_Shell.AdaptiveCardBuilder",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdaptiveCardBuilder
    };

    // ----- FocusSession class --------------------
    constexpr const char* const type_name_FocusSession = "FocusSession";

    static PyObject* _new_FocusSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FocusSession);
        return nullptr;
    }

    static void _dealloc_FocusSession(py::wrapper::Windows::UI::Shell::FocusSession* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusSession_End(py::wrapper::Windows::UI::Shell::FocusSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.End();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSession_get_Id(py::wrapper::Windows::UI::Shell::FocusSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FocusSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::FocusSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusSession[] = {
        { "end", reinterpret_cast<PyCFunction>(FocusSession_End), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FocusSession[] = {
        { "id", reinterpret_cast<getter>(FocusSession_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FocusSession[] = 
    {
        { Py_tp_new, _new_FocusSession },
        { Py_tp_dealloc, _dealloc_FocusSession },
        { Py_tp_methods, _methods_FocusSession },
        { Py_tp_getset, _getset_FocusSession },
        { },
    };

    static PyType_Spec type_spec_FocusSession =
    {
        "_winsdk_Windows_UI_Shell.FocusSession",
        sizeof(py::wrapper::Windows::UI::Shell::FocusSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusSession
    };

    // ----- FocusSessionManager class --------------------
    constexpr const char* const type_name_FocusSessionManager = "FocusSessionManager";

    static PyObject* _new_FocusSessionManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FocusSessionManager);
        return nullptr;
    }

    static void _dealloc_FocusSessionManager(py::wrapper::Windows::UI::Shell::FocusSessionManager* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FocusSessionManager_DeactivateFocus(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.DeactivateFocus();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Shell::FocusSessionManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_GetSession(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetSession(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_TryStartFocusSession(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryStartFocusSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(self->obj.TryStartFocusSession(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_get_IsFocusActive(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsFocusActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_get_IsSupported(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::UI::Shell::FocusSessionManager::IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_add_IsFocusActiveChanged(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::FocusSessionManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsFocusActiveChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusSessionManager_remove_IsFocusActiveChanged(py::wrapper::Windows::UI::Shell::FocusSessionManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsFocusActiveChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FocusSessionManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::FocusSessionManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusSessionManager[] = {
        { "deactivate_focus", reinterpret_cast<PyCFunction>(FocusSessionManager_DeactivateFocus), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(FocusSessionManager_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_session", reinterpret_cast<PyCFunction>(FocusSessionManager_GetSession), METH_VARARGS, nullptr },
        { "try_start_focus_session", reinterpret_cast<PyCFunction>(FocusSessionManager_TryStartFocusSession), METH_VARARGS, nullptr },
        { "get_is_supported", reinterpret_cast<PyCFunction>(FocusSessionManager_get_IsSupported), METH_NOARGS | METH_STATIC, nullptr },
        { "add_is_focus_active_changed", reinterpret_cast<PyCFunction>(FocusSessionManager_add_IsFocusActiveChanged), METH_O, nullptr },
        { "remove_is_focus_active_changed", reinterpret_cast<PyCFunction>(FocusSessionManager_remove_IsFocusActiveChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusSessionManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FocusSessionManager[] = {
        { "is_focus_active", reinterpret_cast<getter>(FocusSessionManager_get_IsFocusActive), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FocusSessionManager[] = 
    {
        { Py_tp_new, _new_FocusSessionManager },
        { Py_tp_dealloc, _dealloc_FocusSessionManager },
        { Py_tp_methods, _methods_FocusSessionManager },
        { Py_tp_getset, _getset_FocusSessionManager },
        { },
    };

    static PyType_Spec type_spec_FocusSessionManager =
    {
        "_winsdk_Windows_UI_Shell.FocusSessionManager",
        sizeof(py::wrapper::Windows::UI::Shell::FocusSessionManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusSessionManager
    };

    // ----- SecurityAppManager class --------------------
    constexpr const char* const type_name_SecurityAppManager = "SecurityAppManager";

    static PyObject* _new_SecurityAppManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Shell::SecurityAppManager instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SecurityAppManager(py::wrapper::Windows::UI::Shell::SecurityAppManager* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SecurityAppManager_Register(py::wrapper::Windows::UI::Shell::SecurityAppManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppKind>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 2);
                auto param3 = py::convert_to<bool>(args, 3);

                return py::convert(self->obj.Register(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecurityAppManager_Unregister(py::wrapper::Windows::UI::Shell::SecurityAppManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppKind>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                self->obj.Unregister(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SecurityAppManager_UpdateState(py::wrapper::Windows::UI::Shell::SecurityAppManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppKind>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppState>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Shell::SecurityAppSubstatus>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 4);

                self->obj.UpdateState(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_SecurityAppManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::SecurityAppManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SecurityAppManager[] = {
        { "register", reinterpret_cast<PyCFunction>(SecurityAppManager_Register), METH_VARARGS, nullptr },
        { "unregister", reinterpret_cast<PyCFunction>(SecurityAppManager_Unregister), METH_VARARGS, nullptr },
        { "update_state", reinterpret_cast<PyCFunction>(SecurityAppManager_UpdateState), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SecurityAppManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SecurityAppManager[] = {
        { }
    };

    static PyType_Slot _type_slots_SecurityAppManager[] = 
    {
        { Py_tp_new, _new_SecurityAppManager },
        { Py_tp_dealloc, _dealloc_SecurityAppManager },
        { Py_tp_methods, _methods_SecurityAppManager },
        { Py_tp_getset, _getset_SecurityAppManager },
        { },
    };

    static PyType_Spec type_spec_SecurityAppManager =
    {
        "_winsdk_Windows_UI_Shell.SecurityAppManager",
        sizeof(py::wrapper::Windows::UI::Shell::SecurityAppManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SecurityAppManager
    };

    // ----- ShareWindowCommandEventArgs class --------------------
    constexpr const char* const type_name_ShareWindowCommandEventArgs = "ShareWindowCommandEventArgs";

    static PyObject* _new_ShareWindowCommandEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ShareWindowCommandEventArgs);
        return nullptr;
    }

    static void _dealloc_ShareWindowCommandEventArgs(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareWindowCommandEventArgs_get_Command(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Command());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ShareWindowCommandEventArgs_put_Command(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Shell::ShareWindowCommand>(arg);

            self->obj.Command(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ShareWindowCommandEventArgs_get_WindowId(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WindowId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ShareWindowCommandEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareWindowCommandEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareWindowCommandEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareWindowCommandEventArgs[] = {
        { "command", reinterpret_cast<getter>(ShareWindowCommandEventArgs_get_Command), reinterpret_cast<setter>(ShareWindowCommandEventArgs_put_Command), nullptr, nullptr },
        { "window_id", reinterpret_cast<getter>(ShareWindowCommandEventArgs_get_WindowId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareWindowCommandEventArgs[] = 
    {
        { Py_tp_new, _new_ShareWindowCommandEventArgs },
        { Py_tp_dealloc, _dealloc_ShareWindowCommandEventArgs },
        { Py_tp_methods, _methods_ShareWindowCommandEventArgs },
        { Py_tp_getset, _getset_ShareWindowCommandEventArgs },
        { },
    };

    static PyType_Spec type_spec_ShareWindowCommandEventArgs =
    {
        "_winsdk_Windows_UI_Shell.ShareWindowCommandEventArgs",
        sizeof(py::wrapper::Windows::UI::Shell::ShareWindowCommandEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareWindowCommandEventArgs
    };

    // ----- ShareWindowCommandSource class --------------------
    constexpr const char* const type_name_ShareWindowCommandSource = "ShareWindowCommandSource";

    static PyObject* _new_ShareWindowCommandSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ShareWindowCommandSource);
        return nullptr;
    }

    static void _dealloc_ShareWindowCommandSource(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareWindowCommandSource_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Shell::ShareWindowCommandSource::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_ReportCommandChanged(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ReportCommandChanged();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_Start(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_Stop(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_add_CommandInvoked(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::ShareWindowCommandSource, winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>>(arg);

            return py::convert(self->obj.CommandInvoked(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_remove_CommandInvoked(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CommandInvoked(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_add_CommandRequested(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::Shell::ShareWindowCommandSource, winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>>(arg);

            return py::convert(self->obj.CommandRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareWindowCommandSource_remove_CommandRequested(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CommandRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ShareWindowCommandSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::ShareWindowCommandSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareWindowCommandSource[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "report_command_changed", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_ReportCommandChanged), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_Stop), METH_VARARGS, nullptr },
        { "add_command_invoked", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_add_CommandInvoked), METH_O, nullptr },
        { "remove_command_invoked", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_remove_CommandInvoked), METH_O, nullptr },
        { "add_command_requested", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_add_CommandRequested), METH_O, nullptr },
        { "remove_command_requested", reinterpret_cast<PyCFunction>(ShareWindowCommandSource_remove_CommandRequested), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareWindowCommandSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareWindowCommandSource[] = {
        { }
    };

    static PyType_Slot _type_slots_ShareWindowCommandSource[] = 
    {
        { Py_tp_new, _new_ShareWindowCommandSource },
        { Py_tp_dealloc, _dealloc_ShareWindowCommandSource },
        { Py_tp_methods, _methods_ShareWindowCommandSource },
        { Py_tp_getset, _getset_ShareWindowCommandSource },
        { },
    };

    static PyType_Spec type_spec_ShareWindowCommandSource =
    {
        "_winsdk_Windows_UI_Shell.ShareWindowCommandSource",
        sizeof(py::wrapper::Windows::UI::Shell::ShareWindowCommandSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareWindowCommandSource
    };

    // ----- TaskbarManager class --------------------
    constexpr const char* const type_name_TaskbarManager = "TaskbarManager";

    static PyObject* _new_TaskbarManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TaskbarManager);
        return nullptr;
    }

    static void _dealloc_TaskbarManager(py::wrapper::Windows::UI::Shell::TaskbarManager* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TaskbarManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Shell::TaskbarManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_IsAppListEntryPinnedAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::AppListEntry>(args, 0);

                return py::convert(self->obj.IsAppListEntryPinnedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_IsCurrentAppPinnedAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.IsCurrentAppPinnedAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_IsSecondaryTilePinnedAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsSecondaryTilePinnedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_RequestPinAppListEntryAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Core::AppListEntry>(args, 0);

                return py::convert(self->obj.RequestPinAppListEntryAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_RequestPinCurrentAppAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestPinCurrentAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_RequestPinSecondaryTileAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::StartScreen::SecondaryTile>(args, 0);

                return py::convert(self->obj.RequestPinSecondaryTileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_TryUnpinSecondaryTileAsync(py::wrapper::Windows::UI::Shell::TaskbarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryUnpinSecondaryTileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_get_IsPinningAllowed(py::wrapper::Windows::UI::Shell::TaskbarManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPinningAllowed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TaskbarManager_get_IsSupported(py::wrapper::Windows::UI::Shell::TaskbarManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TaskbarManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::TaskbarManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TaskbarManager[] = {
        { "get_default", reinterpret_cast<PyCFunction>(TaskbarManager_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "is_app_list_entry_pinned_async", reinterpret_cast<PyCFunction>(TaskbarManager_IsAppListEntryPinnedAsync), METH_VARARGS, nullptr },
        { "is_current_app_pinned_async", reinterpret_cast<PyCFunction>(TaskbarManager_IsCurrentAppPinnedAsync), METH_VARARGS, nullptr },
        { "is_secondary_tile_pinned_async", reinterpret_cast<PyCFunction>(TaskbarManager_IsSecondaryTilePinnedAsync), METH_VARARGS, nullptr },
        { "request_pin_app_list_entry_async", reinterpret_cast<PyCFunction>(TaskbarManager_RequestPinAppListEntryAsync), METH_VARARGS, nullptr },
        { "request_pin_current_app_async", reinterpret_cast<PyCFunction>(TaskbarManager_RequestPinCurrentAppAsync), METH_VARARGS, nullptr },
        { "request_pin_secondary_tile_async", reinterpret_cast<PyCFunction>(TaskbarManager_RequestPinSecondaryTileAsync), METH_VARARGS, nullptr },
        { "try_unpin_secondary_tile_async", reinterpret_cast<PyCFunction>(TaskbarManager_TryUnpinSecondaryTileAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TaskbarManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TaskbarManager[] = {
        { "is_pinning_allowed", reinterpret_cast<getter>(TaskbarManager_get_IsPinningAllowed), nullptr, nullptr, nullptr },
        { "is_supported", reinterpret_cast<getter>(TaskbarManager_get_IsSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TaskbarManager[] = 
    {
        { Py_tp_new, _new_TaskbarManager },
        { Py_tp_dealloc, _dealloc_TaskbarManager },
        { Py_tp_methods, _methods_TaskbarManager },
        { Py_tp_getset, _getset_TaskbarManager },
        { },
    };

    static PyType_Spec type_spec_TaskbarManager =
    {
        "_winsdk_Windows_UI_Shell.TaskbarManager",
        sizeof(py::wrapper::Windows::UI::Shell::TaskbarManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TaskbarManager
    };

    // ----- IAdaptiveCard interface --------------------
    constexpr const char* const type_name_IAdaptiveCard = "IAdaptiveCard";

    static PyObject* _new_IAdaptiveCard(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IAdaptiveCard);
        return nullptr;
    }

    static void _dealloc_IAdaptiveCard(py::wrapper::Windows::UI::Shell::IAdaptiveCard* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAdaptiveCard_ToJson(py::wrapper::Windows::UI::Shell::IAdaptiveCard* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ToJson());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IAdaptiveCard(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::IAdaptiveCard>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAdaptiveCard[] = {
        { "to_json", reinterpret_cast<PyCFunction>(IAdaptiveCard_ToJson), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAdaptiveCard), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAdaptiveCard[] = {
        { }
    };

    static PyType_Slot _type_slots_IAdaptiveCard[] = 
    {
        { Py_tp_new, _new_IAdaptiveCard },
        { Py_tp_dealloc, _dealloc_IAdaptiveCard },
        { Py_tp_methods, _methods_IAdaptiveCard },
        { Py_tp_getset, _getset_IAdaptiveCard },
        { },
    };

    static PyType_Spec type_spec_IAdaptiveCard =
    {
        "_winsdk_Windows_UI_Shell.IAdaptiveCard",
        sizeof(py::wrapper::Windows::UI::Shell::IAdaptiveCard),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAdaptiveCard
    };

    // ----- IAdaptiveCardBuilderStatics interface --------------------
    constexpr const char* const type_name_IAdaptiveCardBuilderStatics = "IAdaptiveCardBuilderStatics";

    static PyObject* _new_IAdaptiveCardBuilderStatics(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IAdaptiveCardBuilderStatics);
        return nullptr;
    }

    static void _dealloc_IAdaptiveCardBuilderStatics(py::wrapper::Windows::UI::Shell::IAdaptiveCardBuilderStatics* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAdaptiveCardBuilderStatics_CreateAdaptiveCardFromJson(py::wrapper::Windows::UI::Shell::IAdaptiveCardBuilderStatics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateAdaptiveCardFromJson(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IAdaptiveCardBuilderStatics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Shell::IAdaptiveCardBuilderStatics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAdaptiveCardBuilderStatics[] = {
        { "create_adaptive_card_from_json", reinterpret_cast<PyCFunction>(IAdaptiveCardBuilderStatics_CreateAdaptiveCardFromJson), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IAdaptiveCardBuilderStatics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAdaptiveCardBuilderStatics[] = {
        { }
    };

    static PyType_Slot _type_slots_IAdaptiveCardBuilderStatics[] = 
    {
        { Py_tp_new, _new_IAdaptiveCardBuilderStatics },
        { Py_tp_dealloc, _dealloc_IAdaptiveCardBuilderStatics },
        { Py_tp_methods, _methods_IAdaptiveCardBuilderStatics },
        { Py_tp_getset, _getset_IAdaptiveCardBuilderStatics },
        { },
    };

    static PyType_Spec type_spec_IAdaptiveCardBuilderStatics =
    {
        "_winsdk_Windows_UI_Shell.IAdaptiveCardBuilderStatics",
        sizeof(py::wrapper::Windows::UI::Shell::IAdaptiveCardBuilderStatics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAdaptiveCardBuilderStatics
    };

    // ----- Windows.UI.Shell Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::Shell");

    static PyMethodDef module_methods[] = {
        {"_register_SecurityAppKind", register_SecurityAppKind, METH_O, "registers type"},
        {"_register_SecurityAppState", register_SecurityAppState, METH_O, "registers type"},
        {"_register_SecurityAppSubstatus", register_SecurityAppSubstatus, METH_O, "registers type"},
        {"_register_ShareWindowCommand", register_ShareWindowCommand, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_SecurityAppKind);
        Py_VISIT(state->type_SecurityAppState);
        Py_VISIT(state->type_SecurityAppSubstatus);
        Py_VISIT(state->type_ShareWindowCommand);
        Py_VISIT(state->type_AdaptiveCardBuilder);
        Py_VISIT(state->type_FocusSession);
        Py_VISIT(state->type_FocusSessionManager);
        Py_VISIT(state->type_SecurityAppManager);
        Py_VISIT(state->type_ShareWindowCommandEventArgs);
        Py_VISIT(state->type_ShareWindowCommandSource);
        Py_VISIT(state->type_TaskbarManager);
        Py_VISIT(state->type_IAdaptiveCard);
        Py_VISIT(state->type_IAdaptiveCardBuilderStatics);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_SecurityAppKind);
        Py_CLEAR(state->type_SecurityAppState);
        Py_CLEAR(state->type_SecurityAppSubstatus);
        Py_CLEAR(state->type_ShareWindowCommand);
        Py_CLEAR(state->type_AdaptiveCardBuilder);
        Py_CLEAR(state->type_FocusSession);
        Py_CLEAR(state->type_FocusSessionManager);
        Py_CLEAR(state->type_SecurityAppManager);
        Py_CLEAR(state->type_ShareWindowCommandEventArgs);
        Py_CLEAR(state->type_ShareWindowCommandSource);
        Py_CLEAR(state->type_TaskbarManager);
        Py_CLEAR(state->type_IAdaptiveCard);
        Py_CLEAR(state->type_IAdaptiveCardBuilderStatics);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_UI_Shell",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::UI::Shell

PyMODINIT_FUNC PyInit__winsdk_Windows_UI_Shell(void) noexcept
{
    using namespace py::cpp::Windows::UI::Shell;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AdaptiveCardBuilder = py::register_python_type(module.get(), type_name_AdaptiveCardBuilder, &type_spec_AdaptiveCardBuilder, nullptr);
    if (!state->type_AdaptiveCardBuilder)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AdaptiveCardBuilder);

    state->type_FocusSession = py::register_python_type(module.get(), type_name_FocusSession, &type_spec_FocusSession, bases.get());
    if (!state->type_FocusSession)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FocusSession);

    state->type_FocusSessionManager = py::register_python_type(module.get(), type_name_FocusSessionManager, &type_spec_FocusSessionManager, bases.get());
    if (!state->type_FocusSessionManager)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FocusSessionManager);

    state->type_SecurityAppManager = py::register_python_type(module.get(), type_name_SecurityAppManager, &type_spec_SecurityAppManager, bases.get());
    if (!state->type_SecurityAppManager)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SecurityAppManager);

    state->type_ShareWindowCommandEventArgs = py::register_python_type(module.get(), type_name_ShareWindowCommandEventArgs, &type_spec_ShareWindowCommandEventArgs, bases.get());
    if (!state->type_ShareWindowCommandEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ShareWindowCommandEventArgs);

    state->type_ShareWindowCommandSource = py::register_python_type(module.get(), type_name_ShareWindowCommandSource, &type_spec_ShareWindowCommandSource, bases.get());
    if (!state->type_ShareWindowCommandSource)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ShareWindowCommandSource);

    state->type_TaskbarManager = py::register_python_type(module.get(), type_name_TaskbarManager, &type_spec_TaskbarManager, bases.get());
    if (!state->type_TaskbarManager)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TaskbarManager);

    state->type_IAdaptiveCard = py::register_python_type(module.get(), type_name_IAdaptiveCard, &type_spec_IAdaptiveCard, bases.get());
    if (!state->type_IAdaptiveCard)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IAdaptiveCard);

    state->type_IAdaptiveCardBuilderStatics = py::register_python_type(module.get(), type_name_IAdaptiveCardBuilderStatics, &type_spec_IAdaptiveCardBuilderStatics, bases.get());
    if (!state->type_IAdaptiveCardBuilderStatics)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IAdaptiveCardBuilderStatics);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::UI::Shell::SecurityAppKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Shell;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Shell");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SecurityAppKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Shell::SecurityAppKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Shell::SecurityAppState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Shell;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Shell");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SecurityAppState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Shell::SecurityAppState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Shell::SecurityAppSubstatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Shell;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Shell");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SecurityAppSubstatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Shell::SecurityAppSubstatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::UI::Shell::ShareWindowCommand>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Shell;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Shell");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ShareWindowCommand;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Shell::ShareWindowCommand is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Shell::AdaptiveCardBuilder>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Shell;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Shell");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AdaptiveCardBuilder;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Shell::AdaptiveCardBuilder is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Shell::FocusSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Shell;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Shell");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FocusSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Shell::FocusSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Shell::FocusSessionManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Shell;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Shell");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FocusSessionManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Shell::FocusSessionManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Shell::SecurityAppManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Shell;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Shell");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SecurityAppManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Shell::SecurityAppManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Shell::ShareWindowCommandEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Shell;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Shell");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ShareWindowCommandEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Shell::ShareWindowCommandEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Shell::ShareWindowCommandSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Shell;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Shell");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ShareWindowCommandSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Shell::ShareWindowCommandSource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Shell::TaskbarManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Shell;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Shell");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TaskbarManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Shell::TaskbarManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Shell::IAdaptiveCard>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Shell;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Shell");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAdaptiveCard;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Shell::IAdaptiveCard is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::Shell::IAdaptiveCardBuilderStatics>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::Shell;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::Shell");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAdaptiveCardBuilderStatics;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::Shell::IAdaptiveCardBuilderStatics is not registered");
        return nullptr;
    }

    return python_type;
}
