// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.3

#include "pybase.h"
#include "py.Windows.ApplicationModel.Chat.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatConversation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatConversationReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageAttachment>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageBlocking>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeTracker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageValidationResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatQueryOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatSearchReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatSyncManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsTransport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsTransportConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Chat::IChatItem>::python_type;

namespace py::cpp::Windows::ApplicationModel::Chat
{
    // ----- ChatCapabilities class --------------------
    constexpr const char* const _type_name_ChatCapabilities = "ChatCapabilities";

    static PyObject* _new_ChatCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatCapabilities);
        return nullptr;
    }

    static void _dealloc_ChatCapabilities(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatCapabilities_get_IsChatCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsChatCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsFileTransferCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsFileTransferCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsGeoLocationPushCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsGeoLocationPushCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsIntegratedMessagingCapable(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsIntegratedMessagingCapable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatCapabilities_get_IsOnline(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOnline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatCapabilities[] = {
        { "is_chat_capable", reinterpret_cast<getter>(ChatCapabilities_get_IsChatCapable), nullptr, nullptr, nullptr },
        { "is_file_transfer_capable", reinterpret_cast<getter>(ChatCapabilities_get_IsFileTransferCapable), nullptr, nullptr, nullptr },
        { "is_geo_location_push_capable", reinterpret_cast<getter>(ChatCapabilities_get_IsGeoLocationPushCapable), nullptr, nullptr, nullptr },
        { "is_integrated_messaging_capable", reinterpret_cast<getter>(ChatCapabilities_get_IsIntegratedMessagingCapable), nullptr, nullptr, nullptr },
        { "is_online", reinterpret_cast<getter>(ChatCapabilities_get_IsOnline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatCapabilities[] = 
    {
        { Py_tp_new, _new_ChatCapabilities },
        { Py_tp_dealloc, _dealloc_ChatCapabilities },
        { Py_tp_methods, _methods_ChatCapabilities },
        { Py_tp_getset, _getset_ChatCapabilities },
        { },
    };

    static PyType_Spec _type_spec_ChatCapabilities =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatCapabilities",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatCapabilities
    };

    // ----- ChatCapabilitiesManager class --------------------
    constexpr const char* const _type_name_ChatCapabilitiesManager = "ChatCapabilitiesManager";

    static PyObject* _new_ChatCapabilitiesManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatCapabilitiesManager);
        return nullptr;
    }

    static PyObject* ChatCapabilitiesManager_GetCachedCapabilitiesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCachedCapabilitiesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCachedCapabilitiesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatCapabilitiesManager_GetCapabilitiesFromNetworkAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCapabilitiesFromNetworkAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager::GetCapabilitiesFromNetworkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatCapabilitiesManager[] = {
        { "get_cached_capabilities_async", reinterpret_cast<PyCFunction>(ChatCapabilitiesManager_GetCachedCapabilitiesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_capabilities_from_network_async", reinterpret_cast<PyCFunction>(ChatCapabilitiesManager_GetCapabilitiesFromNetworkAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatCapabilitiesManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatCapabilitiesManager[] = 
    {
        { Py_tp_new, _new_ChatCapabilitiesManager },
        { Py_tp_methods, _methods_ChatCapabilitiesManager },
        { Py_tp_getset, _getset_ChatCapabilitiesManager },
        { },
    };

    static PyType_Spec _type_spec_ChatCapabilitiesManager =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatCapabilitiesManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatCapabilitiesManager
    };

    // ----- ChatConversation class --------------------
    constexpr const char* const _type_name_ChatConversation = "ChatConversation";

    static PyObject* _new_ChatConversation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatConversation);
        return nullptr;
    }

    static void _dealloc_ChatConversation(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatConversation_DeleteAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_GetMessageReader(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMessageReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_MarkMessagesAsReadAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.MarkMessagesAsReadAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);

                return py::convert(self->obj.MarkMessagesAsReadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_NotifyLocalParticipantComposing(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.NotifyLocalParticipantComposing(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_NotifyRemoteParticipantComposing(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<bool>(args, 2);

                self->obj.NotifyRemoteParticipantComposing(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_SaveAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversation_put_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subject(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversation_get_IsConversationMuted(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsConversationMuted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversation_put_IsConversationMuted(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsConversationMuted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversation_get_HasUnreadMessages(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasUnreadMessages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_Id(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_MostRecentMessageId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MostRecentMessageId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_Participants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Participants());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_ThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ThreadingInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_get_CanModifyParticipants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanModifyParticipants());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversation_put_CanModifyParticipants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanModifyParticipants(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversation_get_ItemKind(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ItemKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_add_RemoteParticipantComposingChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::ChatConversation, winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>>(arg);

            return py::convert(self->obj.RemoteParticipantComposingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatConversation_remove_RemoteParticipantComposingChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RemoteParticipantComposingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatConversation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatConversation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatConversation[] = {
        { "delete_async", reinterpret_cast<PyCFunction>(ChatConversation_DeleteAsync), METH_VARARGS, nullptr },
        { "get_message_reader", reinterpret_cast<PyCFunction>(ChatConversation_GetMessageReader), METH_VARARGS, nullptr },
        { "mark_messages_as_read_async", reinterpret_cast<PyCFunction>(ChatConversation_MarkMessagesAsReadAsync), METH_VARARGS, nullptr },
        { "notify_local_participant_composing", reinterpret_cast<PyCFunction>(ChatConversation_NotifyLocalParticipantComposing), METH_VARARGS, nullptr },
        { "notify_remote_participant_composing", reinterpret_cast<PyCFunction>(ChatConversation_NotifyRemoteParticipantComposing), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(ChatConversation_SaveAsync), METH_VARARGS, nullptr },
        { "add_remote_participant_composing_changed", reinterpret_cast<PyCFunction>(ChatConversation_add_RemoteParticipantComposingChanged), METH_O, nullptr },
        { "remove_remote_participant_composing_changed", reinterpret_cast<PyCFunction>(ChatConversation_remove_RemoteParticipantComposingChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatConversation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatConversation[] = {
        { "subject", reinterpret_cast<getter>(ChatConversation_get_Subject), reinterpret_cast<setter>(ChatConversation_put_Subject), nullptr, nullptr },
        { "is_conversation_muted", reinterpret_cast<getter>(ChatConversation_get_IsConversationMuted), reinterpret_cast<setter>(ChatConversation_put_IsConversationMuted), nullptr, nullptr },
        { "has_unread_messages", reinterpret_cast<getter>(ChatConversation_get_HasUnreadMessages), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ChatConversation_get_Id), nullptr, nullptr, nullptr },
        { "most_recent_message_id", reinterpret_cast<getter>(ChatConversation_get_MostRecentMessageId), nullptr, nullptr, nullptr },
        { "participants", reinterpret_cast<getter>(ChatConversation_get_Participants), nullptr, nullptr, nullptr },
        { "threading_info", reinterpret_cast<getter>(ChatConversation_get_ThreadingInfo), nullptr, nullptr, nullptr },
        { "can_modify_participants", reinterpret_cast<getter>(ChatConversation_get_CanModifyParticipants), reinterpret_cast<setter>(ChatConversation_put_CanModifyParticipants), nullptr, nullptr },
        { "item_kind", reinterpret_cast<getter>(ChatConversation_get_ItemKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatConversation[] = 
    {
        { Py_tp_new, _new_ChatConversation },
        { Py_tp_dealloc, _dealloc_ChatConversation },
        { Py_tp_methods, _methods_ChatConversation },
        { Py_tp_getset, _getset_ChatConversation },
        { },
    };

    static PyType_Spec _type_spec_ChatConversation =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatConversation",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatConversation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatConversation
    };

    // ----- ChatConversationReader class --------------------
    constexpr const char* const _type_name_ChatConversationReader = "ChatConversationReader";

    static PyObject* _new_ChatConversationReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatConversationReader);
        return nullptr;
    }

    static void _dealloc_ChatConversationReader(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatConversationReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.ReadBatchAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ChatConversationReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatConversationReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatConversationReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(ChatConversationReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatConversationReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatConversationReader[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatConversationReader[] = 
    {
        { Py_tp_new, _new_ChatConversationReader },
        { Py_tp_dealloc, _dealloc_ChatConversationReader },
        { Py_tp_methods, _methods_ChatConversationReader },
        { Py_tp_getset, _getset_ChatConversationReader },
        { },
    };

    static PyType_Spec _type_spec_ChatConversationReader =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatConversationReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatConversationReader
    };

    // ----- ChatConversationThreadingInfo class --------------------
    constexpr const char* const _type_name_ChatConversationThreadingInfo = "ChatConversationThreadingInfo";

    static PyObject* _new_ChatConversationThreadingInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatConversationThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatConversationThreadingInfo_get_Kind(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_Kind(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingKind>(arg);

            self->obj.Kind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_Custom(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Custom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_Custom(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Custom(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_ConversationId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConversationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_ConversationId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ConversationId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_ContactId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatConversationThreadingInfo_put_ContactId(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContactId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatConversationThreadingInfo_get_Participants(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Participants());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatConversationThreadingInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatConversationThreadingInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatConversationThreadingInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatConversationThreadingInfo[] = {
        { "kind", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_Kind), reinterpret_cast<setter>(ChatConversationThreadingInfo_put_Kind), nullptr, nullptr },
        { "custom", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_Custom), reinterpret_cast<setter>(ChatConversationThreadingInfo_put_Custom), nullptr, nullptr },
        { "conversation_id", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_ConversationId), reinterpret_cast<setter>(ChatConversationThreadingInfo_put_ConversationId), nullptr, nullptr },
        { "contact_id", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_ContactId), reinterpret_cast<setter>(ChatConversationThreadingInfo_put_ContactId), nullptr, nullptr },
        { "participants", reinterpret_cast<getter>(ChatConversationThreadingInfo_get_Participants), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatConversationThreadingInfo[] = 
    {
        { Py_tp_new, _new_ChatConversationThreadingInfo },
        { Py_tp_dealloc, _dealloc_ChatConversationThreadingInfo },
        { Py_tp_methods, _methods_ChatConversationThreadingInfo },
        { Py_tp_getset, _getset_ChatConversationThreadingInfo },
        { },
    };

    static PyType_Spec _type_spec_ChatConversationThreadingInfo =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatConversationThreadingInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatConversationThreadingInfo
    };

    // ----- ChatMessage class --------------------
    constexpr const char* const _type_name_ChatMessage = "ChatMessage";

    static PyObject* _new_ChatMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessage_get_ItemKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ItemKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_IsIncoming(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsIncoming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsIncoming(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsIncoming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsForwardingDisabled(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsForwardingDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsForwardingDisabled(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsForwardingDisabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_TransportId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TransportId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_From(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.From());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_From(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.From(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_Body(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Body());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_Body(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Body(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_Subject(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subject(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsRead(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsRead(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRead(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_NetworkTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_NetworkTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.NetworkTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_LocalTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalTimestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_LocalTimestamp(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LocalTimestamp(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_RecipientSendStatuses(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecipientSendStatuses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_Recipients(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Recipients());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_TransportFriendlyName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportFriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_Attachments(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Attachments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_Id(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_IsSeen(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSeen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsSeen(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSeen(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_MessageKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_MessageKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageKind>(arg);

            self->obj.MessageKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsReceivedDuringQuietHours(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReceivedDuringQuietHours());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsReceivedDuringQuietHours(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsReceivedDuringQuietHours(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsAutoReply(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAutoReply());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_IsAutoReply(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAutoReply(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_EstimatedDownloadSize(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EstimatedDownloadSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_EstimatedDownloadSize(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.EstimatedDownloadSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_ThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ThreadingInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_ThreadingInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>(arg);

            self->obj.ThreadingInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_ShouldSuppressNotification(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShouldSuppressNotification());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_ShouldSuppressNotification(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShouldSuppressNotification(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_RemoteId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_RemoteId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_MessageOperatorKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageOperatorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_MessageOperatorKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageOperatorKind>(arg);

            self->obj.MessageOperatorKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessage_get_IsReplyDisabled(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReplyDisabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_IsSimMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSimMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_RecipientsDeliveryInfos(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecipientsDeliveryInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessage_get_SyncId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SyncId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessage_put_SyncId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SyncId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ChatMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessage[] = {
        { "item_kind", reinterpret_cast<getter>(ChatMessage_get_ItemKind), nullptr, nullptr, nullptr },
        { "is_incoming", reinterpret_cast<getter>(ChatMessage_get_IsIncoming), reinterpret_cast<setter>(ChatMessage_put_IsIncoming), nullptr, nullptr },
        { "is_forwarding_disabled", reinterpret_cast<getter>(ChatMessage_get_IsForwardingDisabled), reinterpret_cast<setter>(ChatMessage_put_IsForwardingDisabled), nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(ChatMessage_get_TransportId), reinterpret_cast<setter>(ChatMessage_put_TransportId), nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ChatMessage_get_Status), reinterpret_cast<setter>(ChatMessage_put_Status), nullptr, nullptr },
        { "from_", reinterpret_cast<getter>(ChatMessage_get_From), reinterpret_cast<setter>(ChatMessage_put_From), nullptr, nullptr },
        { "body", reinterpret_cast<getter>(ChatMessage_get_Body), reinterpret_cast<setter>(ChatMessage_put_Body), nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(ChatMessage_get_Subject), reinterpret_cast<setter>(ChatMessage_put_Subject), nullptr, nullptr },
        { "is_read", reinterpret_cast<getter>(ChatMessage_get_IsRead), reinterpret_cast<setter>(ChatMessage_put_IsRead), nullptr, nullptr },
        { "network_timestamp", reinterpret_cast<getter>(ChatMessage_get_NetworkTimestamp), reinterpret_cast<setter>(ChatMessage_put_NetworkTimestamp), nullptr, nullptr },
        { "local_timestamp", reinterpret_cast<getter>(ChatMessage_get_LocalTimestamp), reinterpret_cast<setter>(ChatMessage_put_LocalTimestamp), nullptr, nullptr },
        { "recipient_send_statuses", reinterpret_cast<getter>(ChatMessage_get_RecipientSendStatuses), nullptr, nullptr, nullptr },
        { "recipients", reinterpret_cast<getter>(ChatMessage_get_Recipients), nullptr, nullptr, nullptr },
        { "transport_friendly_name", reinterpret_cast<getter>(ChatMessage_get_TransportFriendlyName), nullptr, nullptr, nullptr },
        { "attachments", reinterpret_cast<getter>(ChatMessage_get_Attachments), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ChatMessage_get_Id), nullptr, nullptr, nullptr },
        { "is_seen", reinterpret_cast<getter>(ChatMessage_get_IsSeen), reinterpret_cast<setter>(ChatMessage_put_IsSeen), nullptr, nullptr },
        { "message_kind", reinterpret_cast<getter>(ChatMessage_get_MessageKind), reinterpret_cast<setter>(ChatMessage_put_MessageKind), nullptr, nullptr },
        { "is_received_during_quiet_hours", reinterpret_cast<getter>(ChatMessage_get_IsReceivedDuringQuietHours), reinterpret_cast<setter>(ChatMessage_put_IsReceivedDuringQuietHours), nullptr, nullptr },
        { "is_auto_reply", reinterpret_cast<getter>(ChatMessage_get_IsAutoReply), reinterpret_cast<setter>(ChatMessage_put_IsAutoReply), nullptr, nullptr },
        { "estimated_download_size", reinterpret_cast<getter>(ChatMessage_get_EstimatedDownloadSize), reinterpret_cast<setter>(ChatMessage_put_EstimatedDownloadSize), nullptr, nullptr },
        { "threading_info", reinterpret_cast<getter>(ChatMessage_get_ThreadingInfo), reinterpret_cast<setter>(ChatMessage_put_ThreadingInfo), nullptr, nullptr },
        { "should_suppress_notification", reinterpret_cast<getter>(ChatMessage_get_ShouldSuppressNotification), reinterpret_cast<setter>(ChatMessage_put_ShouldSuppressNotification), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(ChatMessage_get_RemoteId), reinterpret_cast<setter>(ChatMessage_put_RemoteId), nullptr, nullptr },
        { "message_operator_kind", reinterpret_cast<getter>(ChatMessage_get_MessageOperatorKind), reinterpret_cast<setter>(ChatMessage_put_MessageOperatorKind), nullptr, nullptr },
        { "is_reply_disabled", reinterpret_cast<getter>(ChatMessage_get_IsReplyDisabled), nullptr, nullptr, nullptr },
        { "is_sim_message", reinterpret_cast<getter>(ChatMessage_get_IsSimMessage), nullptr, nullptr, nullptr },
        { "recipients_delivery_infos", reinterpret_cast<getter>(ChatMessage_get_RecipientsDeliveryInfos), nullptr, nullptr, nullptr },
        { "sync_id", reinterpret_cast<getter>(ChatMessage_get_SyncId), reinterpret_cast<setter>(ChatMessage_put_SyncId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessage[] = 
    {
        { Py_tp_new, _new_ChatMessage },
        { Py_tp_dealloc, _dealloc_ChatMessage },
        { Py_tp_methods, _methods_ChatMessage },
        { Py_tp_getset, _getset_ChatMessage },
        { },
    };

    static PyType_Spec _type_spec_ChatMessage =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessage",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessage
    };

    // ----- ChatMessageAttachment class --------------------
    constexpr const char* const _type_name_ChatMessageAttachment = "ChatMessageAttachment";

    static PyObject* _new_ChatMessageAttachment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 1);

                winrt::Windows::ApplicationModel::Chat::ChatMessageAttachment instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatMessageAttachment(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageAttachment_get_Text(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_Text(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Text(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_MimeType(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MimeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_MimeType(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.MimeType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_GroupId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GroupId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_GroupId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.GroupId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_DataStreamReference(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataStreamReference());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_DataStreamReference(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.DataStreamReference(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_TransferProgress(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransferProgress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_TransferProgress(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.TransferProgress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_Thumbnail(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_Thumbnail(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatMessageAttachment_get_OriginalFileName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OriginalFileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatMessageAttachment_put_OriginalFileName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OriginalFileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ChatMessageAttachment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageAttachment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageAttachment[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageAttachment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageAttachment[] = {
        { "text", reinterpret_cast<getter>(ChatMessageAttachment_get_Text), reinterpret_cast<setter>(ChatMessageAttachment_put_Text), nullptr, nullptr },
        { "mime_type", reinterpret_cast<getter>(ChatMessageAttachment_get_MimeType), reinterpret_cast<setter>(ChatMessageAttachment_put_MimeType), nullptr, nullptr },
        { "group_id", reinterpret_cast<getter>(ChatMessageAttachment_get_GroupId), reinterpret_cast<setter>(ChatMessageAttachment_put_GroupId), nullptr, nullptr },
        { "data_stream_reference", reinterpret_cast<getter>(ChatMessageAttachment_get_DataStreamReference), reinterpret_cast<setter>(ChatMessageAttachment_put_DataStreamReference), nullptr, nullptr },
        { "transfer_progress", reinterpret_cast<getter>(ChatMessageAttachment_get_TransferProgress), reinterpret_cast<setter>(ChatMessageAttachment_put_TransferProgress), nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(ChatMessageAttachment_get_Thumbnail), reinterpret_cast<setter>(ChatMessageAttachment_put_Thumbnail), nullptr, nullptr },
        { "original_file_name", reinterpret_cast<getter>(ChatMessageAttachment_get_OriginalFileName), reinterpret_cast<setter>(ChatMessageAttachment_put_OriginalFileName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageAttachment[] = 
    {
        { Py_tp_new, _new_ChatMessageAttachment },
        { Py_tp_dealloc, _dealloc_ChatMessageAttachment },
        { Py_tp_methods, _methods_ChatMessageAttachment },
        { Py_tp_getset, _getset_ChatMessageAttachment },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageAttachment =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageAttachment",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageAttachment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageAttachment
    };

    // ----- ChatMessageBlocking class --------------------
    constexpr const char* const _type_name_ChatMessageBlocking = "ChatMessageBlocking";

    static PyObject* _new_ChatMessageBlocking(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageBlocking);
        return nullptr;
    }

    static PyObject* ChatMessageBlocking_MarkMessageAsBlockedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageBlocking::MarkMessageAsBlockedAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageBlocking[] = {
        { "mark_message_as_blocked_async", reinterpret_cast<PyCFunction>(ChatMessageBlocking_MarkMessageAsBlockedAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageBlocking[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageBlocking[] = 
    {
        { Py_tp_new, _new_ChatMessageBlocking },
        { Py_tp_methods, _methods_ChatMessageBlocking },
        { Py_tp_getset, _getset_ChatMessageBlocking },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageBlocking =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageBlocking",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageBlocking
    };

    // ----- ChatMessageChange class --------------------
    constexpr const char* const _type_name_ChatMessageChange = "ChatMessageChange";

    static PyObject* _new_ChatMessageChange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageChange);
        return nullptr;
    }

    static void _dealloc_ChatMessageChange(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageChange_get_ChangeType(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageChange_get_Message(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChange[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageChange[] = {
        { "change_type", reinterpret_cast<getter>(ChatMessageChange_get_ChangeType), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(ChatMessageChange_get_Message), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageChange[] = 
    {
        { Py_tp_new, _new_ChatMessageChange },
        { Py_tp_dealloc, _dealloc_ChatMessageChange },
        { Py_tp_methods, _methods_ChatMessageChange },
        { Py_tp_getset, _getset_ChatMessageChange },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageChange =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageChange",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChange
    };

    // ----- ChatMessageChangeReader class --------------------
    constexpr const char* const _type_name_ChatMessageChangeReader = "ChatMessageChangeReader";

    static PyObject* _new_ChatMessageChangeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageChangeReader);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangeReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageChangeReader_AcceptChanges(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.AcceptChanges();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeReader_AcceptChangesThrough(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>(args, 0);

                self->obj.AcceptChangesThrough(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangeReader[] = {
        { "accept_changes", reinterpret_cast<PyCFunction>(ChatMessageChangeReader_AcceptChanges), METH_VARARGS, nullptr },
        { "accept_changes_through", reinterpret_cast<PyCFunction>(ChatMessageChangeReader_AcceptChangesThrough), METH_VARARGS, nullptr },
        { "read_batch_async", reinterpret_cast<PyCFunction>(ChatMessageChangeReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChangeReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageChangeReader[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageChangeReader[] = 
    {
        { Py_tp_new, _new_ChatMessageChangeReader },
        { Py_tp_dealloc, _dealloc_ChatMessageChangeReader },
        { Py_tp_methods, _methods_ChatMessageChangeReader },
        { Py_tp_getset, _getset_ChatMessageChangeReader },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageChangeReader =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageChangeReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangeReader
    };

    // ----- ChatMessageChangeTracker class --------------------
    constexpr const char* const _type_name_ChatMessageChangeTracker = "ChatMessageChangeTracker";

    static PyObject* _new_ChatMessageChangeTracker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageChangeTracker);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangeTracker(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageChangeTracker_Enable(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeTracker_GetChangeReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetChangeReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageChangeTracker_Reset(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangeTracker[] = {
        { "enable", reinterpret_cast<PyCFunction>(ChatMessageChangeTracker_Enable), METH_VARARGS, nullptr },
        { "get_change_reader", reinterpret_cast<PyCFunction>(ChatMessageChangeTracker_GetChangeReader), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(ChatMessageChangeTracker_Reset), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChangeTracker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageChangeTracker[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageChangeTracker[] = 
    {
        { Py_tp_new, _new_ChatMessageChangeTracker },
        { Py_tp_dealloc, _dealloc_ChatMessageChangeTracker },
        { Py_tp_methods, _methods_ChatMessageChangeTracker },
        { Py_tp_getset, _getset_ChatMessageChangeTracker },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageChangeTracker =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageChangeTracker",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangeTracker
    };

    // ----- ChatMessageChangedDeferral class --------------------
    constexpr const char* const _type_name_ChatMessageChangedDeferral = "ChatMessageChangedDeferral";

    static PyObject* _new_ChatMessageChangedDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageChangedDeferral);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangedDeferral(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageChangedDeferral_Complete(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangedDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(ChatMessageChangedDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChangedDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageChangedDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageChangedDeferral[] = 
    {
        { Py_tp_new, _new_ChatMessageChangedDeferral },
        { Py_tp_dealloc, _dealloc_ChatMessageChangedDeferral },
        { Py_tp_methods, _methods_ChatMessageChangedDeferral },
        { Py_tp_getset, _getset_ChatMessageChangedDeferral },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageChangedDeferral =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageChangedDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangedDeferral
    };

    // ----- ChatMessageChangedEventArgs class --------------------
    constexpr const char* const _type_name_ChatMessageChangedEventArgs = "ChatMessageChangedEventArgs";

    static PyObject* _new_ChatMessageChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ChatMessageChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageChangedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageChangedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ChatMessageChangedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageChangedEventArgs[] = 
    {
        { Py_tp_new, _new_ChatMessageChangedEventArgs },
        { Py_tp_dealloc, _dealloc_ChatMessageChangedEventArgs },
        { Py_tp_methods, _methods_ChatMessageChangedEventArgs },
        { Py_tp_getset, _getset_ChatMessageChangedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageChangedEventArgs
    };

    // ----- ChatMessageManager class --------------------
    constexpr const char* const _type_name_ChatMessageManager = "ChatMessageManager";

    static PyObject* _new_ChatMessageManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageManager);
        return nullptr;
    }

    static PyObject* ChatMessageManager_GetTransportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::GetTransportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_GetTransportsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::GetTransportsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_RegisterTransportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::RegisterTransportAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::RequestStoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_RequestSyncManagerAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::RequestSyncManagerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_ShowComposeSmsMessageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::ChatMessageManager::ShowComposeSmsMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageManager_ShowSmsSettings(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatMessageManager::ShowSmsSettings();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageManager[] = {
        { "get_transport_async", reinterpret_cast<PyCFunction>(ChatMessageManager_GetTransportAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_transports_async", reinterpret_cast<PyCFunction>(ChatMessageManager_GetTransportsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "register_transport_async", reinterpret_cast<PyCFunction>(ChatMessageManager_RegisterTransportAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_store_async", reinterpret_cast<PyCFunction>(ChatMessageManager_RequestStoreAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "request_sync_manager_async", reinterpret_cast<PyCFunction>(ChatMessageManager_RequestSyncManagerAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_compose_sms_message_async", reinterpret_cast<PyCFunction>(ChatMessageManager_ShowComposeSmsMessageAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_sms_settings", reinterpret_cast<PyCFunction>(ChatMessageManager_ShowSmsSettings), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageManager[] = 
    {
        { Py_tp_new, _new_ChatMessageManager },
        { Py_tp_methods, _methods_ChatMessageManager },
        { Py_tp_getset, _getset_ChatMessageManager },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageManager =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageManager
    };

    // ----- ChatMessageNotificationTriggerDetails class --------------------
    constexpr const char* const _type_name_ChatMessageNotificationTriggerDetails = "ChatMessageNotificationTriggerDetails";

    static PyObject* _new_ChatMessageNotificationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_ChatMessageNotificationTriggerDetails(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ChatMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChatMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldDisplayToast(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShouldDisplayToast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldUpdateActionCenter(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShouldUpdateActionCenter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldUpdateBadge(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShouldUpdateBadge());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageNotificationTriggerDetails_get_ShouldUpdateDetailText(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShouldUpdateDetailText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageNotificationTriggerDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageNotificationTriggerDetails[] = {
        { "chat_message", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ChatMessage), nullptr, nullptr, nullptr },
        { "should_display_toast", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ShouldDisplayToast), nullptr, nullptr, nullptr },
        { "should_update_action_center", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ShouldUpdateActionCenter), nullptr, nullptr, nullptr },
        { "should_update_badge", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ShouldUpdateBadge), nullptr, nullptr, nullptr },
        { "should_update_detail_text", reinterpret_cast<getter>(ChatMessageNotificationTriggerDetails_get_ShouldUpdateDetailText), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageNotificationTriggerDetails[] = 
    {
        { Py_tp_new, _new_ChatMessageNotificationTriggerDetails },
        { Py_tp_dealloc, _dealloc_ChatMessageNotificationTriggerDetails },
        { Py_tp_methods, _methods_ChatMessageNotificationTriggerDetails },
        { Py_tp_getset, _getset_ChatMessageNotificationTriggerDetails },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageNotificationTriggerDetails =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageNotificationTriggerDetails
    };

    // ----- ChatMessageReader class --------------------
    constexpr const char* const _type_name_ChatMessageReader = "ChatMessageReader";

    static PyObject* _new_ChatMessageReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageReader);
        return nullptr;
    }

    static void _dealloc_ChatMessageReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.ReadBatchAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(ChatMessageReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageReader[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatMessageReader[] = 
    {
        { Py_tp_new, _new_ChatMessageReader },
        { Py_tp_dealloc, _dealloc_ChatMessageReader },
        { Py_tp_methods, _methods_ChatMessageReader },
        { Py_tp_getset, _getset_ChatMessageReader },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageReader =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageReader
    };

    // ----- ChatMessageStore class --------------------
    constexpr const char* const _type_name_ChatMessageStore = "ChatMessageStore";

    static PyObject* _new_ChatMessageStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageStore);
        return nullptr;
    }

    static void _dealloc_ChatMessageStore(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageStore_DeleteMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_DownloadMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DownloadMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_ForwardMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.ForwardMessageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetConversationAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetConversationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.GetConversationAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetConversationFromThreadingInfoAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>(args, 0);

                return py::convert(self->obj.GetConversationFromThreadingInfoAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetConversationReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConversationReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetConversationReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageByRemoteIdAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetMessageByRemoteIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageBySyncIdAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetMessageBySyncIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetMessageReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMessageReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.GetMessageReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetSearchReader(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatQueryOptions>(args, 0);

                return py::convert(self->obj.GetSearchReader(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_GetUnseenCountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetUnseenCountAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetUnseenCountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_MarkAsSeenAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.MarkAsSeenAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.MarkAsSeenAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_MarkMessageReadAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.MarkMessageReadAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_RetrySendMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RetrySendMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_SaveMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert(self->obj.SaveMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_SendMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert(self->obj.SendMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_TryCancelDownloadMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryCancelDownloadMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_TryCancelSendMessageAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.TryCancelSendMessageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_ValidateMessage(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatMessage>(args, 0);

                return py::convert(self->obj.ValidateMessage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_add_MessageChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::ChatMessageStore, winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>>(arg);

            return py::convert(self->obj.MessageChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_remove_MessageChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_add_StoreChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::ChatMessageStore, winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>>(arg);

            return py::convert(self->obj.StoreChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStore_remove_StoreChanged(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StoreChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageStore[] = {
        { "delete_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_DeleteMessageAsync), METH_VARARGS, nullptr },
        { "download_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_DownloadMessageAsync), METH_VARARGS, nullptr },
        { "forward_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_ForwardMessageAsync), METH_VARARGS, nullptr },
        { "get_conversation_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetConversationAsync), METH_VARARGS, nullptr },
        { "get_conversation_from_threading_info_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetConversationFromThreadingInfoAsync), METH_VARARGS, nullptr },
        { "get_conversation_reader", reinterpret_cast<PyCFunction>(ChatMessageStore_GetConversationReader), METH_VARARGS, nullptr },
        { "get_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetMessageAsync), METH_VARARGS, nullptr },
        { "get_message_by_remote_id_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetMessageByRemoteIdAsync), METH_VARARGS, nullptr },
        { "get_message_by_sync_id_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetMessageBySyncIdAsync), METH_VARARGS, nullptr },
        { "get_message_reader", reinterpret_cast<PyCFunction>(ChatMessageStore_GetMessageReader), METH_VARARGS, nullptr },
        { "get_search_reader", reinterpret_cast<PyCFunction>(ChatMessageStore_GetSearchReader), METH_VARARGS, nullptr },
        { "get_unseen_count_async", reinterpret_cast<PyCFunction>(ChatMessageStore_GetUnseenCountAsync), METH_VARARGS, nullptr },
        { "mark_as_seen_async", reinterpret_cast<PyCFunction>(ChatMessageStore_MarkAsSeenAsync), METH_VARARGS, nullptr },
        { "mark_message_read_async", reinterpret_cast<PyCFunction>(ChatMessageStore_MarkMessageReadAsync), METH_VARARGS, nullptr },
        { "retry_send_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_RetrySendMessageAsync), METH_VARARGS, nullptr },
        { "save_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_SaveMessageAsync), METH_VARARGS, nullptr },
        { "send_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_SendMessageAsync), METH_VARARGS, nullptr },
        { "try_cancel_download_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_TryCancelDownloadMessageAsync), METH_VARARGS, nullptr },
        { "try_cancel_send_message_async", reinterpret_cast<PyCFunction>(ChatMessageStore_TryCancelSendMessageAsync), METH_VARARGS, nullptr },
        { "validate_message", reinterpret_cast<PyCFunction>(ChatMessageStore_ValidateMessage), METH_VARARGS, nullptr },
        { "add_message_changed", reinterpret_cast<PyCFunction>(ChatMessageStore_add_MessageChanged), METH_O, nullptr },
        { "remove_message_changed", reinterpret_cast<PyCFunction>(ChatMessageStore_remove_MessageChanged), METH_O, nullptr },
        { "add_store_changed", reinterpret_cast<PyCFunction>(ChatMessageStore_add_StoreChanged), METH_O, nullptr },
        { "remove_store_changed", reinterpret_cast<PyCFunction>(ChatMessageStore_remove_StoreChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageStore[] = {
        { "change_tracker", reinterpret_cast<getter>(ChatMessageStore_get_ChangeTracker), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageStore[] = 
    {
        { Py_tp_new, _new_ChatMessageStore },
        { Py_tp_dealloc, _dealloc_ChatMessageStore },
        { Py_tp_methods, _methods_ChatMessageStore },
        { Py_tp_getset, _getset_ChatMessageStore },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageStore =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageStore
    };

    // ----- ChatMessageStoreChangedEventArgs class --------------------
    constexpr const char* const _type_name_ChatMessageStoreChangedEventArgs = "ChatMessageStoreChangedEventArgs";

    static PyObject* _new_ChatMessageStoreChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageStoreChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ChatMessageStoreChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageStoreChangedEventArgs_get_Id(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageStoreChangedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageStoreChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageStoreChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageStoreChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageStoreChangedEventArgs[] = {
        { "id", reinterpret_cast<getter>(ChatMessageStoreChangedEventArgs_get_Id), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ChatMessageStoreChangedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageStoreChangedEventArgs[] = 
    {
        { Py_tp_new, _new_ChatMessageStoreChangedEventArgs },
        { Py_tp_dealloc, _dealloc_ChatMessageStoreChangedEventArgs },
        { Py_tp_methods, _methods_ChatMessageStoreChangedEventArgs },
        { Py_tp_getset, _getset_ChatMessageStoreChangedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageStoreChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageStoreChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageStoreChangedEventArgs
    };

    // ----- ChatMessageTransport class --------------------
    constexpr const char* const _type_name_ChatMessageTransport = "ChatMessageTransport";

    static PyObject* _new_ChatMessageTransport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageTransport);
        return nullptr;
    }

    static void _dealloc_ChatMessageTransport(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageTransport_RequestSetAsNotificationProviderAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestSetAsNotificationProviderAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_IsActive(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_IsAppSetAsNotificationProvider(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAppSetAsNotificationProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_TransportFriendlyName(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportFriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_Configuration(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransport_get_TransportKind(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageTransport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageTransport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageTransport[] = {
        { "request_set_as_notification_provider_async", reinterpret_cast<PyCFunction>(ChatMessageTransport_RequestSetAsNotificationProviderAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageTransport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageTransport[] = {
        { "is_active", reinterpret_cast<getter>(ChatMessageTransport_get_IsActive), nullptr, nullptr, nullptr },
        { "is_app_set_as_notification_provider", reinterpret_cast<getter>(ChatMessageTransport_get_IsAppSetAsNotificationProvider), nullptr, nullptr, nullptr },
        { "transport_friendly_name", reinterpret_cast<getter>(ChatMessageTransport_get_TransportFriendlyName), nullptr, nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(ChatMessageTransport_get_TransportId), nullptr, nullptr, nullptr },
        { "configuration", reinterpret_cast<getter>(ChatMessageTransport_get_Configuration), nullptr, nullptr, nullptr },
        { "transport_kind", reinterpret_cast<getter>(ChatMessageTransport_get_TransportKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageTransport[] = 
    {
        { Py_tp_new, _new_ChatMessageTransport },
        { Py_tp_dealloc, _dealloc_ChatMessageTransport },
        { Py_tp_methods, _methods_ChatMessageTransport },
        { Py_tp_getset, _getset_ChatMessageTransport },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageTransport =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageTransport",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageTransport
    };

    // ----- ChatMessageTransportConfiguration class --------------------
    constexpr const char* const _type_name_ChatMessageTransportConfiguration = "ChatMessageTransportConfiguration";

    static PyObject* _new_ChatMessageTransportConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageTransportConfiguration);
        return nullptr;
    }

    static void _dealloc_ChatMessageTransportConfiguration(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageTransportConfiguration_get_ExtendedProperties(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_MaxAttachmentCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxAttachmentCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_MaxMessageSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxMessageSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_MaxRecipientCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxRecipientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageTransportConfiguration_get_SupportedVideoFormat(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedVideoFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageTransportConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageTransportConfiguration[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageTransportConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageTransportConfiguration[] = {
        { "extended_properties", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "max_attachment_count", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_MaxAttachmentCount), nullptr, nullptr, nullptr },
        { "max_message_size_in_kilobytes", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_MaxMessageSizeInKilobytes), nullptr, nullptr, nullptr },
        { "max_recipient_count", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_MaxRecipientCount), nullptr, nullptr, nullptr },
        { "supported_video_format", reinterpret_cast<getter>(ChatMessageTransportConfiguration_get_SupportedVideoFormat), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageTransportConfiguration[] = 
    {
        { Py_tp_new, _new_ChatMessageTransportConfiguration },
        { Py_tp_dealloc, _dealloc_ChatMessageTransportConfiguration },
        { Py_tp_methods, _methods_ChatMessageTransportConfiguration },
        { Py_tp_getset, _getset_ChatMessageTransportConfiguration },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageTransportConfiguration =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageTransportConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageTransportConfiguration
    };

    // ----- ChatMessageValidationResult class --------------------
    constexpr const char* const _type_name_ChatMessageValidationResult = "ChatMessageValidationResult";

    static PyObject* _new_ChatMessageValidationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatMessageValidationResult);
        return nullptr;
    }

    static void _dealloc_ChatMessageValidationResult(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatMessageValidationResult_get_MaxPartCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPartCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageValidationResult_get_PartCount(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PartCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageValidationResult_get_RemainingCharacterCountInPart(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemainingCharacterCountInPart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatMessageValidationResult_get_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatMessageValidationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatMessageValidationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatMessageValidationResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatMessageValidationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatMessageValidationResult[] = {
        { "max_part_count", reinterpret_cast<getter>(ChatMessageValidationResult_get_MaxPartCount), nullptr, nullptr, nullptr },
        { "part_count", reinterpret_cast<getter>(ChatMessageValidationResult_get_PartCount), nullptr, nullptr, nullptr },
        { "remaining_character_count_in_part", reinterpret_cast<getter>(ChatMessageValidationResult_get_RemainingCharacterCountInPart), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ChatMessageValidationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatMessageValidationResult[] = 
    {
        { Py_tp_new, _new_ChatMessageValidationResult },
        { Py_tp_dealloc, _dealloc_ChatMessageValidationResult },
        { Py_tp_methods, _methods_ChatMessageValidationResult },
        { Py_tp_getset, _getset_ChatMessageValidationResult },
        { },
    };

    static PyType_Spec _type_spec_ChatMessageValidationResult =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatMessageValidationResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatMessageValidationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatMessageValidationResult
    };

    // ----- ChatQueryOptions class --------------------
    constexpr const char* const _type_name_ChatQueryOptions = "ChatQueryOptions";

    static PyObject* _new_ChatQueryOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatQueryOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatQueryOptions(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatQueryOptions_get_SearchString(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SearchString());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatQueryOptions_put_SearchString(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SearchString(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ChatQueryOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatQueryOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatQueryOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatQueryOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatQueryOptions[] = {
        { "search_string", reinterpret_cast<getter>(ChatQueryOptions_get_SearchString), reinterpret_cast<setter>(ChatQueryOptions_put_SearchString), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatQueryOptions[] = 
    {
        { Py_tp_new, _new_ChatQueryOptions },
        { Py_tp_dealloc, _dealloc_ChatQueryOptions },
        { Py_tp_methods, _methods_ChatQueryOptions },
        { Py_tp_getset, _getset_ChatQueryOptions },
        { },
    };

    static PyType_Spec _type_spec_ChatQueryOptions =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatQueryOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatQueryOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatQueryOptions
    };

    // ----- ChatRecipientDeliveryInfo class --------------------
    constexpr const char* const _type_name_ChatRecipientDeliveryInfo = "ChatRecipientDeliveryInfo";

    static PyObject* _new_ChatRecipientDeliveryInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ChatRecipientDeliveryInfo(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportAddress(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatRecipientDeliveryInfo_put_TransportAddress(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TransportAddress(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_ReadTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatRecipientDeliveryInfo_put_ReadTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ReadTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_DeliveryTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeliveryTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatRecipientDeliveryInfo_put_DeliveryTime(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.DeliveryTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_IsErrorPermanent(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsErrorPermanent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_Status(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportErrorCode(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportErrorCodeCategory(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportErrorCodeCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ChatRecipientDeliveryInfo_get_TransportInterpretedErrorCode(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportInterpretedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatRecipientDeliveryInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatRecipientDeliveryInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatRecipientDeliveryInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatRecipientDeliveryInfo[] = {
        { "transport_address", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_TransportAddress), reinterpret_cast<setter>(ChatRecipientDeliveryInfo_put_TransportAddress), nullptr, nullptr },
        { "read_time", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_ReadTime), reinterpret_cast<setter>(ChatRecipientDeliveryInfo_put_ReadTime), nullptr, nullptr },
        { "delivery_time", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_DeliveryTime), reinterpret_cast<setter>(ChatRecipientDeliveryInfo_put_DeliveryTime), nullptr, nullptr },
        { "is_error_permanent", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_IsErrorPermanent), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_Status), nullptr, nullptr, nullptr },
        { "transport_error_code", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_TransportErrorCode), nullptr, nullptr, nullptr },
        { "transport_error_code_category", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_TransportErrorCodeCategory), nullptr, nullptr, nullptr },
        { "transport_interpreted_error_code", reinterpret_cast<getter>(ChatRecipientDeliveryInfo_get_TransportInterpretedErrorCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatRecipientDeliveryInfo[] = 
    {
        { Py_tp_new, _new_ChatRecipientDeliveryInfo },
        { Py_tp_dealloc, _dealloc_ChatRecipientDeliveryInfo },
        { Py_tp_methods, _methods_ChatRecipientDeliveryInfo },
        { Py_tp_getset, _getset_ChatRecipientDeliveryInfo },
        { },
    };

    static PyType_Spec _type_spec_ChatRecipientDeliveryInfo =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatRecipientDeliveryInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatRecipientDeliveryInfo
    };

    // ----- ChatSearchReader class --------------------
    constexpr const char* const _type_name_ChatSearchReader = "ChatSearchReader";

    static PyObject* _new_ChatSearchReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatSearchReader);
        return nullptr;
    }

    static void _dealloc_ChatSearchReader(py::wrapper::Windows::ApplicationModel::Chat::ChatSearchReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatSearchReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSearchReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.ReadBatchAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ChatSearchReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatSearchReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatSearchReader[] = {
        { "read_batch_async", reinterpret_cast<PyCFunction>(ChatSearchReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatSearchReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatSearchReader[] = {
        { }
    };

    static PyType_Slot _type_slots_ChatSearchReader[] = 
    {
        { Py_tp_new, _new_ChatSearchReader },
        { Py_tp_dealloc, _dealloc_ChatSearchReader },
        { Py_tp_methods, _methods_ChatSearchReader },
        { Py_tp_getset, _getset_ChatSearchReader },
        { },
    };

    static PyType_Spec _type_spec_ChatSearchReader =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatSearchReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatSearchReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatSearchReader
    };

    // ----- ChatSyncConfiguration class --------------------
    constexpr const char* const _type_name_ChatSyncConfiguration = "ChatSyncConfiguration";

    static PyObject* _new_ChatSyncConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatSyncConfiguration);
        return nullptr;
    }

    static void _dealloc_ChatSyncConfiguration(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatSyncConfiguration_get_RestoreHistorySpan(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RestoreHistorySpan());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatSyncConfiguration_put_RestoreHistorySpan(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatRestoreHistorySpan>(arg);

            self->obj.RestoreHistorySpan(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ChatSyncConfiguration_get_IsSyncEnabled(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSyncEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ChatSyncConfiguration_put_IsSyncEnabled(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSyncEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ChatSyncConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatSyncConfiguration[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatSyncConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatSyncConfiguration[] = {
        { "restore_history_span", reinterpret_cast<getter>(ChatSyncConfiguration_get_RestoreHistorySpan), reinterpret_cast<setter>(ChatSyncConfiguration_put_RestoreHistorySpan), nullptr, nullptr },
        { "is_sync_enabled", reinterpret_cast<getter>(ChatSyncConfiguration_get_IsSyncEnabled), reinterpret_cast<setter>(ChatSyncConfiguration_put_IsSyncEnabled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatSyncConfiguration[] = 
    {
        { Py_tp_new, _new_ChatSyncConfiguration },
        { Py_tp_dealloc, _dealloc_ChatSyncConfiguration },
        { Py_tp_methods, _methods_ChatSyncConfiguration },
        { Py_tp_getset, _getset_ChatSyncConfiguration },
        { },
    };

    static PyType_Spec _type_spec_ChatSyncConfiguration =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatSyncConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatSyncConfiguration
    };

    // ----- ChatSyncManager class --------------------
    constexpr const char* const _type_name_ChatSyncManager = "ChatSyncManager";

    static PyObject* _new_ChatSyncManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ChatSyncManager);
        return nullptr;
    }

    static void _dealloc_ChatSyncManager(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ChatSyncManager_AssociateAccountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::WebAccount>(args, 0);

                return py::convert(self->obj.AssociateAccountAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_IsAccountAssociated(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Security::Credentials::WebAccount>(args, 0);

                return py::convert(self->obj.IsAccountAssociated(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_SetConfigurationAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>(args, 0);

                return py::convert(self->obj.SetConfigurationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_StartSync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.StartSync();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_UnassociateAccountAsync(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.UnassociateAccountAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ChatSyncManager_get_Configuration(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ChatSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::ChatSyncManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ChatSyncManager[] = {
        { "associate_account_async", reinterpret_cast<PyCFunction>(ChatSyncManager_AssociateAccountAsync), METH_VARARGS, nullptr },
        { "is_account_associated", reinterpret_cast<PyCFunction>(ChatSyncManager_IsAccountAssociated), METH_VARARGS, nullptr },
        { "set_configuration_async", reinterpret_cast<PyCFunction>(ChatSyncManager_SetConfigurationAsync), METH_VARARGS, nullptr },
        { "start_sync", reinterpret_cast<PyCFunction>(ChatSyncManager_StartSync), METH_VARARGS, nullptr },
        { "unassociate_account_async", reinterpret_cast<PyCFunction>(ChatSyncManager_UnassociateAccountAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ChatSyncManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ChatSyncManager[] = {
        { "configuration", reinterpret_cast<getter>(ChatSyncManager_get_Configuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ChatSyncManager[] = 
    {
        { Py_tp_new, _new_ChatSyncManager },
        { Py_tp_dealloc, _dealloc_ChatSyncManager },
        { Py_tp_methods, _methods_ChatSyncManager },
        { Py_tp_getset, _getset_ChatSyncManager },
        { },
    };

    static PyType_Spec _type_spec_ChatSyncManager =
    {
        "_winsdk_Windows_ApplicationModel_Chat.ChatSyncManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::ChatSyncManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ChatSyncManager
    };

    // ----- RcsEndUserMessage class --------------------
    constexpr const char* const _type_name_RcsEndUserMessage = "RcsEndUserMessage";

    static PyObject* _new_RcsEndUserMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsEndUserMessage);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessage(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsEndUserMessage_SendResponseAsync(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>(args, 0);

                return py::convert(self->obj.SendResponseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_SendResponseWithPinAsync(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.SendResponseWithPinAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_Actions(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Actions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_IsPinRequired(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPinRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_Text(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_Title(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessage_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsEndUserMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessage[] = {
        { "send_response_async", reinterpret_cast<PyCFunction>(RcsEndUserMessage_SendResponseAsync), METH_VARARGS, nullptr },
        { "send_response_with_pin_async", reinterpret_cast<PyCFunction>(RcsEndUserMessage_SendResponseWithPinAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsEndUserMessage[] = {
        { "actions", reinterpret_cast<getter>(RcsEndUserMessage_get_Actions), nullptr, nullptr, nullptr },
        { "is_pin_required", reinterpret_cast<getter>(RcsEndUserMessage_get_IsPinRequired), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(RcsEndUserMessage_get_Text), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(RcsEndUserMessage_get_Title), nullptr, nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(RcsEndUserMessage_get_TransportId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RcsEndUserMessage[] = 
    {
        { Py_tp_new, _new_RcsEndUserMessage },
        { Py_tp_dealloc, _dealloc_RcsEndUserMessage },
        { Py_tp_methods, _methods_RcsEndUserMessage },
        { Py_tp_getset, _getset_RcsEndUserMessage },
        { },
    };

    static PyType_Spec _type_spec_RcsEndUserMessage =
    {
        "_winsdk_Windows_ApplicationModel_Chat.RcsEndUserMessage",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessage
    };

    // ----- RcsEndUserMessageAction class --------------------
    constexpr const char* const _type_name_RcsEndUserMessageAction = "RcsEndUserMessageAction";

    static PyObject* _new_RcsEndUserMessageAction(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsEndUserMessageAction);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageAction(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAction* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsEndUserMessageAction_get_Label(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsEndUserMessageAction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAction[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessageAction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsEndUserMessageAction[] = {
        { "label", reinterpret_cast<getter>(RcsEndUserMessageAction_get_Label), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageAction[] = 
    {
        { Py_tp_new, _new_RcsEndUserMessageAction },
        { Py_tp_dealloc, _dealloc_RcsEndUserMessageAction },
        { Py_tp_methods, _methods_RcsEndUserMessageAction },
        { Py_tp_getset, _getset_RcsEndUserMessageAction },
        { },
    };

    static PyType_Spec _type_spec_RcsEndUserMessageAction =
    {
        "_winsdk_Windows_ApplicationModel_Chat.RcsEndUserMessageAction",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAction
    };

    // ----- RcsEndUserMessageAvailableEventArgs class --------------------
    constexpr const char* const _type_name_RcsEndUserMessageAvailableEventArgs = "RcsEndUserMessageAvailableEventArgs";

    static PyObject* _new_RcsEndUserMessageAvailableEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsEndUserMessageAvailableEventArgs);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageAvailableEventArgs(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsEndUserMessageAvailableEventArgs_get_IsMessageAvailable(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMessageAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessageAvailableEventArgs_get_Message(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsEndUserMessageAvailableEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAvailableEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessageAvailableEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsEndUserMessageAvailableEventArgs[] = {
        { "is_message_available", reinterpret_cast<getter>(RcsEndUserMessageAvailableEventArgs_get_IsMessageAvailable), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(RcsEndUserMessageAvailableEventArgs_get_Message), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageAvailableEventArgs[] = 
    {
        { Py_tp_new, _new_RcsEndUserMessageAvailableEventArgs },
        { Py_tp_dealloc, _dealloc_RcsEndUserMessageAvailableEventArgs },
        { Py_tp_methods, _methods_RcsEndUserMessageAvailableEventArgs },
        { Py_tp_getset, _getset_RcsEndUserMessageAvailableEventArgs },
        { },
    };

    static PyType_Spec _type_spec_RcsEndUserMessageAvailableEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Chat.RcsEndUserMessageAvailableEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAvailableEventArgs
    };

    // ----- RcsEndUserMessageAvailableTriggerDetails class --------------------
    constexpr const char* const _type_name_RcsEndUserMessageAvailableTriggerDetails = "RcsEndUserMessageAvailableTriggerDetails";

    static PyObject* _new_RcsEndUserMessageAvailableTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsEndUserMessageAvailableTriggerDetails);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageAvailableTriggerDetails(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsEndUserMessageAvailableTriggerDetails_get_Text(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessageAvailableTriggerDetails_get_Title(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsEndUserMessageAvailableTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageAvailableTriggerDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessageAvailableTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsEndUserMessageAvailableTriggerDetails[] = {
        { "text", reinterpret_cast<getter>(RcsEndUserMessageAvailableTriggerDetails_get_Text), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(RcsEndUserMessageAvailableTriggerDetails_get_Title), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageAvailableTriggerDetails[] = 
    {
        { Py_tp_new, _new_RcsEndUserMessageAvailableTriggerDetails },
        { Py_tp_dealloc, _dealloc_RcsEndUserMessageAvailableTriggerDetails },
        { Py_tp_methods, _methods_RcsEndUserMessageAvailableTriggerDetails },
        { Py_tp_getset, _getset_RcsEndUserMessageAvailableTriggerDetails },
        { },
    };

    static PyType_Spec _type_spec_RcsEndUserMessageAvailableTriggerDetails =
    {
        "_winsdk_Windows_ApplicationModel_Chat.RcsEndUserMessageAvailableTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageAvailableTriggerDetails
    };

    // ----- RcsEndUserMessageManager class --------------------
    constexpr const char* const _type_name_RcsEndUserMessageManager = "RcsEndUserMessageManager";

    static PyObject* _new_RcsEndUserMessageManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsEndUserMessageManager);
        return nullptr;
    }

    static void _dealloc_RcsEndUserMessageManager(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsEndUserMessageManager_add_MessageAvailableChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager, winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>>(arg);

            return py::convert(self->obj.MessageAvailableChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsEndUserMessageManager_remove_MessageAvailableChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageAvailableChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsEndUserMessageManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsEndUserMessageManager[] = {
        { "add_message_available_changed", reinterpret_cast<PyCFunction>(RcsEndUserMessageManager_add_MessageAvailableChanged), METH_O, nullptr },
        { "remove_message_available_changed", reinterpret_cast<PyCFunction>(RcsEndUserMessageManager_remove_MessageAvailableChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsEndUserMessageManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsEndUserMessageManager[] = {
        { }
    };

    static PyType_Slot _type_slots_RcsEndUserMessageManager[] = 
    {
        { Py_tp_new, _new_RcsEndUserMessageManager },
        { Py_tp_dealloc, _dealloc_RcsEndUserMessageManager },
        { Py_tp_methods, _methods_RcsEndUserMessageManager },
        { Py_tp_getset, _getset_RcsEndUserMessageManager },
        { },
    };

    static PyType_Spec _type_spec_RcsEndUserMessageManager =
    {
        "_winsdk_Windows_ApplicationModel_Chat.RcsEndUserMessageManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsEndUserMessageManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsEndUserMessageManager
    };

    // ----- RcsManager class --------------------
    constexpr const char* const _type_name_RcsManager = "RcsManager";

    static PyObject* _new_RcsManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsManager);
        return nullptr;
    }

    static PyObject* RcsManager_GetEndUserMessageManager(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::GetEndUserMessageManager());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_GetTransportAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::GetTransportAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_GetTransportsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::GetTransportsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_LeaveConversationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::ChatConversation>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::LeaveConversationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsManager_add_TransportListChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::Chat::RcsManager::TransportListChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsManager_remove_TransportListChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::Chat::RcsManager::TransportListChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsManager[] = {
        { "get_end_user_message_manager", reinterpret_cast<PyCFunction>(RcsManager_GetEndUserMessageManager), METH_VARARGS | METH_STATIC, nullptr },
        { "get_transport_async", reinterpret_cast<PyCFunction>(RcsManager_GetTransportAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_transports_async", reinterpret_cast<PyCFunction>(RcsManager_GetTransportsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "leave_conversation_async", reinterpret_cast<PyCFunction>(RcsManager_LeaveConversationAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_transport_list_changed", reinterpret_cast<PyCFunction>(RcsManager_add_TransportListChanged), METH_O | METH_STATIC, nullptr },
        { "remove_transport_list_changed", reinterpret_cast<PyCFunction>(RcsManager_remove_TransportListChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsManager[] = {
        { }
    };

    static PyType_Slot _type_slots_RcsManager[] = 
    {
        { Py_tp_new, _new_RcsManager },
        { Py_tp_methods, _methods_RcsManager },
        { Py_tp_getset, _getset_RcsManager },
        { },
    };

    static PyType_Spec _type_spec_RcsManager =
    {
        "_winsdk_Windows_ApplicationModel_Chat.RcsManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsManager
    };

    // ----- RcsServiceKindSupportedChangedEventArgs class --------------------
    constexpr const char* const _type_name_RcsServiceKindSupportedChangedEventArgs = "RcsServiceKindSupportedChangedEventArgs";

    static PyObject* _new_RcsServiceKindSupportedChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsServiceKindSupportedChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_RcsServiceKindSupportedChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsServiceKindSupportedChangedEventArgs_get_ServiceKind(py::wrapper::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsServiceKindSupportedChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsServiceKindSupportedChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsServiceKindSupportedChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsServiceKindSupportedChangedEventArgs[] = {
        { "service_kind", reinterpret_cast<getter>(RcsServiceKindSupportedChangedEventArgs_get_ServiceKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RcsServiceKindSupportedChangedEventArgs[] = 
    {
        { Py_tp_new, _new_RcsServiceKindSupportedChangedEventArgs },
        { Py_tp_dealloc, _dealloc_RcsServiceKindSupportedChangedEventArgs },
        { Py_tp_methods, _methods_RcsServiceKindSupportedChangedEventArgs },
        { Py_tp_getset, _getset_RcsServiceKindSupportedChangedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_RcsServiceKindSupportedChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Chat.RcsServiceKindSupportedChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsServiceKindSupportedChangedEventArgs
    };

    // ----- RcsTransport class --------------------
    constexpr const char* const _type_name_RcsTransport = "RcsTransport";

    static PyObject* _new_RcsTransport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsTransport);
        return nullptr;
    }

    static void _dealloc_RcsTransport(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsTransport_IsServiceKindSupported(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsServiceKind>(args, 0);

                return py::convert(self->obj.IsServiceKindSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsTransport_IsStoreAndForwardEnabled(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Chat::RcsServiceKind>(args, 0);

                return py::convert(self->obj.IsStoreAndForwardEnabled(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_Configuration(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_ExtendedProperties(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_IsActive(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_TransportFriendlyName(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportFriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_add_ServiceKindSupportedChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Chat::RcsTransport, winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>>(arg);

            return py::convert(self->obj.ServiceKindSupportedChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransport_remove_ServiceKindSupportedChanged(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServiceKindSupportedChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsTransport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsTransport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsTransport[] = {
        { "is_service_kind_supported", reinterpret_cast<PyCFunction>(RcsTransport_IsServiceKindSupported), METH_VARARGS, nullptr },
        { "is_store_and_forward_enabled", reinterpret_cast<PyCFunction>(RcsTransport_IsStoreAndForwardEnabled), METH_VARARGS, nullptr },
        { "add_service_kind_supported_changed", reinterpret_cast<PyCFunction>(RcsTransport_add_ServiceKindSupportedChanged), METH_O, nullptr },
        { "remove_service_kind_supported_changed", reinterpret_cast<PyCFunction>(RcsTransport_remove_ServiceKindSupportedChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsTransport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsTransport[] = {
        { "configuration", reinterpret_cast<getter>(RcsTransport_get_Configuration), nullptr, nullptr, nullptr },
        { "extended_properties", reinterpret_cast<getter>(RcsTransport_get_ExtendedProperties), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(RcsTransport_get_IsActive), nullptr, nullptr, nullptr },
        { "transport_friendly_name", reinterpret_cast<getter>(RcsTransport_get_TransportFriendlyName), nullptr, nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(RcsTransport_get_TransportId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RcsTransport[] = 
    {
        { Py_tp_new, _new_RcsTransport },
        { Py_tp_dealloc, _dealloc_RcsTransport },
        { Py_tp_methods, _methods_RcsTransport },
        { Py_tp_getset, _getset_RcsTransport },
        { },
    };

    static PyType_Spec _type_spec_RcsTransport =
    {
        "_winsdk_Windows_ApplicationModel_Chat.RcsTransport",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsTransport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsTransport
    };

    // ----- RcsTransportConfiguration class --------------------
    constexpr const char* const _type_name_RcsTransportConfiguration = "RcsTransportConfiguration";

    static PyObject* _new_RcsTransportConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RcsTransportConfiguration);
        return nullptr;
    }

    static void _dealloc_RcsTransportConfiguration(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RcsTransportConfiguration_get_MaxAttachmentCount(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxAttachmentCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxFileSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxFileSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxGroupMessageSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxGroupMessageSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxMessageSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxMessageSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_MaxRecipientCount(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxRecipientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RcsTransportConfiguration_get_WarningFileSizeInKilobytes(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WarningFileSizeInKilobytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RcsTransportConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RcsTransportConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RcsTransportConfiguration[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_RcsTransportConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RcsTransportConfiguration[] = {
        { "max_attachment_count", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxAttachmentCount), nullptr, nullptr, nullptr },
        { "max_file_size_in_kilobytes", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxFileSizeInKilobytes), nullptr, nullptr, nullptr },
        { "max_group_message_size_in_kilobytes", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxGroupMessageSizeInKilobytes), nullptr, nullptr, nullptr },
        { "max_message_size_in_kilobytes", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxMessageSizeInKilobytes), nullptr, nullptr, nullptr },
        { "max_recipient_count", reinterpret_cast<getter>(RcsTransportConfiguration_get_MaxRecipientCount), nullptr, nullptr, nullptr },
        { "warning_file_size_in_kilobytes", reinterpret_cast<getter>(RcsTransportConfiguration_get_WarningFileSizeInKilobytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RcsTransportConfiguration[] = 
    {
        { Py_tp_new, _new_RcsTransportConfiguration },
        { Py_tp_dealloc, _dealloc_RcsTransportConfiguration },
        { Py_tp_methods, _methods_RcsTransportConfiguration },
        { Py_tp_getset, _getset_RcsTransportConfiguration },
        { },
    };

    static PyType_Spec _type_spec_RcsTransportConfiguration =
    {
        "_winsdk_Windows_ApplicationModel_Chat.RcsTransportConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RcsTransportConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RcsTransportConfiguration
    };

    // ----- RemoteParticipantComposingChangedEventArgs class --------------------
    constexpr const char* const _type_name_RemoteParticipantComposingChangedEventArgs = "RemoteParticipantComposingChangedEventArgs";

    static PyObject* _new_RemoteParticipantComposingChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RemoteParticipantComposingChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteParticipantComposingChangedEventArgs(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RemoteParticipantComposingChangedEventArgs_get_IsComposing(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComposing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteParticipantComposingChangedEventArgs_get_ParticipantAddress(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ParticipantAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteParticipantComposingChangedEventArgs_get_TransportId(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RemoteParticipantComposingChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteParticipantComposingChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteParticipantComposingChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteParticipantComposingChangedEventArgs[] = {
        { "is_composing", reinterpret_cast<getter>(RemoteParticipantComposingChangedEventArgs_get_IsComposing), nullptr, nullptr, nullptr },
        { "participant_address", reinterpret_cast<getter>(RemoteParticipantComposingChangedEventArgs_get_ParticipantAddress), nullptr, nullptr, nullptr },
        { "transport_id", reinterpret_cast<getter>(RemoteParticipantComposingChangedEventArgs_get_TransportId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteParticipantComposingChangedEventArgs[] = 
    {
        { Py_tp_new, _new_RemoteParticipantComposingChangedEventArgs },
        { Py_tp_dealloc, _dealloc_RemoteParticipantComposingChangedEventArgs },
        { Py_tp_methods, _methods_RemoteParticipantComposingChangedEventArgs },
        { Py_tp_getset, _getset_RemoteParticipantComposingChangedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_RemoteParticipantComposingChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Chat.RemoteParticipantComposingChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteParticipantComposingChangedEventArgs
    };

    // ----- IChatItem interface --------------------
    constexpr const char* const _type_name_IChatItem = "IChatItem";

    static PyObject* _new_IChatItem(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IChatItem);
        return nullptr;
    }

    static void _dealloc_IChatItem(py::wrapper::Windows::ApplicationModel::Chat::IChatItem* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IChatItem_get_ItemKind(py::wrapper::Windows::ApplicationModel::Chat::IChatItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ItemKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IChatItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Chat::IChatItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IChatItem[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IChatItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IChatItem[] = {
        { "item_kind", reinterpret_cast<getter>(IChatItem_get_ItemKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IChatItem[] = 
    {
        { Py_tp_new, _new_IChatItem },
        { Py_tp_dealloc, _dealloc_IChatItem },
        { Py_tp_methods, _methods_IChatItem },
        { Py_tp_getset, _getset_IChatItem },
        { },
    };

    static PyType_Spec _type_spec_IChatItem =
    {
        "_winsdk_Windows_ApplicationModel_Chat.IChatItem",
        sizeof(py::wrapper::Windows::ApplicationModel::Chat::IChatItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IChatItem
    };

    // ----- Windows.ApplicationModel.Chat Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilities>::python_type = py::register_python_type(module, _type_name_ChatCapabilities, &_type_spec_ChatCapabilities, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatCapabilitiesManager>::python_type = py::register_python_type(module, _type_name_ChatCapabilitiesManager, &_type_spec_ChatCapabilitiesManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatConversation>::python_type = py::register_python_type(module, _type_name_ChatConversation, &_type_spec_ChatConversation, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatConversationReader>::python_type = py::register_python_type(module, _type_name_ChatConversationReader, &_type_spec_ChatConversationReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatConversationThreadingInfo>::python_type = py::register_python_type(module, _type_name_ChatConversationThreadingInfo, &_type_spec_ChatConversationThreadingInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessage>::python_type = py::register_python_type(module, _type_name_ChatMessage, &_type_spec_ChatMessage, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageAttachment>::python_type = py::register_python_type(module, _type_name_ChatMessageAttachment, &_type_spec_ChatMessageAttachment, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageBlocking>::python_type = py::register_python_type(module, _type_name_ChatMessageBlocking, &_type_spec_ChatMessageBlocking, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChange>::python_type = py::register_python_type(module, _type_name_ChatMessageChange, &_type_spec_ChatMessageChange, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeReader>::python_type = py::register_python_type(module, _type_name_ChatMessageChangeReader, &_type_spec_ChatMessageChangeReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangeTracker>::python_type = py::register_python_type(module, _type_name_ChatMessageChangeTracker, &_type_spec_ChatMessageChangeTracker, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedDeferral>::python_type = py::register_python_type(module, _type_name_ChatMessageChangedDeferral, &_type_spec_ChatMessageChangedDeferral, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageChangedEventArgs>::python_type = py::register_python_type(module, _type_name_ChatMessageChangedEventArgs, &_type_spec_ChatMessageChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageManager>::python_type = py::register_python_type(module, _type_name_ChatMessageManager, &_type_spec_ChatMessageManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageNotificationTriggerDetails>::python_type = py::register_python_type(module, _type_name_ChatMessageNotificationTriggerDetails, &_type_spec_ChatMessageNotificationTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageReader>::python_type = py::register_python_type(module, _type_name_ChatMessageReader, &_type_spec_ChatMessageReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStore>::python_type = py::register_python_type(module, _type_name_ChatMessageStore, &_type_spec_ChatMessageStore, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageStoreChangedEventArgs>::python_type = py::register_python_type(module, _type_name_ChatMessageStoreChangedEventArgs, &_type_spec_ChatMessageStoreChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransport>::python_type = py::register_python_type(module, _type_name_ChatMessageTransport, &_type_spec_ChatMessageTransport, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageTransportConfiguration>::python_type = py::register_python_type(module, _type_name_ChatMessageTransportConfiguration, &_type_spec_ChatMessageTransportConfiguration, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatMessageValidationResult>::python_type = py::register_python_type(module, _type_name_ChatMessageValidationResult, &_type_spec_ChatMessageValidationResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatQueryOptions>::python_type = py::register_python_type(module, _type_name_ChatQueryOptions, &_type_spec_ChatQueryOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatRecipientDeliveryInfo>::python_type = py::register_python_type(module, _type_name_ChatRecipientDeliveryInfo, &_type_spec_ChatRecipientDeliveryInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatSearchReader>::python_type = py::register_python_type(module, _type_name_ChatSearchReader, &_type_spec_ChatSearchReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatSyncConfiguration>::python_type = py::register_python_type(module, _type_name_ChatSyncConfiguration, &_type_spec_ChatSyncConfiguration, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::ChatSyncManager>::python_type = py::register_python_type(module, _type_name_ChatSyncManager, &_type_spec_ChatSyncManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessage>::python_type = py::register_python_type(module, _type_name_RcsEndUserMessage, &_type_spec_RcsEndUserMessage, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAction>::python_type = py::register_python_type(module, _type_name_RcsEndUserMessageAction, &_type_spec_RcsEndUserMessageAction, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableEventArgs>::python_type = py::register_python_type(module, _type_name_RcsEndUserMessageAvailableEventArgs, &_type_spec_RcsEndUserMessageAvailableEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageAvailableTriggerDetails>::python_type = py::register_python_type(module, _type_name_RcsEndUserMessageAvailableTriggerDetails, &_type_spec_RcsEndUserMessageAvailableTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsEndUserMessageManager>::python_type = py::register_python_type(module, _type_name_RcsEndUserMessageManager, &_type_spec_RcsEndUserMessageManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsManager>::python_type = py::register_python_type(module, _type_name_RcsManager, &_type_spec_RcsManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsServiceKindSupportedChangedEventArgs>::python_type = py::register_python_type(module, _type_name_RcsServiceKindSupportedChangedEventArgs, &_type_spec_RcsServiceKindSupportedChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsTransport>::python_type = py::register_python_type(module, _type_name_RcsTransport, &_type_spec_RcsTransport, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RcsTransportConfiguration>::python_type = py::register_python_type(module, _type_name_RcsTransportConfiguration, &_type_spec_RcsTransportConfiguration, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::RemoteParticipantComposingChangedEventArgs>::python_type = py::register_python_type(module, _type_name_RemoteParticipantComposingChangedEventArgs, &_type_spec_RemoteParticipantComposingChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Chat::IChatItem>::python_type = py::register_python_type(module, _type_name_IChatItem, &_type_spec_IChatItem, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Chat");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_Chat",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::ApplicationModel::Chat

PyMODINIT_FUNC
PyInit__winsdk_Windows_ApplicationModel_Chat (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::Chat::module_def);
}
