// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.2

#include "pybase.h"
#include "py.Windows.Networking.Sockets.h"

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ControlChannelTrigger>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocket>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocket>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocket>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocketControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocketInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerStreamWebSocket>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::ServerStreamWebSocketInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityContext>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::SocketError>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocket>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListener>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocket>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocketControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocketInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketError>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketKeepAlive>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IControlChannelTriggerEventDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocket>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketControl2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketInformation2>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::BandwidthStatistics>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>::python_type;

PyObject* py::converter<winrt::Windows::Networking::Sockets::BandwidthStatistics>::convert(winrt::Windows::Networking::Sockets::BandwidthStatistics instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Networking::Sockets::BandwidthStatistics>());
}
winrt::Windows::Networking::Sockets::BandwidthStatistics py::converter<winrt::Windows::Networking::Sockets::BandwidthStatistics>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Networking::Sockets::BandwidthStatistics>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::Sockets::BandwidthStatistics>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Networking::Sockets::BandwidthStatistics return_value{};

    PyObject* py_OutboundBitsPerSecond = PyDict_GetItemString(obj, "outbound_bits_per_second");
    if (!py_OutboundBitsPerSecond) { throw winrt::hresult_invalid_argument(); }
    return_value.OutboundBitsPerSecond = converter<uint64_t>::convert_to(py_OutboundBitsPerSecond);

    PyObject* py_InboundBitsPerSecond = PyDict_GetItemString(obj, "inbound_bits_per_second");
    if (!py_InboundBitsPerSecond) { throw winrt::hresult_invalid_argument(); }
    return_value.InboundBitsPerSecond = converter<uint64_t>::convert_to(py_InboundBitsPerSecond);

    PyObject* py_OutboundBitsPerSecondInstability = PyDict_GetItemString(obj, "outbound_bits_per_second_instability");
    if (!py_OutboundBitsPerSecondInstability) { throw winrt::hresult_invalid_argument(); }
    return_value.OutboundBitsPerSecondInstability = converter<uint64_t>::convert_to(py_OutboundBitsPerSecondInstability);

    PyObject* py_InboundBitsPerSecondInstability = PyDict_GetItemString(obj, "inbound_bits_per_second_instability");
    if (!py_InboundBitsPerSecondInstability) { throw winrt::hresult_invalid_argument(); }
    return_value.InboundBitsPerSecondInstability = converter<uint64_t>::convert_to(py_InboundBitsPerSecondInstability);

    PyObject* py_OutboundBandwidthPeaked = PyDict_GetItemString(obj, "outbound_bandwidth_peaked");
    if (!py_OutboundBandwidthPeaked) { throw winrt::hresult_invalid_argument(); }
    return_value.OutboundBandwidthPeaked = converter<bool>::convert_to(py_OutboundBandwidthPeaked);

    PyObject* py_InboundBandwidthPeaked = PyDict_GetItemString(obj, "inbound_bandwidth_peaked");
    if (!py_InboundBandwidthPeaked) { throw winrt::hresult_invalid_argument(); }
    return_value.InboundBandwidthPeaked = converter<bool>::convert_to(py_InboundBandwidthPeaked);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>::convert(winrt::Windows::Networking::Sockets::RoundTripTimeStatistics instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>());
}
winrt::Windows::Networking::Sockets::RoundTripTimeStatistics py::converter<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Networking::Sockets::RoundTripTimeStatistics return_value{};

    PyObject* py_Variance = PyDict_GetItemString(obj, "variance");
    if (!py_Variance) { throw winrt::hresult_invalid_argument(); }
    return_value.Variance = converter<uint32_t>::convert_to(py_Variance);

    PyObject* py_Max = PyDict_GetItemString(obj, "max");
    if (!py_Max) { throw winrt::hresult_invalid_argument(); }
    return_value.Max = converter<uint32_t>::convert_to(py_Max);

    PyObject* py_Min = PyDict_GetItemString(obj, "min");
    if (!py_Min) { throw winrt::hresult_invalid_argument(); }
    return_value.Min = converter<uint32_t>::convert_to(py_Min);

    PyObject* py_Sum = PyDict_GetItemString(obj, "sum");
    if (!py_Sum) { throw winrt::hresult_invalid_argument(); }
    return_value.Sum = converter<uint32_t>::convert_to(py_Sum);

    return return_value;
}

namespace py::cpp::Windows::Networking::Sockets
{
    // ----- ControlChannelTrigger class --------------------
    constexpr const char* const _type_name_ControlChannelTrigger = "ControlChannelTrigger";

    static PyObject* _new_ControlChannelTrigger(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                winrt::Windows::Networking::Sockets::ControlChannelTrigger instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Sockets::ControlChannelTriggerResourceType>(args, 2);

                winrt::Windows::Networking::Sockets::ControlChannelTrigger instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ControlChannelTrigger_Close(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_DecreaseNetworkKeepAliveInterval(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.DecreaseNetworkKeepAliveInterval();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_FlushTransport(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.FlushTransport();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_UsingTransport(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.UsingTransport(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_WaitForPushEnabled(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.WaitForPushEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_ServerKeepAliveIntervalInMinutes(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerKeepAliveIntervalInMinutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ControlChannelTrigger_put_ServerKeepAliveIntervalInMinutes(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ServerKeepAliveIntervalInMinutes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ControlChannelTrigger_get_ControlChannelTriggerId(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ControlChannelTriggerId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_CurrentKeepAliveIntervalInMinutes(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentKeepAliveIntervalInMinutes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_KeepAliveTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeepAliveTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_PushNotificationTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PushNotificationTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_TransportObject(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransportObject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ControlChannelTrigger_get_IsWakeFromLowPowerSupported(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWakeFromLowPowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ControlChannelTrigger(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ControlChannelTrigger>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ControlChannelTrigger[] = {
        { "close", reinterpret_cast<PyCFunction>(ControlChannelTrigger_Close), METH_VARARGS, nullptr },
        { "decrease_network_keep_alive_interval", reinterpret_cast<PyCFunction>(ControlChannelTrigger_DecreaseNetworkKeepAliveInterval), METH_VARARGS, nullptr },
        { "flush_transport", reinterpret_cast<PyCFunction>(ControlChannelTrigger_FlushTransport), METH_VARARGS, nullptr },
        { "using_transport", reinterpret_cast<PyCFunction>(ControlChannelTrigger_UsingTransport), METH_VARARGS, nullptr },
        { "wait_for_push_enabled", reinterpret_cast<PyCFunction>(ControlChannelTrigger_WaitForPushEnabled), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ControlChannelTrigger), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ControlChannelTrigger), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ControlChannelTrigger), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ControlChannelTrigger[] = {
        { "server_keep_alive_interval_in_minutes", reinterpret_cast<getter>(ControlChannelTrigger_get_ServerKeepAliveIntervalInMinutes), reinterpret_cast<setter>(ControlChannelTrigger_put_ServerKeepAliveIntervalInMinutes), nullptr, nullptr },
        { "control_channel_trigger_id", reinterpret_cast<getter>(ControlChannelTrigger_get_ControlChannelTriggerId), nullptr, nullptr, nullptr },
        { "current_keep_alive_interval_in_minutes", reinterpret_cast<getter>(ControlChannelTrigger_get_CurrentKeepAliveIntervalInMinutes), nullptr, nullptr, nullptr },
        { "keep_alive_trigger", reinterpret_cast<getter>(ControlChannelTrigger_get_KeepAliveTrigger), nullptr, nullptr, nullptr },
        { "push_notification_trigger", reinterpret_cast<getter>(ControlChannelTrigger_get_PushNotificationTrigger), nullptr, nullptr, nullptr },
        { "transport_object", reinterpret_cast<getter>(ControlChannelTrigger_get_TransportObject), nullptr, nullptr, nullptr },
        { "is_wake_from_low_power_supported", reinterpret_cast<getter>(ControlChannelTrigger_get_IsWakeFromLowPowerSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ControlChannelTrigger[] = 
    {
        { Py_tp_new, _new_ControlChannelTrigger },
        { Py_tp_dealloc, _dealloc_ControlChannelTrigger },
        { Py_tp_methods, _methods_ControlChannelTrigger },
        { Py_tp_getset, _getset_ControlChannelTrigger },
        { },
    };

    static PyType_Spec _type_spec_ControlChannelTrigger =
    {
        "_winsdk_Windows_Networking_Sockets.ControlChannelTrigger",
        sizeof(py::wrapper::Windows::Networking::Sockets::ControlChannelTrigger),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ControlChannelTrigger
    };

    // ----- DatagramSocket class --------------------
    constexpr const char* const _type_name_DatagramSocket = "DatagramSocket";

    static PyObject* _new_DatagramSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::DatagramSocket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DatagramSocket(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DatagramSocket_BindEndpointAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.BindEndpointAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_BindServiceNameAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.BindServiceNameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 1);

                return py::convert(self->obj.BindServiceNameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_CancelIOAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CancelIOAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_Close(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::EndpointPair>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.ConnectAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_EnableTransferOwnership(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.EnableTransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityConnectedStandbyAction>(args, 1);

                self->obj.EnableTransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_GetEndpointPairsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Networking::Sockets::DatagramSocket::GetEndpointPairsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::HostNameSortOptions>(args, 2);

                return py::convert(winrt::Windows::Networking::Sockets::DatagramSocket::GetEndpointPairsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_GetOutputStreamAsync(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::EndpointPair>(args, 0);

                return py::convert(self->obj.GetOutputStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetOutputStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_JoinMulticastGroup(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);

                self->obj.JoinMulticastGroup(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_TransferOwnership(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);

                self->obj.TransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                self->obj.TransferOwnership(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_get_Control(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_get_Information(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_add_MessageReceived(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::DatagramSocket, winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocket_remove_MessageReceived(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DatagramSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DatagramSocket(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_DatagramSocket(py::wrapper::Windows::Networking::Sockets::DatagramSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocket[] = {
        { "bind_endpoint_async", reinterpret_cast<PyCFunction>(DatagramSocket_BindEndpointAsync), METH_VARARGS, nullptr },
        { "bind_service_name_async", reinterpret_cast<PyCFunction>(DatagramSocket_BindServiceNameAsync), METH_VARARGS, nullptr },
        { "cancel_i_o_async", reinterpret_cast<PyCFunction>(DatagramSocket_CancelIOAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(DatagramSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(DatagramSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "enable_transfer_ownership", reinterpret_cast<PyCFunction>(DatagramSocket_EnableTransferOwnership), METH_VARARGS, nullptr },
        { "get_endpoint_pairs_async", reinterpret_cast<PyCFunction>(DatagramSocket_GetEndpointPairsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_output_stream_async", reinterpret_cast<PyCFunction>(DatagramSocket_GetOutputStreamAsync), METH_VARARGS, nullptr },
        { "join_multicast_group", reinterpret_cast<PyCFunction>(DatagramSocket_JoinMulticastGroup), METH_VARARGS, nullptr },
        { "transfer_ownership", reinterpret_cast<PyCFunction>(DatagramSocket_TransferOwnership), METH_VARARGS, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(DatagramSocket_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(DatagramSocket_remove_MessageReceived), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatagramSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DatagramSocket), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_DatagramSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatagramSocket[] = {
        { "control", reinterpret_cast<getter>(DatagramSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(DatagramSocket_get_Information), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(DatagramSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DatagramSocket[] = 
    {
        { Py_tp_new, _new_DatagramSocket },
        { Py_tp_dealloc, _dealloc_DatagramSocket },
        { Py_tp_methods, _methods_DatagramSocket },
        { Py_tp_getset, _getset_DatagramSocket },
        { },
    };

    static PyType_Spec _type_spec_DatagramSocket =
    {
        "_winsdk_Windows_Networking_Sockets.DatagramSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocket
    };

    // ----- DatagramSocketControl class --------------------
    constexpr const char* const _type_name_DatagramSocketControl = "DatagramSocketControl";

    static PyObject* _new_DatagramSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DatagramSocketControl);
        return nullptr;
    }

    static void _dealloc_DatagramSocketControl(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DatagramSocketControl_get_QualityOfService(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QualityOfService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_QualityOfService(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketQualityOfService>(arg);

            self->obj.QualityOfService(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundUnicastHopLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.OutboundUnicastHopLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_InboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_InboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.InboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_DontFragment(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DontFragment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_DontFragment(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DontFragment(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DatagramSocketControl_get_MulticastOnly(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MulticastOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DatagramSocketControl_put_MulticastOnly(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.MulticastOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DatagramSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocketControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DatagramSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatagramSocketControl[] = {
        { "quality_of_service", reinterpret_cast<getter>(DatagramSocketControl_get_QualityOfService), reinterpret_cast<setter>(DatagramSocketControl_put_QualityOfService), nullptr, nullptr },
        { "outbound_unicast_hop_limit", reinterpret_cast<getter>(DatagramSocketControl_get_OutboundUnicastHopLimit), reinterpret_cast<setter>(DatagramSocketControl_put_OutboundUnicastHopLimit), nullptr, nullptr },
        { "inbound_buffer_size_in_bytes", reinterpret_cast<getter>(DatagramSocketControl_get_InboundBufferSizeInBytes), reinterpret_cast<setter>(DatagramSocketControl_put_InboundBufferSizeInBytes), nullptr, nullptr },
        { "dont_fragment", reinterpret_cast<getter>(DatagramSocketControl_get_DontFragment), reinterpret_cast<setter>(DatagramSocketControl_put_DontFragment), nullptr, nullptr },
        { "multicast_only", reinterpret_cast<getter>(DatagramSocketControl_get_MulticastOnly), reinterpret_cast<setter>(DatagramSocketControl_put_MulticastOnly), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DatagramSocketControl[] = 
    {
        { Py_tp_new, _new_DatagramSocketControl },
        { Py_tp_dealloc, _dealloc_DatagramSocketControl },
        { Py_tp_methods, _methods_DatagramSocketControl },
        { Py_tp_getset, _getset_DatagramSocketControl },
        { },
    };

    static PyType_Spec _type_spec_DatagramSocketControl =
    {
        "_winsdk_Windows_Networking_Sockets.DatagramSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocketControl
    };

    // ----- DatagramSocketInformation class --------------------
    constexpr const char* const _type_name_DatagramSocketInformation = "DatagramSocketInformation";

    static PyObject* _new_DatagramSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DatagramSocketInformation);
        return nullptr;
    }

    static void _dealloc_DatagramSocketInformation(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DatagramSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketInformation_get_LocalPort(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketInformation_get_RemoteAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketInformation_get_RemotePort(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemotePort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DatagramSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocketInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DatagramSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatagramSocketInformation[] = {
        { "local_address", reinterpret_cast<getter>(DatagramSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "local_port", reinterpret_cast<getter>(DatagramSocketInformation_get_LocalPort), nullptr, nullptr, nullptr },
        { "remote_address", reinterpret_cast<getter>(DatagramSocketInformation_get_RemoteAddress), nullptr, nullptr, nullptr },
        { "remote_port", reinterpret_cast<getter>(DatagramSocketInformation_get_RemotePort), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DatagramSocketInformation[] = 
    {
        { Py_tp_new, _new_DatagramSocketInformation },
        { Py_tp_dealloc, _dealloc_DatagramSocketInformation },
        { Py_tp_methods, _methods_DatagramSocketInformation },
        { Py_tp_getset, _getset_DatagramSocketInformation },
        { },
    };

    static PyType_Spec _type_spec_DatagramSocketInformation =
    {
        "_winsdk_Windows_Networking_Sockets.DatagramSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocketInformation
    };

    // ----- DatagramSocketMessageReceivedEventArgs class --------------------
    constexpr const char* const _type_name_DatagramSocketMessageReceivedEventArgs = "DatagramSocketMessageReceivedEventArgs";

    static PyObject* _new_DatagramSocketMessageReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DatagramSocketMessageReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_DatagramSocketMessageReceivedEventArgs(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_GetDataReader(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDataReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_GetDataStream(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDataStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_get_RemoteAddress(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DatagramSocketMessageReceivedEventArgs_get_RemotePort(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemotePort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DatagramSocketMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DatagramSocketMessageReceivedEventArgs[] = {
        { "get_data_reader", reinterpret_cast<PyCFunction>(DatagramSocketMessageReceivedEventArgs_GetDataReader), METH_VARARGS, nullptr },
        { "get_data_stream", reinterpret_cast<PyCFunction>(DatagramSocketMessageReceivedEventArgs_GetDataStream), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DatagramSocketMessageReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DatagramSocketMessageReceivedEventArgs[] = {
        { "local_address", reinterpret_cast<getter>(DatagramSocketMessageReceivedEventArgs_get_LocalAddress), nullptr, nullptr, nullptr },
        { "remote_address", reinterpret_cast<getter>(DatagramSocketMessageReceivedEventArgs_get_RemoteAddress), nullptr, nullptr, nullptr },
        { "remote_port", reinterpret_cast<getter>(DatagramSocketMessageReceivedEventArgs_get_RemotePort), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DatagramSocketMessageReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_DatagramSocketMessageReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_DatagramSocketMessageReceivedEventArgs },
        { Py_tp_methods, _methods_DatagramSocketMessageReceivedEventArgs },
        { Py_tp_getset, _getset_DatagramSocketMessageReceivedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_DatagramSocketMessageReceivedEventArgs =
    {
        "_winsdk_Windows_Networking_Sockets.DatagramSocketMessageReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DatagramSocketMessageReceivedEventArgs
    };

    // ----- MessageWebSocket class --------------------
    constexpr const char* const _type_name_MessageWebSocket = "MessageWebSocket";

    static PyObject* _new_MessageWebSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::MessageWebSocket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MessageWebSocket(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MessageWebSocket_Close(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_SendFinalFrameAsync(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.SendFinalFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_SendNonfinalFrameAsync(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.SendNonfinalFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_SetRequestHeader(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_get_Control(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_add_MessageReceived(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::MessageWebSocket, winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_remove_MessageReceived(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::IWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_add_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::MessageWebSocket, winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>>(arg);

            return py::convert(self->obj.ServerCustomValidationRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocket_remove_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServerCustomValidationRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MessageWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MessageWebSocket(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MessageWebSocket(py::wrapper::Windows::Networking::Sockets::MessageWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(MessageWebSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(MessageWebSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "send_final_frame_async", reinterpret_cast<PyCFunction>(MessageWebSocket_SendFinalFrameAsync), METH_VARARGS, nullptr },
        { "send_nonfinal_frame_async", reinterpret_cast<PyCFunction>(MessageWebSocket_SendNonfinalFrameAsync), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(MessageWebSocket_SetRequestHeader), METH_VARARGS, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(MessageWebSocket_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(MessageWebSocket_remove_MessageReceived), METH_O, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(MessageWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(MessageWebSocket_remove_Closed), METH_O, nullptr },
        { "add_server_custom_validation_requested", reinterpret_cast<PyCFunction>(MessageWebSocket_add_ServerCustomValidationRequested), METH_O, nullptr },
        { "remove_server_custom_validation_requested", reinterpret_cast<PyCFunction>(MessageWebSocket_remove_ServerCustomValidationRequested), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MessageWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MessageWebSocket), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MessageWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MessageWebSocket[] = {
        { "control", reinterpret_cast<getter>(MessageWebSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(MessageWebSocket_get_Information), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(MessageWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MessageWebSocket[] = 
    {
        { Py_tp_new, _new_MessageWebSocket },
        { Py_tp_dealloc, _dealloc_MessageWebSocket },
        { Py_tp_methods, _methods_MessageWebSocket },
        { Py_tp_getset, _getset_MessageWebSocket },
        { },
    };

    static PyType_Spec _type_spec_MessageWebSocket =
    {
        "_winsdk_Windows_Networking_Sockets.MessageWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocket
    };

    // ----- MessageWebSocketControl class --------------------
    constexpr const char* const _type_name_MessageWebSocketControl = "MessageWebSocketControl";

    static PyObject* _new_MessageWebSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MessageWebSocketControl);
        return nullptr;
    }

    static void _dealloc_MessageWebSocketControl(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MessageWebSocketControl_get_MessageType(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_MessageType(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketMessageType>(arg);

            self->obj.MessageType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_MaxMessageSize(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxMessageSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_MaxMessageSize(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxMessageSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ReceiveMode(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReceiveMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ReceiveMode(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::MessageWebSocketReceiveMode>(arg);

            self->obj.ReceiveMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredUnsolicitedPongInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ClientCertificate(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClientCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ClientCertificate(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.ClientCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ActualUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActualUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketControl_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MessageWebSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MessageWebSocketControl_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketControl_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MessageWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocketControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MessageWebSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MessageWebSocketControl[] = {
        { "message_type", reinterpret_cast<getter>(MessageWebSocketControl_get_MessageType), reinterpret_cast<setter>(MessageWebSocketControl_put_MessageType), nullptr, nullptr },
        { "max_message_size", reinterpret_cast<getter>(MessageWebSocketControl_get_MaxMessageSize), reinterpret_cast<setter>(MessageWebSocketControl_put_MaxMessageSize), nullptr, nullptr },
        { "receive_mode", reinterpret_cast<getter>(MessageWebSocketControl_get_ReceiveMode), reinterpret_cast<setter>(MessageWebSocketControl_put_ReceiveMode), nullptr, nullptr },
        { "desired_unsolicited_pong_interval", reinterpret_cast<getter>(MessageWebSocketControl_get_DesiredUnsolicitedPongInterval), reinterpret_cast<setter>(MessageWebSocketControl_put_DesiredUnsolicitedPongInterval), nullptr, nullptr },
        { "client_certificate", reinterpret_cast<getter>(MessageWebSocketControl_get_ClientCertificate), reinterpret_cast<setter>(MessageWebSocketControl_put_ClientCertificate), nullptr, nullptr },
        { "actual_unsolicited_pong_interval", reinterpret_cast<getter>(MessageWebSocketControl_get_ActualUnsolicitedPongInterval), nullptr, nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(MessageWebSocketControl_get_ServerCredential), reinterpret_cast<setter>(MessageWebSocketControl_put_ServerCredential), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(MessageWebSocketControl_get_ProxyCredential), reinterpret_cast<setter>(MessageWebSocketControl_put_ProxyCredential), nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(MessageWebSocketControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(MessageWebSocketControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "supported_protocols", reinterpret_cast<getter>(MessageWebSocketControl_get_SupportedProtocols), nullptr, nullptr, nullptr },
        { "ignorable_server_certificate_errors", reinterpret_cast<getter>(MessageWebSocketControl_get_IgnorableServerCertificateErrors), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MessageWebSocketControl[] = 
    {
        { Py_tp_new, _new_MessageWebSocketControl },
        { Py_tp_dealloc, _dealloc_MessageWebSocketControl },
        { Py_tp_methods, _methods_MessageWebSocketControl },
        { Py_tp_getset, _getset_MessageWebSocketControl },
        { },
    };

    static PyType_Spec _type_spec_MessageWebSocketControl =
    {
        "_winsdk_Windows_Networking_Sockets.MessageWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocketControl
    };

    // ----- MessageWebSocketInformation class --------------------
    constexpr const char* const _type_name_MessageWebSocketInformation = "MessageWebSocketInformation";

    static PyObject* _new_MessageWebSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MessageWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_MessageWebSocketInformation(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MessageWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketInformation_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MessageWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocketInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MessageWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MessageWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(MessageWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(MessageWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(MessageWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { "server_certificate", reinterpret_cast<getter>(MessageWebSocketInformation_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(MessageWebSocketInformation_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(MessageWebSocketInformation_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(MessageWebSocketInformation_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MessageWebSocketInformation[] = 
    {
        { Py_tp_new, _new_MessageWebSocketInformation },
        { Py_tp_dealloc, _dealloc_MessageWebSocketInformation },
        { Py_tp_methods, _methods_MessageWebSocketInformation },
        { Py_tp_getset, _getset_MessageWebSocketInformation },
        { },
    };

    static PyType_Spec _type_spec_MessageWebSocketInformation =
    {
        "_winsdk_Windows_Networking_Sockets.MessageWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocketInformation
    };

    // ----- MessageWebSocketMessageReceivedEventArgs class --------------------
    constexpr const char* const _type_name_MessageWebSocketMessageReceivedEventArgs = "MessageWebSocketMessageReceivedEventArgs";

    static PyObject* _new_MessageWebSocketMessageReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MessageWebSocketMessageReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MessageWebSocketMessageReceivedEventArgs(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_GetDataReader(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDataReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_GetDataStream(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDataStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_get_MessageType(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MessageWebSocketMessageReceivedEventArgs_get_IsMessageComplete(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMessageComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MessageWebSocketMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MessageWebSocketMessageReceivedEventArgs[] = {
        { "get_data_reader", reinterpret_cast<PyCFunction>(MessageWebSocketMessageReceivedEventArgs_GetDataReader), METH_VARARGS, nullptr },
        { "get_data_stream", reinterpret_cast<PyCFunction>(MessageWebSocketMessageReceivedEventArgs_GetDataStream), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MessageWebSocketMessageReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MessageWebSocketMessageReceivedEventArgs[] = {
        { "message_type", reinterpret_cast<getter>(MessageWebSocketMessageReceivedEventArgs_get_MessageType), nullptr, nullptr, nullptr },
        { "is_message_complete", reinterpret_cast<getter>(MessageWebSocketMessageReceivedEventArgs_get_IsMessageComplete), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MessageWebSocketMessageReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MessageWebSocketMessageReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MessageWebSocketMessageReceivedEventArgs },
        { Py_tp_methods, _methods_MessageWebSocketMessageReceivedEventArgs },
        { Py_tp_getset, _getset_MessageWebSocketMessageReceivedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MessageWebSocketMessageReceivedEventArgs =
    {
        "_winsdk_Windows_Networking_Sockets.MessageWebSocketMessageReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MessageWebSocketMessageReceivedEventArgs
    };

    // ----- ServerMessageWebSocket class --------------------
    constexpr const char* const _type_name_ServerMessageWebSocket = "ServerMessageWebSocket";

    static PyObject* _new_ServerMessageWebSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ServerMessageWebSocket);
        return nullptr;
    }

    static void _dealloc_ServerMessageWebSocket(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ServerMessageWebSocket_Close(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_get_Control(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::ServerMessageWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_add_MessageReceived(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::ServerMessageWebSocket, winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocket_remove_MessageReceived(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ServerMessageWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerMessageWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ServerMessageWebSocket(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ServerMessageWebSocket(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerMessageWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_Close), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_remove_Closed), METH_O, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(ServerMessageWebSocket_remove_MessageReceived), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerMessageWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ServerMessageWebSocket), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ServerMessageWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerMessageWebSocket[] = {
        { "control", reinterpret_cast<getter>(ServerMessageWebSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(ServerMessageWebSocket_get_Information), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(ServerMessageWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerMessageWebSocket[] = 
    {
        { Py_tp_new, _new_ServerMessageWebSocket },
        { Py_tp_dealloc, _dealloc_ServerMessageWebSocket },
        { Py_tp_methods, _methods_ServerMessageWebSocket },
        { Py_tp_getset, _getset_ServerMessageWebSocket },
        { },
    };

    static PyType_Spec _type_spec_ServerMessageWebSocket =
    {
        "_winsdk_Windows_Networking_Sockets.ServerMessageWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerMessageWebSocket
    };

    // ----- ServerMessageWebSocketControl class --------------------
    constexpr const char* const _type_name_ServerMessageWebSocketControl = "ServerMessageWebSocketControl";

    static PyObject* _new_ServerMessageWebSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ServerMessageWebSocketControl);
        return nullptr;
    }

    static void _dealloc_ServerMessageWebSocketControl(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ServerMessageWebSocketControl_get_MessageType(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MessageType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ServerMessageWebSocketControl_put_MessageType(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketMessageType>(arg);

            self->obj.MessageType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ServerMessageWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerMessageWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerMessageWebSocketControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerMessageWebSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerMessageWebSocketControl[] = {
        { "message_type", reinterpret_cast<getter>(ServerMessageWebSocketControl_get_MessageType), reinterpret_cast<setter>(ServerMessageWebSocketControl_put_MessageType), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerMessageWebSocketControl[] = 
    {
        { Py_tp_new, _new_ServerMessageWebSocketControl },
        { Py_tp_dealloc, _dealloc_ServerMessageWebSocketControl },
        { Py_tp_methods, _methods_ServerMessageWebSocketControl },
        { Py_tp_getset, _getset_ServerMessageWebSocketControl },
        { },
    };

    static PyType_Spec _type_spec_ServerMessageWebSocketControl =
    {
        "_winsdk_Windows_Networking_Sockets.ServerMessageWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerMessageWebSocketControl
    };

    // ----- ServerMessageWebSocketInformation class --------------------
    constexpr const char* const _type_name_ServerMessageWebSocketInformation = "ServerMessageWebSocketInformation";

    static PyObject* _new_ServerMessageWebSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ServerMessageWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_ServerMessageWebSocketInformation(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ServerMessageWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerMessageWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ServerMessageWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerMessageWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerMessageWebSocketInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerMessageWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerMessageWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(ServerMessageWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(ServerMessageWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(ServerMessageWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerMessageWebSocketInformation[] = 
    {
        { Py_tp_new, _new_ServerMessageWebSocketInformation },
        { Py_tp_dealloc, _dealloc_ServerMessageWebSocketInformation },
        { Py_tp_methods, _methods_ServerMessageWebSocketInformation },
        { Py_tp_getset, _getset_ServerMessageWebSocketInformation },
        { },
    };

    static PyType_Spec _type_spec_ServerMessageWebSocketInformation =
    {
        "_winsdk_Windows_Networking_Sockets.ServerMessageWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerMessageWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerMessageWebSocketInformation
    };

    // ----- ServerStreamWebSocket class --------------------
    constexpr const char* const _type_name_ServerStreamWebSocket = "ServerStreamWebSocket";

    static PyObject* _new_ServerStreamWebSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ServerStreamWebSocket);
        return nullptr;
    }

    static void _dealloc_ServerStreamWebSocket(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ServerStreamWebSocket_Close(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_get_InputStream(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::ServerStreamWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ServerStreamWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerStreamWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ServerStreamWebSocket(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ServerStreamWebSocket(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerStreamWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(ServerStreamWebSocket_Close), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(ServerStreamWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(ServerStreamWebSocket_remove_Closed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerStreamWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ServerStreamWebSocket), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ServerStreamWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerStreamWebSocket[] = {
        { "information", reinterpret_cast<getter>(ServerStreamWebSocket_get_Information), nullptr, nullptr, nullptr },
        { "input_stream", reinterpret_cast<getter>(ServerStreamWebSocket_get_InputStream), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(ServerStreamWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerStreamWebSocket[] = 
    {
        { Py_tp_new, _new_ServerStreamWebSocket },
        { Py_tp_dealloc, _dealloc_ServerStreamWebSocket },
        { Py_tp_methods, _methods_ServerStreamWebSocket },
        { Py_tp_getset, _getset_ServerStreamWebSocket },
        { },
    };

    static PyType_Spec _type_spec_ServerStreamWebSocket =
    {
        "_winsdk_Windows_Networking_Sockets.ServerStreamWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerStreamWebSocket
    };

    // ----- ServerStreamWebSocketInformation class --------------------
    constexpr const char* const _type_name_ServerStreamWebSocketInformation = "ServerStreamWebSocketInformation";

    static PyObject* _new_ServerStreamWebSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ServerStreamWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_ServerStreamWebSocketInformation(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ServerStreamWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ServerStreamWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ServerStreamWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::ServerStreamWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ServerStreamWebSocketInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ServerStreamWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ServerStreamWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(ServerStreamWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(ServerStreamWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(ServerStreamWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ServerStreamWebSocketInformation[] = 
    {
        { Py_tp_new, _new_ServerStreamWebSocketInformation },
        { Py_tp_dealloc, _dealloc_ServerStreamWebSocketInformation },
        { Py_tp_methods, _methods_ServerStreamWebSocketInformation },
        { Py_tp_getset, _getset_ServerStreamWebSocketInformation },
        { },
    };

    static PyType_Spec _type_spec_ServerStreamWebSocketInformation =
    {
        "_winsdk_Windows_Networking_Sockets.ServerStreamWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::ServerStreamWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ServerStreamWebSocketInformation
    };

    // ----- SocketActivityContext class --------------------
    constexpr const char* const _type_name_SocketActivityContext = "SocketActivityContext";

    static PyObject* _new_SocketActivityContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Networking::Sockets::SocketActivityContext instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SocketActivityContext(py::wrapper::Windows::Networking::Sockets::SocketActivityContext* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SocketActivityContext_get_Data(py::wrapper::Windows::Networking::Sockets::SocketActivityContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SocketActivityContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::SocketActivityContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityContext[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SocketActivityContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SocketActivityContext[] = {
        { "data", reinterpret_cast<getter>(SocketActivityContext_get_Data), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SocketActivityContext[] = 
    {
        { Py_tp_new, _new_SocketActivityContext },
        { Py_tp_dealloc, _dealloc_SocketActivityContext },
        { Py_tp_methods, _methods_SocketActivityContext },
        { Py_tp_getset, _getset_SocketActivityContext },
        { },
    };

    static PyType_Spec _type_spec_SocketActivityContext =
    {
        "_winsdk_Windows_Networking_Sockets.SocketActivityContext",
        sizeof(py::wrapper::Windows::Networking::Sockets::SocketActivityContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityContext
    };

    // ----- SocketActivityInformation class --------------------
    constexpr const char* const _type_name_SocketActivityInformation = "SocketActivityInformation";

    static PyObject* _new_SocketActivityInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SocketActivityInformation);
        return nullptr;
    }

    static void _dealloc_SocketActivityInformation(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SocketActivityInformation_get_Context(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_DatagramSocket(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DatagramSocket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_Id(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_SocketKind(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SocketKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_StreamSocket(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StreamSocket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StreamSocketListener());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_TaskId(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityInformation_get_AllSockets(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::Sockets::SocketActivityInformation::AllSockets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SocketActivityInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::SocketActivityInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityInformation[] = {
        { "get_all_sockets", reinterpret_cast<PyCFunction>(SocketActivityInformation_get_AllSockets), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SocketActivityInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SocketActivityInformation[] = {
        { "context", reinterpret_cast<getter>(SocketActivityInformation_get_Context), nullptr, nullptr, nullptr },
        { "datagram_socket", reinterpret_cast<getter>(SocketActivityInformation_get_DatagramSocket), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(SocketActivityInformation_get_Id), nullptr, nullptr, nullptr },
        { "socket_kind", reinterpret_cast<getter>(SocketActivityInformation_get_SocketKind), nullptr, nullptr, nullptr },
        { "stream_socket", reinterpret_cast<getter>(SocketActivityInformation_get_StreamSocket), nullptr, nullptr, nullptr },
        { "stream_socket_listener", reinterpret_cast<getter>(SocketActivityInformation_get_StreamSocketListener), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(SocketActivityInformation_get_TaskId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SocketActivityInformation[] = 
    {
        { Py_tp_new, _new_SocketActivityInformation },
        { Py_tp_dealloc, _dealloc_SocketActivityInformation },
        { Py_tp_methods, _methods_SocketActivityInformation },
        { Py_tp_getset, _getset_SocketActivityInformation },
        { },
    };

    static PyType_Spec _type_spec_SocketActivityInformation =
    {
        "_winsdk_Windows_Networking_Sockets.SocketActivityInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::SocketActivityInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityInformation
    };

    // ----- SocketActivityTriggerDetails class --------------------
    constexpr const char* const _type_name_SocketActivityTriggerDetails = "SocketActivityTriggerDetails";

    static PyObject* _new_SocketActivityTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SocketActivityTriggerDetails);
        return nullptr;
    }

    static void _dealloc_SocketActivityTriggerDetails(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SocketActivityTriggerDetails_get_Reason(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SocketActivityTriggerDetails_get_SocketInformation(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SocketInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SocketActivityTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::SocketActivityTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketActivityTriggerDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SocketActivityTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SocketActivityTriggerDetails[] = {
        { "reason", reinterpret_cast<getter>(SocketActivityTriggerDetails_get_Reason), nullptr, nullptr, nullptr },
        { "socket_information", reinterpret_cast<getter>(SocketActivityTriggerDetails_get_SocketInformation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SocketActivityTriggerDetails[] = 
    {
        { Py_tp_new, _new_SocketActivityTriggerDetails },
        { Py_tp_dealloc, _dealloc_SocketActivityTriggerDetails },
        { Py_tp_methods, _methods_SocketActivityTriggerDetails },
        { Py_tp_getset, _getset_SocketActivityTriggerDetails },
        { },
    };

    static PyType_Spec _type_spec_SocketActivityTriggerDetails =
    {
        "_winsdk_Windows_Networking_Sockets.SocketActivityTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::Sockets::SocketActivityTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketActivityTriggerDetails
    };

    // ----- SocketError class --------------------
    constexpr const char* const _type_name_SocketError = "SocketError";

    static PyObject* _new_SocketError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SocketError);
        return nullptr;
    }

    static PyObject* SocketError_GetStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Networking::Sockets::SocketError::GetStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_SocketError[] = {
        { "get_status", reinterpret_cast<PyCFunction>(SocketError_GetStatus), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SocketError[] = {
        { }
    };

    static PyType_Slot _type_slots_SocketError[] = 
    {
        { Py_tp_new, _new_SocketError },
        { Py_tp_methods, _methods_SocketError },
        { Py_tp_getset, _getset_SocketError },
        { },
    };

    static PyType_Spec _type_spec_SocketError =
    {
        "_winsdk_Windows_Networking_Sockets.SocketError",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SocketError
    };

    // ----- StreamSocket class --------------------
    constexpr const char* const _type_name_StreamSocket = "StreamSocket";

    static PyObject* _new_StreamSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::StreamSocket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StreamSocket(py::wrapper::Windows::Networking::Sockets::StreamSocket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamSocket_CancelIOAsync(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CancelIOAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_Close(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::EndpointPair>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.ConnectAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 2);

                return py::convert(self->obj.ConnectAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 3);

                return py::convert(self->obj.ConnectAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_EnableTransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.EnableTransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityConnectedStandbyAction>(args, 1);

                self->obj.EnableTransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_GetEndpointPairsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(winrt::Windows::Networking::Sockets::StreamSocket::GetEndpointPairsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::HostNameSortOptions>(args, 2);

                return py::convert(winrt::Windows::Networking::Sockets::StreamSocket::GetEndpointPairsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_TransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);

                self->obj.TransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                self->obj.TransferOwnership(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_UpgradeToSslAsync(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostName>(args, 1);

                return py::convert(self->obj.UpgradeToSslAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_Control(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_Information(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_InputStream(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::StreamSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamSocket(py::wrapper::Windows::Networking::Sockets::StreamSocket* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_StreamSocket(py::wrapper::Windows::Networking::Sockets::StreamSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocket[] = {
        { "cancel_i_o_async", reinterpret_cast<PyCFunction>(StreamSocket_CancelIOAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(StreamSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(StreamSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "enable_transfer_ownership", reinterpret_cast<PyCFunction>(StreamSocket_EnableTransferOwnership), METH_VARARGS, nullptr },
        { "get_endpoint_pairs_async", reinterpret_cast<PyCFunction>(StreamSocket_GetEndpointPairsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "transfer_ownership", reinterpret_cast<PyCFunction>(StreamSocket_TransferOwnership), METH_VARARGS, nullptr },
        { "upgrade_to_ssl_async", reinterpret_cast<PyCFunction>(StreamSocket_UpgradeToSslAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StreamSocket), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_StreamSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocket[] = {
        { "control", reinterpret_cast<getter>(StreamSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(StreamSocket_get_Information), nullptr, nullptr, nullptr },
        { "input_stream", reinterpret_cast<getter>(StreamSocket_get_InputStream), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(StreamSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocket[] = 
    {
        { Py_tp_new, _new_StreamSocket },
        { Py_tp_dealloc, _dealloc_StreamSocket },
        { Py_tp_methods, _methods_StreamSocket },
        { Py_tp_getset, _getset_StreamSocket },
        { },
    };

    static PyType_Spec _type_spec_StreamSocket =
    {
        "_winsdk_Windows_Networking_Sockets.StreamSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocket
    };

    // ----- StreamSocketControl class --------------------
    constexpr const char* const _type_name_StreamSocketControl = "StreamSocketControl";

    static PyObject* _new_StreamSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamSocketControl);
        return nullptr;
    }

    static void _dealloc_StreamSocketControl(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamSocketControl_get_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QualityOfService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketQualityOfService>(arg);

            self->obj.QualityOfService(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundUnicastHopLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.OutboundUnicastHopLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NoDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeepAlive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeepAlive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketControl_get_SerializeConnectionAttempts(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SerializeConnectionAttempts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_SerializeConnectionAttempts(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SerializeConnectionAttempts(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClientCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.ClientCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketControl_get_MinProtectionLevel(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketControl_put_MinProtectionLevel(py::wrapper::Windows::Networking::Sockets::StreamSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(arg);

            self->obj.MinProtectionLevel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StreamSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketControl[] = {
        { "quality_of_service", reinterpret_cast<getter>(StreamSocketControl_get_QualityOfService), reinterpret_cast<setter>(StreamSocketControl_put_QualityOfService), nullptr, nullptr },
        { "outbound_unicast_hop_limit", reinterpret_cast<getter>(StreamSocketControl_get_OutboundUnicastHopLimit), reinterpret_cast<setter>(StreamSocketControl_put_OutboundUnicastHopLimit), nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(StreamSocketControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(StreamSocketControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "no_delay", reinterpret_cast<getter>(StreamSocketControl_get_NoDelay), reinterpret_cast<setter>(StreamSocketControl_put_NoDelay), nullptr, nullptr },
        { "keep_alive", reinterpret_cast<getter>(StreamSocketControl_get_KeepAlive), reinterpret_cast<setter>(StreamSocketControl_put_KeepAlive), nullptr, nullptr },
        { "ignorable_server_certificate_errors", reinterpret_cast<getter>(StreamSocketControl_get_IgnorableServerCertificateErrors), nullptr, nullptr, nullptr },
        { "serialize_connection_attempts", reinterpret_cast<getter>(StreamSocketControl_get_SerializeConnectionAttempts), reinterpret_cast<setter>(StreamSocketControl_put_SerializeConnectionAttempts), nullptr, nullptr },
        { "client_certificate", reinterpret_cast<getter>(StreamSocketControl_get_ClientCertificate), reinterpret_cast<setter>(StreamSocketControl_put_ClientCertificate), nullptr, nullptr },
        { "min_protection_level", reinterpret_cast<getter>(StreamSocketControl_get_MinProtectionLevel), reinterpret_cast<setter>(StreamSocketControl_put_MinProtectionLevel), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketControl[] = 
    {
        { Py_tp_new, _new_StreamSocketControl },
        { Py_tp_dealloc, _dealloc_StreamSocketControl },
        { Py_tp_methods, _methods_StreamSocketControl },
        { Py_tp_getset, _getset_StreamSocketControl },
        { },
    };

    static PyType_Spec _type_spec_StreamSocketControl =
    {
        "_winsdk_Windows_Networking_Sockets.StreamSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketControl
    };

    // ----- StreamSocketInformation class --------------------
    constexpr const char* const _type_name_StreamSocketInformation = "StreamSocketInformation";

    static PyObject* _new_StreamSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamSocketInformation);
        return nullptr;
    }

    static void _dealloc_StreamSocketInformation(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_LocalPort(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ProtectionLevel(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemoteAddress(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemoteHostName(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteHostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemotePort(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemotePort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RemoteServiceName(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteServiceName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_RoundTripTimeStatistics(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoundTripTimeStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_SessionKey(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SessionKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketInformation_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(StreamSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(StreamSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "local_port", reinterpret_cast<getter>(StreamSocketInformation_get_LocalPort), nullptr, nullptr, nullptr },
        { "protection_level", reinterpret_cast<getter>(StreamSocketInformation_get_ProtectionLevel), nullptr, nullptr, nullptr },
        { "remote_address", reinterpret_cast<getter>(StreamSocketInformation_get_RemoteAddress), nullptr, nullptr, nullptr },
        { "remote_host_name", reinterpret_cast<getter>(StreamSocketInformation_get_RemoteHostName), nullptr, nullptr, nullptr },
        { "remote_port", reinterpret_cast<getter>(StreamSocketInformation_get_RemotePort), nullptr, nullptr, nullptr },
        { "remote_service_name", reinterpret_cast<getter>(StreamSocketInformation_get_RemoteServiceName), nullptr, nullptr, nullptr },
        { "round_trip_time_statistics", reinterpret_cast<getter>(StreamSocketInformation_get_RoundTripTimeStatistics), nullptr, nullptr, nullptr },
        { "session_key", reinterpret_cast<getter>(StreamSocketInformation_get_SessionKey), nullptr, nullptr, nullptr },
        { "server_certificate", reinterpret_cast<getter>(StreamSocketInformation_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(StreamSocketInformation_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(StreamSocketInformation_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(StreamSocketInformation_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketInformation[] = 
    {
        { Py_tp_new, _new_StreamSocketInformation },
        { Py_tp_dealloc, _dealloc_StreamSocketInformation },
        { Py_tp_methods, _methods_StreamSocketInformation },
        { Py_tp_getset, _getset_StreamSocketInformation },
        { },
    };

    static PyType_Spec _type_spec_StreamSocketInformation =
    {
        "_winsdk_Windows_Networking_Sockets.StreamSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketInformation
    };

    // ----- StreamSocketListener class --------------------
    constexpr const char* const _type_name_StreamSocketListener = "StreamSocketListener";

    static PyObject* _new_StreamSocketListener(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::StreamSocketListener instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamSocketListener_BindEndpointAsync(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.BindEndpointAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_BindServiceNameAsync(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.BindServiceNameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 1);

                return py::convert(self->obj.BindServiceNameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketProtectionLevel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 2);

                return py::convert(self->obj.BindServiceNameAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_CancelIOAsync(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CancelIOAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_Close(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_EnableTransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.EnableTransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityConnectedStandbyAction>(args, 1);

                self->obj.EnableTransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_TransferOwnership(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.TransferOwnership(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Sockets::SocketActivityContext>(args, 1);

                self->obj.TransferOwnership(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_get_Control(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_get_Information(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_add_ConnectionReceived(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::StreamSocketListener, winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>>(arg);

            return py::convert(self->obj.ConnectionReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamSocketListener_remove_ConnectionReceived(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamSocketListener(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListener>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_StreamSocketListener(py::wrapper::Windows::Networking::Sockets::StreamSocketListener* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListener[] = {
        { "bind_endpoint_async", reinterpret_cast<PyCFunction>(StreamSocketListener_BindEndpointAsync), METH_VARARGS, nullptr },
        { "bind_service_name_async", reinterpret_cast<PyCFunction>(StreamSocketListener_BindServiceNameAsync), METH_VARARGS, nullptr },
        { "cancel_i_o_async", reinterpret_cast<PyCFunction>(StreamSocketListener_CancelIOAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(StreamSocketListener_Close), METH_VARARGS, nullptr },
        { "enable_transfer_ownership", reinterpret_cast<PyCFunction>(StreamSocketListener_EnableTransferOwnership), METH_VARARGS, nullptr },
        { "transfer_ownership", reinterpret_cast<PyCFunction>(StreamSocketListener_TransferOwnership), METH_VARARGS, nullptr },
        { "add_connection_received", reinterpret_cast<PyCFunction>(StreamSocketListener_add_ConnectionReceived), METH_O, nullptr },
        { "remove_connection_received", reinterpret_cast<PyCFunction>(StreamSocketListener_remove_ConnectionReceived), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketListener), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StreamSocketListener), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_StreamSocketListener), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketListener[] = {
        { "control", reinterpret_cast<getter>(StreamSocketListener_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(StreamSocketListener_get_Information), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketListener[] = 
    {
        { Py_tp_new, _new_StreamSocketListener },
        { Py_tp_dealloc, _dealloc_StreamSocketListener },
        { Py_tp_methods, _methods_StreamSocketListener },
        { Py_tp_getset, _getset_StreamSocketListener },
        { },
    };

    static PyType_Spec _type_spec_StreamSocketListener =
    {
        "_winsdk_Windows_Networking_Sockets.StreamSocketListener",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListener),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListener
    };

    // ----- StreamSocketListenerConnectionReceivedEventArgs class --------------------
    constexpr const char* const _type_name_StreamSocketListenerConnectionReceivedEventArgs = "StreamSocketListenerConnectionReceivedEventArgs";

    static PyObject* _new_StreamSocketListenerConnectionReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamSocketListenerConnectionReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_StreamSocketListenerConnectionReceivedEventArgs(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamSocketListenerConnectionReceivedEventArgs_get_Socket(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Socket());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamSocketListenerConnectionReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListenerConnectionReceivedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketListenerConnectionReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketListenerConnectionReceivedEventArgs[] = {
        { "socket", reinterpret_cast<getter>(StreamSocketListenerConnectionReceivedEventArgs_get_Socket), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketListenerConnectionReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_StreamSocketListenerConnectionReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_StreamSocketListenerConnectionReceivedEventArgs },
        { Py_tp_methods, _methods_StreamSocketListenerConnectionReceivedEventArgs },
        { Py_tp_getset, _getset_StreamSocketListenerConnectionReceivedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_StreamSocketListenerConnectionReceivedEventArgs =
    {
        "_winsdk_Windows_Networking_Sockets.StreamSocketListenerConnectionReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListenerConnectionReceivedEventArgs
    };

    // ----- StreamSocketListenerControl class --------------------
    constexpr const char* const _type_name_StreamSocketListenerControl = "StreamSocketListenerControl";

    static PyObject* _new_StreamSocketListenerControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamSocketListenerControl);
        return nullptr;
    }

    static void _dealloc_StreamSocketListenerControl(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamSocketListenerControl_get_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QualityOfService());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_QualityOfService(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Sockets::SocketQualityOfService>(arg);

            self->obj.QualityOfService(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundUnicastHopLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_OutboundUnicastHopLimit(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.OutboundUnicastHopLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NoDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamSocketListenerControl_get_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeepAlive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamSocketListenerControl_put_KeepAlive(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.KeepAlive(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StreamSocketListenerControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListenerControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListenerControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketListenerControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketListenerControl[] = {
        { "quality_of_service", reinterpret_cast<getter>(StreamSocketListenerControl_get_QualityOfService), reinterpret_cast<setter>(StreamSocketListenerControl_put_QualityOfService), nullptr, nullptr },
        { "outbound_unicast_hop_limit", reinterpret_cast<getter>(StreamSocketListenerControl_get_OutboundUnicastHopLimit), reinterpret_cast<setter>(StreamSocketListenerControl_put_OutboundUnicastHopLimit), nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(StreamSocketListenerControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(StreamSocketListenerControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "no_delay", reinterpret_cast<getter>(StreamSocketListenerControl_get_NoDelay), reinterpret_cast<setter>(StreamSocketListenerControl_put_NoDelay), nullptr, nullptr },
        { "keep_alive", reinterpret_cast<getter>(StreamSocketListenerControl_get_KeepAlive), reinterpret_cast<setter>(StreamSocketListenerControl_put_KeepAlive), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketListenerControl[] = 
    {
        { Py_tp_new, _new_StreamSocketListenerControl },
        { Py_tp_dealloc, _dealloc_StreamSocketListenerControl },
        { Py_tp_methods, _methods_StreamSocketListenerControl },
        { Py_tp_getset, _getset_StreamSocketListenerControl },
        { },
    };

    static PyType_Spec _type_spec_StreamSocketListenerControl =
    {
        "_winsdk_Windows_Networking_Sockets.StreamSocketListenerControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListenerControl
    };

    // ----- StreamSocketListenerInformation class --------------------
    constexpr const char* const _type_name_StreamSocketListenerInformation = "StreamSocketListenerInformation";

    static PyObject* _new_StreamSocketListenerInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamSocketListenerInformation);
        return nullptr;
    }

    static void _dealloc_StreamSocketListenerInformation(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamSocketListenerInformation_get_LocalPort(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalPort());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamSocketListenerInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamSocketListenerInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamSocketListenerInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamSocketListenerInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamSocketListenerInformation[] = {
        { "local_port", reinterpret_cast<getter>(StreamSocketListenerInformation_get_LocalPort), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamSocketListenerInformation[] = 
    {
        { Py_tp_new, _new_StreamSocketListenerInformation },
        { Py_tp_dealloc, _dealloc_StreamSocketListenerInformation },
        { Py_tp_methods, _methods_StreamSocketListenerInformation },
        { Py_tp_getset, _getset_StreamSocketListenerInformation },
        { },
    };

    static PyType_Spec _type_spec_StreamSocketListenerInformation =
    {
        "_winsdk_Windows_Networking_Sockets.StreamSocketListenerInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamSocketListenerInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamSocketListenerInformation
    };

    // ----- StreamWebSocket class --------------------
    constexpr const char* const _type_name_StreamWebSocket = "StreamWebSocket";

    static PyObject* _new_StreamWebSocket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::StreamWebSocket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StreamWebSocket(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamWebSocket_Close(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_SetRequestHeader(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_Control(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Control());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_Information(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Information());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_InputStream(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::IWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_add_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::StreamWebSocket, winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>>(arg);

            return py::convert(self->obj.ServerCustomValidationRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocket_remove_ServerCustomValidationRequested(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ServerCustomValidationRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StreamWebSocket(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_StreamWebSocket(py::wrapper::Windows::Networking::Sockets::StreamWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(StreamWebSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(StreamWebSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(StreamWebSocket_SetRequestHeader), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(StreamWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(StreamWebSocket_remove_Closed), METH_O, nullptr },
        { "add_server_custom_validation_requested", reinterpret_cast<PyCFunction>(StreamWebSocket_add_ServerCustomValidationRequested), METH_O, nullptr },
        { "remove_server_custom_validation_requested", reinterpret_cast<PyCFunction>(StreamWebSocket_remove_ServerCustomValidationRequested), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StreamWebSocket), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_StreamWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamWebSocket[] = {
        { "control", reinterpret_cast<getter>(StreamWebSocket_get_Control), nullptr, nullptr, nullptr },
        { "information", reinterpret_cast<getter>(StreamWebSocket_get_Information), nullptr, nullptr, nullptr },
        { "input_stream", reinterpret_cast<getter>(StreamWebSocket_get_InputStream), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(StreamWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamWebSocket[] = 
    {
        { Py_tp_new, _new_StreamWebSocket },
        { Py_tp_dealloc, _dealloc_StreamWebSocket },
        { Py_tp_methods, _methods_StreamWebSocket },
        { Py_tp_getset, _getset_StreamWebSocket },
        { },
    };

    static PyType_Spec _type_spec_StreamWebSocket =
    {
        "_winsdk_Windows_Networking_Sockets.StreamWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamWebSocket
    };

    // ----- StreamWebSocketControl class --------------------
    constexpr const char* const _type_name_StreamWebSocketControl = "StreamWebSocketControl";

    static PyObject* _new_StreamWebSocketControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamWebSocketControl);
        return nullptr;
    }

    static void _dealloc_StreamWebSocketControl(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamWebSocketControl_get_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NoDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_NoDelay(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.NoDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_DesiredUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DesiredUnsolicitedPongInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClientCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_ClientCertificate(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Cryptography::Certificates::Certificate>(arg);

            self->obj.ClientCertificate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_ActualUnsolicitedPongInterval(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActualUnsolicitedPongInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketControl_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StreamWebSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StreamWebSocketControl_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketControl_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamWebSocketControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamWebSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamWebSocketControl[] = {
        { "no_delay", reinterpret_cast<getter>(StreamWebSocketControl_get_NoDelay), reinterpret_cast<setter>(StreamWebSocketControl_put_NoDelay), nullptr, nullptr },
        { "desired_unsolicited_pong_interval", reinterpret_cast<getter>(StreamWebSocketControl_get_DesiredUnsolicitedPongInterval), reinterpret_cast<setter>(StreamWebSocketControl_put_DesiredUnsolicitedPongInterval), nullptr, nullptr },
        { "client_certificate", reinterpret_cast<getter>(StreamWebSocketControl_get_ClientCertificate), reinterpret_cast<setter>(StreamWebSocketControl_put_ClientCertificate), nullptr, nullptr },
        { "actual_unsolicited_pong_interval", reinterpret_cast<getter>(StreamWebSocketControl_get_ActualUnsolicitedPongInterval), nullptr, nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(StreamWebSocketControl_get_ServerCredential), reinterpret_cast<setter>(StreamWebSocketControl_put_ServerCredential), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(StreamWebSocketControl_get_ProxyCredential), reinterpret_cast<setter>(StreamWebSocketControl_put_ProxyCredential), nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(StreamWebSocketControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(StreamWebSocketControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "supported_protocols", reinterpret_cast<getter>(StreamWebSocketControl_get_SupportedProtocols), nullptr, nullptr, nullptr },
        { "ignorable_server_certificate_errors", reinterpret_cast<getter>(StreamWebSocketControl_get_IgnorableServerCertificateErrors), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamWebSocketControl[] = 
    {
        { Py_tp_new, _new_StreamWebSocketControl },
        { Py_tp_dealloc, _dealloc_StreamWebSocketControl },
        { Py_tp_methods, _methods_StreamWebSocketControl },
        { Py_tp_getset, _getset_StreamWebSocketControl },
        { },
    };

    static PyType_Spec _type_spec_StreamWebSocketControl =
    {
        "_winsdk_Windows_Networking_Sockets.StreamWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamWebSocketControl
    };

    // ----- StreamWebSocketInformation class --------------------
    constexpr const char* const _type_name_StreamWebSocketInformation = "StreamWebSocketInformation";

    static PyObject* _new_StreamWebSocketInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StreamWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_StreamWebSocketInformation(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StreamWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StreamWebSocketInformation_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StreamWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::StreamWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StreamWebSocketInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StreamWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StreamWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(StreamWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(StreamWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(StreamWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { "server_certificate", reinterpret_cast<getter>(StreamWebSocketInformation_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(StreamWebSocketInformation_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(StreamWebSocketInformation_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(StreamWebSocketInformation_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StreamWebSocketInformation[] = 
    {
        { Py_tp_new, _new_StreamWebSocketInformation },
        { Py_tp_dealloc, _dealloc_StreamWebSocketInformation },
        { Py_tp_methods, _methods_StreamWebSocketInformation },
        { Py_tp_getset, _getset_StreamWebSocketInformation },
        { },
    };

    static PyType_Spec _type_spec_StreamWebSocketInformation =
    {
        "_winsdk_Windows_Networking_Sockets.StreamWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::StreamWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StreamWebSocketInformation
    };

    // ----- WebSocketClosedEventArgs class --------------------
    constexpr const char* const _type_name_WebSocketClosedEventArgs = "WebSocketClosedEventArgs";

    static PyObject* _new_WebSocketClosedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_WebSocketClosedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebSocketClosedEventArgs(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WebSocketClosedEventArgs_get_Code(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Code());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketClosedEventArgs_get_Reason(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WebSocketClosedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketClosedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_WebSocketClosedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebSocketClosedEventArgs[] = {
        { "code", reinterpret_cast<getter>(WebSocketClosedEventArgs_get_Code), nullptr, nullptr, nullptr },
        { "reason", reinterpret_cast<getter>(WebSocketClosedEventArgs_get_Reason), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebSocketClosedEventArgs[] = 
    {
        { Py_tp_new, _new_WebSocketClosedEventArgs },
        { Py_tp_dealloc, _dealloc_WebSocketClosedEventArgs },
        { Py_tp_methods, _methods_WebSocketClosedEventArgs },
        { Py_tp_getset, _getset_WebSocketClosedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_WebSocketClosedEventArgs =
    {
        "_winsdk_Windows_Networking_Sockets.WebSocketClosedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::WebSocketClosedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketClosedEventArgs
    };

    // ----- WebSocketError class --------------------
    constexpr const char* const _type_name_WebSocketError = "WebSocketError";

    static PyObject* _new_WebSocketError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_WebSocketError);
        return nullptr;
    }

    static PyObject* WebSocketError_GetStatus(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Networking::Sockets::WebSocketError::GetStatus(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketError[] = {
        { "get_status", reinterpret_cast<PyCFunction>(WebSocketError_GetStatus), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebSocketError[] = {
        { }
    };

    static PyType_Slot _type_slots_WebSocketError[] = 
    {
        { Py_tp_new, _new_WebSocketError },
        { Py_tp_methods, _methods_WebSocketError },
        { Py_tp_getset, _getset_WebSocketError },
        { },
    };

    static PyType_Spec _type_spec_WebSocketError =
    {
        "_winsdk_Windows_Networking_Sockets.WebSocketError",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketError
    };

    // ----- WebSocketKeepAlive class --------------------
    constexpr const char* const _type_name_WebSocketKeepAlive = "WebSocketKeepAlive";

    static PyObject* _new_WebSocketKeepAlive(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Sockets::WebSocketKeepAlive instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WebSocketKeepAlive(py::wrapper::Windows::Networking::Sockets::WebSocketKeepAlive* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WebSocketKeepAlive_Run(py::wrapper::Windows::Networking::Sockets::WebSocketKeepAlive* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Background::IBackgroundTaskInstance>(args, 0);

                self->obj.Run(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_WebSocketKeepAlive(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::WebSocketKeepAlive>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketKeepAlive[] = {
        { "run", reinterpret_cast<PyCFunction>(WebSocketKeepAlive_Run), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebSocketKeepAlive), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebSocketKeepAlive[] = {
        { }
    };

    static PyType_Slot _type_slots_WebSocketKeepAlive[] = 
    {
        { Py_tp_new, _new_WebSocketKeepAlive },
        { Py_tp_dealloc, _dealloc_WebSocketKeepAlive },
        { Py_tp_methods, _methods_WebSocketKeepAlive },
        { Py_tp_getset, _getset_WebSocketKeepAlive },
        { },
    };

    static PyType_Spec _type_spec_WebSocketKeepAlive =
    {
        "_winsdk_Windows_Networking_Sockets.WebSocketKeepAlive",
        sizeof(py::wrapper::Windows::Networking::Sockets::WebSocketKeepAlive),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketKeepAlive
    };

    // ----- WebSocketServerCustomValidationRequestedEventArgs class --------------------
    constexpr const char* const _type_name_WebSocketServerCustomValidationRequestedEventArgs = "WebSocketServerCustomValidationRequestedEventArgs";

    static PyObject* _new_WebSocketServerCustomValidationRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_WebSocketServerCustomValidationRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebSocketServerCustomValidationRequestedEventArgs(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_GetDeferral(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_Reject(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reject();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebSocketServerCustomValidationRequestedEventArgs_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WebSocketServerCustomValidationRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebSocketServerCustomValidationRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(WebSocketServerCustomValidationRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "reject", reinterpret_cast<PyCFunction>(WebSocketServerCustomValidationRequestedEventArgs_Reject), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WebSocketServerCustomValidationRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebSocketServerCustomValidationRequestedEventArgs[] = {
        { "server_certificate", reinterpret_cast<getter>(WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(WebSocketServerCustomValidationRequestedEventArgs_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(WebSocketServerCustomValidationRequestedEventArgs_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebSocketServerCustomValidationRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_WebSocketServerCustomValidationRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_WebSocketServerCustomValidationRequestedEventArgs },
        { Py_tp_methods, _methods_WebSocketServerCustomValidationRequestedEventArgs },
        { Py_tp_getset, _getset_WebSocketServerCustomValidationRequestedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_WebSocketServerCustomValidationRequestedEventArgs =
    {
        "_winsdk_Windows_Networking_Sockets.WebSocketServerCustomValidationRequestedEventArgs",
        sizeof(py::wrapper::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebSocketServerCustomValidationRequestedEventArgs
    };

    // ----- IControlChannelTriggerEventDetails interface --------------------
    constexpr const char* const _type_name_IControlChannelTriggerEventDetails = "IControlChannelTriggerEventDetails";

    static PyObject* _new_IControlChannelTriggerEventDetails(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IControlChannelTriggerEventDetails);
        return nullptr;
    }

    static void _dealloc_IControlChannelTriggerEventDetails(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerEventDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IControlChannelTriggerEventDetails_get_ControlChannelTrigger(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ControlChannelTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IControlChannelTriggerEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IControlChannelTriggerEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IControlChannelTriggerEventDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IControlChannelTriggerEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IControlChannelTriggerEventDetails[] = {
        { "control_channel_trigger", reinterpret_cast<getter>(IControlChannelTriggerEventDetails_get_ControlChannelTrigger), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IControlChannelTriggerEventDetails[] = 
    {
        { Py_tp_new, _new_IControlChannelTriggerEventDetails },
        { Py_tp_dealloc, _dealloc_IControlChannelTriggerEventDetails },
        { Py_tp_methods, _methods_IControlChannelTriggerEventDetails },
        { Py_tp_getset, _getset_IControlChannelTriggerEventDetails },
        { },
    };

    static PyType_Spec _type_spec_IControlChannelTriggerEventDetails =
    {
        "_winsdk_Windows_Networking_Sockets.IControlChannelTriggerEventDetails",
        sizeof(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IControlChannelTriggerEventDetails
    };

    // ----- IControlChannelTriggerResetEventDetails interface --------------------
    constexpr const char* const _type_name_IControlChannelTriggerResetEventDetails = "IControlChannelTriggerResetEventDetails";

    static PyObject* _new_IControlChannelTriggerResetEventDetails(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IControlChannelTriggerResetEventDetails);
        return nullptr;
    }

    static void _dealloc_IControlChannelTriggerResetEventDetails(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IControlChannelTriggerResetEventDetails_get_HardwareSlotReset(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareSlotReset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IControlChannelTriggerResetEventDetails_get_ResetReason(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResetReason());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IControlChannelTriggerResetEventDetails_get_SoftwareSlotReset(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SoftwareSlotReset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IControlChannelTriggerResetEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IControlChannelTriggerResetEventDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IControlChannelTriggerResetEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IControlChannelTriggerResetEventDetails[] = {
        { "hardware_slot_reset", reinterpret_cast<getter>(IControlChannelTriggerResetEventDetails_get_HardwareSlotReset), nullptr, nullptr, nullptr },
        { "reset_reason", reinterpret_cast<getter>(IControlChannelTriggerResetEventDetails_get_ResetReason), nullptr, nullptr, nullptr },
        { "software_slot_reset", reinterpret_cast<getter>(IControlChannelTriggerResetEventDetails_get_SoftwareSlotReset), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IControlChannelTriggerResetEventDetails[] = 
    {
        { Py_tp_new, _new_IControlChannelTriggerResetEventDetails },
        { Py_tp_dealloc, _dealloc_IControlChannelTriggerResetEventDetails },
        { Py_tp_methods, _methods_IControlChannelTriggerResetEventDetails },
        { Py_tp_getset, _getset_IControlChannelTriggerResetEventDetails },
        { },
    };

    static PyType_Spec _type_spec_IControlChannelTriggerResetEventDetails =
    {
        "_winsdk_Windows_Networking_Sockets.IControlChannelTriggerResetEventDetails",
        sizeof(py::wrapper::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IControlChannelTriggerResetEventDetails
    };

    // ----- IWebSocket interface --------------------
    constexpr const char* const _type_name_IWebSocket = "IWebSocket";

    static PyObject* _new_IWebSocket(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IWebSocket);
        return nullptr;
    }

    static void _dealloc_IWebSocket(py::wrapper::Windows::Networking::Sockets::IWebSocket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IWebSocket_Close(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.Close(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebSocket_ConnectAsync(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(self->obj.ConnectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebSocket_SetRequestHeader(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.SetRequestHeader(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IWebSocket_get_OutputStream(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocket_add_Closed(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::Sockets::IWebSocket, winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>>(arg);

            return py::convert(self->obj.Closed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocket_remove_Closed(py::wrapper::Windows::Networking::Sockets::IWebSocket* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Closed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWebSocket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IWebSocket(py::wrapper::Windows::Networking::Sockets::IWebSocket* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IWebSocket(py::wrapper::Windows::Networking::Sockets::IWebSocket* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocket[] = {
        { "close", reinterpret_cast<PyCFunction>(IWebSocket_Close), METH_VARARGS, nullptr },
        { "connect_async", reinterpret_cast<PyCFunction>(IWebSocket_ConnectAsync), METH_VARARGS, nullptr },
        { "set_request_header", reinterpret_cast<PyCFunction>(IWebSocket_SetRequestHeader), METH_VARARGS, nullptr },
        { "add_closed", reinterpret_cast<PyCFunction>(IWebSocket_add_Closed), METH_O, nullptr },
        { "remove_closed", reinterpret_cast<PyCFunction>(IWebSocket_remove_Closed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocket), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IWebSocket), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IWebSocket), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocket[] = {
        { "output_stream", reinterpret_cast<getter>(IWebSocket_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocket[] = 
    {
        { Py_tp_new, _new_IWebSocket },
        { Py_tp_dealloc, _dealloc_IWebSocket },
        { Py_tp_methods, _methods_IWebSocket },
        { Py_tp_getset, _getset_IWebSocket },
        { },
    };

    static PyType_Spec _type_spec_IWebSocket =
    {
        "_winsdk_Windows_Networking_Sockets.IWebSocket",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocket
    };

    // ----- IWebSocketControl interface --------------------
    constexpr const char* const _type_name_IWebSocketControl = "IWebSocketControl";

    static PyObject* _new_IWebSocketControl(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IWebSocketControl);
        return nullptr;
    }

    static void _dealloc_IWebSocketControl(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IWebSocketControl_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::IWebSocketControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWebSocketControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocketControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocketControl[] = {
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(IWebSocketControl_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(IWebSocketControl_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(IWebSocketControl_get_ProxyCredential), reinterpret_cast<setter>(IWebSocketControl_put_ProxyCredential), nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(IWebSocketControl_get_ServerCredential), reinterpret_cast<setter>(IWebSocketControl_put_ServerCredential), nullptr, nullptr },
        { "supported_protocols", reinterpret_cast<getter>(IWebSocketControl_get_SupportedProtocols), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocketControl[] = 
    {
        { Py_tp_new, _new_IWebSocketControl },
        { Py_tp_dealloc, _dealloc_IWebSocketControl },
        { Py_tp_methods, _methods_IWebSocketControl },
        { Py_tp_getset, _getset_IWebSocketControl },
        { },
    };

    static PyType_Spec _type_spec_IWebSocketControl =
    {
        "_winsdk_Windows_Networking_Sockets.IWebSocketControl",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketControl
    };

    // ----- IWebSocketControl2 interface --------------------
    constexpr const char* const _type_name_IWebSocketControl2 = "IWebSocketControl2";

    static PyObject* _new_IWebSocketControl2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IWebSocketControl2);
        return nullptr;
    }

    static void _dealloc_IWebSocketControl2(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IWebSocketControl2_get_IgnorableServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnorableServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketControl2_get_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBufferSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl2_put_OutboundBufferSizeInBytes(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.OutboundBufferSizeInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl2_get_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl2_put_ProxyCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ProxyCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl2_get_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IWebSocketControl2_put_ServerCredential(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.ServerCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IWebSocketControl2_get_SupportedProtocols(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedProtocols());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWebSocketControl2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketControl2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketControl2[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocketControl2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocketControl2[] = {
        { "ignorable_server_certificate_errors", reinterpret_cast<getter>(IWebSocketControl2_get_IgnorableServerCertificateErrors), nullptr, nullptr, nullptr },
        { "outbound_buffer_size_in_bytes", reinterpret_cast<getter>(IWebSocketControl2_get_OutboundBufferSizeInBytes), reinterpret_cast<setter>(IWebSocketControl2_put_OutboundBufferSizeInBytes), nullptr, nullptr },
        { "proxy_credential", reinterpret_cast<getter>(IWebSocketControl2_get_ProxyCredential), reinterpret_cast<setter>(IWebSocketControl2_put_ProxyCredential), nullptr, nullptr },
        { "server_credential", reinterpret_cast<getter>(IWebSocketControl2_get_ServerCredential), reinterpret_cast<setter>(IWebSocketControl2_put_ServerCredential), nullptr, nullptr },
        { "supported_protocols", reinterpret_cast<getter>(IWebSocketControl2_get_SupportedProtocols), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocketControl2[] = 
    {
        { Py_tp_new, _new_IWebSocketControl2 },
        { Py_tp_dealloc, _dealloc_IWebSocketControl2 },
        { Py_tp_methods, _methods_IWebSocketControl2 },
        { Py_tp_getset, _getset_IWebSocketControl2 },
        { },
    };

    static PyType_Spec _type_spec_IWebSocketControl2 =
    {
        "_winsdk_Windows_Networking_Sockets.IWebSocketControl2",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketControl2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketControl2
    };

    // ----- IWebSocketInformation interface --------------------
    constexpr const char* const _type_name_IWebSocketInformation = "IWebSocketInformation";

    static PyObject* _new_IWebSocketInformation(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IWebSocketInformation);
        return nullptr;
    }

    static void _dealloc_IWebSocketInformation(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IWebSocketInformation_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation_get_Protocol(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWebSocketInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocketInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocketInformation[] = {
        { "bandwidth_statistics", reinterpret_cast<getter>(IWebSocketInformation_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(IWebSocketInformation_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(IWebSocketInformation_get_Protocol), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocketInformation[] = 
    {
        { Py_tp_new, _new_IWebSocketInformation },
        { Py_tp_dealloc, _dealloc_IWebSocketInformation },
        { Py_tp_methods, _methods_IWebSocketInformation },
        { Py_tp_getset, _getset_IWebSocketInformation },
        { },
    };

    static PyType_Spec _type_spec_IWebSocketInformation =
    {
        "_winsdk_Windows_Networking_Sockets.IWebSocketInformation",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketInformation
    };

    // ----- IWebSocketInformation2 interface --------------------
    constexpr const char* const _type_name_IWebSocketInformation2 = "IWebSocketInformation2";

    static PyObject* _new_IWebSocketInformation2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IWebSocketInformation2);
        return nullptr;
    }

    static void _dealloc_IWebSocketInformation2(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IWebSocketInformation2_get_ServerCertificate(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_ServerCertificateErrorSeverity(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrorSeverity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_ServerCertificateErrors(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerCertificateErrors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_ServerIntermediateCertificates(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServerIntermediateCertificates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BandwidthStatistics());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_LocalAddress(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebSocketInformation2_get_Protocol(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Protocol());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWebSocketInformation2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Sockets::IWebSocketInformation2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebSocketInformation2[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebSocketInformation2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebSocketInformation2[] = {
        { "server_certificate", reinterpret_cast<getter>(IWebSocketInformation2_get_ServerCertificate), nullptr, nullptr, nullptr },
        { "server_certificate_error_severity", reinterpret_cast<getter>(IWebSocketInformation2_get_ServerCertificateErrorSeverity), nullptr, nullptr, nullptr },
        { "server_certificate_errors", reinterpret_cast<getter>(IWebSocketInformation2_get_ServerCertificateErrors), nullptr, nullptr, nullptr },
        { "server_intermediate_certificates", reinterpret_cast<getter>(IWebSocketInformation2_get_ServerIntermediateCertificates), nullptr, nullptr, nullptr },
        { "bandwidth_statistics", reinterpret_cast<getter>(IWebSocketInformation2_get_BandwidthStatistics), nullptr, nullptr, nullptr },
        { "local_address", reinterpret_cast<getter>(IWebSocketInformation2_get_LocalAddress), nullptr, nullptr, nullptr },
        { "protocol", reinterpret_cast<getter>(IWebSocketInformation2_get_Protocol), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebSocketInformation2[] = 
    {
        { Py_tp_new, _new_IWebSocketInformation2 },
        { Py_tp_dealloc, _dealloc_IWebSocketInformation2 },
        { Py_tp_methods, _methods_IWebSocketInformation2 },
        { Py_tp_getset, _getset_IWebSocketInformation2 },
        { },
    };

    static PyType_Spec _type_spec_IWebSocketInformation2 =
    {
        "_winsdk_Windows_Networking_Sockets.IWebSocketInformation2",
        sizeof(py::wrapper::Windows::Networking::Sockets::IWebSocketInformation2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebSocketInformation2
    };

    // ----- BandwidthStatistics struct --------------------
    constexpr const char* const _type_name_BandwidthStatistics = "BandwidthStatistics";

    PyObject* _new_BandwidthStatistics(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::Sockets::BandwidthStatistics return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Networking::Sockets::BandwidthStatistics>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _OutboundBitsPerSecond{};
        uint64_t _InboundBitsPerSecond{};
        uint64_t _OutboundBitsPerSecondInstability{};
        uint64_t _InboundBitsPerSecondInstability{};
        bool _OutboundBandwidthPeaked{};
        bool _InboundBandwidthPeaked{};

        static const char* kwlist[] = {"outbound_bits_per_second", "inbound_bits_per_second", "outbound_bits_per_second_instability", "inbound_bits_per_second_instability", "outbound_bandwidth_peaked", "inbound_bandwidth_peaked", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KKKKpp", const_cast<char**>(kwlist), &_OutboundBitsPerSecond, &_InboundBitsPerSecond, &_OutboundBitsPerSecondInstability, &_InboundBitsPerSecondInstability, &_OutboundBandwidthPeaked, &_InboundBandwidthPeaked))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::Sockets::BandwidthStatistics return_value{ _OutboundBitsPerSecond, _InboundBitsPerSecond, _OutboundBitsPerSecondInstability, _InboundBitsPerSecondInstability, _OutboundBandwidthPeaked, _InboundBandwidthPeaked };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_BandwidthStatistics(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self)
    {
    }

    static PyObject* BandwidthStatistics_get_OutboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBitsPerSecond);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_OutboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.OutboundBitsPerSecond = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_InboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBitsPerSecond);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_InboundBitsPerSecond(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.InboundBitsPerSecond = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_OutboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBitsPerSecondInstability);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_OutboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.OutboundBitsPerSecondInstability = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_InboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBitsPerSecondInstability);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_InboundBitsPerSecondInstability(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.InboundBitsPerSecondInstability = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_OutboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBandwidthPeaked);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_OutboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.OutboundBandwidthPeaked = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* BandwidthStatistics_get_InboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBandwidthPeaked);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int BandwidthStatistics_set_InboundBandwidthPeaked(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.InboundBandwidthPeaked = py::converter<bool>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_BandwidthStatistics[] = {
        { "outbound_bits_per_second", reinterpret_cast<getter>(BandwidthStatistics_get_OutboundBitsPerSecond), reinterpret_cast<setter>(BandwidthStatistics_set_OutboundBitsPerSecond), nullptr, nullptr },
        { "inbound_bits_per_second", reinterpret_cast<getter>(BandwidthStatistics_get_InboundBitsPerSecond), reinterpret_cast<setter>(BandwidthStatistics_set_InboundBitsPerSecond), nullptr, nullptr },
        { "outbound_bits_per_second_instability", reinterpret_cast<getter>(BandwidthStatistics_get_OutboundBitsPerSecondInstability), reinterpret_cast<setter>(BandwidthStatistics_set_OutboundBitsPerSecondInstability), nullptr, nullptr },
        { "inbound_bits_per_second_instability", reinterpret_cast<getter>(BandwidthStatistics_get_InboundBitsPerSecondInstability), reinterpret_cast<setter>(BandwidthStatistics_set_InboundBitsPerSecondInstability), nullptr, nullptr },
        { "outbound_bandwidth_peaked", reinterpret_cast<getter>(BandwidthStatistics_get_OutboundBandwidthPeaked), reinterpret_cast<setter>(BandwidthStatistics_set_OutboundBandwidthPeaked), nullptr, nullptr },
        { "inbound_bandwidth_peaked", reinterpret_cast<getter>(BandwidthStatistics_get_InboundBandwidthPeaked), reinterpret_cast<setter>(BandwidthStatistics_set_InboundBandwidthPeaked), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BandwidthStatistics[] = 
    {
        { Py_tp_new, _new_BandwidthStatistics },
        { Py_tp_dealloc, _dealloc_BandwidthStatistics },
        { Py_tp_getset, _getset_BandwidthStatistics },
        { },
    };

    static PyType_Spec _type_spec_BandwidthStatistics =
    {
        "_winsdk_Windows_Networking_Sockets.BandwidthStatistics",
        sizeof(py::wrapper::Windows::Networking::Sockets::BandwidthStatistics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BandwidthStatistics
    };

    // ----- RoundTripTimeStatistics struct --------------------
    constexpr const char* const _type_name_RoundTripTimeStatistics = "RoundTripTimeStatistics";

    PyObject* _new_RoundTripTimeStatistics(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::Sockets::RoundTripTimeStatistics return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _Variance{};
        uint32_t _Max{};
        uint32_t _Min{};
        uint32_t _Sum{};

        static const char* kwlist[] = {"variance", "max", "min", "sum", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIII", const_cast<char**>(kwlist), &_Variance, &_Max, &_Min, &_Sum))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::Sockets::RoundTripTimeStatistics return_value{ _Variance, _Max, _Min, _Sum };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_RoundTripTimeStatistics(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self)
    {
    }

    static PyObject* RoundTripTimeStatistics_get_Variance(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Variance);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Variance(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Variance = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RoundTripTimeStatistics_get_Max(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Max(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Max = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RoundTripTimeStatistics_get_Min(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Min(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Min = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RoundTripTimeStatistics_get_Sum(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Sum);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RoundTripTimeStatistics_set_Sum(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Sum = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_RoundTripTimeStatistics[] = {
        { "variance", reinterpret_cast<getter>(RoundTripTimeStatistics_get_Variance), reinterpret_cast<setter>(RoundTripTimeStatistics_set_Variance), nullptr, nullptr },
        { "max", reinterpret_cast<getter>(RoundTripTimeStatistics_get_Max), reinterpret_cast<setter>(RoundTripTimeStatistics_set_Max), nullptr, nullptr },
        { "min", reinterpret_cast<getter>(RoundTripTimeStatistics_get_Min), reinterpret_cast<setter>(RoundTripTimeStatistics_set_Min), nullptr, nullptr },
        { "sum", reinterpret_cast<getter>(RoundTripTimeStatistics_get_Sum), reinterpret_cast<setter>(RoundTripTimeStatistics_set_Sum), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RoundTripTimeStatistics[] = 
    {
        { Py_tp_new, _new_RoundTripTimeStatistics },
        { Py_tp_dealloc, _dealloc_RoundTripTimeStatistics },
        { Py_tp_getset, _getset_RoundTripTimeStatistics },
        { },
    };

    static PyType_Spec _type_spec_RoundTripTimeStatistics =
    {
        "_winsdk_Windows_Networking_Sockets.RoundTripTimeStatistics",
        sizeof(py::wrapper::Windows::Networking::Sockets::RoundTripTimeStatistics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RoundTripTimeStatistics
    };

    // ----- Windows.Networking.Sockets Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Networking::Sockets::ControlChannelTrigger>::python_type = py::register_python_type(module, _type_name_ControlChannelTrigger, &_type_spec_ControlChannelTrigger, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocket>::python_type = py::register_python_type(module, _type_name_DatagramSocket, &_type_spec_DatagramSocket, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketControl>::python_type = py::register_python_type(module, _type_name_DatagramSocketControl, &_type_spec_DatagramSocketControl, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketInformation>::python_type = py::register_python_type(module, _type_name_DatagramSocketInformation, &_type_spec_DatagramSocketInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::DatagramSocketMessageReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_DatagramSocketMessageReceivedEventArgs, &_type_spec_DatagramSocketMessageReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocket>::python_type = py::register_python_type(module, _type_name_MessageWebSocket, &_type_spec_MessageWebSocket, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketControl>::python_type = py::register_python_type(module, _type_name_MessageWebSocketControl, &_type_spec_MessageWebSocketControl, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketInformation>::python_type = py::register_python_type(module, _type_name_MessageWebSocketInformation, &_type_spec_MessageWebSocketInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::MessageWebSocketMessageReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_MessageWebSocketMessageReceivedEventArgs, &_type_spec_MessageWebSocketMessageReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocket>::python_type = py::register_python_type(module, _type_name_ServerMessageWebSocket, &_type_spec_ServerMessageWebSocket, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocketControl>::python_type = py::register_python_type(module, _type_name_ServerMessageWebSocketControl, &_type_spec_ServerMessageWebSocketControl, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::ServerMessageWebSocketInformation>::python_type = py::register_python_type(module, _type_name_ServerMessageWebSocketInformation, &_type_spec_ServerMessageWebSocketInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::ServerStreamWebSocket>::python_type = py::register_python_type(module, _type_name_ServerStreamWebSocket, &_type_spec_ServerStreamWebSocket, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::ServerStreamWebSocketInformation>::python_type = py::register_python_type(module, _type_name_ServerStreamWebSocketInformation, &_type_spec_ServerStreamWebSocketInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityContext>::python_type = py::register_python_type(module, _type_name_SocketActivityContext, &_type_spec_SocketActivityContext, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityInformation>::python_type = py::register_python_type(module, _type_name_SocketActivityInformation, &_type_spec_SocketActivityInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::SocketActivityTriggerDetails>::python_type = py::register_python_type(module, _type_name_SocketActivityTriggerDetails, &_type_spec_SocketActivityTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::SocketError>::python_type = py::register_python_type(module, _type_name_SocketError, &_type_spec_SocketError, nullptr);
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocket>::python_type = py::register_python_type(module, _type_name_StreamSocket, &_type_spec_StreamSocket, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketControl>::python_type = py::register_python_type(module, _type_name_StreamSocketControl, &_type_spec_StreamSocketControl, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketInformation>::python_type = py::register_python_type(module, _type_name_StreamSocketInformation, &_type_spec_StreamSocketInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListener>::python_type = py::register_python_type(module, _type_name_StreamSocketListener, &_type_spec_StreamSocketListener, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerConnectionReceivedEventArgs>::python_type = py::register_python_type(module, _type_name_StreamSocketListenerConnectionReceivedEventArgs, &_type_spec_StreamSocketListenerConnectionReceivedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerControl>::python_type = py::register_python_type(module, _type_name_StreamSocketListenerControl, &_type_spec_StreamSocketListenerControl, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamSocketListenerInformation>::python_type = py::register_python_type(module, _type_name_StreamSocketListenerInformation, &_type_spec_StreamSocketListenerInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocket>::python_type = py::register_python_type(module, _type_name_StreamWebSocket, &_type_spec_StreamWebSocket, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocketControl>::python_type = py::register_python_type(module, _type_name_StreamWebSocketControl, &_type_spec_StreamWebSocketControl, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::StreamWebSocketInformation>::python_type = py::register_python_type(module, _type_name_StreamWebSocketInformation, &_type_spec_StreamWebSocketInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketClosedEventArgs>::python_type = py::register_python_type(module, _type_name_WebSocketClosedEventArgs, &_type_spec_WebSocketClosedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketError>::python_type = py::register_python_type(module, _type_name_WebSocketError, &_type_spec_WebSocketError, nullptr);
            py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketKeepAlive>::python_type = py::register_python_type(module, _type_name_WebSocketKeepAlive, &_type_spec_WebSocketKeepAlive, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::WebSocketServerCustomValidationRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_WebSocketServerCustomValidationRequestedEventArgs, &_type_spec_WebSocketServerCustomValidationRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::IControlChannelTriggerEventDetails>::python_type = py::register_python_type(module, _type_name_IControlChannelTriggerEventDetails, &_type_spec_IControlChannelTriggerEventDetails, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::IControlChannelTriggerResetEventDetails>::python_type = py::register_python_type(module, _type_name_IControlChannelTriggerResetEventDetails, &_type_spec_IControlChannelTriggerResetEventDetails, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocket>::python_type = py::register_python_type(module, _type_name_IWebSocket, &_type_spec_IWebSocket, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketControl>::python_type = py::register_python_type(module, _type_name_IWebSocketControl, &_type_spec_IWebSocketControl, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketControl2>::python_type = py::register_python_type(module, _type_name_IWebSocketControl2, &_type_spec_IWebSocketControl2, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketInformation>::python_type = py::register_python_type(module, _type_name_IWebSocketInformation, &_type_spec_IWebSocketInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::IWebSocketInformation2>::python_type = py::register_python_type(module, _type_name_IWebSocketInformation2, &_type_spec_IWebSocketInformation2, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::BandwidthStatistics>::python_type = py::register_python_type(module, _type_name_BandwidthStatistics, &_type_spec_BandwidthStatistics, bases.get());
            py::winrt_type<winrt::Windows::Networking::Sockets::RoundTripTimeStatistics>::python_type = py::register_python_type(module, _type_name_RoundTripTimeStatistics, &_type_spec_RoundTripTimeStatistics, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Networking.Sockets");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Networking_Sockets",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Networking::Sockets

PyMODINIT_FUNC
PyInit__winsdk_Windows_Networking_Sockets (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Networking::Sockets::module_def);
}
