// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.4

#include "pybase.h"
#include "py.Windows.ApplicationModel.Appointments.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::Appointment>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendar>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentConflictResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentException>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentInvitee>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentManagerForUser>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentOrganizer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentRecurrence>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStore>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChange>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreNotificationTriggerDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Appointments::IAppointmentParticipant>::python_type;

namespace py::cpp::Windows::ApplicationModel::Appointments
{
    // ----- Appointment class --------------------
    constexpr const char* const _type_name_Appointment = "Appointment";

    static PyObject* _new_Appointment(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Appointments::Appointment instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_Appointment(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Appointment_get_Location(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Location(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Location(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_AllDay(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllDay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_AllDay(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllDay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Organizer(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Organizer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Organizer(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentOrganizer>(arg);

            self->obj.Organizer(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Duration(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Duration(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Details(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Details());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Details(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Details(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_BusyStatus(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BusyStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_BusyStatus(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentBusyStatus>(arg);

            self->obj.BusyStatus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Recurrence(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Recurrence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Recurrence(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentRecurrence>(arg);

            self->obj.Recurrence(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Subject(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Subject(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subject(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Uri(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Uri(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.Uri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_StartTime(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_StartTime(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.StartTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Sensitivity(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Sensitivity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Sensitivity(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentSensitivity>(arg);

            self->obj.Sensitivity(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Reminder(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Reminder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_Reminder(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Reminder(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_Invitees(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Invitees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Appointment_get_AllowNewTimeProposal(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowNewTimeProposal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_AllowNewTimeProposal(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowNewTimeProposal(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_UserResponse(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserResponse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_UserResponse(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentParticipantResponse>(arg);

            self->obj.UserResponse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_RoamingId(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoamingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_RoamingId(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RoamingId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_ReplyTime(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReplyTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_ReplyTime(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ReplyTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_IsResponseRequested(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsResponseRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_IsResponseRequested(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsResponseRequested(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_IsOrganizedByUser(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOrganizedByUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_IsOrganizedByUser(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsOrganizedByUser(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_IsCanceledMeeting(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCanceledMeeting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_IsCanceledMeeting(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCanceledMeeting(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_OnlineMeetingLink(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OnlineMeetingLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_OnlineMeetingLink(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.OnlineMeetingLink(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_HasInvitees(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasInvitees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Appointment_get_CalendarId(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CalendarId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Appointment_get_LocalId(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Appointment_get_OriginalStartTime(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OriginalStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Appointment_get_RemoteChangeNumber(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteChangeNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_RemoteChangeNumber(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.RemoteChangeNumber(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_DetailsKind(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetailsKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Appointment_put_DetailsKind(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentDetailsKind>(arg);

            self->obj.DetailsKind(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Appointment_get_ChangeNumber(py::wrapper::Windows::ApplicationModel::Appointments::Appointment* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Appointment(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::Appointment>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Appointment[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_Appointment), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Appointment[] = {
        { "location", reinterpret_cast<getter>(Appointment_get_Location), reinterpret_cast<setter>(Appointment_put_Location), nullptr, nullptr },
        { "all_day", reinterpret_cast<getter>(Appointment_get_AllDay), reinterpret_cast<setter>(Appointment_put_AllDay), nullptr, nullptr },
        { "organizer", reinterpret_cast<getter>(Appointment_get_Organizer), reinterpret_cast<setter>(Appointment_put_Organizer), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(Appointment_get_Duration), reinterpret_cast<setter>(Appointment_put_Duration), nullptr, nullptr },
        { "details", reinterpret_cast<getter>(Appointment_get_Details), reinterpret_cast<setter>(Appointment_put_Details), nullptr, nullptr },
        { "busy_status", reinterpret_cast<getter>(Appointment_get_BusyStatus), reinterpret_cast<setter>(Appointment_put_BusyStatus), nullptr, nullptr },
        { "recurrence", reinterpret_cast<getter>(Appointment_get_Recurrence), reinterpret_cast<setter>(Appointment_put_Recurrence), nullptr, nullptr },
        { "subject", reinterpret_cast<getter>(Appointment_get_Subject), reinterpret_cast<setter>(Appointment_put_Subject), nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(Appointment_get_Uri), reinterpret_cast<setter>(Appointment_put_Uri), nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(Appointment_get_StartTime), reinterpret_cast<setter>(Appointment_put_StartTime), nullptr, nullptr },
        { "sensitivity", reinterpret_cast<getter>(Appointment_get_Sensitivity), reinterpret_cast<setter>(Appointment_put_Sensitivity), nullptr, nullptr },
        { "reminder", reinterpret_cast<getter>(Appointment_get_Reminder), reinterpret_cast<setter>(Appointment_put_Reminder), nullptr, nullptr },
        { "invitees", reinterpret_cast<getter>(Appointment_get_Invitees), nullptr, nullptr, nullptr },
        { "allow_new_time_proposal", reinterpret_cast<getter>(Appointment_get_AllowNewTimeProposal), reinterpret_cast<setter>(Appointment_put_AllowNewTimeProposal), nullptr, nullptr },
        { "user_response", reinterpret_cast<getter>(Appointment_get_UserResponse), reinterpret_cast<setter>(Appointment_put_UserResponse), nullptr, nullptr },
        { "roaming_id", reinterpret_cast<getter>(Appointment_get_RoamingId), reinterpret_cast<setter>(Appointment_put_RoamingId), nullptr, nullptr },
        { "reply_time", reinterpret_cast<getter>(Appointment_get_ReplyTime), reinterpret_cast<setter>(Appointment_put_ReplyTime), nullptr, nullptr },
        { "is_response_requested", reinterpret_cast<getter>(Appointment_get_IsResponseRequested), reinterpret_cast<setter>(Appointment_put_IsResponseRequested), nullptr, nullptr },
        { "is_organized_by_user", reinterpret_cast<getter>(Appointment_get_IsOrganizedByUser), reinterpret_cast<setter>(Appointment_put_IsOrganizedByUser), nullptr, nullptr },
        { "is_canceled_meeting", reinterpret_cast<getter>(Appointment_get_IsCanceledMeeting), reinterpret_cast<setter>(Appointment_put_IsCanceledMeeting), nullptr, nullptr },
        { "online_meeting_link", reinterpret_cast<getter>(Appointment_get_OnlineMeetingLink), reinterpret_cast<setter>(Appointment_put_OnlineMeetingLink), nullptr, nullptr },
        { "has_invitees", reinterpret_cast<getter>(Appointment_get_HasInvitees), nullptr, nullptr, nullptr },
        { "calendar_id", reinterpret_cast<getter>(Appointment_get_CalendarId), nullptr, nullptr, nullptr },
        { "local_id", reinterpret_cast<getter>(Appointment_get_LocalId), nullptr, nullptr, nullptr },
        { "original_start_time", reinterpret_cast<getter>(Appointment_get_OriginalStartTime), nullptr, nullptr, nullptr },
        { "remote_change_number", reinterpret_cast<getter>(Appointment_get_RemoteChangeNumber), reinterpret_cast<setter>(Appointment_put_RemoteChangeNumber), nullptr, nullptr },
        { "details_kind", reinterpret_cast<getter>(Appointment_get_DetailsKind), reinterpret_cast<setter>(Appointment_put_DetailsKind), nullptr, nullptr },
        { "change_number", reinterpret_cast<getter>(Appointment_get_ChangeNumber), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Appointment[] = 
    {
        { Py_tp_new, _new_Appointment },
        { Py_tp_dealloc, _dealloc_Appointment },
        { Py_tp_methods, _methods_Appointment },
        { Py_tp_getset, _getset_Appointment },
        { },
    };

    static PyType_Spec _type_spec_Appointment =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.Appointment",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::Appointment),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Appointment
    };

    // ----- AppointmentCalendar class --------------------
    constexpr const char* const _type_name_AppointmentCalendar = "AppointmentCalendar";

    static PyObject* _new_AppointmentCalendar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppointmentCalendar);
        return nullptr;
    }

    static void _dealloc_AppointmentCalendar(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppointmentCalendar_DeleteAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteAppointmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_DeleteAppointmentInstanceAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.DeleteAppointmentInstanceAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_DeleteAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_FindAllInstancesAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);

                return py::convert(self->obj.FindAllInstancesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions>(args, 3);

                return py::convert(self->obj.FindAllInstancesAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_FindAppointmentsAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.FindAppointmentsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions>(args, 2);

                return py::convert(self->obj.FindAppointmentsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_FindExceptionsFromMasterAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindExceptionsFromMasterAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_FindUnexpandedAppointmentsAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindUnexpandedAppointmentsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions>(args, 0);

                return py::convert(self->obj.FindUnexpandedAppointmentsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_GetAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAppointmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_GetAppointmentInstanceAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.GetAppointmentInstanceAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_RegisterSyncManagerAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RegisterSyncManagerAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_SaveAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);

                return py::convert(self->obj.SaveAppointmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_SaveAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SaveAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_TryCancelMeetingAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<bool>(args, 3);

                return py::convert(self->obj.TryCancelMeetingAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_TryCreateOrUpdateAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.TryCreateOrUpdateAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_TryForwardMeetingAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::ApplicationModel::Appointments::AppointmentInvitee>>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                return py::convert(self->obj.TryForwardMeetingAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_TryProposeNewTimeForMeetingAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);

                return py::convert(self->obj.TryProposeNewTimeForMeetingAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_TryUpdateMeetingResponseAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentParticipantResponse>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);
                auto param4 = py::convert_to<bool>(args, 4);

                return py::convert(self->obj.TryUpdateMeetingResponseAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_get_SummaryCardView(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SummaryCardView());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_SummaryCardView(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentSummaryCardView>(arg);

            self->obj.SummaryCardView(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OtherAppWriteAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_OtherAppWriteAccess(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarOtherAppWriteAccess>(arg);

            self->obj.OtherAppWriteAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_DisplayColor(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_DisplayColor(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.DisplayColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_IsHidden(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHidden());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_IsHidden(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsHidden(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OtherAppReadAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_OtherAppReadAccess(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarOtherAppReadAccess>(arg);

            self->obj.OtherAppReadAccess(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_LocalId(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_get_SourceDisplayName(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_get_CanCancelMeetings(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanCancelMeetings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_CanCancelMeetings(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanCancelMeetings(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_CanNotifyInvitees(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanNotifyInvitees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_CanNotifyInvitees(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanNotifyInvitees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_RemoteId(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_RemoteId(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RemoteId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_MustNofityInvitees(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MustNofityInvitees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_MustNofityInvitees(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.MustNofityInvitees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_CanUpdateMeetingResponses(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanUpdateMeetingResponses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_CanUpdateMeetingResponses(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanUpdateMeetingResponses(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_CanProposeNewTimeForMeetings(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanProposeNewTimeForMeetings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_CanProposeNewTimeForMeetings(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanProposeNewTimeForMeetings(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_CanCreateOrUpdateAppointments(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanCreateOrUpdateAppointments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_CanCreateOrUpdateAppointments(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanCreateOrUpdateAppointments(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_CanForwardMeetings(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanForwardMeetings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendar_put_CanForwardMeetings(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.CanForwardMeetings(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendar_get_SyncManager(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SyncManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendar_get_UserDataAccountId(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserDataAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentCalendar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentCalendar[] = {
        { "delete_appointment_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_DeleteAppointmentAsync), METH_VARARGS, nullptr },
        { "delete_appointment_instance_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_DeleteAppointmentInstanceAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_DeleteAsync), METH_VARARGS, nullptr },
        { "find_all_instances_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_FindAllInstancesAsync), METH_VARARGS, nullptr },
        { "find_appointments_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_FindAppointmentsAsync), METH_VARARGS, nullptr },
        { "find_exceptions_from_master_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_FindExceptionsFromMasterAsync), METH_VARARGS, nullptr },
        { "find_unexpanded_appointments_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_FindUnexpandedAppointmentsAsync), METH_VARARGS, nullptr },
        { "get_appointment_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_GetAppointmentAsync), METH_VARARGS, nullptr },
        { "get_appointment_instance_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_GetAppointmentInstanceAsync), METH_VARARGS, nullptr },
        { "register_sync_manager_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_RegisterSyncManagerAsync), METH_VARARGS, nullptr },
        { "save_appointment_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_SaveAppointmentAsync), METH_VARARGS, nullptr },
        { "save_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_SaveAsync), METH_VARARGS, nullptr },
        { "try_cancel_meeting_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_TryCancelMeetingAsync), METH_VARARGS, nullptr },
        { "try_create_or_update_appointment_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_TryCreateOrUpdateAppointmentAsync), METH_VARARGS, nullptr },
        { "try_forward_meeting_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_TryForwardMeetingAsync), METH_VARARGS, nullptr },
        { "try_propose_new_time_for_meeting_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_TryProposeNewTimeForMeetingAsync), METH_VARARGS, nullptr },
        { "try_update_meeting_response_async", reinterpret_cast<PyCFunction>(AppointmentCalendar_TryUpdateMeetingResponseAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentCalendar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentCalendar[] = {
        { "summary_card_view", reinterpret_cast<getter>(AppointmentCalendar_get_SummaryCardView), reinterpret_cast<setter>(AppointmentCalendar_put_SummaryCardView), nullptr, nullptr },
        { "other_app_write_access", reinterpret_cast<getter>(AppointmentCalendar_get_OtherAppWriteAccess), reinterpret_cast<setter>(AppointmentCalendar_put_OtherAppWriteAccess), nullptr, nullptr },
        { "display_color", reinterpret_cast<getter>(AppointmentCalendar_get_DisplayColor), reinterpret_cast<setter>(AppointmentCalendar_put_DisplayColor), nullptr, nullptr },
        { "is_hidden", reinterpret_cast<getter>(AppointmentCalendar_get_IsHidden), reinterpret_cast<setter>(AppointmentCalendar_put_IsHidden), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(AppointmentCalendar_get_DisplayName), reinterpret_cast<setter>(AppointmentCalendar_put_DisplayName), nullptr, nullptr },
        { "other_app_read_access", reinterpret_cast<getter>(AppointmentCalendar_get_OtherAppReadAccess), reinterpret_cast<setter>(AppointmentCalendar_put_OtherAppReadAccess), nullptr, nullptr },
        { "local_id", reinterpret_cast<getter>(AppointmentCalendar_get_LocalId), nullptr, nullptr, nullptr },
        { "source_display_name", reinterpret_cast<getter>(AppointmentCalendar_get_SourceDisplayName), nullptr, nullptr, nullptr },
        { "can_cancel_meetings", reinterpret_cast<getter>(AppointmentCalendar_get_CanCancelMeetings), reinterpret_cast<setter>(AppointmentCalendar_put_CanCancelMeetings), nullptr, nullptr },
        { "can_notify_invitees", reinterpret_cast<getter>(AppointmentCalendar_get_CanNotifyInvitees), reinterpret_cast<setter>(AppointmentCalendar_put_CanNotifyInvitees), nullptr, nullptr },
        { "remote_id", reinterpret_cast<getter>(AppointmentCalendar_get_RemoteId), reinterpret_cast<setter>(AppointmentCalendar_put_RemoteId), nullptr, nullptr },
        { "must_nofity_invitees", reinterpret_cast<getter>(AppointmentCalendar_get_MustNofityInvitees), reinterpret_cast<setter>(AppointmentCalendar_put_MustNofityInvitees), nullptr, nullptr },
        { "can_update_meeting_responses", reinterpret_cast<getter>(AppointmentCalendar_get_CanUpdateMeetingResponses), reinterpret_cast<setter>(AppointmentCalendar_put_CanUpdateMeetingResponses), nullptr, nullptr },
        { "can_propose_new_time_for_meetings", reinterpret_cast<getter>(AppointmentCalendar_get_CanProposeNewTimeForMeetings), reinterpret_cast<setter>(AppointmentCalendar_put_CanProposeNewTimeForMeetings), nullptr, nullptr },
        { "can_create_or_update_appointments", reinterpret_cast<getter>(AppointmentCalendar_get_CanCreateOrUpdateAppointments), reinterpret_cast<setter>(AppointmentCalendar_put_CanCreateOrUpdateAppointments), nullptr, nullptr },
        { "can_forward_meetings", reinterpret_cast<getter>(AppointmentCalendar_get_CanForwardMeetings), reinterpret_cast<setter>(AppointmentCalendar_put_CanForwardMeetings), nullptr, nullptr },
        { "sync_manager", reinterpret_cast<getter>(AppointmentCalendar_get_SyncManager), nullptr, nullptr, nullptr },
        { "user_data_account_id", reinterpret_cast<getter>(AppointmentCalendar_get_UserDataAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentCalendar[] = 
    {
        { Py_tp_new, _new_AppointmentCalendar },
        { Py_tp_dealloc, _dealloc_AppointmentCalendar },
        { Py_tp_methods, _methods_AppointmentCalendar },
        { Py_tp_getset, _getset_AppointmentCalendar },
        { },
    };

    static PyType_Spec _type_spec_AppointmentCalendar =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentCalendar",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentCalendar
    };

    // ----- AppointmentCalendarSyncManager class --------------------
    constexpr const char* const _type_name_AppointmentCalendarSyncManager = "AppointmentCalendarSyncManager";

    static PyObject* _new_AppointmentCalendarSyncManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppointmentCalendarSyncManager);
        return nullptr;
    }

    static void _dealloc_AppointmentCalendarSyncManager(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppointmentCalendarSyncManager_SyncAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SyncAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendarSyncManager_get_Status(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendarSyncManager_put_Status(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendarSyncManager_get_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastSuccessfulSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendarSyncManager_put_LastSuccessfulSyncTime(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastSuccessfulSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendarSyncManager_get_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastAttemptedSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentCalendarSyncManager_put_LastAttemptedSyncTime(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(arg);

            self->obj.LastAttemptedSyncTime(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentCalendarSyncManager_add_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.SyncStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentCalendarSyncManager_remove_SyncStatusChanged(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SyncStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentCalendarSyncManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentCalendarSyncManager[] = {
        { "sync_async", reinterpret_cast<PyCFunction>(AppointmentCalendarSyncManager_SyncAsync), METH_VARARGS, nullptr },
        { "add_sync_status_changed", reinterpret_cast<PyCFunction>(AppointmentCalendarSyncManager_add_SyncStatusChanged), METH_O, nullptr },
        { "remove_sync_status_changed", reinterpret_cast<PyCFunction>(AppointmentCalendarSyncManager_remove_SyncStatusChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentCalendarSyncManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentCalendarSyncManager[] = {
        { "status", reinterpret_cast<getter>(AppointmentCalendarSyncManager_get_Status), reinterpret_cast<setter>(AppointmentCalendarSyncManager_put_Status), nullptr, nullptr },
        { "last_successful_sync_time", reinterpret_cast<getter>(AppointmentCalendarSyncManager_get_LastSuccessfulSyncTime), reinterpret_cast<setter>(AppointmentCalendarSyncManager_put_LastSuccessfulSyncTime), nullptr, nullptr },
        { "last_attempted_sync_time", reinterpret_cast<getter>(AppointmentCalendarSyncManager_get_LastAttemptedSyncTime), reinterpret_cast<setter>(AppointmentCalendarSyncManager_put_LastAttemptedSyncTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentCalendarSyncManager[] = 
    {
        { Py_tp_new, _new_AppointmentCalendarSyncManager },
        { Py_tp_dealloc, _dealloc_AppointmentCalendarSyncManager },
        { Py_tp_methods, _methods_AppointmentCalendarSyncManager },
        { Py_tp_getset, _getset_AppointmentCalendarSyncManager },
        { },
    };

    static PyType_Spec _type_spec_AppointmentCalendarSyncManager =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentCalendarSyncManager",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentCalendarSyncManager
    };

    // ----- AppointmentConflictResult class --------------------
    constexpr const char* const _type_name_AppointmentConflictResult = "AppointmentConflictResult";

    static PyObject* _new_AppointmentConflictResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppointmentConflictResult);
        return nullptr;
    }

    static void _dealloc_AppointmentConflictResult(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentConflictResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppointmentConflictResult_get_Date(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentConflictResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentConflictResult_get_Type(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentConflictResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentConflictResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentConflictResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentConflictResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentConflictResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentConflictResult[] = {
        { "date", reinterpret_cast<getter>(AppointmentConflictResult_get_Date), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(AppointmentConflictResult_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentConflictResult[] = 
    {
        { Py_tp_new, _new_AppointmentConflictResult },
        { Py_tp_dealloc, _dealloc_AppointmentConflictResult },
        { Py_tp_methods, _methods_AppointmentConflictResult },
        { Py_tp_getset, _getset_AppointmentConflictResult },
        { },
    };

    static PyType_Spec _type_spec_AppointmentConflictResult =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentConflictResult",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentConflictResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentConflictResult
    };

    // ----- AppointmentException class --------------------
    constexpr const char* const _type_name_AppointmentException = "AppointmentException";

    static PyObject* _new_AppointmentException(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppointmentException);
        return nullptr;
    }

    static void _dealloc_AppointmentException(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentException* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppointmentException_get_Appointment(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentException* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Appointment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentException_get_ExceptionProperties(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentException* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExceptionProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentException_get_IsDeleted(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentException* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDeleted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentException(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentException>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentException[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentException), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentException[] = {
        { "appointment", reinterpret_cast<getter>(AppointmentException_get_Appointment), nullptr, nullptr, nullptr },
        { "exception_properties", reinterpret_cast<getter>(AppointmentException_get_ExceptionProperties), nullptr, nullptr, nullptr },
        { "is_deleted", reinterpret_cast<getter>(AppointmentException_get_IsDeleted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentException[] = 
    {
        { Py_tp_new, _new_AppointmentException },
        { Py_tp_dealloc, _dealloc_AppointmentException },
        { Py_tp_methods, _methods_AppointmentException },
        { Py_tp_getset, _getset_AppointmentException },
        { },
    };

    static PyType_Spec _type_spec_AppointmentException =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentException",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentException),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentException
    };

    // ----- AppointmentInvitee class --------------------
    constexpr const char* const _type_name_AppointmentInvitee = "AppointmentInvitee";

    static PyObject* _new_AppointmentInvitee(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Appointments::AppointmentInvitee instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppointmentInvitee(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppointmentInvitee_get_Role(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Role());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentInvitee_put_Role(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentParticipantRole>(arg);

            self->obj.Role(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentInvitee_get_Response(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentInvitee_put_Response(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentParticipantResponse>(arg);

            self->obj.Response(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentInvitee_get_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentInvitee_put_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentInvitee_get_Address(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentInvitee_put_Address(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AppointmentInvitee(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentInvitee>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentInvitee[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentInvitee), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentInvitee[] = {
        { "role", reinterpret_cast<getter>(AppointmentInvitee_get_Role), reinterpret_cast<setter>(AppointmentInvitee_put_Role), nullptr, nullptr },
        { "response", reinterpret_cast<getter>(AppointmentInvitee_get_Response), reinterpret_cast<setter>(AppointmentInvitee_put_Response), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(AppointmentInvitee_get_DisplayName), reinterpret_cast<setter>(AppointmentInvitee_put_DisplayName), nullptr, nullptr },
        { "address", reinterpret_cast<getter>(AppointmentInvitee_get_Address), reinterpret_cast<setter>(AppointmentInvitee_put_Address), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentInvitee[] = 
    {
        { Py_tp_new, _new_AppointmentInvitee },
        { Py_tp_dealloc, _dealloc_AppointmentInvitee },
        { Py_tp_methods, _methods_AppointmentInvitee },
        { Py_tp_getset, _getset_AppointmentInvitee },
        { },
    };

    static PyType_Spec _type_spec_AppointmentInvitee =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentInvitee",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentInvitee),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentInvitee
    };

    // ----- AppointmentManager class --------------------
    constexpr const char* const _type_name_AppointmentManager = "AppointmentManager";

    static PyObject* _new_AppointmentManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppointmentManager);
        return nullptr;
    }

    static PyObject* AppointmentManager_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreAccessType>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManager_ShowAddAppointmentAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowAddAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowAddAppointmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManager_ShowAppointmentDetailsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowAppointmentDetailsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowAppointmentDetailsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManager_ShowEditNewAppointmentAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowEditNewAppointmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManager_ShowRemoveAppointmentAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowRemoveAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowRemoveAppointmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 3);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowRemoveAppointmentAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManager_ShowReplaceAppointmentAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowReplaceAppointmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 3);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowReplaceAppointmentAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 4);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowReplaceAppointmentAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManager_ShowTimeFrameAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentManager::ShowTimeFrameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentManager[] = {
        { "get_for_user", reinterpret_cast<PyCFunction>(AppointmentManager_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "request_store_async", reinterpret_cast<PyCFunction>(AppointmentManager_RequestStoreAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_add_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManager_ShowAddAppointmentAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_appointment_details_async", reinterpret_cast<PyCFunction>(AppointmentManager_ShowAppointmentDetailsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_edit_new_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManager_ShowEditNewAppointmentAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_remove_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManager_ShowRemoveAppointmentAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_replace_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManager_ShowReplaceAppointmentAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "show_time_frame_async", reinterpret_cast<PyCFunction>(AppointmentManager_ShowTimeFrameAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AppointmentManager[] = 
    {
        { Py_tp_new, _new_AppointmentManager },
        { Py_tp_methods, _methods_AppointmentManager },
        { Py_tp_getset, _getset_AppointmentManager },
        { },
    };

    static PyType_Spec _type_spec_AppointmentManager =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentManager
    };

    // ----- AppointmentManagerForUser class --------------------
    constexpr const char* const _type_name_AppointmentManagerForUser = "AppointmentManagerForUser";

    static PyObject* _new_AppointmentManagerForUser(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppointmentManagerForUser);
        return nullptr;
    }

    static void _dealloc_AppointmentManagerForUser(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppointmentManagerForUser_RequestStoreAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreAccessType>(args, 0);

                return py::convert(self->obj.RequestStoreAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManagerForUser_ShowAddAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.ShowAddAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);

                return py::convert(self->obj.ShowAddAppointmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManagerForUser_ShowAppointmentDetailsAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ShowAppointmentDetailsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.ShowAppointmentDetailsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManagerForUser_ShowEditNewAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);

                return py::convert(self->obj.ShowEditNewAppointmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManagerForUser_ShowRemoveAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.ShowRemoveAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);

                return py::convert(self->obj.ShowRemoveAppointmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 3);

                return py::convert(self->obj.ShowRemoveAppointmentAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManagerForUser_ShowReplaceAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);

                return py::convert(self->obj.ShowReplaceAppointmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 3);

                return py::convert(self->obj.ShowReplaceAppointmentAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 4);

                return py::convert(self->obj.ShowReplaceAppointmentAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManagerForUser_ShowTimeFrameAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.ShowTimeFrameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentManagerForUser_get_User(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentManagerForUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentManagerForUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentManagerForUser[] = {
        { "request_store_async", reinterpret_cast<PyCFunction>(AppointmentManagerForUser_RequestStoreAsync), METH_VARARGS, nullptr },
        { "show_add_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManagerForUser_ShowAddAppointmentAsync), METH_VARARGS, nullptr },
        { "show_appointment_details_async", reinterpret_cast<PyCFunction>(AppointmentManagerForUser_ShowAppointmentDetailsAsync), METH_VARARGS, nullptr },
        { "show_edit_new_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManagerForUser_ShowEditNewAppointmentAsync), METH_VARARGS, nullptr },
        { "show_remove_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManagerForUser_ShowRemoveAppointmentAsync), METH_VARARGS, nullptr },
        { "show_replace_appointment_async", reinterpret_cast<PyCFunction>(AppointmentManagerForUser_ShowReplaceAppointmentAsync), METH_VARARGS, nullptr },
        { "show_time_frame_async", reinterpret_cast<PyCFunction>(AppointmentManagerForUser_ShowTimeFrameAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentManagerForUser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentManagerForUser[] = {
        { "user", reinterpret_cast<getter>(AppointmentManagerForUser_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentManagerForUser[] = 
    {
        { Py_tp_new, _new_AppointmentManagerForUser },
        { Py_tp_dealloc, _dealloc_AppointmentManagerForUser },
        { Py_tp_methods, _methods_AppointmentManagerForUser },
        { Py_tp_getset, _getset_AppointmentManagerForUser },
        { },
    };

    static PyType_Spec _type_spec_AppointmentManagerForUser =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentManagerForUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentManagerForUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentManagerForUser
    };

    // ----- AppointmentOrganizer class --------------------
    constexpr const char* const _type_name_AppointmentOrganizer = "AppointmentOrganizer";

    static PyObject* _new_AppointmentOrganizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Appointments::AppointmentOrganizer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppointmentOrganizer(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentOrganizer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppointmentOrganizer_get_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentOrganizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentOrganizer_put_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentOrganizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentOrganizer_get_Address(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentOrganizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentOrganizer_put_Address(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentOrganizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AppointmentOrganizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentOrganizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentOrganizer[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentOrganizer), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentOrganizer[] = {
        { "display_name", reinterpret_cast<getter>(AppointmentOrganizer_get_DisplayName), reinterpret_cast<setter>(AppointmentOrganizer_put_DisplayName), nullptr, nullptr },
        { "address", reinterpret_cast<getter>(AppointmentOrganizer_get_Address), reinterpret_cast<setter>(AppointmentOrganizer_put_Address), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentOrganizer[] = 
    {
        { Py_tp_new, _new_AppointmentOrganizer },
        { Py_tp_dealloc, _dealloc_AppointmentOrganizer },
        { Py_tp_methods, _methods_AppointmentOrganizer },
        { Py_tp_getset, _getset_AppointmentOrganizer },
        { },
    };

    static PyType_Spec _type_spec_AppointmentOrganizer =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentOrganizer",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentOrganizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentOrganizer
    };

    // ----- AppointmentProperties class --------------------
    constexpr const char* const _type_name_AppointmentProperties = "AppointmentProperties";

    static PyObject* _new_AppointmentProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppointmentProperties);
        return nullptr;
    }

    static PyObject* AppointmentProperties_get_HasInvitees(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::HasInvitees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_AllDay(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::AllDay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_AllowNewTimeProposal(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::AllowNewTimeProposal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_BusyStatus(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::BusyStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_DefaultProperties(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::DefaultProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Details(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Details());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Duration(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Recurrence(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Recurrence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Invitees(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Invitees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_IsCanceledMeeting(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::IsCanceledMeeting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_IsOrganizedByUser(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::IsOrganizedByUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_IsResponseRequested(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::IsResponseRequested());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Location(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Location());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_OnlineMeetingLink(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::OnlineMeetingLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Organizer(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Organizer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_OriginalStartTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::OriginalStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Reminder(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Reminder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_ReplyTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::ReplyTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Sensitivity(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Sensitivity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_StartTime(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Subject(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Subject());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_Uri(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_UserResponse(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::UserResponse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_DetailsKind(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::DetailsKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_RemoteChangeNumber(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::RemoteChangeNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentProperties_get_ChangeNumber(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::Appointments::AppointmentProperties::ChangeNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentProperties[] = {
        { "get_has_invitees", reinterpret_cast<PyCFunction>(AppointmentProperties_get_HasInvitees), METH_NOARGS | METH_STATIC, nullptr },
        { "get_all_day", reinterpret_cast<PyCFunction>(AppointmentProperties_get_AllDay), METH_NOARGS | METH_STATIC, nullptr },
        { "get_allow_new_time_proposal", reinterpret_cast<PyCFunction>(AppointmentProperties_get_AllowNewTimeProposal), METH_NOARGS | METH_STATIC, nullptr },
        { "get_busy_status", reinterpret_cast<PyCFunction>(AppointmentProperties_get_BusyStatus), METH_NOARGS | METH_STATIC, nullptr },
        { "get_default_properties", reinterpret_cast<PyCFunction>(AppointmentProperties_get_DefaultProperties), METH_NOARGS | METH_STATIC, nullptr },
        { "get_details", reinterpret_cast<PyCFunction>(AppointmentProperties_get_Details), METH_NOARGS | METH_STATIC, nullptr },
        { "get_duration", reinterpret_cast<PyCFunction>(AppointmentProperties_get_Duration), METH_NOARGS | METH_STATIC, nullptr },
        { "get_recurrence", reinterpret_cast<PyCFunction>(AppointmentProperties_get_Recurrence), METH_NOARGS | METH_STATIC, nullptr },
        { "get_invitees", reinterpret_cast<PyCFunction>(AppointmentProperties_get_Invitees), METH_NOARGS | METH_STATIC, nullptr },
        { "get_is_canceled_meeting", reinterpret_cast<PyCFunction>(AppointmentProperties_get_IsCanceledMeeting), METH_NOARGS | METH_STATIC, nullptr },
        { "get_is_organized_by_user", reinterpret_cast<PyCFunction>(AppointmentProperties_get_IsOrganizedByUser), METH_NOARGS | METH_STATIC, nullptr },
        { "get_is_response_requested", reinterpret_cast<PyCFunction>(AppointmentProperties_get_IsResponseRequested), METH_NOARGS | METH_STATIC, nullptr },
        { "get_location", reinterpret_cast<PyCFunction>(AppointmentProperties_get_Location), METH_NOARGS | METH_STATIC, nullptr },
        { "get_online_meeting_link", reinterpret_cast<PyCFunction>(AppointmentProperties_get_OnlineMeetingLink), METH_NOARGS | METH_STATIC, nullptr },
        { "get_organizer", reinterpret_cast<PyCFunction>(AppointmentProperties_get_Organizer), METH_NOARGS | METH_STATIC, nullptr },
        { "get_original_start_time", reinterpret_cast<PyCFunction>(AppointmentProperties_get_OriginalStartTime), METH_NOARGS | METH_STATIC, nullptr },
        { "get_reminder", reinterpret_cast<PyCFunction>(AppointmentProperties_get_Reminder), METH_NOARGS | METH_STATIC, nullptr },
        { "get_reply_time", reinterpret_cast<PyCFunction>(AppointmentProperties_get_ReplyTime), METH_NOARGS | METH_STATIC, nullptr },
        { "get_sensitivity", reinterpret_cast<PyCFunction>(AppointmentProperties_get_Sensitivity), METH_NOARGS | METH_STATIC, nullptr },
        { "get_start_time", reinterpret_cast<PyCFunction>(AppointmentProperties_get_StartTime), METH_NOARGS | METH_STATIC, nullptr },
        { "get_subject", reinterpret_cast<PyCFunction>(AppointmentProperties_get_Subject), METH_NOARGS | METH_STATIC, nullptr },
        { "get_uri", reinterpret_cast<PyCFunction>(AppointmentProperties_get_Uri), METH_NOARGS | METH_STATIC, nullptr },
        { "get_user_response", reinterpret_cast<PyCFunction>(AppointmentProperties_get_UserResponse), METH_NOARGS | METH_STATIC, nullptr },
        { "get_details_kind", reinterpret_cast<PyCFunction>(AppointmentProperties_get_DetailsKind), METH_NOARGS | METH_STATIC, nullptr },
        { "get_remote_change_number", reinterpret_cast<PyCFunction>(AppointmentProperties_get_RemoteChangeNumber), METH_NOARGS | METH_STATIC, nullptr },
        { "get_change_number", reinterpret_cast<PyCFunction>(AppointmentProperties_get_ChangeNumber), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_AppointmentProperties[] = 
    {
        { Py_tp_new, _new_AppointmentProperties },
        { Py_tp_methods, _methods_AppointmentProperties },
        { Py_tp_getset, _getset_AppointmentProperties },
        { },
    };

    static PyType_Spec _type_spec_AppointmentProperties =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentProperties
    };

    // ----- AppointmentRecurrence class --------------------
    constexpr const char* const _type_name_AppointmentRecurrence = "AppointmentRecurrence";

    static PyObject* _new_AppointmentRecurrence(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Appointments::AppointmentRecurrence instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AppointmentRecurrence(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppointmentRecurrence_get_Unit(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Unit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_Unit(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentRecurrenceUnit>(arg);

            self->obj.Unit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_Occurrences(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Occurrences());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_Occurrences(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Occurrences(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_Month(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Month());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_Month(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Month(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_Interval(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_Interval(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Interval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_DaysOfWeek(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DaysOfWeek());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_DaysOfWeek(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentDaysOfWeek>(arg);

            self->obj.DaysOfWeek(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_Day(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Day());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_Day(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Day(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_WeekOfMonth(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WeekOfMonth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_WeekOfMonth(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentWeekOfMonth>(arg);

            self->obj.WeekOfMonth(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_Until(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Until());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_Until(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.Until(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_TimeZone(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeZone());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AppointmentRecurrence_put_TimeZone(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.TimeZone(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AppointmentRecurrence_get_RecurrenceType(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecurrenceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentRecurrence_get_CalendarIdentifier(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CalendarIdentifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentRecurrence(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentRecurrence>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentRecurrence[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentRecurrence), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentRecurrence[] = {
        { "unit", reinterpret_cast<getter>(AppointmentRecurrence_get_Unit), reinterpret_cast<setter>(AppointmentRecurrence_put_Unit), nullptr, nullptr },
        { "occurrences", reinterpret_cast<getter>(AppointmentRecurrence_get_Occurrences), reinterpret_cast<setter>(AppointmentRecurrence_put_Occurrences), nullptr, nullptr },
        { "month", reinterpret_cast<getter>(AppointmentRecurrence_get_Month), reinterpret_cast<setter>(AppointmentRecurrence_put_Month), nullptr, nullptr },
        { "interval", reinterpret_cast<getter>(AppointmentRecurrence_get_Interval), reinterpret_cast<setter>(AppointmentRecurrence_put_Interval), nullptr, nullptr },
        { "days_of_week", reinterpret_cast<getter>(AppointmentRecurrence_get_DaysOfWeek), reinterpret_cast<setter>(AppointmentRecurrence_put_DaysOfWeek), nullptr, nullptr },
        { "day", reinterpret_cast<getter>(AppointmentRecurrence_get_Day), reinterpret_cast<setter>(AppointmentRecurrence_put_Day), nullptr, nullptr },
        { "week_of_month", reinterpret_cast<getter>(AppointmentRecurrence_get_WeekOfMonth), reinterpret_cast<setter>(AppointmentRecurrence_put_WeekOfMonth), nullptr, nullptr },
        { "until", reinterpret_cast<getter>(AppointmentRecurrence_get_Until), reinterpret_cast<setter>(AppointmentRecurrence_put_Until), nullptr, nullptr },
        { "time_zone", reinterpret_cast<getter>(AppointmentRecurrence_get_TimeZone), reinterpret_cast<setter>(AppointmentRecurrence_put_TimeZone), nullptr, nullptr },
        { "recurrence_type", reinterpret_cast<getter>(AppointmentRecurrence_get_RecurrenceType), nullptr, nullptr, nullptr },
        { "calendar_identifier", reinterpret_cast<getter>(AppointmentRecurrence_get_CalendarIdentifier), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentRecurrence[] = 
    {
        { Py_tp_new, _new_AppointmentRecurrence },
        { Py_tp_dealloc, _dealloc_AppointmentRecurrence },
        { Py_tp_methods, _methods_AppointmentRecurrence },
        { Py_tp_getset, _getset_AppointmentRecurrence },
        { },
    };

    static PyType_Spec _type_spec_AppointmentRecurrence =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentRecurrence",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentRecurrence),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentRecurrence
    };

    // ----- AppointmentStore class --------------------
    constexpr const char* const _type_name_AppointmentStore = "AppointmentStore";

    static PyObject* _new_AppointmentStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppointmentStore);
        return nullptr;
    }

    static void _dealloc_AppointmentStore(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppointmentStore_CreateAppointmentCalendarAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CreateAppointmentCalendarAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateAppointmentCalendarAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_FindAppointmentCalendarsAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindAppointmentCalendarsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::FindAppointmentCalendarsOptions>(args, 0);

                return py::convert(self->obj.FindAppointmentCalendarsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_FindAppointmentsAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.FindAppointmentsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions>(args, 2);

                return py::convert(self->obj.FindAppointmentsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_FindConflictAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);

                return py::convert(self->obj.FindConflictAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.FindConflictAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_FindLocalIdsFromRoamingIdAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindLocalIdsFromRoamingIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_GetAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAppointmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_GetAppointmentCalendarAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAppointmentCalendarAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_GetAppointmentInstanceAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.GetAppointmentInstanceAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_GetChangeTracker(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetChangeTracker(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_MoveAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendar>(args, 1);

                return py::convert(self->obj.MoveAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_ShowAddAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.ShowAddAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_ShowAppointmentDetailsAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ShowAppointmentDetailsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.ShowAppointmentDetailsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_ShowEditNewAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 0);

                return py::convert(self->obj.ShowEditNewAppointmentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_ShowRemoveAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                return py::convert(self->obj.ShowRemoveAppointmentAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 3);

                return py::convert(self->obj.ShowRemoveAppointmentAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_ShowReplaceAppointmentAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);

                return py::convert(self->obj.ShowReplaceAppointmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::Appointment>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::UI::Popups::Placement>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 4);

                return py::convert(self->obj.ShowReplaceAppointmentAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_get_ChangeTracker(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeTracker());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_add_StoreChanged(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Appointments::AppointmentStore, winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs>>(arg);

            return py::convert(self->obj.StoreChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentStore_remove_StoreChanged(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StoreChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStore[] = {
        { "create_appointment_calendar_async", reinterpret_cast<PyCFunction>(AppointmentStore_CreateAppointmentCalendarAsync), METH_VARARGS, nullptr },
        { "find_appointment_calendars_async", reinterpret_cast<PyCFunction>(AppointmentStore_FindAppointmentCalendarsAsync), METH_VARARGS, nullptr },
        { "find_appointments_async", reinterpret_cast<PyCFunction>(AppointmentStore_FindAppointmentsAsync), METH_VARARGS, nullptr },
        { "find_conflict_async", reinterpret_cast<PyCFunction>(AppointmentStore_FindConflictAsync), METH_VARARGS, nullptr },
        { "find_local_ids_from_roaming_id_async", reinterpret_cast<PyCFunction>(AppointmentStore_FindLocalIdsFromRoamingIdAsync), METH_VARARGS, nullptr },
        { "get_appointment_async", reinterpret_cast<PyCFunction>(AppointmentStore_GetAppointmentAsync), METH_VARARGS, nullptr },
        { "get_appointment_calendar_async", reinterpret_cast<PyCFunction>(AppointmentStore_GetAppointmentCalendarAsync), METH_VARARGS, nullptr },
        { "get_appointment_instance_async", reinterpret_cast<PyCFunction>(AppointmentStore_GetAppointmentInstanceAsync), METH_VARARGS, nullptr },
        { "get_change_tracker", reinterpret_cast<PyCFunction>(AppointmentStore_GetChangeTracker), METH_VARARGS, nullptr },
        { "move_appointment_async", reinterpret_cast<PyCFunction>(AppointmentStore_MoveAppointmentAsync), METH_VARARGS, nullptr },
        { "show_add_appointment_async", reinterpret_cast<PyCFunction>(AppointmentStore_ShowAddAppointmentAsync), METH_VARARGS, nullptr },
        { "show_appointment_details_async", reinterpret_cast<PyCFunction>(AppointmentStore_ShowAppointmentDetailsAsync), METH_VARARGS, nullptr },
        { "show_edit_new_appointment_async", reinterpret_cast<PyCFunction>(AppointmentStore_ShowEditNewAppointmentAsync), METH_VARARGS, nullptr },
        { "show_remove_appointment_async", reinterpret_cast<PyCFunction>(AppointmentStore_ShowRemoveAppointmentAsync), METH_VARARGS, nullptr },
        { "show_replace_appointment_async", reinterpret_cast<PyCFunction>(AppointmentStore_ShowReplaceAppointmentAsync), METH_VARARGS, nullptr },
        { "add_store_changed", reinterpret_cast<PyCFunction>(AppointmentStore_add_StoreChanged), METH_O, nullptr },
        { "remove_store_changed", reinterpret_cast<PyCFunction>(AppointmentStore_remove_StoreChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStore[] = {
        { "change_tracker", reinterpret_cast<getter>(AppointmentStore_get_ChangeTracker), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentStore[] = 
    {
        { Py_tp_new, _new_AppointmentStore },
        { Py_tp_dealloc, _dealloc_AppointmentStore },
        { Py_tp_methods, _methods_AppointmentStore },
        { Py_tp_getset, _getset_AppointmentStore },
        { },
    };

    static PyType_Spec _type_spec_AppointmentStore =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStore
    };

    // ----- AppointmentStoreChange class --------------------
    constexpr const char* const _type_name_AppointmentStoreChange = "AppointmentStoreChange";

    static PyObject* _new_AppointmentStoreChange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppointmentStoreChange);
        return nullptr;
    }

    static void _dealloc_AppointmentStoreChange(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChange* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppointmentStoreChange_get_Appointment(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Appointment());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentStoreChange_get_ChangeType(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentStoreChange_get_AppointmentCalendar(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppointmentCalendar());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentStoreChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreChange[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStoreChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStoreChange[] = {
        { "appointment", reinterpret_cast<getter>(AppointmentStoreChange_get_Appointment), nullptr, nullptr, nullptr },
        { "change_type", reinterpret_cast<getter>(AppointmentStoreChange_get_ChangeType), nullptr, nullptr, nullptr },
        { "appointment_calendar", reinterpret_cast<getter>(AppointmentStoreChange_get_AppointmentCalendar), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentStoreChange[] = 
    {
        { Py_tp_new, _new_AppointmentStoreChange },
        { Py_tp_dealloc, _dealloc_AppointmentStoreChange },
        { Py_tp_methods, _methods_AppointmentStoreChange },
        { Py_tp_getset, _getset_AppointmentStoreChange },
        { },
    };

    static PyType_Spec _type_spec_AppointmentStoreChange =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentStoreChange",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreChange
    };

    // ----- AppointmentStoreChangeReader class --------------------
    constexpr const char* const _type_name_AppointmentStoreChangeReader = "AppointmentStoreChangeReader";

    static PyObject* _new_AppointmentStoreChangeReader(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppointmentStoreChangeReader);
        return nullptr;
    }

    static void _dealloc_AppointmentStoreChangeReader(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppointmentStoreChangeReader_AcceptChanges(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.AcceptChanges();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStoreChangeReader_AcceptChangesThrough(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChange>(args, 0);

                self->obj.AcceptChangesThrough(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStoreChangeReader_ReadBatchAsync(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ReadBatchAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentStoreChangeReader(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreChangeReader[] = {
        { "accept_changes", reinterpret_cast<PyCFunction>(AppointmentStoreChangeReader_AcceptChanges), METH_VARARGS, nullptr },
        { "accept_changes_through", reinterpret_cast<PyCFunction>(AppointmentStoreChangeReader_AcceptChangesThrough), METH_VARARGS, nullptr },
        { "read_batch_async", reinterpret_cast<PyCFunction>(AppointmentStoreChangeReader_ReadBatchAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStoreChangeReader), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStoreChangeReader[] = {
        { }
    };

    static PyType_Slot _type_slots_AppointmentStoreChangeReader[] = 
    {
        { Py_tp_new, _new_AppointmentStoreChangeReader },
        { Py_tp_dealloc, _dealloc_AppointmentStoreChangeReader },
        { Py_tp_methods, _methods_AppointmentStoreChangeReader },
        { Py_tp_getset, _getset_AppointmentStoreChangeReader },
        { },
    };

    static PyType_Spec _type_spec_AppointmentStoreChangeReader =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentStoreChangeReader",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreChangeReader
    };

    // ----- AppointmentStoreChangeTracker class --------------------
    constexpr const char* const _type_name_AppointmentStoreChangeTracker = "AppointmentStoreChangeTracker";

    static PyObject* _new_AppointmentStoreChangeTracker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppointmentStoreChangeTracker);
        return nullptr;
    }

    static void _dealloc_AppointmentStoreChangeTracker(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppointmentStoreChangeTracker_Enable(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Enable();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStoreChangeTracker_GetChangeReader(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetChangeReader());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStoreChangeTracker_Reset(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Reset();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppointmentStoreChangeTracker_get_IsTracking(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTracking());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentStoreChangeTracker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreChangeTracker[] = {
        { "enable", reinterpret_cast<PyCFunction>(AppointmentStoreChangeTracker_Enable), METH_VARARGS, nullptr },
        { "get_change_reader", reinterpret_cast<PyCFunction>(AppointmentStoreChangeTracker_GetChangeReader), METH_VARARGS, nullptr },
        { "reset", reinterpret_cast<PyCFunction>(AppointmentStoreChangeTracker_Reset), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStoreChangeTracker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStoreChangeTracker[] = {
        { "is_tracking", reinterpret_cast<getter>(AppointmentStoreChangeTracker_get_IsTracking), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentStoreChangeTracker[] = 
    {
        { Py_tp_new, _new_AppointmentStoreChangeTracker },
        { Py_tp_dealloc, _dealloc_AppointmentStoreChangeTracker },
        { Py_tp_methods, _methods_AppointmentStoreChangeTracker },
        { Py_tp_getset, _getset_AppointmentStoreChangeTracker },
        { },
    };

    static PyType_Spec _type_spec_AppointmentStoreChangeTracker =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentStoreChangeTracker",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreChangeTracker
    };

    // ----- AppointmentStoreChangedDeferral class --------------------
    constexpr const char* const _type_name_AppointmentStoreChangedDeferral = "AppointmentStoreChangedDeferral";

    static PyObject* _new_AppointmentStoreChangedDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppointmentStoreChangedDeferral);
        return nullptr;
    }

    static void _dealloc_AppointmentStoreChangedDeferral(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangedDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppointmentStoreChangedDeferral_Complete(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangedDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentStoreChangedDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreChangedDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(AppointmentStoreChangedDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStoreChangedDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStoreChangedDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_AppointmentStoreChangedDeferral[] = 
    {
        { Py_tp_new, _new_AppointmentStoreChangedDeferral },
        { Py_tp_dealloc, _dealloc_AppointmentStoreChangedDeferral },
        { Py_tp_methods, _methods_AppointmentStoreChangedDeferral },
        { Py_tp_getset, _getset_AppointmentStoreChangedDeferral },
        { },
    };

    static PyType_Spec _type_spec_AppointmentStoreChangedDeferral =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentStoreChangedDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangedDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreChangedDeferral
    };

    // ----- AppointmentStoreChangedEventArgs class --------------------
    constexpr const char* const _type_name_AppointmentStoreChangedEventArgs = "AppointmentStoreChangedEventArgs";

    static PyObject* _new_AppointmentStoreChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppointmentStoreChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppointmentStoreChangedEventArgs(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppointmentStoreChangedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentStoreChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreChangedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(AppointmentStoreChangedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStoreChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStoreChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_AppointmentStoreChangedEventArgs[] = 
    {
        { Py_tp_new, _new_AppointmentStoreChangedEventArgs },
        { Py_tp_dealloc, _dealloc_AppointmentStoreChangedEventArgs },
        { Py_tp_methods, _methods_AppointmentStoreChangedEventArgs },
        { Py_tp_getset, _getset_AppointmentStoreChangedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_AppointmentStoreChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentStoreChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreChangedEventArgs
    };

    // ----- AppointmentStoreNotificationTriggerDetails class --------------------
    constexpr const char* const _type_name_AppointmentStoreNotificationTriggerDetails = "AppointmentStoreNotificationTriggerDetails";

    static PyObject* _new_AppointmentStoreNotificationTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppointmentStoreNotificationTriggerDetails);
        return nullptr;
    }

    static void _dealloc_AppointmentStoreNotificationTriggerDetails(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreNotificationTriggerDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_AppointmentStoreNotificationTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreNotificationTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentStoreNotificationTriggerDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentStoreNotificationTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentStoreNotificationTriggerDetails[] = {
        { }
    };

    static PyType_Slot _type_slots_AppointmentStoreNotificationTriggerDetails[] = 
    {
        { Py_tp_new, _new_AppointmentStoreNotificationTriggerDetails },
        { Py_tp_dealloc, _dealloc_AppointmentStoreNotificationTriggerDetails },
        { Py_tp_methods, _methods_AppointmentStoreNotificationTriggerDetails },
        { Py_tp_getset, _getset_AppointmentStoreNotificationTriggerDetails },
        { },
    };

    static PyType_Spec _type_spec_AppointmentStoreNotificationTriggerDetails =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.AppointmentStoreNotificationTriggerDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::AppointmentStoreNotificationTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentStoreNotificationTriggerDetails
    };

    // ----- FindAppointmentsOptions class --------------------
    constexpr const char* const _type_name_FindAppointmentsOptions = "FindAppointmentsOptions";

    static PyObject* _new_FindAppointmentsOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FindAppointmentsOptions(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FindAppointmentsOptions_get_MaxCount(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindAppointmentsOptions_put_MaxCount(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MaxCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindAppointmentsOptions_get_IncludeHidden(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IncludeHidden());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FindAppointmentsOptions_put_IncludeHidden(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IncludeHidden(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FindAppointmentsOptions_get_CalendarIds(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CalendarIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FindAppointmentsOptions_get_FetchProperties(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FetchProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FindAppointmentsOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FindAppointmentsOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FindAppointmentsOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FindAppointmentsOptions[] = {
        { "max_count", reinterpret_cast<getter>(FindAppointmentsOptions_get_MaxCount), reinterpret_cast<setter>(FindAppointmentsOptions_put_MaxCount), nullptr, nullptr },
        { "include_hidden", reinterpret_cast<getter>(FindAppointmentsOptions_get_IncludeHidden), reinterpret_cast<setter>(FindAppointmentsOptions_put_IncludeHidden), nullptr, nullptr },
        { "calendar_ids", reinterpret_cast<getter>(FindAppointmentsOptions_get_CalendarIds), nullptr, nullptr, nullptr },
        { "fetch_properties", reinterpret_cast<getter>(FindAppointmentsOptions_get_FetchProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FindAppointmentsOptions[] = 
    {
        { Py_tp_new, _new_FindAppointmentsOptions },
        { Py_tp_dealloc, _dealloc_FindAppointmentsOptions },
        { Py_tp_methods, _methods_FindAppointmentsOptions },
        { Py_tp_getset, _getset_FindAppointmentsOptions },
        { },
    };

    static PyType_Spec _type_spec_FindAppointmentsOptions =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.FindAppointmentsOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::FindAppointmentsOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FindAppointmentsOptions
    };

    // ----- IAppointmentParticipant interface --------------------
    constexpr const char* const _type_name_IAppointmentParticipant = "IAppointmentParticipant";

    static PyObject* _new_IAppointmentParticipant(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAppointmentParticipant);
        return nullptr;
    }

    static void _dealloc_IAppointmentParticipant(py::wrapper::Windows::ApplicationModel::Appointments::IAppointmentParticipant* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IAppointmentParticipant_get_Address(py::wrapper::Windows::ApplicationModel::Appointments::IAppointmentParticipant* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAppointmentParticipant_put_Address(py::wrapper::Windows::ApplicationModel::Appointments::IAppointmentParticipant* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Address(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IAppointmentParticipant_get_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::IAppointmentParticipant* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IAppointmentParticipant_put_DisplayName(py::wrapper::Windows::ApplicationModel::Appointments::IAppointmentParticipant* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_IAppointmentParticipant(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Appointments::IAppointmentParticipant>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentParticipant[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentParticipant), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAppointmentParticipant[] = {
        { "address", reinterpret_cast<getter>(IAppointmentParticipant_get_Address), reinterpret_cast<setter>(IAppointmentParticipant_put_Address), nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(IAppointmentParticipant_get_DisplayName), reinterpret_cast<setter>(IAppointmentParticipant_put_DisplayName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAppointmentParticipant[] = 
    {
        { Py_tp_new, _new_IAppointmentParticipant },
        { Py_tp_dealloc, _dealloc_IAppointmentParticipant },
        { Py_tp_methods, _methods_IAppointmentParticipant },
        { Py_tp_getset, _getset_IAppointmentParticipant },
        { },
    };

    static PyType_Spec _type_spec_IAppointmentParticipant =
    {
        "_winsdk_Windows_ApplicationModel_Appointments.IAppointmentParticipant",
        sizeof(py::wrapper::Windows::ApplicationModel::Appointments::IAppointmentParticipant),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAppointmentParticipant
    };

    // ----- Windows.ApplicationModel.Appointments Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::Appointment>::python_type = py::register_python_type(module, _type_name_Appointment, &_type_spec_Appointment, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendar>::python_type = py::register_python_type(module, _type_name_AppointmentCalendar, &_type_spec_AppointmentCalendar, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentCalendarSyncManager>::python_type = py::register_python_type(module, _type_name_AppointmentCalendarSyncManager, &_type_spec_AppointmentCalendarSyncManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentConflictResult>::python_type = py::register_python_type(module, _type_name_AppointmentConflictResult, &_type_spec_AppointmentConflictResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentException>::python_type = py::register_python_type(module, _type_name_AppointmentException, &_type_spec_AppointmentException, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentInvitee>::python_type = py::register_python_type(module, _type_name_AppointmentInvitee, &_type_spec_AppointmentInvitee, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentManager>::python_type = py::register_python_type(module, _type_name_AppointmentManager, &_type_spec_AppointmentManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentManagerForUser>::python_type = py::register_python_type(module, _type_name_AppointmentManagerForUser, &_type_spec_AppointmentManagerForUser, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentOrganizer>::python_type = py::register_python_type(module, _type_name_AppointmentOrganizer, &_type_spec_AppointmentOrganizer, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentProperties>::python_type = py::register_python_type(module, _type_name_AppointmentProperties, &_type_spec_AppointmentProperties, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentRecurrence>::python_type = py::register_python_type(module, _type_name_AppointmentRecurrence, &_type_spec_AppointmentRecurrence, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStore>::python_type = py::register_python_type(module, _type_name_AppointmentStore, &_type_spec_AppointmentStore, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChange>::python_type = py::register_python_type(module, _type_name_AppointmentStoreChange, &_type_spec_AppointmentStoreChange, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangeReader>::python_type = py::register_python_type(module, _type_name_AppointmentStoreChangeReader, &_type_spec_AppointmentStoreChangeReader, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangeTracker>::python_type = py::register_python_type(module, _type_name_AppointmentStoreChangeTracker, &_type_spec_AppointmentStoreChangeTracker, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedDeferral>::python_type = py::register_python_type(module, _type_name_AppointmentStoreChangedDeferral, &_type_spec_AppointmentStoreChangedDeferral, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreChangedEventArgs>::python_type = py::register_python_type(module, _type_name_AppointmentStoreChangedEventArgs, &_type_spec_AppointmentStoreChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::AppointmentStoreNotificationTriggerDetails>::python_type = py::register_python_type(module, _type_name_AppointmentStoreNotificationTriggerDetails, &_type_spec_AppointmentStoreNotificationTriggerDetails, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::FindAppointmentsOptions>::python_type = py::register_python_type(module, _type_name_FindAppointmentsOptions, &_type_spec_FindAppointmentsOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::Appointments::IAppointmentParticipant>::python_type = py::register_python_type(module, _type_name_IAppointmentParticipant, &_type_spec_IAppointmentParticipant, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.Appointments");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_Appointments",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::ApplicationModel::Appointments

PyMODINIT_FUNC
PyInit__winsdk_Windows_ApplicationModel_Appointments (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::Appointments::module_def);
}
