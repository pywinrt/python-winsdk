// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.ApplicationModel.DataTransfer.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::Clipboard>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataPackageView>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataProviderDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataProviderRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataRequestDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::HtmlFormatHelper>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ShareProvider>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ShareProviderOperation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ShareTargetInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ShareUIOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::SharedStorageAccessManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs>::python_type;

namespace py::cpp::Windows::ApplicationModel::DataTransfer
{
    // ----- Clipboard class --------------------
    constexpr const char* const _type_name_Clipboard = "Clipboard";

    static PyObject* _new_Clipboard(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Clipboard);
        return nullptr;
    }

    static PyObject* Clipboard_Clear(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::DataTransfer::Clipboard::Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_ClearHistory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::ClearHistory());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_DeleteItemFromHistory(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::DeleteItemFromHistory(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_Flush(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::DataTransfer::Clipboard::Flush();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_GetContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::GetContent());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_GetHistoryItemsAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::GetHistoryItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_IsHistoryEnabled(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::IsHistoryEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_IsRoamingEnabled(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::IsRoamingEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_SetContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>(args, 0);

                winrt::Windows::ApplicationModel::DataTransfer::Clipboard::SetContent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_SetContentWithOptions(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions>(args, 1);

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::SetContentWithOptions(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_SetHistoryItemAsContent(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::SetHistoryItemAsContent(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Clipboard_add_HistoryChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryChangedEventArgs>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::HistoryChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Clipboard_remove_HistoryChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::DataTransfer::Clipboard::HistoryChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Clipboard_add_HistoryEnabledChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::HistoryEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Clipboard_remove_HistoryEnabledChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::DataTransfer::Clipboard::HistoryEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Clipboard_add_RoamingEnabledChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::RoamingEnabledChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Clipboard_remove_RoamingEnabledChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::DataTransfer::Clipboard::RoamingEnabledChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Clipboard_add_ContentChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::Clipboard::ContentChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Clipboard_remove_ContentChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::ApplicationModel::DataTransfer::Clipboard::ContentChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Clipboard[] = {
        { "clear", reinterpret_cast<PyCFunction>(Clipboard_Clear), METH_VARARGS | METH_STATIC, nullptr },
        { "clear_history", reinterpret_cast<PyCFunction>(Clipboard_ClearHistory), METH_VARARGS | METH_STATIC, nullptr },
        { "delete_item_from_history", reinterpret_cast<PyCFunction>(Clipboard_DeleteItemFromHistory), METH_VARARGS | METH_STATIC, nullptr },
        { "flush", reinterpret_cast<PyCFunction>(Clipboard_Flush), METH_VARARGS | METH_STATIC, nullptr },
        { "get_content", reinterpret_cast<PyCFunction>(Clipboard_GetContent), METH_VARARGS | METH_STATIC, nullptr },
        { "get_history_items_async", reinterpret_cast<PyCFunction>(Clipboard_GetHistoryItemsAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "is_history_enabled", reinterpret_cast<PyCFunction>(Clipboard_IsHistoryEnabled), METH_VARARGS | METH_STATIC, nullptr },
        { "is_roaming_enabled", reinterpret_cast<PyCFunction>(Clipboard_IsRoamingEnabled), METH_VARARGS | METH_STATIC, nullptr },
        { "set_content", reinterpret_cast<PyCFunction>(Clipboard_SetContent), METH_VARARGS | METH_STATIC, nullptr },
        { "set_content_with_options", reinterpret_cast<PyCFunction>(Clipboard_SetContentWithOptions), METH_VARARGS | METH_STATIC, nullptr },
        { "set_history_item_as_content", reinterpret_cast<PyCFunction>(Clipboard_SetHistoryItemAsContent), METH_VARARGS | METH_STATIC, nullptr },
        { "add_history_changed", reinterpret_cast<PyCFunction>(Clipboard_add_HistoryChanged), METH_O | METH_STATIC, nullptr },
        { "remove_history_changed", reinterpret_cast<PyCFunction>(Clipboard_remove_HistoryChanged), METH_O | METH_STATIC, nullptr },
        { "add_history_enabled_changed", reinterpret_cast<PyCFunction>(Clipboard_add_HistoryEnabledChanged), METH_O | METH_STATIC, nullptr },
        { "remove_history_enabled_changed", reinterpret_cast<PyCFunction>(Clipboard_remove_HistoryEnabledChanged), METH_O | METH_STATIC, nullptr },
        { "add_roaming_enabled_changed", reinterpret_cast<PyCFunction>(Clipboard_add_RoamingEnabledChanged), METH_O | METH_STATIC, nullptr },
        { "remove_roaming_enabled_changed", reinterpret_cast<PyCFunction>(Clipboard_remove_RoamingEnabledChanged), METH_O | METH_STATIC, nullptr },
        { "add_content_changed", reinterpret_cast<PyCFunction>(Clipboard_add_ContentChanged), METH_O | METH_STATIC, nullptr },
        { "remove_content_changed", reinterpret_cast<PyCFunction>(Clipboard_remove_ContentChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Clipboard[] = {
        { }
    };

    static PyType_Slot _type_slots_Clipboard[] = 
    {
        { Py_tp_new, _new_Clipboard },
        { Py_tp_methods, _methods_Clipboard },
        { Py_tp_getset, _getset_Clipboard },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Clipboard =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.Clipboard",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Clipboard
    };

    // ----- ClipboardContentOptions class --------------------
    constexpr const char* const _type_name_ClipboardContentOptions = "ClipboardContentOptions";

    static PyObject* _new_ClipboardContentOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ClipboardContentOptions(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClipboardContentOptions_get_IsRoamable(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRoamable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClipboardContentOptions_put_IsRoamable(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsRoamable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClipboardContentOptions_get_IsAllowedInHistory(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAllowedInHistory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ClipboardContentOptions_put_IsAllowedInHistory(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAllowedInHistory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ClipboardContentOptions_get_HistoryFormats(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HistoryFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClipboardContentOptions_get_RoamingFormats(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoamingFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClipboardContentOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClipboardContentOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ClipboardContentOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClipboardContentOptions[] = {
        { "is_roamable", reinterpret_cast<getter>(ClipboardContentOptions_get_IsRoamable), reinterpret_cast<setter>(ClipboardContentOptions_put_IsRoamable), nullptr, nullptr },
        { "is_allowed_in_history", reinterpret_cast<getter>(ClipboardContentOptions_get_IsAllowedInHistory), reinterpret_cast<setter>(ClipboardContentOptions_put_IsAllowedInHistory), nullptr, nullptr },
        { "history_formats", reinterpret_cast<getter>(ClipboardContentOptions_get_HistoryFormats), nullptr, nullptr, nullptr },
        { "roaming_formats", reinterpret_cast<getter>(ClipboardContentOptions_get_RoamingFormats), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClipboardContentOptions[] = 
    {
        { Py_tp_new, _new_ClipboardContentOptions },
        { Py_tp_dealloc, _dealloc_ClipboardContentOptions },
        { Py_tp_methods, _methods_ClipboardContentOptions },
        { Py_tp_getset, _getset_ClipboardContentOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClipboardContentOptions =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.ClipboardContentOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClipboardContentOptions
    };

    // ----- ClipboardHistoryChangedEventArgs class --------------------
    constexpr const char* const _type_name_ClipboardHistoryChangedEventArgs = "ClipboardHistoryChangedEventArgs";

    static PyObject* _new_ClipboardHistoryChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClipboardHistoryChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ClipboardHistoryChangedEventArgs(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ClipboardHistoryChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClipboardHistoryChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ClipboardHistoryChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClipboardHistoryChangedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ClipboardHistoryChangedEventArgs[] = 
    {
        { Py_tp_new, _new_ClipboardHistoryChangedEventArgs },
        { Py_tp_dealloc, _dealloc_ClipboardHistoryChangedEventArgs },
        { Py_tp_methods, _methods_ClipboardHistoryChangedEventArgs },
        { Py_tp_getset, _getset_ClipboardHistoryChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClipboardHistoryChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.ClipboardHistoryChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClipboardHistoryChangedEventArgs
    };

    // ----- ClipboardHistoryItem class --------------------
    constexpr const char* const _type_name_ClipboardHistoryItem = "ClipboardHistoryItem";

    static PyObject* _new_ClipboardHistoryItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClipboardHistoryItem);
        return nullptr;
    }

    static void _dealloc_ClipboardHistoryItem(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClipboardHistoryItem_get_Content(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Content());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClipboardHistoryItem_get_Id(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClipboardHistoryItem_get_Timestamp(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClipboardHistoryItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClipboardHistoryItem[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ClipboardHistoryItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClipboardHistoryItem[] = {
        { "content", reinterpret_cast<getter>(ClipboardHistoryItem_get_Content), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ClipboardHistoryItem_get_Id), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(ClipboardHistoryItem_get_Timestamp), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClipboardHistoryItem[] = 
    {
        { Py_tp_new, _new_ClipboardHistoryItem },
        { Py_tp_dealloc, _dealloc_ClipboardHistoryItem },
        { Py_tp_methods, _methods_ClipboardHistoryItem },
        { Py_tp_getset, _getset_ClipboardHistoryItem },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClipboardHistoryItem =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.ClipboardHistoryItem",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClipboardHistoryItem
    };

    // ----- ClipboardHistoryItemsResult class --------------------
    constexpr const char* const _type_name_ClipboardHistoryItemsResult = "ClipboardHistoryItemsResult";

    static PyObject* _new_ClipboardHistoryItemsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ClipboardHistoryItemsResult);
        return nullptr;
    }

    static void _dealloc_ClipboardHistoryItemsResult(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ClipboardHistoryItemsResult_get_Items(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Items());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ClipboardHistoryItemsResult_get_Status(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ClipboardHistoryItemsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ClipboardHistoryItemsResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ClipboardHistoryItemsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ClipboardHistoryItemsResult[] = {
        { "items", reinterpret_cast<getter>(ClipboardHistoryItemsResult_get_Items), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ClipboardHistoryItemsResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ClipboardHistoryItemsResult[] = 
    {
        { Py_tp_new, _new_ClipboardHistoryItemsResult },
        { Py_tp_dealloc, _dealloc_ClipboardHistoryItemsResult },
        { Py_tp_methods, _methods_ClipboardHistoryItemsResult },
        { Py_tp_getset, _getset_ClipboardHistoryItemsResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ClipboardHistoryItemsResult =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.ClipboardHistoryItemsResult",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ClipboardHistoryItemsResult
    };

    // ----- DataPackage class --------------------
    constexpr const char* const _type_name_DataPackage = "DataPackage";

    static PyObject* _new_DataPackage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::DataTransfer::DataPackage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DataPackage(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataPackage_GetView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetApplicationLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.SetApplicationLink(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetBitmap(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::RandomAccessStreamReference>(args, 0);

                self->obj.SetBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetData(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetData(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetDataProvider(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataProviderHandler>(args, 1);

                self->obj.SetDataProvider(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetHtmlFormat(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetHtmlFormat(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetRtf(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetRtf(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetStorageItems(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::IStorageItem>>(args, 0);

                self->obj.SetStorageItems(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::IStorageItem>>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.SetStorageItems(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetText(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetText(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetUri(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.SetUri(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_SetWebLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                self->obj.SetWebLink(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackage_get_RequestedOperation(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackage_put_RequestedOperation(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>(arg);

            self->obj.RequestedOperation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackage_get_Properties(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_get_ResourceMap(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResourceMap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_add_Destroyed(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::DataTransfer::DataPackage, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Destroyed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_remove_Destroyed(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Destroyed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_add_OperationCompleted(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::DataTransfer::DataPackage, winrt::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs>>(arg);

            return py::convert(self->obj.OperationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_remove_OperationCompleted(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OperationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_add_ShareCompleted(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::DataTransfer::DataPackage, winrt::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs>>(arg);

            return py::convert(self->obj.ShareCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_remove_ShareCompleted(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShareCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_add_ShareCanceled(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::DataTransfer::DataPackage, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ShareCanceled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackage_remove_ShareCanceled(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShareCanceled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataPackage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataPackage[] = {
        { "get_view", reinterpret_cast<PyCFunction>(DataPackage_GetView), METH_VARARGS, nullptr },
        { "set_application_link", reinterpret_cast<PyCFunction>(DataPackage_SetApplicationLink), METH_VARARGS, nullptr },
        { "set_bitmap", reinterpret_cast<PyCFunction>(DataPackage_SetBitmap), METH_VARARGS, nullptr },
        { "set_data", reinterpret_cast<PyCFunction>(DataPackage_SetData), METH_VARARGS, nullptr },
        { "set_data_provider", reinterpret_cast<PyCFunction>(DataPackage_SetDataProvider), METH_VARARGS, nullptr },
        { "set_html_format", reinterpret_cast<PyCFunction>(DataPackage_SetHtmlFormat), METH_VARARGS, nullptr },
        { "set_rtf", reinterpret_cast<PyCFunction>(DataPackage_SetRtf), METH_VARARGS, nullptr },
        { "set_storage_items", reinterpret_cast<PyCFunction>(DataPackage_SetStorageItems), METH_VARARGS, nullptr },
        { "set_text", reinterpret_cast<PyCFunction>(DataPackage_SetText), METH_VARARGS, nullptr },
        { "set_uri", reinterpret_cast<PyCFunction>(DataPackage_SetUri), METH_VARARGS, nullptr },
        { "set_web_link", reinterpret_cast<PyCFunction>(DataPackage_SetWebLink), METH_VARARGS, nullptr },
        { "add_destroyed", reinterpret_cast<PyCFunction>(DataPackage_add_Destroyed), METH_O, nullptr },
        { "remove_destroyed", reinterpret_cast<PyCFunction>(DataPackage_remove_Destroyed), METH_O, nullptr },
        { "add_operation_completed", reinterpret_cast<PyCFunction>(DataPackage_add_OperationCompleted), METH_O, nullptr },
        { "remove_operation_completed", reinterpret_cast<PyCFunction>(DataPackage_remove_OperationCompleted), METH_O, nullptr },
        { "add_share_completed", reinterpret_cast<PyCFunction>(DataPackage_add_ShareCompleted), METH_O, nullptr },
        { "remove_share_completed", reinterpret_cast<PyCFunction>(DataPackage_remove_ShareCompleted), METH_O, nullptr },
        { "add_share_canceled", reinterpret_cast<PyCFunction>(DataPackage_add_ShareCanceled), METH_O, nullptr },
        { "remove_share_canceled", reinterpret_cast<PyCFunction>(DataPackage_remove_ShareCanceled), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataPackage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataPackage[] = {
        { "requested_operation", reinterpret_cast<getter>(DataPackage_get_RequestedOperation), reinterpret_cast<setter>(DataPackage_put_RequestedOperation), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DataPackage_get_Properties), nullptr, nullptr, nullptr },
        { "resource_map", reinterpret_cast<getter>(DataPackage_get_ResourceMap), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataPackage[] = 
    {
        { Py_tp_new, _new_DataPackage },
        { Py_tp_dealloc, _dealloc_DataPackage },
        { Py_tp_methods, _methods_DataPackage },
        { Py_tp_getset, _getset_DataPackage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataPackage =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.DataPackage",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPackage
    };

    // ----- DataPackagePropertySet class --------------------
    constexpr const char* const _type_name_DataPackagePropertySet = "DataPackagePropertySet";

    static PyObject* _new_DataPackagePropertySet(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataPackagePropertySet);
        return nullptr;
    }

    static void _dealloc_DataPackagePropertySet(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataPackagePropertySet_Clear(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_First(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_GetView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_HasKey(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_Insert(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_Lookup(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_Remove(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_get_Title(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_Title(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_Thumbnail(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_Thumbnail(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Thumbnail(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_Description(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_Description(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_ApplicationName(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ApplicationName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_ApplicationName(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ApplicationName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_ApplicationListingUri(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ApplicationListingUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_ApplicationListingUri(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ApplicationListingUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_FileTypes(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySet_get_Square30x30Logo(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Square30x30Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_Square30x30Logo(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Square30x30Logo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_PackageFamilyName(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_PackageFamilyName(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PackageFamilyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_LogoBackgroundColor(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LogoBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_LogoBackgroundColor(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.LogoBackgroundColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_ContentSourceWebLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentSourceWebLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_ContentSourceWebLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ContentSourceWebLink(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_ContentSourceApplicationLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentSourceApplicationLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_ContentSourceApplicationLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ContentSourceApplicationLink(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_EnterpriseId(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EnterpriseId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_EnterpriseId(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.EnterpriseId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_ContentSourceUserActivityJson(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentSourceUserActivityJson());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataPackagePropertySet_put_ContentSourceUserActivityJson(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentSourceUserActivityJson(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataPackagePropertySet_get_Size(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataPackagePropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_DataPackagePropertySet(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _map_length_DataPackagePropertySet(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_DataPackagePropertySet(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_DataPackagePropertySet(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::hstring>(key);
            if (value == nullptr) { self->obj.Remove(_key); }
            else { self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value)); }
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_DataPackagePropertySet[] = {
        { "clear", reinterpret_cast<PyCFunction>(DataPackagePropertySet_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(DataPackagePropertySet_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(DataPackagePropertySet_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(DataPackagePropertySet_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(DataPackagePropertySet_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(DataPackagePropertySet_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(DataPackagePropertySet_Remove), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataPackagePropertySet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataPackagePropertySet[] = {
        { "title", reinterpret_cast<getter>(DataPackagePropertySet_get_Title), reinterpret_cast<setter>(DataPackagePropertySet_put_Title), nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(DataPackagePropertySet_get_Thumbnail), reinterpret_cast<setter>(DataPackagePropertySet_put_Thumbnail), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(DataPackagePropertySet_get_Description), reinterpret_cast<setter>(DataPackagePropertySet_put_Description), nullptr, nullptr },
        { "application_name", reinterpret_cast<getter>(DataPackagePropertySet_get_ApplicationName), reinterpret_cast<setter>(DataPackagePropertySet_put_ApplicationName), nullptr, nullptr },
        { "application_listing_uri", reinterpret_cast<getter>(DataPackagePropertySet_get_ApplicationListingUri), reinterpret_cast<setter>(DataPackagePropertySet_put_ApplicationListingUri), nullptr, nullptr },
        { "file_types", reinterpret_cast<getter>(DataPackagePropertySet_get_FileTypes), nullptr, nullptr, nullptr },
        { "square30x30_logo", reinterpret_cast<getter>(DataPackagePropertySet_get_Square30x30Logo), reinterpret_cast<setter>(DataPackagePropertySet_put_Square30x30Logo), nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(DataPackagePropertySet_get_PackageFamilyName), reinterpret_cast<setter>(DataPackagePropertySet_put_PackageFamilyName), nullptr, nullptr },
        { "logo_background_color", reinterpret_cast<getter>(DataPackagePropertySet_get_LogoBackgroundColor), reinterpret_cast<setter>(DataPackagePropertySet_put_LogoBackgroundColor), nullptr, nullptr },
        { "content_source_web_link", reinterpret_cast<getter>(DataPackagePropertySet_get_ContentSourceWebLink), reinterpret_cast<setter>(DataPackagePropertySet_put_ContentSourceWebLink), nullptr, nullptr },
        { "content_source_application_link", reinterpret_cast<getter>(DataPackagePropertySet_get_ContentSourceApplicationLink), reinterpret_cast<setter>(DataPackagePropertySet_put_ContentSourceApplicationLink), nullptr, nullptr },
        { "enterprise_id", reinterpret_cast<getter>(DataPackagePropertySet_get_EnterpriseId), reinterpret_cast<setter>(DataPackagePropertySet_put_EnterpriseId), nullptr, nullptr },
        { "content_source_user_activity_json", reinterpret_cast<getter>(DataPackagePropertySet_get_ContentSourceUserActivityJson), reinterpret_cast<setter>(DataPackagePropertySet_put_ContentSourceUserActivityJson), nullptr, nullptr },
        { "size", reinterpret_cast<getter>(DataPackagePropertySet_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataPackagePropertySet[] = 
    {
        { Py_tp_new, _new_DataPackagePropertySet },
        { Py_tp_dealloc, _dealloc_DataPackagePropertySet },
        { Py_tp_methods, _methods_DataPackagePropertySet },
        { Py_tp_getset, _getset_DataPackagePropertySet },
        { Py_tp_iter, _iterator_DataPackagePropertySet },
        { Py_mp_length, _map_length_DataPackagePropertySet },
        { Py_mp_subscript, _map_subscript_DataPackagePropertySet },
        { Py_mp_ass_subscript, _map_assign_DataPackagePropertySet },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataPackagePropertySet =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.DataPackagePropertySet",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPackagePropertySet
    };

    // ----- DataPackagePropertySetView class --------------------
    constexpr const char* const _type_name_DataPackagePropertySetView = "DataPackagePropertySetView";

    static PyObject* _new_DataPackagePropertySetView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataPackagePropertySetView);
        return nullptr;
    }

    static void _dealloc_DataPackagePropertySetView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataPackagePropertySetView_First(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_HasKey(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_Lookup(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_Split(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param0 { nullptr };
                winrt::Windows::Foundation::Collections::IMapView<winrt::hstring, winrt::Windows::Foundation::IInspectable> param1 { nullptr };

                self->obj.Split(param0, param1);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out0.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_ApplicationListingUri(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ApplicationListingUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_ApplicationName(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ApplicationName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_Description(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_FileTypes(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_Thumbnail(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_Title(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_ContentSourceApplicationLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentSourceApplicationLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_ContentSourceWebLink(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentSourceWebLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_LogoBackgroundColor(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LogoBackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_PackageFamilyName(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_Square30x30Logo(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Square30x30Logo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_EnterpriseId(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EnterpriseId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_ContentSourceUserActivityJson(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentSourceUserActivityJson());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_IsFromRoamingClipboard(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsFromRoamingClipboard());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackagePropertySetView_get_Size(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataPackagePropertySetView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_DataPackagePropertySetView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _map_length_DataPackagePropertySetView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_DataPackagePropertySetView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView* self, PyObject* key) noexcept
    {
        try
        {
            return py::convert(self->obj.Lookup(py::convert_to<winrt::hstring>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataPackagePropertySetView[] = {
        { "first", reinterpret_cast<PyCFunction>(DataPackagePropertySetView_First), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(DataPackagePropertySetView_HasKey), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(DataPackagePropertySetView_Lookup), METH_VARARGS, nullptr },
        { "split", reinterpret_cast<PyCFunction>(DataPackagePropertySetView_Split), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataPackagePropertySetView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataPackagePropertySetView[] = {
        { "application_listing_uri", reinterpret_cast<getter>(DataPackagePropertySetView_get_ApplicationListingUri), nullptr, nullptr, nullptr },
        { "application_name", reinterpret_cast<getter>(DataPackagePropertySetView_get_ApplicationName), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(DataPackagePropertySetView_get_Description), nullptr, nullptr, nullptr },
        { "file_types", reinterpret_cast<getter>(DataPackagePropertySetView_get_FileTypes), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(DataPackagePropertySetView_get_Thumbnail), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(DataPackagePropertySetView_get_Title), nullptr, nullptr, nullptr },
        { "content_source_application_link", reinterpret_cast<getter>(DataPackagePropertySetView_get_ContentSourceApplicationLink), nullptr, nullptr, nullptr },
        { "content_source_web_link", reinterpret_cast<getter>(DataPackagePropertySetView_get_ContentSourceWebLink), nullptr, nullptr, nullptr },
        { "logo_background_color", reinterpret_cast<getter>(DataPackagePropertySetView_get_LogoBackgroundColor), nullptr, nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(DataPackagePropertySetView_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { "square30x30_logo", reinterpret_cast<getter>(DataPackagePropertySetView_get_Square30x30Logo), nullptr, nullptr, nullptr },
        { "enterprise_id", reinterpret_cast<getter>(DataPackagePropertySetView_get_EnterpriseId), nullptr, nullptr, nullptr },
        { "content_source_user_activity_json", reinterpret_cast<getter>(DataPackagePropertySetView_get_ContentSourceUserActivityJson), nullptr, nullptr, nullptr },
        { "is_from_roaming_clipboard", reinterpret_cast<getter>(DataPackagePropertySetView_get_IsFromRoamingClipboard), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(DataPackagePropertySetView_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataPackagePropertySetView[] = 
    {
        { Py_tp_new, _new_DataPackagePropertySetView },
        { Py_tp_dealloc, _dealloc_DataPackagePropertySetView },
        { Py_tp_methods, _methods_DataPackagePropertySetView },
        { Py_tp_getset, _getset_DataPackagePropertySetView },
        { Py_tp_iter, _iterator_DataPackagePropertySetView },
        { Py_mp_length, _map_length_DataPackagePropertySetView },
        { Py_mp_subscript, _map_subscript_DataPackagePropertySetView },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataPackagePropertySetView =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.DataPackagePropertySetView",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPackagePropertySetView
    };

    // ----- DataPackageView class --------------------
    constexpr const char* const _type_name_DataPackageView = "DataPackageView";

    static PyObject* _new_DataPackageView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataPackageView);
        return nullptr;
    }

    static void _dealloc_DataPackageView(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataPackageView_Contains(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.Contains(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetApplicationLinkAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetApplicationLinkAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetBitmapAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBitmapAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetDataAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetDataAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetHtmlFormatAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetHtmlFormatAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetResourceMapAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetResourceMapAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetRtfAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRtfAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetStorageItemsAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStorageItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetTextAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetTextAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetTextAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetUriAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetUriAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_GetWebLinkAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetWebLinkAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_ReportOperationCompleted(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataPackageOperation>(args, 0);

                self->obj.ReportOperationCompleted(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_RequestAccessAsync(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestAccessAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RequestAccessAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_SetAcceptedFormatId(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.SetAcceptedFormatId(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_UnlockAndAssumeEnterpriseIdentity(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.UnlockAndAssumeEnterpriseIdentity());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataPackageView_get_AvailableFormats(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AvailableFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackageView_get_Properties(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPackageView_get_RequestedOperation(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestedOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataPackageView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataPackageView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataPackageView[] = {
        { "contains", reinterpret_cast<PyCFunction>(DataPackageView_Contains), METH_VARARGS, nullptr },
        { "get_application_link_async", reinterpret_cast<PyCFunction>(DataPackageView_GetApplicationLinkAsync), METH_VARARGS, nullptr },
        { "get_bitmap_async", reinterpret_cast<PyCFunction>(DataPackageView_GetBitmapAsync), METH_VARARGS, nullptr },
        { "get_data_async", reinterpret_cast<PyCFunction>(DataPackageView_GetDataAsync), METH_VARARGS, nullptr },
        { "get_html_format_async", reinterpret_cast<PyCFunction>(DataPackageView_GetHtmlFormatAsync), METH_VARARGS, nullptr },
        { "get_resource_map_async", reinterpret_cast<PyCFunction>(DataPackageView_GetResourceMapAsync), METH_VARARGS, nullptr },
        { "get_rtf_async", reinterpret_cast<PyCFunction>(DataPackageView_GetRtfAsync), METH_VARARGS, nullptr },
        { "get_storage_items_async", reinterpret_cast<PyCFunction>(DataPackageView_GetStorageItemsAsync), METH_VARARGS, nullptr },
        { "get_text_async", reinterpret_cast<PyCFunction>(DataPackageView_GetTextAsync), METH_VARARGS, nullptr },
        { "get_uri_async", reinterpret_cast<PyCFunction>(DataPackageView_GetUriAsync), METH_VARARGS, nullptr },
        { "get_web_link_async", reinterpret_cast<PyCFunction>(DataPackageView_GetWebLinkAsync), METH_VARARGS, nullptr },
        { "report_operation_completed", reinterpret_cast<PyCFunction>(DataPackageView_ReportOperationCompleted), METH_VARARGS, nullptr },
        { "request_access_async", reinterpret_cast<PyCFunction>(DataPackageView_RequestAccessAsync), METH_VARARGS, nullptr },
        { "set_accepted_format_id", reinterpret_cast<PyCFunction>(DataPackageView_SetAcceptedFormatId), METH_VARARGS, nullptr },
        { "unlock_and_assume_enterprise_identity", reinterpret_cast<PyCFunction>(DataPackageView_UnlockAndAssumeEnterpriseIdentity), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataPackageView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataPackageView[] = {
        { "available_formats", reinterpret_cast<getter>(DataPackageView_get_AvailableFormats), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DataPackageView_get_Properties), nullptr, nullptr, nullptr },
        { "requested_operation", reinterpret_cast<getter>(DataPackageView_get_RequestedOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataPackageView[] = 
    {
        { Py_tp_new, _new_DataPackageView },
        { Py_tp_dealloc, _dealloc_DataPackageView },
        { Py_tp_methods, _methods_DataPackageView },
        { Py_tp_getset, _getset_DataPackageView },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataPackageView =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.DataPackageView",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataPackageView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPackageView
    };

    // ----- DataProviderDeferral class --------------------
    constexpr const char* const _type_name_DataProviderDeferral = "DataProviderDeferral";

    static PyObject* _new_DataProviderDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataProviderDeferral);
        return nullptr;
    }

    static void _dealloc_DataProviderDeferral(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataProviderDeferral_Complete(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_DataProviderDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataProviderDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataProviderDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(DataProviderDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataProviderDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataProviderDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_DataProviderDeferral[] = 
    {
        { Py_tp_new, _new_DataProviderDeferral },
        { Py_tp_dealloc, _dealloc_DataProviderDeferral },
        { Py_tp_methods, _methods_DataProviderDeferral },
        { Py_tp_getset, _getset_DataProviderDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataProviderDeferral =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.DataProviderDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataProviderDeferral
    };

    // ----- DataProviderRequest class --------------------
    constexpr const char* const _type_name_DataProviderRequest = "DataProviderRequest";

    static PyObject* _new_DataProviderRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataProviderRequest);
        return nullptr;
    }

    static void _dealloc_DataProviderRequest(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataProviderRequest_GetDeferral(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataProviderRequest_SetData(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                self->obj.SetData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataProviderRequest_get_Deadline(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataProviderRequest_get_FormatId(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FormatId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataProviderRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataProviderRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataProviderRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DataProviderRequest_GetDeferral), METH_VARARGS, nullptr },
        { "set_data", reinterpret_cast<PyCFunction>(DataProviderRequest_SetData), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataProviderRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataProviderRequest[] = {
        { "deadline", reinterpret_cast<getter>(DataProviderRequest_get_Deadline), nullptr, nullptr, nullptr },
        { "format_id", reinterpret_cast<getter>(DataProviderRequest_get_FormatId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataProviderRequest[] = 
    {
        { Py_tp_new, _new_DataProviderRequest },
        { Py_tp_dealloc, _dealloc_DataProviderRequest },
        { Py_tp_methods, _methods_DataProviderRequest },
        { Py_tp_getset, _getset_DataProviderRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataProviderRequest =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.DataProviderRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataProviderRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataProviderRequest
    };

    // ----- DataRequest class --------------------
    constexpr const char* const _type_name_DataRequest = "DataRequest";

    static PyObject* _new_DataRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataRequest);
        return nullptr;
    }

    static void _dealloc_DataRequest(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataRequest_FailWithDisplayText(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.FailWithDisplayText(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataRequest_GetDeferral(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataRequest_get_Data(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DataRequest_put_Data(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>(arg);

            self->obj.Data(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DataRequest_get_Deadline(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataRequest[] = {
        { "fail_with_display_text", reinterpret_cast<PyCFunction>(DataRequest_FailWithDisplayText), METH_VARARGS, nullptr },
        { "get_deferral", reinterpret_cast<PyCFunction>(DataRequest_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataRequest[] = {
        { "data", reinterpret_cast<getter>(DataRequest_get_Data), reinterpret_cast<setter>(DataRequest_put_Data), nullptr, nullptr },
        { "deadline", reinterpret_cast<getter>(DataRequest_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataRequest[] = 
    {
        { Py_tp_new, _new_DataRequest },
        { Py_tp_dealloc, _dealloc_DataRequest },
        { Py_tp_methods, _methods_DataRequest },
        { Py_tp_getset, _getset_DataRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataRequest =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.DataRequest",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataRequest
    };

    // ----- DataRequestDeferral class --------------------
    constexpr const char* const _type_name_DataRequestDeferral = "DataRequestDeferral";

    static PyObject* _new_DataRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataRequestDeferral);
        return nullptr;
    }

    static void _dealloc_DataRequestDeferral(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequestDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataRequestDeferral_Complete(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequestDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_DataRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(DataRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_DataRequestDeferral[] = 
    {
        { Py_tp_new, _new_DataRequestDeferral },
        { Py_tp_dealloc, _dealloc_DataRequestDeferral },
        { Py_tp_methods, _methods_DataRequestDeferral },
        { Py_tp_getset, _getset_DataRequestDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataRequestDeferral =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.DataRequestDeferral",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataRequestDeferral
    };

    // ----- DataRequestedEventArgs class --------------------
    constexpr const char* const _type_name_DataRequestedEventArgs = "DataRequestedEventArgs";

    static PyObject* _new_DataRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_DataRequestedEventArgs(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataRequestedEventArgs_get_Request(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DataRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(DataRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_DataRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_DataRequestedEventArgs },
        { Py_tp_methods, _methods_DataRequestedEventArgs },
        { Py_tp_getset, _getset_DataRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataRequestedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.DataRequestedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataRequestedEventArgs
    };

    // ----- DataTransferManager class --------------------
    constexpr const char* const _type_name_DataTransferManager = "DataTransferManager";

    static PyObject* _new_DataTransferManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataTransferManager);
        return nullptr;
    }

    static void _dealloc_DataTransferManager(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataTransferManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_ShowShareUI(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager::ShowShareUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::ShareUIOptions>(args, 0);

                winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager::ShowShareUI(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_add_DataRequested(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager, winrt::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs>>(arg);

            return py::convert(self->obj.DataRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_remove_DataRequested(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_add_TargetApplicationChosen(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager, winrt::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs>>(arg);

            return py::convert(self->obj.TargetApplicationChosen(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_remove_TargetApplicationChosen(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TargetApplicationChosen(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_add_ShareProvidersRequested(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager, winrt::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs>>(arg);

            return py::convert(self->obj.ShareProvidersRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataTransferManager_remove_ShareProvidersRequested(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ShareProvidersRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataTransferManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataTransferManager[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(DataTransferManager_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(DataTransferManager_IsSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "show_share_u_i", reinterpret_cast<PyCFunction>(DataTransferManager_ShowShareUI), METH_VARARGS | METH_STATIC, nullptr },
        { "add_data_requested", reinterpret_cast<PyCFunction>(DataTransferManager_add_DataRequested), METH_O, nullptr },
        { "remove_data_requested", reinterpret_cast<PyCFunction>(DataTransferManager_remove_DataRequested), METH_O, nullptr },
        { "add_target_application_chosen", reinterpret_cast<PyCFunction>(DataTransferManager_add_TargetApplicationChosen), METH_O, nullptr },
        { "remove_target_application_chosen", reinterpret_cast<PyCFunction>(DataTransferManager_remove_TargetApplicationChosen), METH_O, nullptr },
        { "add_share_providers_requested", reinterpret_cast<PyCFunction>(DataTransferManager_add_ShareProvidersRequested), METH_O, nullptr },
        { "remove_share_providers_requested", reinterpret_cast<PyCFunction>(DataTransferManager_remove_ShareProvidersRequested), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DataTransferManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataTransferManager[] = {
        { }
    };

    static PyType_Slot _type_slots_DataTransferManager[] = 
    {
        { Py_tp_new, _new_DataTransferManager },
        { Py_tp_dealloc, _dealloc_DataTransferManager },
        { Py_tp_methods, _methods_DataTransferManager },
        { Py_tp_getset, _getset_DataTransferManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataTransferManager =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.DataTransferManager",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::DataTransferManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataTransferManager
    };

    // ----- HtmlFormatHelper class --------------------
    constexpr const char* const _type_name_HtmlFormatHelper = "HtmlFormatHelper";

    static PyObject* _new_HtmlFormatHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HtmlFormatHelper);
        return nullptr;
    }

    static PyObject* HtmlFormatHelper_CreateHtmlFormat(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::HtmlFormatHelper::CreateHtmlFormat(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HtmlFormatHelper_GetStaticFragment(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::HtmlFormatHelper::GetStaticFragment(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_HtmlFormatHelper[] = {
        { "create_html_format", reinterpret_cast<PyCFunction>(HtmlFormatHelper_CreateHtmlFormat), METH_VARARGS | METH_STATIC, nullptr },
        { "get_static_fragment", reinterpret_cast<PyCFunction>(HtmlFormatHelper_GetStaticFragment), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HtmlFormatHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_HtmlFormatHelper[] = 
    {
        { Py_tp_new, _new_HtmlFormatHelper },
        { Py_tp_methods, _methods_HtmlFormatHelper },
        { Py_tp_getset, _getset_HtmlFormatHelper },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HtmlFormatHelper =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.HtmlFormatHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HtmlFormatHelper
    };

    // ----- OperationCompletedEventArgs class --------------------
    constexpr const char* const _type_name_OperationCompletedEventArgs = "OperationCompletedEventArgs";

    static PyObject* _new_OperationCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_OperationCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_OperationCompletedEventArgs(py::wrapper::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* OperationCompletedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OperationCompletedEventArgs_get_AcceptedFormatId(py::wrapper::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AcceptedFormatId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_OperationCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OperationCompletedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_OperationCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OperationCompletedEventArgs[] = {
        { "operation", reinterpret_cast<getter>(OperationCompletedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "accepted_format_id", reinterpret_cast<getter>(OperationCompletedEventArgs_get_AcceptedFormatId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OperationCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_OperationCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_OperationCompletedEventArgs },
        { Py_tp_methods, _methods_OperationCompletedEventArgs },
        { Py_tp_getset, _getset_OperationCompletedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_OperationCompletedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.OperationCompletedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OperationCompletedEventArgs
    };

    // ----- ShareCompletedEventArgs class --------------------
    constexpr const char* const _type_name_ShareCompletedEventArgs = "ShareCompletedEventArgs";

    static PyObject* _new_ShareCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ShareCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_ShareCompletedEventArgs(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ShareCompletedEventArgs_get_ShareTarget(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShareTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ShareCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareCompletedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareCompletedEventArgs[] = {
        { "share_target", reinterpret_cast<getter>(ShareCompletedEventArgs_get_ShareTarget), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_ShareCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_ShareCompletedEventArgs },
        { Py_tp_methods, _methods_ShareCompletedEventArgs },
        { Py_tp_getset, _getset_ShareCompletedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ShareCompletedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.ShareCompletedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareCompletedEventArgs
    };

    // ----- ShareProvider class --------------------
    constexpr const char* const _type_name_ShareProvider = "ShareProvider";

    static PyObject* _new_ShareProvider(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::RandomAccessStreamReference>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::UI::Color>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::ShareProviderHandler>(args, 3);

                winrt::Windows::ApplicationModel::DataTransfer::ShareProvider instance{ param0, param1, param2, param3 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ShareProvider(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvider* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ShareProvider_get_Tag(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ShareProvider_put_Tag(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvider* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ShareProvider_get_BackgroundColor(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareProvider_get_DisplayIcon(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayIcon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareProvider_get_Title(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ShareProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ShareProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareProvider[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareProvider[] = {
        { "tag", reinterpret_cast<getter>(ShareProvider_get_Tag), reinterpret_cast<setter>(ShareProvider_put_Tag), nullptr, nullptr },
        { "background_color", reinterpret_cast<getter>(ShareProvider_get_BackgroundColor), nullptr, nullptr, nullptr },
        { "display_icon", reinterpret_cast<getter>(ShareProvider_get_DisplayIcon), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(ShareProvider_get_Title), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareProvider[] = 
    {
        { Py_tp_new, _new_ShareProvider },
        { Py_tp_dealloc, _dealloc_ShareProvider },
        { Py_tp_methods, _methods_ShareProvider },
        { Py_tp_getset, _getset_ShareProvider },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ShareProvider =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.ShareProvider",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareProvider
    };

    // ----- ShareProviderOperation class --------------------
    constexpr const char* const _type_name_ShareProviderOperation = "ShareProviderOperation";

    static PyObject* _new_ShareProviderOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ShareProviderOperation);
        return nullptr;
    }

    static void _dealloc_ShareProviderOperation(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProviderOperation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ShareProviderOperation_ReportCompleted(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProviderOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ReportCompleted();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareProviderOperation_get_Data(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProviderOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareProviderOperation_get_Provider(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProviderOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Provider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ShareProviderOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ShareProviderOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareProviderOperation[] = {
        { "report_completed", reinterpret_cast<PyCFunction>(ShareProviderOperation_ReportCompleted), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareProviderOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareProviderOperation[] = {
        { "data", reinterpret_cast<getter>(ShareProviderOperation_get_Data), nullptr, nullptr, nullptr },
        { "provider", reinterpret_cast<getter>(ShareProviderOperation_get_Provider), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareProviderOperation[] = 
    {
        { Py_tp_new, _new_ShareProviderOperation },
        { Py_tp_dealloc, _dealloc_ShareProviderOperation },
        { Py_tp_methods, _methods_ShareProviderOperation },
        { Py_tp_getset, _getset_ShareProviderOperation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ShareProviderOperation =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.ShareProviderOperation",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProviderOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareProviderOperation
    };

    // ----- ShareProvidersRequestedEventArgs class --------------------
    constexpr const char* const _type_name_ShareProvidersRequestedEventArgs = "ShareProvidersRequestedEventArgs";

    static PyObject* _new_ShareProvidersRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ShareProvidersRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_ShareProvidersRequestedEventArgs(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ShareProvidersRequestedEventArgs_GetDeferral(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ShareProvidersRequestedEventArgs_get_Data(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareProvidersRequestedEventArgs_get_Providers(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Providers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ShareProvidersRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareProvidersRequestedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(ShareProvidersRequestedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareProvidersRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareProvidersRequestedEventArgs[] = {
        { "data", reinterpret_cast<getter>(ShareProvidersRequestedEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "providers", reinterpret_cast<getter>(ShareProvidersRequestedEventArgs_get_Providers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareProvidersRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_ShareProvidersRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_ShareProvidersRequestedEventArgs },
        { Py_tp_methods, _methods_ShareProvidersRequestedEventArgs },
        { Py_tp_getset, _getset_ShareProvidersRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ShareProvidersRequestedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.ShareProvidersRequestedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareProvidersRequestedEventArgs
    };

    // ----- ShareTargetInfo class --------------------
    constexpr const char* const _type_name_ShareTargetInfo = "ShareTargetInfo";

    static PyObject* _new_ShareTargetInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ShareTargetInfo);
        return nullptr;
    }

    static void _dealloc_ShareTargetInfo(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareTargetInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ShareTargetInfo_get_AppUserModelId(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareTargetInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppUserModelId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareTargetInfo_get_ShareProvider(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareTargetInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShareProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ShareTargetInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ShareTargetInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareTargetInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareTargetInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareTargetInfo[] = {
        { "app_user_model_id", reinterpret_cast<getter>(ShareTargetInfo_get_AppUserModelId), nullptr, nullptr, nullptr },
        { "share_provider", reinterpret_cast<getter>(ShareTargetInfo_get_ShareProvider), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareTargetInfo[] = 
    {
        { Py_tp_new, _new_ShareTargetInfo },
        { Py_tp_dealloc, _dealloc_ShareTargetInfo },
        { Py_tp_methods, _methods_ShareTargetInfo },
        { Py_tp_getset, _getset_ShareTargetInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ShareTargetInfo =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.ShareTargetInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareTargetInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareTargetInfo
    };

    // ----- ShareUIOptions class --------------------
    constexpr const char* const _type_name_ShareUIOptions = "ShareUIOptions";

    static PyObject* _new_ShareUIOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::DataTransfer::ShareUIOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ShareUIOptions(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareUIOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ShareUIOptions_get_Theme(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Theme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ShareUIOptions_put_Theme(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::DataTransfer::ShareUITheme>(arg);

            self->obj.Theme(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ShareUIOptions_get_SelectionRect(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelectionRect());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ShareUIOptions_put_SelectionRect(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::Rect>>(arg);

            self->obj.SelectionRect(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ShareUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::ShareUIOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareUIOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareUIOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareUIOptions[] = {
        { "theme", reinterpret_cast<getter>(ShareUIOptions_get_Theme), reinterpret_cast<setter>(ShareUIOptions_put_Theme), nullptr, nullptr },
        { "selection_rect", reinterpret_cast<getter>(ShareUIOptions_get_SelectionRect), reinterpret_cast<setter>(ShareUIOptions_put_SelectionRect), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareUIOptions[] = 
    {
        { Py_tp_new, _new_ShareUIOptions },
        { Py_tp_dealloc, _dealloc_ShareUIOptions },
        { Py_tp_methods, _methods_ShareUIOptions },
        { Py_tp_getset, _getset_ShareUIOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ShareUIOptions =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.ShareUIOptions",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::ShareUIOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareUIOptions
    };

    // ----- SharedStorageAccessManager class --------------------
    constexpr const char* const _type_name_SharedStorageAccessManager = "SharedStorageAccessManager";

    static PyObject* _new_SharedStorageAccessManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SharedStorageAccessManager);
        return nullptr;
    }

    static PyObject* SharedStorageAccessManager_AddFile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::SharedStorageAccessManager::AddFile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SharedStorageAccessManager_RedeemTokenForFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::ApplicationModel::DataTransfer::SharedStorageAccessManager::RedeemTokenForFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SharedStorageAccessManager_RemoveFile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::DataTransfer::SharedStorageAccessManager::RemoveFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_SharedStorageAccessManager[] = {
        { "add_file", reinterpret_cast<PyCFunction>(SharedStorageAccessManager_AddFile), METH_VARARGS | METH_STATIC, nullptr },
        { "redeem_token_for_file_async", reinterpret_cast<PyCFunction>(SharedStorageAccessManager_RedeemTokenForFileAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "remove_file", reinterpret_cast<PyCFunction>(SharedStorageAccessManager_RemoveFile), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SharedStorageAccessManager[] = {
        { }
    };

    static PyType_Slot _type_slots_SharedStorageAccessManager[] = 
    {
        { Py_tp_new, _new_SharedStorageAccessManager },
        { Py_tp_methods, _methods_SharedStorageAccessManager },
        { Py_tp_getset, _getset_SharedStorageAccessManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SharedStorageAccessManager =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.SharedStorageAccessManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SharedStorageAccessManager
    };

    // ----- StandardDataFormats class --------------------
    constexpr const char* const _type_name_StandardDataFormats = "StandardDataFormats";

    static PyObject* _new_StandardDataFormats(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StandardDataFormats);
        return nullptr;
    }

    static PyObject* StandardDataFormats_get_Bitmap(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::Bitmap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_Html(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::Html());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_Rtf(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::Rtf());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_StorageItems(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::StorageItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_Text(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_Uri(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_ApplicationLink(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::ApplicationLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_WebLink(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::WebLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StandardDataFormats_get_UserActivityJsonArray(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats::UserActivityJsonArray());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StandardDataFormats[] = {
        { "get_bitmap", reinterpret_cast<PyCFunction>(StandardDataFormats_get_Bitmap), METH_NOARGS | METH_STATIC, nullptr },
        { "get_html", reinterpret_cast<PyCFunction>(StandardDataFormats_get_Html), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rtf", reinterpret_cast<PyCFunction>(StandardDataFormats_get_Rtf), METH_NOARGS | METH_STATIC, nullptr },
        { "get_storage_items", reinterpret_cast<PyCFunction>(StandardDataFormats_get_StorageItems), METH_NOARGS | METH_STATIC, nullptr },
        { "get_text", reinterpret_cast<PyCFunction>(StandardDataFormats_get_Text), METH_NOARGS | METH_STATIC, nullptr },
        { "get_uri", reinterpret_cast<PyCFunction>(StandardDataFormats_get_Uri), METH_NOARGS | METH_STATIC, nullptr },
        { "get_application_link", reinterpret_cast<PyCFunction>(StandardDataFormats_get_ApplicationLink), METH_NOARGS | METH_STATIC, nullptr },
        { "get_web_link", reinterpret_cast<PyCFunction>(StandardDataFormats_get_WebLink), METH_NOARGS | METH_STATIC, nullptr },
        { "get_user_activity_json_array", reinterpret_cast<PyCFunction>(StandardDataFormats_get_UserActivityJsonArray), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StandardDataFormats[] = {
        { }
    };

    static PyType_Slot _type_slots_StandardDataFormats[] = 
    {
        { Py_tp_new, _new_StandardDataFormats },
        { Py_tp_methods, _methods_StandardDataFormats },
        { Py_tp_getset, _getset_StandardDataFormats },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StandardDataFormats =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.StandardDataFormats",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StandardDataFormats
    };

    // ----- TargetApplicationChosenEventArgs class --------------------
    constexpr const char* const _type_name_TargetApplicationChosenEventArgs = "TargetApplicationChosenEventArgs";

    static PyObject* _new_TargetApplicationChosenEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TargetApplicationChosenEventArgs);
        return nullptr;
    }

    static void _dealloc_TargetApplicationChosenEventArgs(py::wrapper::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TargetApplicationChosenEventArgs_get_ApplicationName(py::wrapper::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ApplicationName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TargetApplicationChosenEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TargetApplicationChosenEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TargetApplicationChosenEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TargetApplicationChosenEventArgs[] = {
        { "application_name", reinterpret_cast<getter>(TargetApplicationChosenEventArgs_get_ApplicationName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TargetApplicationChosenEventArgs[] = 
    {
        { Py_tp_new, _new_TargetApplicationChosenEventArgs },
        { Py_tp_dealloc, _dealloc_TargetApplicationChosenEventArgs },
        { Py_tp_methods, _methods_TargetApplicationChosenEventArgs },
        { Py_tp_getset, _getset_TargetApplicationChosenEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TargetApplicationChosenEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_DataTransfer.TargetApplicationChosenEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TargetApplicationChosenEventArgs
    };

    // ----- Windows.ApplicationModel.DataTransfer Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::Clipboard>::python_type = py::register_python_type(module, _type_name_Clipboard, &_type_spec_Clipboard, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ClipboardContentOptions>::python_type = py::register_python_type(module, _type_name_ClipboardContentOptions, &_type_spec_ClipboardContentOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryChangedEventArgs>::python_type = py::register_python_type(module, _type_name_ClipboardHistoryChangedEventArgs, &_type_spec_ClipboardHistoryChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItem>::python_type = py::register_python_type(module, _type_name_ClipboardHistoryItem, &_type_spec_ClipboardHistoryItem, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ClipboardHistoryItemsResult>::python_type = py::register_python_type(module, _type_name_ClipboardHistoryItemsResult, &_type_spec_ClipboardHistoryItemsResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataPackage>::python_type = py::register_python_type(module, _type_name_DataPackage, &_type_spec_DataPackage, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataPackagePropertySet>::python_type = py::register_python_type(module, _type_name_DataPackagePropertySet, &_type_spec_DataPackagePropertySet, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataPackagePropertySetView>::python_type = py::register_python_type(module, _type_name_DataPackagePropertySetView, &_type_spec_DataPackagePropertySetView, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataPackageView>::python_type = py::register_python_type(module, _type_name_DataPackageView, &_type_spec_DataPackageView, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataProviderDeferral>::python_type = py::register_python_type(module, _type_name_DataProviderDeferral, &_type_spec_DataProviderDeferral, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataProviderRequest>::python_type = py::register_python_type(module, _type_name_DataProviderRequest, &_type_spec_DataProviderRequest, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataRequest>::python_type = py::register_python_type(module, _type_name_DataRequest, &_type_spec_DataRequest, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataRequestDeferral>::python_type = py::register_python_type(module, _type_name_DataRequestDeferral, &_type_spec_DataRequestDeferral, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_DataRequestedEventArgs, &_type_spec_DataRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::DataTransferManager>::python_type = py::register_python_type(module, _type_name_DataTransferManager, &_type_spec_DataTransferManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::HtmlFormatHelper>::python_type = py::register_python_type(module, _type_name_HtmlFormatHelper, &_type_spec_HtmlFormatHelper, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::OperationCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_OperationCompletedEventArgs, &_type_spec_OperationCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ShareCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_ShareCompletedEventArgs, &_type_spec_ShareCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ShareProvider>::python_type = py::register_python_type(module, _type_name_ShareProvider, &_type_spec_ShareProvider, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ShareProviderOperation>::python_type = py::register_python_type(module, _type_name_ShareProviderOperation, &_type_spec_ShareProviderOperation, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ShareProvidersRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_ShareProvidersRequestedEventArgs, &_type_spec_ShareProvidersRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ShareTargetInfo>::python_type = py::register_python_type(module, _type_name_ShareTargetInfo, &_type_spec_ShareTargetInfo, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::ShareUIOptions>::python_type = py::register_python_type(module, _type_name_ShareUIOptions, &_type_spec_ShareUIOptions, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::SharedStorageAccessManager>::python_type = py::register_python_type(module, _type_name_SharedStorageAccessManager, &_type_spec_SharedStorageAccessManager, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::StandardDataFormats>::python_type = py::register_python_type(module, _type_name_StandardDataFormats, &_type_spec_StandardDataFormats, nullptr);
            py::winrt_type<winrt::Windows::ApplicationModel::DataTransfer::TargetApplicationChosenEventArgs>::python_type = py::register_python_type(module, _type_name_TargetApplicationChosenEventArgs, &_type_spec_TargetApplicationChosenEventArgs, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.DataTransfer");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_DataTransfer",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::ApplicationModel::DataTransfer

PyMODINIT_FUNC
PyInit__winsdk_Windows_ApplicationModel_DataTransfer (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::DataTransfer::module_def);
}
