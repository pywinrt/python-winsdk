// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.3

#include "pybase.h"
#include "py.Windows.Foundation.Diagnostics.h"

PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::ErrorDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::FileLoggingSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingActivity>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingChannel>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingFields>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::IErrorReportingSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::ILoggingSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Foundation::Diagnostics::ILoggingTarget>::python_type;

namespace py::cpp::Windows::Foundation::Diagnostics
{
    // ----- AsyncCausalityTracer class --------------------
    constexpr const char* const _type_name_AsyncCausalityTracer = "AsyncCausalityTracer";

    static PyObject* _new_AsyncCausalityTracer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AsyncCausalityTracer);
        return nullptr;
    }

    static PyObject* AsyncCausalityTracer_TraceOperationCompletion(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<uint64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::AsyncStatus>(args, 4);

                winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceOperationCompletion(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_TraceOperationCreation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<uint64_t>(args, 3);
                auto param4 = py::convert_to<winrt::hstring>(args, 4);
                auto param5 = py::convert_to<uint64_t>(args, 5);

                winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceOperationCreation(param0, param1, param2, param3, param4, param5);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_TraceOperationRelation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<uint64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityRelation>(args, 4);

                winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceOperationRelation(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_TraceSynchronousWorkCompletion(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySynchronousWork>(args, 2);

                winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceSynchronousWorkCompletion(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_TraceSynchronousWorkStart(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalityTraceLevel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySource>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);
                auto param3 = py::convert_to<uint64_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Diagnostics::CausalitySynchronousWork>(args, 4);

                winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TraceSynchronousWorkStart(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_add_TracingStatusChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs>>(arg);

            return py::convert(winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TracingStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AsyncCausalityTracer_remove_TracingStatusChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer::TracingStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AsyncCausalityTracer[] = {
        { "trace_operation_completion", reinterpret_cast<PyCFunction>(AsyncCausalityTracer_TraceOperationCompletion), METH_VARARGS | METH_STATIC, nullptr },
        { "trace_operation_creation", reinterpret_cast<PyCFunction>(AsyncCausalityTracer_TraceOperationCreation), METH_VARARGS | METH_STATIC, nullptr },
        { "trace_operation_relation", reinterpret_cast<PyCFunction>(AsyncCausalityTracer_TraceOperationRelation), METH_VARARGS | METH_STATIC, nullptr },
        { "trace_synchronous_work_completion", reinterpret_cast<PyCFunction>(AsyncCausalityTracer_TraceSynchronousWorkCompletion), METH_VARARGS | METH_STATIC, nullptr },
        { "trace_synchronous_work_start", reinterpret_cast<PyCFunction>(AsyncCausalityTracer_TraceSynchronousWorkStart), METH_VARARGS | METH_STATIC, nullptr },
        { "add_tracing_status_changed", reinterpret_cast<PyCFunction>(AsyncCausalityTracer_add_TracingStatusChanged), METH_O | METH_STATIC, nullptr },
        { "remove_tracing_status_changed", reinterpret_cast<PyCFunction>(AsyncCausalityTracer_remove_TracingStatusChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AsyncCausalityTracer[] = {
        { }
    };

    static PyType_Slot _type_slots_AsyncCausalityTracer[] = 
    {
        { Py_tp_new, _new_AsyncCausalityTracer },
        { Py_tp_methods, _methods_AsyncCausalityTracer },
        { Py_tp_getset, _getset_AsyncCausalityTracer },
        { },
    };

    static PyType_Spec _type_spec_AsyncCausalityTracer =
    {
        "_winsdk_Windows_Foundation_Diagnostics.AsyncCausalityTracer",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AsyncCausalityTracer
    };

    // ----- ErrorDetails class --------------------
    constexpr const char* const _type_name_ErrorDetails = "ErrorDetails";

    static PyObject* _new_ErrorDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ErrorDetails);
        return nullptr;
    }

    static void _dealloc_ErrorDetails(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ErrorDetails_CreateFromHResultAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(winrt::Windows::Foundation::Diagnostics::ErrorDetails::CreateFromHResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ErrorDetails_get_Description(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ErrorDetails_get_HelpUri(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HelpUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ErrorDetails_get_LongDescription(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LongDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ErrorDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::ErrorDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ErrorDetails[] = {
        { "create_from_h_result_async", reinterpret_cast<PyCFunction>(ErrorDetails_CreateFromHResultAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ErrorDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ErrorDetails[] = {
        { "description", reinterpret_cast<getter>(ErrorDetails_get_Description), nullptr, nullptr, nullptr },
        { "help_uri", reinterpret_cast<getter>(ErrorDetails_get_HelpUri), nullptr, nullptr, nullptr },
        { "long_description", reinterpret_cast<getter>(ErrorDetails_get_LongDescription), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ErrorDetails[] = 
    {
        { Py_tp_new, _new_ErrorDetails },
        { Py_tp_dealloc, _dealloc_ErrorDetails },
        { Py_tp_methods, _methods_ErrorDetails },
        { Py_tp_getset, _getset_ErrorDetails },
        { },
    };

    static PyType_Spec _type_spec_ErrorDetails =
    {
        "_winsdk_Windows_Foundation_Diagnostics.ErrorDetails",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::ErrorDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ErrorDetails
    };

    // ----- FileLoggingSession class --------------------
    constexpr const char* const _type_name_FileLoggingSession = "FileLoggingSession";

    static PyObject* _new_FileLoggingSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::Diagnostics::FileLoggingSession instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FileLoggingSession_AddLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.AddLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                self->obj.AddLoggingChannel(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_Close(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_CloseAndSaveToFileAsync(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CloseAndSaveToFileAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_RemoveLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.RemoveLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_get_Name(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_add_LogFileGenerated(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession, winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>>(arg);

            return py::convert(self->obj.LogFileGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileLoggingSession_remove_LogFileGenerated(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LogFileGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FileLoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::FileLoggingSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_FileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_FileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileLoggingSession[] = {
        { "add_logging_channel", reinterpret_cast<PyCFunction>(FileLoggingSession_AddLoggingChannel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(FileLoggingSession_Close), METH_VARARGS, nullptr },
        { "close_and_save_to_file_async", reinterpret_cast<PyCFunction>(FileLoggingSession_CloseAndSaveToFileAsync), METH_VARARGS, nullptr },
        { "remove_logging_channel", reinterpret_cast<PyCFunction>(FileLoggingSession_RemoveLoggingChannel), METH_VARARGS, nullptr },
        { "add_log_file_generated", reinterpret_cast<PyCFunction>(FileLoggingSession_add_LogFileGenerated), METH_O, nullptr },
        { "remove_log_file_generated", reinterpret_cast<PyCFunction>(FileLoggingSession_remove_LogFileGenerated), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileLoggingSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_FileLoggingSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_FileLoggingSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileLoggingSession[] = {
        { "name", reinterpret_cast<getter>(FileLoggingSession_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileLoggingSession[] = 
    {
        { Py_tp_new, _new_FileLoggingSession },
        { Py_tp_dealloc, _dealloc_FileLoggingSession },
        { Py_tp_methods, _methods_FileLoggingSession },
        { Py_tp_getset, _getset_FileLoggingSession },
        { },
    };

    static PyType_Spec _type_spec_FileLoggingSession =
    {
        "_winsdk_Windows_Foundation_Diagnostics.FileLoggingSession",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::FileLoggingSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileLoggingSession
    };

    // ----- LogFileGeneratedEventArgs class --------------------
    constexpr const char* const _type_name_LogFileGeneratedEventArgs = "LogFileGeneratedEventArgs";

    static PyObject* _new_LogFileGeneratedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LogFileGeneratedEventArgs);
        return nullptr;
    }

    static void _dealloc_LogFileGeneratedEventArgs(py::wrapper::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LogFileGeneratedEventArgs_get_File(py::wrapper::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LogFileGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LogFileGeneratedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LogFileGeneratedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LogFileGeneratedEventArgs[] = {
        { "file", reinterpret_cast<getter>(LogFileGeneratedEventArgs_get_File), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LogFileGeneratedEventArgs[] = 
    {
        { Py_tp_new, _new_LogFileGeneratedEventArgs },
        { Py_tp_dealloc, _dealloc_LogFileGeneratedEventArgs },
        { Py_tp_methods, _methods_LogFileGeneratedEventArgs },
        { Py_tp_getset, _getset_LogFileGeneratedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_LogFileGeneratedEventArgs =
    {
        "_winsdk_Windows_Foundation_Diagnostics.LogFileGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LogFileGeneratedEventArgs
    };

    // ----- LoggingActivity class --------------------
    constexpr const char* const _type_name_LoggingActivity = "LoggingActivity";

    static PyObject* _new_LoggingActivity(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 1);

                winrt::Windows::Foundation::Diagnostics::LoggingActivity instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                winrt::Windows::Foundation::Diagnostics::LoggingActivity instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LoggingActivity_Close(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_IsEnabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.IsEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);

                return py::convert(self->obj.IsEnabled(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                return py::convert(self->obj.IsEnabled(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_LogEvent(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.LogEvent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                self->obj.LogEvent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                self->obj.LogEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                self->obj.LogEvent(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_StartActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.StartActivity(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                return py::convert(self->obj.StartActivity(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                return py::convert(self->obj.StartActivity(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                return py::convert(self->obj.StartActivity(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_StopActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.StopActivity(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                self->obj.StopActivity(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 2);

                self->obj.StopActivity(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_get_Id(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_get_Name(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingActivity_get_Channel(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LoggingActivity(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingActivity>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LoggingActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_LoggingActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingActivity[] = {
        { "close", reinterpret_cast<PyCFunction>(LoggingActivity_Close), METH_VARARGS, nullptr },
        { "is_enabled", reinterpret_cast<PyCFunction>(LoggingActivity_IsEnabled), METH_VARARGS, nullptr },
        { "log_event", reinterpret_cast<PyCFunction>(LoggingActivity_LogEvent), METH_VARARGS, nullptr },
        { "start_activity", reinterpret_cast<PyCFunction>(LoggingActivity_StartActivity), METH_VARARGS, nullptr },
        { "stop_activity", reinterpret_cast<PyCFunction>(LoggingActivity_StopActivity), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoggingActivity), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LoggingActivity), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LoggingActivity), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoggingActivity[] = {
        { "id", reinterpret_cast<getter>(LoggingActivity_get_Id), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(LoggingActivity_get_Name), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(LoggingActivity_get_Channel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoggingActivity[] = 
    {
        { Py_tp_new, _new_LoggingActivity },
        { Py_tp_dealloc, _dealloc_LoggingActivity },
        { Py_tp_methods, _methods_LoggingActivity },
        { Py_tp_getset, _getset_LoggingActivity },
        { },
    };

    static PyType_Spec _type_spec_LoggingActivity =
    {
        "_winsdk_Windows_Foundation_Diagnostics.LoggingActivity",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingActivity),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingActivity
    };

    // ----- LoggingChannel class --------------------
    constexpr const char* const _type_name_LoggingChannel = "LoggingChannel";

    static PyObject* _new_LoggingChannel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions>(args, 1);

                winrt::Windows::Foundation::Diagnostics::LoggingChannel instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                winrt::Windows::Foundation::Diagnostics::LoggingChannel instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::Diagnostics::LoggingChannel instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LoggingChannel_Close(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_IsEnabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.IsEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);

                return py::convert(self->obj.IsEnabled(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                return py::convert(self->obj.IsEnabled(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_LogEvent(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.LogEvent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                self->obj.LogEvent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                self->obj.LogEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                self->obj.LogEvent(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_LogMessage(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.LogMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                self->obj.LogMessage(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_LogValuePair(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.LogValuePair(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                self->obj.LogValuePair(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_StartActivity(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.StartActivity(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                return py::convert(self->obj.StartActivity(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                return py::convert(self->obj.StartActivity(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                return py::convert(self->obj.StartActivity(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_get_Enabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_get_Level(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Level());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_get_Name(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_get_Id(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_add_LoggingEnabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::Diagnostics::ILoggingChannel, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LoggingEnabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LoggingChannel_remove_LoggingEnabled(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LoggingEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LoggingChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_LoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingChannel[] = {
        { "close", reinterpret_cast<PyCFunction>(LoggingChannel_Close), METH_VARARGS, nullptr },
        { "is_enabled", reinterpret_cast<PyCFunction>(LoggingChannel_IsEnabled), METH_VARARGS, nullptr },
        { "log_event", reinterpret_cast<PyCFunction>(LoggingChannel_LogEvent), METH_VARARGS, nullptr },
        { "log_message", reinterpret_cast<PyCFunction>(LoggingChannel_LogMessage), METH_VARARGS, nullptr },
        { "log_value_pair", reinterpret_cast<PyCFunction>(LoggingChannel_LogValuePair), METH_VARARGS, nullptr },
        { "start_activity", reinterpret_cast<PyCFunction>(LoggingChannel_StartActivity), METH_VARARGS, nullptr },
        { "add_logging_enabled", reinterpret_cast<PyCFunction>(LoggingChannel_add_LoggingEnabled), METH_O, nullptr },
        { "remove_logging_enabled", reinterpret_cast<PyCFunction>(LoggingChannel_remove_LoggingEnabled), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoggingChannel), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LoggingChannel), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LoggingChannel), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoggingChannel[] = {
        { "enabled", reinterpret_cast<getter>(LoggingChannel_get_Enabled), nullptr, nullptr, nullptr },
        { "level", reinterpret_cast<getter>(LoggingChannel_get_Level), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(LoggingChannel_get_Name), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(LoggingChannel_get_Id), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoggingChannel[] = 
    {
        { Py_tp_new, _new_LoggingChannel },
        { Py_tp_dealloc, _dealloc_LoggingChannel },
        { Py_tp_methods, _methods_LoggingChannel },
        { Py_tp_getset, _getset_LoggingChannel },
        { },
    };

    static PyType_Spec _type_spec_LoggingChannel =
    {
        "_winsdk_Windows_Foundation_Diagnostics.LoggingChannel",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingChannel
    };

    // ----- LoggingChannelOptions class --------------------
    constexpr const char* const _type_name_LoggingChannelOptions = "LoggingChannelOptions";

    static PyObject* _new_LoggingChannelOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingChannelOptions(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannelOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LoggingChannelOptions_get_Group(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannelOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Group());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingChannelOptions_put_Group(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannelOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.Group(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LoggingChannelOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingChannelOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LoggingChannelOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoggingChannelOptions[] = {
        { "group", reinterpret_cast<getter>(LoggingChannelOptions_get_Group), reinterpret_cast<setter>(LoggingChannelOptions_put_Group), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoggingChannelOptions[] = 
    {
        { Py_tp_new, _new_LoggingChannelOptions },
        { Py_tp_dealloc, _dealloc_LoggingChannelOptions },
        { Py_tp_methods, _methods_LoggingChannelOptions },
        { Py_tp_getset, _getset_LoggingChannelOptions },
        { },
    };

    static PyType_Spec _type_spec_LoggingChannelOptions =
    {
        "_winsdk_Windows_Foundation_Diagnostics.LoggingChannelOptions",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingChannelOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingChannelOptions
    };

    // ----- LoggingFields class --------------------
    constexpr const char* const _type_name_LoggingFields = "LoggingFields";

    static PyObject* _new_LoggingFields(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Diagnostics::LoggingFields instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingFields(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LoggingFields_AddBoolean(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.AddBoolean(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddBoolean(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddBoolean(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddBooleanArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<bool>>(args, 1);

                self->obj.AddBooleanArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<bool>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddBooleanArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<bool>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddBooleanArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddChar16(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<char16_t>(args, 1);

                self->obj.AddChar16(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<char16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddChar16(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<char16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddChar16(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddChar16Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<char16_t>>(args, 1);

                self->obj.AddChar16Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<char16_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddChar16Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<char16_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddChar16Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDateTime(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                self->obj.AddDateTime(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddDateTime(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddDateTime(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDateTimeArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::DateTime>>(args, 1);

                self->obj.AddDateTimeArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::DateTime>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddDateTimeArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::DateTime>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddDateTimeArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDouble(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);

                self->obj.AddDouble(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddDouble(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<double>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddDouble(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddDoubleArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<double>>(args, 1);

                self->obj.AddDoubleArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<double>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddDoubleArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<double>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddDoubleArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddEmpty(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.AddEmpty(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 1);

                self->obj.AddEmpty(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);

                self->obj.AddEmpty(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddGuid(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                self->obj.AddGuid(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddGuid(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddGuid(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddGuidArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::guid>>(args, 1);

                self->obj.AddGuidArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::guid>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddGuidArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::guid>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddGuidArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt16(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int16_t>(args, 1);

                self->obj.AddInt16(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddInt16(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddInt16(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt16Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int16_t>>(args, 1);

                self->obj.AddInt16Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int16_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddInt16Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int16_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddInt16Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt32(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.AddInt32(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddInt32(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddInt32(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt32Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                self->obj.AddInt32Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddInt32Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddInt32Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt64(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                self->obj.AddInt64(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddInt64(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddInt64(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddInt64Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int64_t>>(args, 1);

                self->obj.AddInt64Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int64_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddInt64Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int64_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddInt64Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddPoint(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);

                self->obj.AddPoint(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddPoint(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Point>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddPoint(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddPointArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 1);

                self->obj.AddPointArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddPointArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddPointArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddRect(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);

                self->obj.AddRect(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddRect(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Rect>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddRect(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddRectArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Rect>>(args, 1);

                self->obj.AddRectArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Rect>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddRectArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Rect>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddRectArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSingle(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);

                self->obj.AddSingle(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddSingle(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<float>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddSingle(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSingleArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<float>>(args, 1);

                self->obj.AddSingleArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<float>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddSingleArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<float>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddSingleArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSize(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);

                self->obj.AddSize(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddSize(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Size>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddSize(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddSizeArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Size>>(args, 1);

                self->obj.AddSizeArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Size>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddSizeArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Size>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddSizeArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddString(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.AddString(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddString(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddString(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddStringArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::hstring>>(args, 1);

                self->obj.AddStringArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddStringArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddStringArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddTimeSpan(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                self->obj.AddTimeSpan(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddTimeSpan(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddTimeSpan(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddTimeSpanArray(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::TimeSpan>>(args, 1);

                self->obj.AddTimeSpanArray(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::TimeSpan>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddTimeSpanArray(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::TimeSpan>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddTimeSpanArray(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt16(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                self->obj.AddUInt16(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt16(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt16(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt16Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint16_t>>(args, 1);

                self->obj.AddUInt16Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint16_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt16Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint16_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt16Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt32(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                self->obj.AddUInt32(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt32(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt32(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt32Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint32_t>>(args, 1);

                self->obj.AddUInt32Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint32_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt32Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint32_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt32Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt64(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);

                self->obj.AddUInt64(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt64(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt64(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt64Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint64_t>>(args, 1);

                self->obj.AddUInt64Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint64_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt64Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint64_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt64Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt8(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                self->obj.AddUInt8(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt8(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt8(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_AddUInt8Array(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                self->obj.AddUInt8Array(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);

                self->obj.AddUInt8Array(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFieldFormat>(args, 2);
                auto param3 = py::convert_to<int32_t>(args, 3);

                self->obj.AddUInt8Array(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_BeginStruct(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.BeginStruct(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.BeginStruct(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_Clear(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingFields_EndStruct(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.EndStruct();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_LoggingFields(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingFields>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingFields[] = {
        { "add_boolean", reinterpret_cast<PyCFunction>(LoggingFields_AddBoolean), METH_VARARGS, nullptr },
        { "add_boolean_array", reinterpret_cast<PyCFunction>(LoggingFields_AddBooleanArray), METH_VARARGS, nullptr },
        { "add_char16", reinterpret_cast<PyCFunction>(LoggingFields_AddChar16), METH_VARARGS, nullptr },
        { "add_char16_array", reinterpret_cast<PyCFunction>(LoggingFields_AddChar16Array), METH_VARARGS, nullptr },
        { "add_date_time", reinterpret_cast<PyCFunction>(LoggingFields_AddDateTime), METH_VARARGS, nullptr },
        { "add_date_time_array", reinterpret_cast<PyCFunction>(LoggingFields_AddDateTimeArray), METH_VARARGS, nullptr },
        { "add_double", reinterpret_cast<PyCFunction>(LoggingFields_AddDouble), METH_VARARGS, nullptr },
        { "add_double_array", reinterpret_cast<PyCFunction>(LoggingFields_AddDoubleArray), METH_VARARGS, nullptr },
        { "add_empty", reinterpret_cast<PyCFunction>(LoggingFields_AddEmpty), METH_VARARGS, nullptr },
        { "add_guid", reinterpret_cast<PyCFunction>(LoggingFields_AddGuid), METH_VARARGS, nullptr },
        { "add_guid_array", reinterpret_cast<PyCFunction>(LoggingFields_AddGuidArray), METH_VARARGS, nullptr },
        { "add_int16", reinterpret_cast<PyCFunction>(LoggingFields_AddInt16), METH_VARARGS, nullptr },
        { "add_int16_array", reinterpret_cast<PyCFunction>(LoggingFields_AddInt16Array), METH_VARARGS, nullptr },
        { "add_int32", reinterpret_cast<PyCFunction>(LoggingFields_AddInt32), METH_VARARGS, nullptr },
        { "add_int32_array", reinterpret_cast<PyCFunction>(LoggingFields_AddInt32Array), METH_VARARGS, nullptr },
        { "add_int64", reinterpret_cast<PyCFunction>(LoggingFields_AddInt64), METH_VARARGS, nullptr },
        { "add_int64_array", reinterpret_cast<PyCFunction>(LoggingFields_AddInt64Array), METH_VARARGS, nullptr },
        { "add_point", reinterpret_cast<PyCFunction>(LoggingFields_AddPoint), METH_VARARGS, nullptr },
        { "add_point_array", reinterpret_cast<PyCFunction>(LoggingFields_AddPointArray), METH_VARARGS, nullptr },
        { "add_rect", reinterpret_cast<PyCFunction>(LoggingFields_AddRect), METH_VARARGS, nullptr },
        { "add_rect_array", reinterpret_cast<PyCFunction>(LoggingFields_AddRectArray), METH_VARARGS, nullptr },
        { "add_single", reinterpret_cast<PyCFunction>(LoggingFields_AddSingle), METH_VARARGS, nullptr },
        { "add_single_array", reinterpret_cast<PyCFunction>(LoggingFields_AddSingleArray), METH_VARARGS, nullptr },
        { "add_size", reinterpret_cast<PyCFunction>(LoggingFields_AddSize), METH_VARARGS, nullptr },
        { "add_size_array", reinterpret_cast<PyCFunction>(LoggingFields_AddSizeArray), METH_VARARGS, nullptr },
        { "add_string", reinterpret_cast<PyCFunction>(LoggingFields_AddString), METH_VARARGS, nullptr },
        { "add_string_array", reinterpret_cast<PyCFunction>(LoggingFields_AddStringArray), METH_VARARGS, nullptr },
        { "add_time_span", reinterpret_cast<PyCFunction>(LoggingFields_AddTimeSpan), METH_VARARGS, nullptr },
        { "add_time_span_array", reinterpret_cast<PyCFunction>(LoggingFields_AddTimeSpanArray), METH_VARARGS, nullptr },
        { "add_uint16", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt16), METH_VARARGS, nullptr },
        { "add_uint16_array", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt16Array), METH_VARARGS, nullptr },
        { "add_uint32", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt32), METH_VARARGS, nullptr },
        { "add_uint32_array", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt32Array), METH_VARARGS, nullptr },
        { "add_uint64", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt64), METH_VARARGS, nullptr },
        { "add_uint64_array", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt64Array), METH_VARARGS, nullptr },
        { "add_uint8", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt8), METH_VARARGS, nullptr },
        { "add_uint8_array", reinterpret_cast<PyCFunction>(LoggingFields_AddUInt8Array), METH_VARARGS, nullptr },
        { "begin_struct", reinterpret_cast<PyCFunction>(LoggingFields_BeginStruct), METH_VARARGS, nullptr },
        { "clear", reinterpret_cast<PyCFunction>(LoggingFields_Clear), METH_VARARGS, nullptr },
        { "end_struct", reinterpret_cast<PyCFunction>(LoggingFields_EndStruct), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoggingFields), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoggingFields[] = {
        { }
    };

    static PyType_Slot _type_slots_LoggingFields[] = 
    {
        { Py_tp_new, _new_LoggingFields },
        { Py_tp_dealloc, _dealloc_LoggingFields },
        { Py_tp_methods, _methods_LoggingFields },
        { Py_tp_getset, _getset_LoggingFields },
        { },
    };

    static PyType_Spec _type_spec_LoggingFields =
    {
        "_winsdk_Windows_Foundation_Diagnostics.LoggingFields",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingFields),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingFields
    };

    // ----- LoggingOptions class --------------------
    constexpr const char* const _type_name_LoggingOptions = "LoggingOptions";

    static PyObject* _new_LoggingOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Diagnostics::LoggingOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int64_t>(args, 0);

                winrt::Windows::Foundation::Diagnostics::LoggingOptions instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingOptions(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LoggingOptions_get_Task(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Task());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_Task(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int16_t>(arg);

            self->obj.Task(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_Tags(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tags());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_Tags(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Tags(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_RelatedActivityId(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelatedActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_RelatedActivityId(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.RelatedActivityId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_Opcode(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Opcode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_Opcode(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOpcode>(arg);

            self->obj.Opcode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_Keywords(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Keywords());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_Keywords(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int64_t>(arg);

            self->obj.Keywords(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LoggingOptions_get_ActivityId(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LoggingOptions_put_ActivityId(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.ActivityId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LoggingOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LoggingOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoggingOptions[] = {
        { "task", reinterpret_cast<getter>(LoggingOptions_get_Task), reinterpret_cast<setter>(LoggingOptions_put_Task), nullptr, nullptr },
        { "tags", reinterpret_cast<getter>(LoggingOptions_get_Tags), reinterpret_cast<setter>(LoggingOptions_put_Tags), nullptr, nullptr },
        { "related_activity_id", reinterpret_cast<getter>(LoggingOptions_get_RelatedActivityId), reinterpret_cast<setter>(LoggingOptions_put_RelatedActivityId), nullptr, nullptr },
        { "opcode", reinterpret_cast<getter>(LoggingOptions_get_Opcode), reinterpret_cast<setter>(LoggingOptions_put_Opcode), nullptr, nullptr },
        { "keywords", reinterpret_cast<getter>(LoggingOptions_get_Keywords), reinterpret_cast<setter>(LoggingOptions_put_Keywords), nullptr, nullptr },
        { "activity_id", reinterpret_cast<getter>(LoggingOptions_get_ActivityId), reinterpret_cast<setter>(LoggingOptions_put_ActivityId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoggingOptions[] = 
    {
        { Py_tp_new, _new_LoggingOptions },
        { Py_tp_dealloc, _dealloc_LoggingOptions },
        { Py_tp_methods, _methods_LoggingOptions },
        { Py_tp_getset, _getset_LoggingOptions },
        { },
    };

    static PyType_Spec _type_spec_LoggingOptions =
    {
        "_winsdk_Windows_Foundation_Diagnostics.LoggingOptions",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingOptions
    };

    // ----- LoggingSession class --------------------
    constexpr const char* const _type_name_LoggingSession = "LoggingSession";

    static PyObject* _new_LoggingSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Foundation::Diagnostics::LoggingSession instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LoggingSession(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LoggingSession_AddLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.AddLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                self->obj.AddLoggingChannel(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingSession_Close(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingSession_RemoveLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.RemoveLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingSession_SaveToFileAsync(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.SaveToFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LoggingSession_get_Name(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::LoggingSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_LoggingSession(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_LoggingSession(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LoggingSession[] = {
        { "add_logging_channel", reinterpret_cast<PyCFunction>(LoggingSession_AddLoggingChannel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(LoggingSession_Close), METH_VARARGS, nullptr },
        { "remove_logging_channel", reinterpret_cast<PyCFunction>(LoggingSession_RemoveLoggingChannel), METH_VARARGS, nullptr },
        { "save_to_file_async", reinterpret_cast<PyCFunction>(LoggingSession_SaveToFileAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LoggingSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_LoggingSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_LoggingSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_LoggingSession[] = {
        { "name", reinterpret_cast<getter>(LoggingSession_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LoggingSession[] = 
    {
        { Py_tp_new, _new_LoggingSession },
        { Py_tp_dealloc, _dealloc_LoggingSession },
        { Py_tp_methods, _methods_LoggingSession },
        { Py_tp_getset, _getset_LoggingSession },
        { },
    };

    static PyType_Spec _type_spec_LoggingSession =
    {
        "_winsdk_Windows_Foundation_Diagnostics.LoggingSession",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::LoggingSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LoggingSession
    };

    // ----- RuntimeBrokerErrorSettings class --------------------
    constexpr const char* const _type_name_RuntimeBrokerErrorSettings = "RuntimeBrokerErrorSettings";

    static PyObject* _new_RuntimeBrokerErrorSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RuntimeBrokerErrorSettings(py::wrapper::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RuntimeBrokerErrorSettings_GetErrorOptions(py::wrapper::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetErrorOptions());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RuntimeBrokerErrorSettings_SetErrorOptions(py::wrapper::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ErrorOptions>(args, 0);

                self->obj.SetErrorOptions(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_RuntimeBrokerErrorSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RuntimeBrokerErrorSettings[] = {
        { "get_error_options", reinterpret_cast<PyCFunction>(RuntimeBrokerErrorSettings_GetErrorOptions), METH_VARARGS, nullptr },
        { "set_error_options", reinterpret_cast<PyCFunction>(RuntimeBrokerErrorSettings_SetErrorOptions), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RuntimeBrokerErrorSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RuntimeBrokerErrorSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_RuntimeBrokerErrorSettings[] = 
    {
        { Py_tp_new, _new_RuntimeBrokerErrorSettings },
        { Py_tp_dealloc, _dealloc_RuntimeBrokerErrorSettings },
        { Py_tp_methods, _methods_RuntimeBrokerErrorSettings },
        { Py_tp_getset, _getset_RuntimeBrokerErrorSettings },
        { },
    };

    static PyType_Spec _type_spec_RuntimeBrokerErrorSettings =
    {
        "_winsdk_Windows_Foundation_Diagnostics.RuntimeBrokerErrorSettings",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RuntimeBrokerErrorSettings
    };

    // ----- TracingStatusChangedEventArgs class --------------------
    constexpr const char* const _type_name_TracingStatusChangedEventArgs = "TracingStatusChangedEventArgs";

    static PyObject* _new_TracingStatusChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TracingStatusChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_TracingStatusChangedEventArgs(py::wrapper::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TracingStatusChangedEventArgs_get_Enabled(py::wrapper::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TracingStatusChangedEventArgs_get_TraceLevel(py::wrapper::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TraceLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TracingStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TracingStatusChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TracingStatusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TracingStatusChangedEventArgs[] = {
        { "enabled", reinterpret_cast<getter>(TracingStatusChangedEventArgs_get_Enabled), nullptr, nullptr, nullptr },
        { "trace_level", reinterpret_cast<getter>(TracingStatusChangedEventArgs_get_TraceLevel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TracingStatusChangedEventArgs[] = 
    {
        { Py_tp_new, _new_TracingStatusChangedEventArgs },
        { Py_tp_dealloc, _dealloc_TracingStatusChangedEventArgs },
        { Py_tp_methods, _methods_TracingStatusChangedEventArgs },
        { Py_tp_getset, _getset_TracingStatusChangedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_TracingStatusChangedEventArgs =
    {
        "_winsdk_Windows_Foundation_Diagnostics.TracingStatusChangedEventArgs",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TracingStatusChangedEventArgs
    };

    // ----- IErrorReportingSettings interface --------------------
    constexpr const char* const _type_name_IErrorReportingSettings = "IErrorReportingSettings";

    static PyObject* _new_IErrorReportingSettings(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IErrorReportingSettings);
        return nullptr;
    }

    static void _dealloc_IErrorReportingSettings(py::wrapper::Windows::Foundation::Diagnostics::IErrorReportingSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IErrorReportingSettings_GetErrorOptions(py::wrapper::Windows::Foundation::Diagnostics::IErrorReportingSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetErrorOptions());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IErrorReportingSettings_SetErrorOptions(py::wrapper::Windows::Foundation::Diagnostics::IErrorReportingSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ErrorOptions>(args, 0);

                self->obj.SetErrorOptions(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IErrorReportingSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::IErrorReportingSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IErrorReportingSettings[] = {
        { "get_error_options", reinterpret_cast<PyCFunction>(IErrorReportingSettings_GetErrorOptions), METH_VARARGS, nullptr },
        { "set_error_options", reinterpret_cast<PyCFunction>(IErrorReportingSettings_SetErrorOptions), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IErrorReportingSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IErrorReportingSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_IErrorReportingSettings[] = 
    {
        { Py_tp_new, _new_IErrorReportingSettings },
        { Py_tp_dealloc, _dealloc_IErrorReportingSettings },
        { Py_tp_methods, _methods_IErrorReportingSettings },
        { Py_tp_getset, _getset_IErrorReportingSettings },
        { },
    };

    static PyType_Spec _type_spec_IErrorReportingSettings =
    {
        "_winsdk_Windows_Foundation_Diagnostics.IErrorReportingSettings",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::IErrorReportingSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IErrorReportingSettings
    };

    // ----- IFileLoggingSession interface --------------------
    constexpr const char* const _type_name_IFileLoggingSession = "IFileLoggingSession";

    static PyObject* _new_IFileLoggingSession(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IFileLoggingSession);
        return nullptr;
    }

    static void _dealloc_IFileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IFileLoggingSession_AddLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.AddLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                self->obj.AddLoggingChannel(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_Close(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_CloseAndSaveToFileAsync(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CloseAndSaveToFileAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_RemoveLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.RemoveLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_get_Name(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_add_LogFileGenerated(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession, winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>>(arg);

            return py::convert(self->obj.LogFileGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileLoggingSession_remove_LogFileGenerated(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LogFileGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IFileLoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IFileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IFileLoggingSession(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileLoggingSession[] = {
        { "add_logging_channel", reinterpret_cast<PyCFunction>(IFileLoggingSession_AddLoggingChannel), METH_VARARGS, nullptr },
        { "close_and_save_to_file_async", reinterpret_cast<PyCFunction>(IFileLoggingSession_CloseAndSaveToFileAsync), METH_VARARGS, nullptr },
        { "remove_logging_channel", reinterpret_cast<PyCFunction>(IFileLoggingSession_RemoveLoggingChannel), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IFileLoggingSession_Close), METH_VARARGS, nullptr },
        { "add_log_file_generated", reinterpret_cast<PyCFunction>(IFileLoggingSession_add_LogFileGenerated), METH_O, nullptr },
        { "remove_log_file_generated", reinterpret_cast<PyCFunction>(IFileLoggingSession_remove_LogFileGenerated), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileLoggingSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IFileLoggingSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IFileLoggingSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileLoggingSession[] = {
        { "name", reinterpret_cast<getter>(IFileLoggingSession_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileLoggingSession[] = 
    {
        { Py_tp_new, _new_IFileLoggingSession },
        { Py_tp_dealloc, _dealloc_IFileLoggingSession },
        { Py_tp_methods, _methods_IFileLoggingSession },
        { Py_tp_getset, _getset_IFileLoggingSession },
        { },
    };

    static PyType_Spec _type_spec_IFileLoggingSession =
    {
        "_winsdk_Windows_Foundation_Diagnostics.IFileLoggingSession",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::IFileLoggingSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileLoggingSession
    };

    // ----- ILoggingChannel interface --------------------
    constexpr const char* const _type_name_ILoggingChannel = "ILoggingChannel";

    static PyObject* _new_ILoggingChannel(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILoggingChannel);
        return nullptr;
    }

    static void _dealloc_ILoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILoggingChannel_Close(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_LogMessage(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.LogMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                self->obj.LogMessage(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_LogValuePair(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                self->obj.LogValuePair(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                self->obj.LogValuePair(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_get_Enabled(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_get_Level(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Level());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_get_Name(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_add_LoggingEnabled(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::Diagnostics::ILoggingChannel, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LoggingEnabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILoggingChannel_remove_LoggingEnabled(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LoggingEnabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ILoggingChannel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ILoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ILoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILoggingChannel[] = {
        { "log_message", reinterpret_cast<PyCFunction>(ILoggingChannel_LogMessage), METH_VARARGS, nullptr },
        { "log_value_pair", reinterpret_cast<PyCFunction>(ILoggingChannel_LogValuePair), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ILoggingChannel_Close), METH_VARARGS, nullptr },
        { "add_logging_enabled", reinterpret_cast<PyCFunction>(ILoggingChannel_add_LoggingEnabled), METH_O, nullptr },
        { "remove_logging_enabled", reinterpret_cast<PyCFunction>(ILoggingChannel_remove_LoggingEnabled), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILoggingChannel), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ILoggingChannel), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ILoggingChannel), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILoggingChannel[] = {
        { "enabled", reinterpret_cast<getter>(ILoggingChannel_get_Enabled), nullptr, nullptr, nullptr },
        { "level", reinterpret_cast<getter>(ILoggingChannel_get_Level), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(ILoggingChannel_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILoggingChannel[] = 
    {
        { Py_tp_new, _new_ILoggingChannel },
        { Py_tp_dealloc, _dealloc_ILoggingChannel },
        { Py_tp_methods, _methods_ILoggingChannel },
        { Py_tp_getset, _getset_ILoggingChannel },
        { },
    };

    static PyType_Spec _type_spec_ILoggingChannel =
    {
        "_winsdk_Windows_Foundation_Diagnostics.ILoggingChannel",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::ILoggingChannel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILoggingChannel
    };

    // ----- ILoggingSession interface --------------------
    constexpr const char* const _type_name_ILoggingSession = "ILoggingSession";

    static PyObject* _new_ILoggingSession(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILoggingSession);
        return nullptr;
    }

    static void _dealloc_ILoggingSession(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILoggingSession_AddLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.AddLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 1);

                self->obj.AddLoggingChannel(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingSession_Close(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingSession_RemoveLoggingChannel(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>(args, 0);

                self->obj.RemoveLoggingChannel(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingSession_SaveToFileAsync(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.SaveToFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingSession_get_Name(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ILoggingSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::ILoggingSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ILoggingSession(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ILoggingSession(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILoggingSession[] = {
        { "add_logging_channel", reinterpret_cast<PyCFunction>(ILoggingSession_AddLoggingChannel), METH_VARARGS, nullptr },
        { "remove_logging_channel", reinterpret_cast<PyCFunction>(ILoggingSession_RemoveLoggingChannel), METH_VARARGS, nullptr },
        { "save_to_file_async", reinterpret_cast<PyCFunction>(ILoggingSession_SaveToFileAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ILoggingSession_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILoggingSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ILoggingSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ILoggingSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILoggingSession[] = {
        { "name", reinterpret_cast<getter>(ILoggingSession_get_Name), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILoggingSession[] = 
    {
        { Py_tp_new, _new_ILoggingSession },
        { Py_tp_dealloc, _dealloc_ILoggingSession },
        { Py_tp_methods, _methods_ILoggingSession },
        { Py_tp_getset, _getset_ILoggingSession },
        { },
    };

    static PyType_Spec _type_spec_ILoggingSession =
    {
        "_winsdk_Windows_Foundation_Diagnostics.ILoggingSession",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::ILoggingSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILoggingSession
    };

    // ----- ILoggingTarget interface --------------------
    constexpr const char* const _type_name_ILoggingTarget = "ILoggingTarget";

    static PyObject* _new_ILoggingTarget(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILoggingTarget);
        return nullptr;
    }

    static void _dealloc_ILoggingTarget(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILoggingTarget_IsEnabled(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.IsEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);

                return py::convert(self->obj.IsEnabled(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 0);
                auto param1 = py::convert_to<int64_t>(args, 1);

                return py::convert(self->obj.IsEnabled(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingTarget_LogEvent(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.LogEvent(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                self->obj.LogEvent(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                self->obj.LogEvent(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                self->obj.LogEvent(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ILoggingTarget_StartActivity(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.StartActivity(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);

                return py::convert(self->obj.StartActivity(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);

                return py::convert(self->obj.StartActivity(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingFields>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingLevel>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Diagnostics::LoggingOptions>(args, 3);

                return py::convert(self->obj.StartActivity(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ILoggingTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Foundation::Diagnostics::ILoggingTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILoggingTarget[] = {
        { "is_enabled", reinterpret_cast<PyCFunction>(ILoggingTarget_IsEnabled), METH_VARARGS, nullptr },
        { "log_event", reinterpret_cast<PyCFunction>(ILoggingTarget_LogEvent), METH_VARARGS, nullptr },
        { "start_activity", reinterpret_cast<PyCFunction>(ILoggingTarget_StartActivity), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ILoggingTarget), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILoggingTarget[] = {
        { }
    };

    static PyType_Slot _type_slots_ILoggingTarget[] = 
    {
        { Py_tp_new, _new_ILoggingTarget },
        { Py_tp_dealloc, _dealloc_ILoggingTarget },
        { Py_tp_methods, _methods_ILoggingTarget },
        { Py_tp_getset, _getset_ILoggingTarget },
        { },
    };

    static PyType_Spec _type_spec_ILoggingTarget =
    {
        "_winsdk_Windows_Foundation_Diagnostics.ILoggingTarget",
        sizeof(py::wrapper::Windows::Foundation::Diagnostics::ILoggingTarget),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILoggingTarget
    };

    // ----- Windows.Foundation.Diagnostics Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Foundation::Diagnostics::AsyncCausalityTracer>::python_type = py::register_python_type(module, _type_name_AsyncCausalityTracer, &_type_spec_AsyncCausalityTracer, nullptr);
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::ErrorDetails>::python_type = py::register_python_type(module, _type_name_ErrorDetails, &_type_spec_ErrorDetails, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::FileLoggingSession>::python_type = py::register_python_type(module, _type_name_FileLoggingSession, &_type_spec_FileLoggingSession, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::LogFileGeneratedEventArgs>::python_type = py::register_python_type(module, _type_name_LogFileGeneratedEventArgs, &_type_spec_LogFileGeneratedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingActivity>::python_type = py::register_python_type(module, _type_name_LoggingActivity, &_type_spec_LoggingActivity, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingChannel>::python_type = py::register_python_type(module, _type_name_LoggingChannel, &_type_spec_LoggingChannel, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingChannelOptions>::python_type = py::register_python_type(module, _type_name_LoggingChannelOptions, &_type_spec_LoggingChannelOptions, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingFields>::python_type = py::register_python_type(module, _type_name_LoggingFields, &_type_spec_LoggingFields, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingOptions>::python_type = py::register_python_type(module, _type_name_LoggingOptions, &_type_spec_LoggingOptions, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::LoggingSession>::python_type = py::register_python_type(module, _type_name_LoggingSession, &_type_spec_LoggingSession, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::RuntimeBrokerErrorSettings>::python_type = py::register_python_type(module, _type_name_RuntimeBrokerErrorSettings, &_type_spec_RuntimeBrokerErrorSettings, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::TracingStatusChangedEventArgs>::python_type = py::register_python_type(module, _type_name_TracingStatusChangedEventArgs, &_type_spec_TracingStatusChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::IErrorReportingSettings>::python_type = py::register_python_type(module, _type_name_IErrorReportingSettings, &_type_spec_IErrorReportingSettings, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::IFileLoggingSession>::python_type = py::register_python_type(module, _type_name_IFileLoggingSession, &_type_spec_IFileLoggingSession, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::ILoggingChannel>::python_type = py::register_python_type(module, _type_name_ILoggingChannel, &_type_spec_ILoggingChannel, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::ILoggingSession>::python_type = py::register_python_type(module, _type_name_ILoggingSession, &_type_spec_ILoggingSession, bases.get());
            py::winrt_type<winrt::Windows::Foundation::Diagnostics::ILoggingTarget>::python_type = py::register_python_type(module, _type_name_ILoggingTarget, &_type_spec_ILoggingTarget, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Foundation.Diagnostics");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Foundation_Diagnostics",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Foundation::Diagnostics

PyMODINIT_FUNC
PyInit__winsdk_Windows_Foundation_Diagnostics (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Foundation::Diagnostics::module_def);
}
