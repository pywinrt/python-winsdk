// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Gaming.Input.h"

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::ArcadeStick>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::FlightStick>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Gamepad>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Headset>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::RacingWheel>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::RawGameController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::UINavigationController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::IGameController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::ArcadeStickReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::FlightStickReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::GamepadReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::GamepadVibration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::RacingWheelReading>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::UINavigationReading>::python_type;

PyObject* py::converter<winrt::Windows::Gaming::Input::ArcadeStickReading>::convert(winrt::Windows::Gaming::Input::ArcadeStickReading instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Gaming::Input::ArcadeStickReading>());
}
winrt::Windows::Gaming::Input::ArcadeStickReading py::converter<winrt::Windows::Gaming::Input::ArcadeStickReading>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Gaming::Input::ArcadeStickReading>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::ArcadeStickReading>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Gaming::Input::ArcadeStickReading return_value{};

    PyObject* py_Timestamp = PyDict_GetItemString(obj, "timestamp");
    if (!py_Timestamp) { throw winrt::hresult_invalid_argument(); }
    return_value.Timestamp = converter<uint64_t>::convert_to(py_Timestamp);

    PyObject* py_Buttons = PyDict_GetItemString(obj, "buttons");
    if (!py_Buttons) { throw winrt::hresult_invalid_argument(); }
    return_value.Buttons = converter<winrt::Windows::Gaming::Input::ArcadeStickButtons>::convert_to(py_Buttons);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Gaming::Input::FlightStickReading>::convert(winrt::Windows::Gaming::Input::FlightStickReading instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Gaming::Input::FlightStickReading>());
}
winrt::Windows::Gaming::Input::FlightStickReading py::converter<winrt::Windows::Gaming::Input::FlightStickReading>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Gaming::Input::FlightStickReading>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::FlightStickReading>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Gaming::Input::FlightStickReading return_value{};

    PyObject* py_Timestamp = PyDict_GetItemString(obj, "timestamp");
    if (!py_Timestamp) { throw winrt::hresult_invalid_argument(); }
    return_value.Timestamp = converter<uint64_t>::convert_to(py_Timestamp);

    PyObject* py_Buttons = PyDict_GetItemString(obj, "buttons");
    if (!py_Buttons) { throw winrt::hresult_invalid_argument(); }
    return_value.Buttons = converter<winrt::Windows::Gaming::Input::FlightStickButtons>::convert_to(py_Buttons);

    PyObject* py_HatSwitch = PyDict_GetItemString(obj, "hat_switch");
    if (!py_HatSwitch) { throw winrt::hresult_invalid_argument(); }
    return_value.HatSwitch = converter<winrt::Windows::Gaming::Input::GameControllerSwitchPosition>::convert_to(py_HatSwitch);

    PyObject* py_Roll = PyDict_GetItemString(obj, "roll");
    if (!py_Roll) { throw winrt::hresult_invalid_argument(); }
    return_value.Roll = converter<double>::convert_to(py_Roll);

    PyObject* py_Pitch = PyDict_GetItemString(obj, "pitch");
    if (!py_Pitch) { throw winrt::hresult_invalid_argument(); }
    return_value.Pitch = converter<double>::convert_to(py_Pitch);

    PyObject* py_Yaw = PyDict_GetItemString(obj, "yaw");
    if (!py_Yaw) { throw winrt::hresult_invalid_argument(); }
    return_value.Yaw = converter<double>::convert_to(py_Yaw);

    PyObject* py_Throttle = PyDict_GetItemString(obj, "throttle");
    if (!py_Throttle) { throw winrt::hresult_invalid_argument(); }
    return_value.Throttle = converter<double>::convert_to(py_Throttle);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Gaming::Input::GamepadReading>::convert(winrt::Windows::Gaming::Input::GamepadReading instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Gaming::Input::GamepadReading>());
}
winrt::Windows::Gaming::Input::GamepadReading py::converter<winrt::Windows::Gaming::Input::GamepadReading>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Gaming::Input::GamepadReading>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadReading>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Gaming::Input::GamepadReading return_value{};

    PyObject* py_Timestamp = PyDict_GetItemString(obj, "timestamp");
    if (!py_Timestamp) { throw winrt::hresult_invalid_argument(); }
    return_value.Timestamp = converter<uint64_t>::convert_to(py_Timestamp);

    PyObject* py_Buttons = PyDict_GetItemString(obj, "buttons");
    if (!py_Buttons) { throw winrt::hresult_invalid_argument(); }
    return_value.Buttons = converter<winrt::Windows::Gaming::Input::GamepadButtons>::convert_to(py_Buttons);

    PyObject* py_LeftTrigger = PyDict_GetItemString(obj, "left_trigger");
    if (!py_LeftTrigger) { throw winrt::hresult_invalid_argument(); }
    return_value.LeftTrigger = converter<double>::convert_to(py_LeftTrigger);

    PyObject* py_RightTrigger = PyDict_GetItemString(obj, "right_trigger");
    if (!py_RightTrigger) { throw winrt::hresult_invalid_argument(); }
    return_value.RightTrigger = converter<double>::convert_to(py_RightTrigger);

    PyObject* py_LeftThumbstickX = PyDict_GetItemString(obj, "left_thumbstick_x");
    if (!py_LeftThumbstickX) { throw winrt::hresult_invalid_argument(); }
    return_value.LeftThumbstickX = converter<double>::convert_to(py_LeftThumbstickX);

    PyObject* py_LeftThumbstickY = PyDict_GetItemString(obj, "left_thumbstick_y");
    if (!py_LeftThumbstickY) { throw winrt::hresult_invalid_argument(); }
    return_value.LeftThumbstickY = converter<double>::convert_to(py_LeftThumbstickY);

    PyObject* py_RightThumbstickX = PyDict_GetItemString(obj, "right_thumbstick_x");
    if (!py_RightThumbstickX) { throw winrt::hresult_invalid_argument(); }
    return_value.RightThumbstickX = converter<double>::convert_to(py_RightThumbstickX);

    PyObject* py_RightThumbstickY = PyDict_GetItemString(obj, "right_thumbstick_y");
    if (!py_RightThumbstickY) { throw winrt::hresult_invalid_argument(); }
    return_value.RightThumbstickY = converter<double>::convert_to(py_RightThumbstickY);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Gaming::Input::GamepadVibration>::convert(winrt::Windows::Gaming::Input::GamepadVibration instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Gaming::Input::GamepadVibration>());
}
winrt::Windows::Gaming::Input::GamepadVibration py::converter<winrt::Windows::Gaming::Input::GamepadVibration>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Gaming::Input::GamepadVibration>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadVibration>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Gaming::Input::GamepadVibration return_value{};

    PyObject* py_LeftMotor = PyDict_GetItemString(obj, "left_motor");
    if (!py_LeftMotor) { throw winrt::hresult_invalid_argument(); }
    return_value.LeftMotor = converter<double>::convert_to(py_LeftMotor);

    PyObject* py_RightMotor = PyDict_GetItemString(obj, "right_motor");
    if (!py_RightMotor) { throw winrt::hresult_invalid_argument(); }
    return_value.RightMotor = converter<double>::convert_to(py_RightMotor);

    PyObject* py_LeftTrigger = PyDict_GetItemString(obj, "left_trigger");
    if (!py_LeftTrigger) { throw winrt::hresult_invalid_argument(); }
    return_value.LeftTrigger = converter<double>::convert_to(py_LeftTrigger);

    PyObject* py_RightTrigger = PyDict_GetItemString(obj, "right_trigger");
    if (!py_RightTrigger) { throw winrt::hresult_invalid_argument(); }
    return_value.RightTrigger = converter<double>::convert_to(py_RightTrigger);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Gaming::Input::RacingWheelReading>::convert(winrt::Windows::Gaming::Input::RacingWheelReading instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Gaming::Input::RacingWheelReading>());
}
winrt::Windows::Gaming::Input::RacingWheelReading py::converter<winrt::Windows::Gaming::Input::RacingWheelReading>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Gaming::Input::RacingWheelReading>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::RacingWheelReading>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Gaming::Input::RacingWheelReading return_value{};

    PyObject* py_Timestamp = PyDict_GetItemString(obj, "timestamp");
    if (!py_Timestamp) { throw winrt::hresult_invalid_argument(); }
    return_value.Timestamp = converter<uint64_t>::convert_to(py_Timestamp);

    PyObject* py_Buttons = PyDict_GetItemString(obj, "buttons");
    if (!py_Buttons) { throw winrt::hresult_invalid_argument(); }
    return_value.Buttons = converter<winrt::Windows::Gaming::Input::RacingWheelButtons>::convert_to(py_Buttons);

    PyObject* py_PatternShifterGear = PyDict_GetItemString(obj, "pattern_shifter_gear");
    if (!py_PatternShifterGear) { throw winrt::hresult_invalid_argument(); }
    return_value.PatternShifterGear = converter<int32_t>::convert_to(py_PatternShifterGear);

    PyObject* py_Wheel = PyDict_GetItemString(obj, "wheel");
    if (!py_Wheel) { throw winrt::hresult_invalid_argument(); }
    return_value.Wheel = converter<double>::convert_to(py_Wheel);

    PyObject* py_Throttle = PyDict_GetItemString(obj, "throttle");
    if (!py_Throttle) { throw winrt::hresult_invalid_argument(); }
    return_value.Throttle = converter<double>::convert_to(py_Throttle);

    PyObject* py_Brake = PyDict_GetItemString(obj, "brake");
    if (!py_Brake) { throw winrt::hresult_invalid_argument(); }
    return_value.Brake = converter<double>::convert_to(py_Brake);

    PyObject* py_Clutch = PyDict_GetItemString(obj, "clutch");
    if (!py_Clutch) { throw winrt::hresult_invalid_argument(); }
    return_value.Clutch = converter<double>::convert_to(py_Clutch);

    PyObject* py_Handbrake = PyDict_GetItemString(obj, "handbrake");
    if (!py_Handbrake) { throw winrt::hresult_invalid_argument(); }
    return_value.Handbrake = converter<double>::convert_to(py_Handbrake);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Gaming::Input::UINavigationReading>::convert(winrt::Windows::Gaming::Input::UINavigationReading instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Gaming::Input::UINavigationReading>());
}
winrt::Windows::Gaming::Input::UINavigationReading py::converter<winrt::Windows::Gaming::Input::UINavigationReading>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Gaming::Input::UINavigationReading>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::UINavigationReading>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Gaming::Input::UINavigationReading return_value{};

    PyObject* py_Timestamp = PyDict_GetItemString(obj, "timestamp");
    if (!py_Timestamp) { throw winrt::hresult_invalid_argument(); }
    return_value.Timestamp = converter<uint64_t>::convert_to(py_Timestamp);

    PyObject* py_RequiredButtons = PyDict_GetItemString(obj, "required_buttons");
    if (!py_RequiredButtons) { throw winrt::hresult_invalid_argument(); }
    return_value.RequiredButtons = converter<winrt::Windows::Gaming::Input::RequiredUINavigationButtons>::convert_to(py_RequiredButtons);

    PyObject* py_OptionalButtons = PyDict_GetItemString(obj, "optional_buttons");
    if (!py_OptionalButtons) { throw winrt::hresult_invalid_argument(); }
    return_value.OptionalButtons = converter<winrt::Windows::Gaming::Input::OptionalUINavigationButtons>::convert_to(py_OptionalButtons);

    return return_value;
}

namespace py::cpp::Windows::Gaming::Input
{
    // ----- ArcadeStick class --------------------
    constexpr const char* const _type_name_ArcadeStick = "ArcadeStick";

    static PyObject* _new_ArcadeStick(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ArcadeStick);
        return nullptr;
    }

    static void _dealloc_ArcadeStick(py::wrapper::Windows::Gaming::Input::ArcadeStick* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ArcadeStick_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::ArcadeStick::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_GetButtonLabel(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::ArcadeStickButtons>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_GetCurrentReading(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_Headset(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_IsWireless(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_User(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_ArcadeSticks(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Gaming::Input::ArcadeStick::ArcadeSticks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_UserChanged(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_UserChanged(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_ArcadeStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::ArcadeStick>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_ArcadeStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_ArcadeStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::ArcadeStick>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_ArcadeStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ArcadeStick(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::ArcadeStick>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ArcadeStick[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(ArcadeStick_FromGameController), METH_VARARGS | METH_STATIC, nullptr },
        { "get_button_label", reinterpret_cast<PyCFunction>(ArcadeStick_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(ArcadeStick_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(ArcadeStick_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "get_arcade_sticks", reinterpret_cast<PyCFunction>(ArcadeStick_get_ArcadeSticks), METH_NOARGS | METH_STATIC, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(ArcadeStick_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(ArcadeStick_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(ArcadeStick_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(ArcadeStick_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(ArcadeStick_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(ArcadeStick_remove_UserChanged), METH_O, nullptr },
        { "add_arcade_stick_added", reinterpret_cast<PyCFunction>(ArcadeStick_add_ArcadeStickAdded), METH_O | METH_STATIC, nullptr },
        { "remove_arcade_stick_added", reinterpret_cast<PyCFunction>(ArcadeStick_remove_ArcadeStickAdded), METH_O | METH_STATIC, nullptr },
        { "add_arcade_stick_removed", reinterpret_cast<PyCFunction>(ArcadeStick_add_ArcadeStickRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_arcade_stick_removed", reinterpret_cast<PyCFunction>(ArcadeStick_remove_ArcadeStickRemoved), METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ArcadeStick), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ArcadeStick[] = {
        { "headset", reinterpret_cast<getter>(ArcadeStick_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(ArcadeStick_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ArcadeStick_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ArcadeStick[] = 
    {
        { Py_tp_new, _new_ArcadeStick },
        { Py_tp_dealloc, _dealloc_ArcadeStick },
        { Py_tp_methods, _methods_ArcadeStick },
        { Py_tp_getset, _getset_ArcadeStick },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ArcadeStick =
    {
        "_winsdk_Windows_Gaming_Input.ArcadeStick",
        sizeof(py::wrapper::Windows::Gaming::Input::ArcadeStick),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ArcadeStick
    };

    // ----- FlightStick class --------------------
    constexpr const char* const _type_name_FlightStick = "FlightStick";

    static PyObject* _new_FlightStick(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FlightStick);
        return nullptr;
    }

    static void _dealloc_FlightStick(py::wrapper::Windows::Gaming::Input::FlightStick* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FlightStick_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::FlightStick::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_GetButtonLabel(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::FlightStickButtons>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_GetCurrentReading(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_HatSwitchKind(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HatSwitchKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_Headset(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_IsWireless(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_User(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_FlightSticks(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Gaming::Input::FlightStick::FlightSticks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_UserChanged(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_UserChanged(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_FlightStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::FlightStick>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::FlightStick::FlightStickAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_FlightStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::FlightStick::FlightStickAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_FlightStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::FlightStick>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::FlightStick::FlightStickRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_FlightStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::FlightStick::FlightStickRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FlightStick(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::FlightStick>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlightStick[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(FlightStick_FromGameController), METH_VARARGS | METH_STATIC, nullptr },
        { "get_button_label", reinterpret_cast<PyCFunction>(FlightStick_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(FlightStick_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(FlightStick_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "get_flight_sticks", reinterpret_cast<PyCFunction>(FlightStick_get_FlightSticks), METH_NOARGS | METH_STATIC, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(FlightStick_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(FlightStick_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(FlightStick_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(FlightStick_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(FlightStick_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(FlightStick_remove_UserChanged), METH_O, nullptr },
        { "add_flight_stick_added", reinterpret_cast<PyCFunction>(FlightStick_add_FlightStickAdded), METH_O | METH_STATIC, nullptr },
        { "remove_flight_stick_added", reinterpret_cast<PyCFunction>(FlightStick_remove_FlightStickAdded), METH_O | METH_STATIC, nullptr },
        { "add_flight_stick_removed", reinterpret_cast<PyCFunction>(FlightStick_add_FlightStickRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_flight_stick_removed", reinterpret_cast<PyCFunction>(FlightStick_remove_FlightStickRemoved), METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlightStick), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlightStick[] = {
        { "hat_switch_kind", reinterpret_cast<getter>(FlightStick_get_HatSwitchKind), nullptr, nullptr, nullptr },
        { "headset", reinterpret_cast<getter>(FlightStick_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(FlightStick_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FlightStick_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlightStick[] = 
    {
        { Py_tp_new, _new_FlightStick },
        { Py_tp_dealloc, _dealloc_FlightStick },
        { Py_tp_methods, _methods_FlightStick },
        { Py_tp_getset, _getset_FlightStick },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FlightStick =
    {
        "_winsdk_Windows_Gaming_Input.FlightStick",
        sizeof(py::wrapper::Windows::Gaming::Input::FlightStick),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlightStick
    };

    // ----- Gamepad class --------------------
    constexpr const char* const _type_name_Gamepad = "Gamepad";

    static PyObject* _new_Gamepad(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Gamepad);
        return nullptr;
    }

    static void _dealloc_Gamepad(py::wrapper::Windows::Gaming::Input::Gamepad* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Gamepad_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::Gamepad::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_GetButtonLabel(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::GamepadButtons>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_GetCurrentReading(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_Headset(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_IsWireless(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_User(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_Vibration(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Vibration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Gamepad_put_Vibration(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Gaming::Input::GamepadVibration>(arg);

            self->obj.Vibration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Gamepad_get_Gamepads(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Gaming::Input::Gamepad::Gamepads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_UserChanged(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_UserChanged(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_GamepadAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::Gamepad>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::Gamepad::GamepadAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_GamepadAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::Gamepad::GamepadAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_GamepadRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::Gamepad>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::Gamepad::GamepadRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_GamepadRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::Gamepad::GamepadRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Gamepad(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Gamepad>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Gamepad[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(Gamepad_FromGameController), METH_VARARGS | METH_STATIC, nullptr },
        { "get_button_label", reinterpret_cast<PyCFunction>(Gamepad_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(Gamepad_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(Gamepad_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "get_gamepads", reinterpret_cast<PyCFunction>(Gamepad_get_Gamepads), METH_NOARGS | METH_STATIC, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(Gamepad_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(Gamepad_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(Gamepad_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(Gamepad_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(Gamepad_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(Gamepad_remove_UserChanged), METH_O, nullptr },
        { "add_gamepad_added", reinterpret_cast<PyCFunction>(Gamepad_add_GamepadAdded), METH_O | METH_STATIC, nullptr },
        { "remove_gamepad_added", reinterpret_cast<PyCFunction>(Gamepad_remove_GamepadAdded), METH_O | METH_STATIC, nullptr },
        { "add_gamepad_removed", reinterpret_cast<PyCFunction>(Gamepad_add_GamepadRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_gamepad_removed", reinterpret_cast<PyCFunction>(Gamepad_remove_GamepadRemoved), METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Gamepad), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Gamepad[] = {
        { "headset", reinterpret_cast<getter>(Gamepad_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(Gamepad_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(Gamepad_get_User), nullptr, nullptr, nullptr },
        { "vibration", reinterpret_cast<getter>(Gamepad_get_Vibration), reinterpret_cast<setter>(Gamepad_put_Vibration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Gamepad[] = 
    {
        { Py_tp_new, _new_Gamepad },
        { Py_tp_dealloc, _dealloc_Gamepad },
        { Py_tp_methods, _methods_Gamepad },
        { Py_tp_getset, _getset_Gamepad },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Gamepad =
    {
        "_winsdk_Windows_Gaming_Input.Gamepad",
        sizeof(py::wrapper::Windows::Gaming::Input::Gamepad),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Gamepad
    };

    // ----- Headset class --------------------
    constexpr const char* const _type_name_Headset = "Headset";

    static PyObject* _new_Headset(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_Headset);
        return nullptr;
    }

    static void _dealloc_Headset(py::wrapper::Windows::Gaming::Input::Headset* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* Headset_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::Headset* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Headset_get_CaptureDeviceId(py::wrapper::Windows::Gaming::Input::Headset* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CaptureDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Headset_get_RenderDeviceId(py::wrapper::Windows::Gaming::Input::Headset* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RenderDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Headset(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Headset>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Headset[] = {
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(Headset_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Headset), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Headset[] = {
        { "capture_device_id", reinterpret_cast<getter>(Headset_get_CaptureDeviceId), nullptr, nullptr, nullptr },
        { "render_device_id", reinterpret_cast<getter>(Headset_get_RenderDeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Headset[] = 
    {
        { Py_tp_new, _new_Headset },
        { Py_tp_dealloc, _dealloc_Headset },
        { Py_tp_methods, _methods_Headset },
        { Py_tp_getset, _getset_Headset },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_Headset =
    {
        "_winsdk_Windows_Gaming_Input.Headset",
        sizeof(py::wrapper::Windows::Gaming::Input::Headset),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Headset
    };

    // ----- RacingWheel class --------------------
    constexpr const char* const _type_name_RacingWheel = "RacingWheel";

    static PyObject* _new_RacingWheel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RacingWheel);
        return nullptr;
    }

    static void _dealloc_RacingWheel(py::wrapper::Windows::Gaming::Input::RacingWheel* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RacingWheel_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::RacingWheel::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_GetButtonLabel(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::RacingWheelButtons>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_GetCurrentReading(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_Headset(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_IsWireless(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_User(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_HasClutch(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasClutch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_HasHandbrake(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasHandbrake());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_HasPatternShifter(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasPatternShifter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_MaxPatternShifterGear(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPatternShifterGear());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_MaxWheelAngle(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxWheelAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_WheelMotor(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WheelMotor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_RacingWheels(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Gaming::Input::RacingWheel::RacingWheels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_UserChanged(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_UserChanged(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_RacingWheelAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RacingWheel>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::RacingWheel::RacingWheelAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_RacingWheelAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::RacingWheel::RacingWheelAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_RacingWheelRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RacingWheel>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::RacingWheel::RacingWheelRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_RacingWheelRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::RacingWheel::RacingWheelRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RacingWheel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::RacingWheel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RacingWheel[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(RacingWheel_FromGameController), METH_VARARGS | METH_STATIC, nullptr },
        { "get_button_label", reinterpret_cast<PyCFunction>(RacingWheel_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(RacingWheel_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(RacingWheel_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "get_racing_wheels", reinterpret_cast<PyCFunction>(RacingWheel_get_RacingWheels), METH_NOARGS | METH_STATIC, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(RacingWheel_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(RacingWheel_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(RacingWheel_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(RacingWheel_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(RacingWheel_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(RacingWheel_remove_UserChanged), METH_O, nullptr },
        { "add_racing_wheel_added", reinterpret_cast<PyCFunction>(RacingWheel_add_RacingWheelAdded), METH_O | METH_STATIC, nullptr },
        { "remove_racing_wheel_added", reinterpret_cast<PyCFunction>(RacingWheel_remove_RacingWheelAdded), METH_O | METH_STATIC, nullptr },
        { "add_racing_wheel_removed", reinterpret_cast<PyCFunction>(RacingWheel_add_RacingWheelRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_racing_wheel_removed", reinterpret_cast<PyCFunction>(RacingWheel_remove_RacingWheelRemoved), METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RacingWheel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RacingWheel[] = {
        { "headset", reinterpret_cast<getter>(RacingWheel_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(RacingWheel_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RacingWheel_get_User), nullptr, nullptr, nullptr },
        { "has_clutch", reinterpret_cast<getter>(RacingWheel_get_HasClutch), nullptr, nullptr, nullptr },
        { "has_handbrake", reinterpret_cast<getter>(RacingWheel_get_HasHandbrake), nullptr, nullptr, nullptr },
        { "has_pattern_shifter", reinterpret_cast<getter>(RacingWheel_get_HasPatternShifter), nullptr, nullptr, nullptr },
        { "max_pattern_shifter_gear", reinterpret_cast<getter>(RacingWheel_get_MaxPatternShifterGear), nullptr, nullptr, nullptr },
        { "max_wheel_angle", reinterpret_cast<getter>(RacingWheel_get_MaxWheelAngle), nullptr, nullptr, nullptr },
        { "wheel_motor", reinterpret_cast<getter>(RacingWheel_get_WheelMotor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RacingWheel[] = 
    {
        { Py_tp_new, _new_RacingWheel },
        { Py_tp_dealloc, _dealloc_RacingWheel },
        { Py_tp_methods, _methods_RacingWheel },
        { Py_tp_getset, _getset_RacingWheel },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RacingWheel =
    {
        "_winsdk_Windows_Gaming_Input.RacingWheel",
        sizeof(py::wrapper::Windows::Gaming::Input::RacingWheel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RacingWheel
    };

    // ----- RawGameController class --------------------
    constexpr const char* const _type_name_RawGameController = "RawGameController";

    static PyObject* _new_RawGameController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RawGameController);
        return nullptr;
    }

    static void _dealloc_RawGameController(py::wrapper::Windows::Gaming::Input::RawGameController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RawGameController_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::RawGameController::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_GetButtonLabel(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_GetCurrentReading(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0_count = py::convert_to<winrt::com_array<bool>::size_type>(args, 0);
                winrt::com_array<bool> param0 ( param0_count, py::empty_instance<bool>::get() );
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Gaming::Input::GameControllerSwitchPosition>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Gaming::Input::GameControllerSwitchPosition> param1 ( param1_count, py::empty_instance<winrt::Windows::Gaming::Input::GameControllerSwitchPosition>::get() );
                auto param2_count = py::convert_to<winrt::com_array<double>::size_type>(args, 2);
                winrt::com_array<double> param2 ( param2_count, py::empty_instance<double>::get() );

                auto return_value = self->obj.GetCurrentReading(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(4, out_return_value.get(), out0.get(), out1.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_GetSwitchKind(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetSwitchKind(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_Headset(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_IsWireless(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_User(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_AxisCount(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AxisCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_ButtonCount(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ButtonCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_ForceFeedbackMotors(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceFeedbackMotors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_SwitchCount(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SwitchCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_DisplayName(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_NonRoamableId(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NonRoamableId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_SimpleHapticsControllers(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimpleHapticsControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_RawGameControllers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Gaming::Input::RawGameController::RawGameControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_UserChanged(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_UserChanged(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_RawGameControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RawGameController>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::RawGameController::RawGameControllerAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_RawGameControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::RawGameController::RawGameControllerAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_RawGameControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RawGameController>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::RawGameController::RawGameControllerRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_RawGameControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::RawGameController::RawGameControllerRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RawGameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::RawGameController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RawGameController[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(RawGameController_FromGameController), METH_VARARGS | METH_STATIC, nullptr },
        { "get_button_label", reinterpret_cast<PyCFunction>(RawGameController_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(RawGameController_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_switch_kind", reinterpret_cast<PyCFunction>(RawGameController_GetSwitchKind), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(RawGameController_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "get_raw_game_controllers", reinterpret_cast<PyCFunction>(RawGameController_get_RawGameControllers), METH_NOARGS | METH_STATIC, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(RawGameController_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(RawGameController_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(RawGameController_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(RawGameController_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(RawGameController_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(RawGameController_remove_UserChanged), METH_O, nullptr },
        { "add_raw_game_controller_added", reinterpret_cast<PyCFunction>(RawGameController_add_RawGameControllerAdded), METH_O | METH_STATIC, nullptr },
        { "remove_raw_game_controller_added", reinterpret_cast<PyCFunction>(RawGameController_remove_RawGameControllerAdded), METH_O | METH_STATIC, nullptr },
        { "add_raw_game_controller_removed", reinterpret_cast<PyCFunction>(RawGameController_add_RawGameControllerRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_raw_game_controller_removed", reinterpret_cast<PyCFunction>(RawGameController_remove_RawGameControllerRemoved), METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RawGameController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RawGameController[] = {
        { "headset", reinterpret_cast<getter>(RawGameController_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(RawGameController_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RawGameController_get_User), nullptr, nullptr, nullptr },
        { "axis_count", reinterpret_cast<getter>(RawGameController_get_AxisCount), nullptr, nullptr, nullptr },
        { "button_count", reinterpret_cast<getter>(RawGameController_get_ButtonCount), nullptr, nullptr, nullptr },
        { "force_feedback_motors", reinterpret_cast<getter>(RawGameController_get_ForceFeedbackMotors), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(RawGameController_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(RawGameController_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "switch_count", reinterpret_cast<getter>(RawGameController_get_SwitchCount), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(RawGameController_get_DisplayName), nullptr, nullptr, nullptr },
        { "non_roamable_id", reinterpret_cast<getter>(RawGameController_get_NonRoamableId), nullptr, nullptr, nullptr },
        { "simple_haptics_controllers", reinterpret_cast<getter>(RawGameController_get_SimpleHapticsControllers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RawGameController[] = 
    {
        { Py_tp_new, _new_RawGameController },
        { Py_tp_dealloc, _dealloc_RawGameController },
        { Py_tp_methods, _methods_RawGameController },
        { Py_tp_getset, _getset_RawGameController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RawGameController =
    {
        "_winsdk_Windows_Gaming_Input.RawGameController",
        sizeof(py::wrapper::Windows::Gaming::Input::RawGameController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RawGameController
    };

    // ----- UINavigationController class --------------------
    constexpr const char* const _type_name_UINavigationController = "UINavigationController";

    static PyObject* _new_UINavigationController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UINavigationController);
        return nullptr;
    }

    static void _dealloc_UINavigationController(py::wrapper::Windows::Gaming::Input::UINavigationController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UINavigationController_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::UINavigationController::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_GetCurrentReading(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_GetOptionalButtonLabel(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::OptionalUINavigationButtons>(args, 0);

                return py::convert(self->obj.GetOptionalButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_GetRequiredButtonLabel(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::RequiredUINavigationButtons>(args, 0);

                return py::convert(self->obj.GetRequiredButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_Headset(py::wrapper::Windows::Gaming::Input::UINavigationController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_IsWireless(py::wrapper::Windows::Gaming::Input::UINavigationController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_User(py::wrapper::Windows::Gaming::Input::UINavigationController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_UINavigationControllers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_UserChanged(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_UserChanged(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_UINavigationControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::UINavigationController>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_UINavigationControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_UINavigationControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::UINavigationController>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_UINavigationControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UINavigationController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::UINavigationController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UINavigationController[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(UINavigationController_FromGameController), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(UINavigationController_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_optional_button_label", reinterpret_cast<PyCFunction>(UINavigationController_GetOptionalButtonLabel), METH_VARARGS, nullptr },
        { "get_required_button_label", reinterpret_cast<PyCFunction>(UINavigationController_GetRequiredButtonLabel), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(UINavigationController_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "get_u_i_navigation_controllers", reinterpret_cast<PyCFunction>(UINavigationController_get_UINavigationControllers), METH_NOARGS | METH_STATIC, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(UINavigationController_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(UINavigationController_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(UINavigationController_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(UINavigationController_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(UINavigationController_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(UINavigationController_remove_UserChanged), METH_O, nullptr },
        { "add_u_i_navigation_controller_added", reinterpret_cast<PyCFunction>(UINavigationController_add_UINavigationControllerAdded), METH_O | METH_STATIC, nullptr },
        { "remove_u_i_navigation_controller_added", reinterpret_cast<PyCFunction>(UINavigationController_remove_UINavigationControllerAdded), METH_O | METH_STATIC, nullptr },
        { "add_u_i_navigation_controller_removed", reinterpret_cast<PyCFunction>(UINavigationController_add_UINavigationControllerRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_u_i_navigation_controller_removed", reinterpret_cast<PyCFunction>(UINavigationController_remove_UINavigationControllerRemoved), METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UINavigationController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UINavigationController[] = {
        { "headset", reinterpret_cast<getter>(UINavigationController_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(UINavigationController_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(UINavigationController_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UINavigationController[] = 
    {
        { Py_tp_new, _new_UINavigationController },
        { Py_tp_dealloc, _dealloc_UINavigationController },
        { Py_tp_methods, _methods_UINavigationController },
        { Py_tp_getset, _getset_UINavigationController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UINavigationController =
    {
        "_winsdk_Windows_Gaming_Input.UINavigationController",
        sizeof(py::wrapper::Windows::Gaming::Input::UINavigationController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UINavigationController
    };

    // ----- IGameController interface --------------------
    constexpr const char* const _type_name_IGameController = "IGameController";

    static PyObject* _new_IGameController(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IGameController);
        return nullptr;
    }

    static void _dealloc_IGameController(py::wrapper::Windows::Gaming::Input::IGameController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IGameController_get_Headset(py::wrapper::Windows::Gaming::Input::IGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_get_IsWireless(py::wrapper::Windows::Gaming::Input::IGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_get_User(py::wrapper::Windows::Gaming::Input::IGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_add_UserChanged(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_remove_UserChanged(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IGameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::IGameController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameController[] = {
        { "add_headset_connected", reinterpret_cast<PyCFunction>(IGameController_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(IGameController_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(IGameController_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(IGameController_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(IGameController_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(IGameController_remove_UserChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGameController[] = {
        { "headset", reinterpret_cast<getter>(IGameController_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(IGameController_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(IGameController_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IGameController[] = 
    {
        { Py_tp_new, _new_IGameController },
        { Py_tp_dealloc, _dealloc_IGameController },
        { Py_tp_methods, _methods_IGameController },
        { Py_tp_getset, _getset_IGameController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IGameController =
    {
        "_winsdk_Windows_Gaming_Input.IGameController",
        sizeof(py::wrapper::Windows::Gaming::Input::IGameController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameController
    };

    // ----- IGameControllerBatteryInfo interface --------------------
    constexpr const char* const _type_name_IGameControllerBatteryInfo = "IGameControllerBatteryInfo";

    static PyObject* _new_IGameControllerBatteryInfo(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IGameControllerBatteryInfo);
        return nullptr;
    }

    static void _dealloc_IGameControllerBatteryInfo(py::wrapper::Windows::Gaming::Input::IGameControllerBatteryInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IGameControllerBatteryInfo_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::IGameControllerBatteryInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IGameControllerBatteryInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameControllerBatteryInfo[] = {
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(IGameControllerBatteryInfo_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameControllerBatteryInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGameControllerBatteryInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_IGameControllerBatteryInfo[] = 
    {
        { Py_tp_new, _new_IGameControllerBatteryInfo },
        { Py_tp_dealloc, _dealloc_IGameControllerBatteryInfo },
        { Py_tp_methods, _methods_IGameControllerBatteryInfo },
        { Py_tp_getset, _getset_IGameControllerBatteryInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IGameControllerBatteryInfo =
    {
        "_winsdk_Windows_Gaming_Input.IGameControllerBatteryInfo",
        sizeof(py::wrapper::Windows::Gaming::Input::IGameControllerBatteryInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameControllerBatteryInfo
    };

    // ----- ArcadeStickReading struct --------------------
    constexpr const char* const _type_name_ArcadeStickReading = "ArcadeStickReading";

    PyObject* _new_ArcadeStickReading(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::ArcadeStickReading return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Gaming::Input::ArcadeStickReading>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};

        static const char* kwlist[] = {"timestamp", "buttons", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KI", const_cast<char**>(kwlist), &_Timestamp, &_Buttons))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::ArcadeStickReading return_value{ _Timestamp, static_cast<winrt::Windows::Gaming::Input::ArcadeStickButtons>(_Buttons) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_ArcadeStickReading(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self)
    {
    }

    static PyObject* ArcadeStickReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcadeStickReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ArcadeStickReading_get_Buttons(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcadeStickReading_set_Buttons(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::converter<winrt::Windows::Gaming::Input::ArcadeStickButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_ArcadeStickReading[] = {
        { "timestamp", reinterpret_cast<getter>(ArcadeStickReading_get_Timestamp), reinterpret_cast<setter>(ArcadeStickReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(ArcadeStickReading_get_Buttons), reinterpret_cast<setter>(ArcadeStickReading_set_Buttons), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ArcadeStickReading[] = 
    {
        { Py_tp_new, _new_ArcadeStickReading },
        { Py_tp_dealloc, _dealloc_ArcadeStickReading },
        { Py_tp_getset, _getset_ArcadeStickReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ArcadeStickReading =
    {
        "_winsdk_Windows_Gaming_Input.ArcadeStickReading",
        sizeof(py::wrapper::Windows::Gaming::Input::ArcadeStickReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ArcadeStickReading
    };

    // ----- FlightStickReading struct --------------------
    constexpr const char* const _type_name_FlightStickReading = "FlightStickReading";

    PyObject* _new_FlightStickReading(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::FlightStickReading return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Gaming::Input::FlightStickReading>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};
        int32_t _HatSwitch{};
        double _Roll{};
        double _Pitch{};
        double _Yaw{};
        double _Throttle{};

        static const char* kwlist[] = {"timestamp", "buttons", "hat_switch", "roll", "pitch", "yaw", "throttle", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KIidddd", const_cast<char**>(kwlist), &_Timestamp, &_Buttons, &_HatSwitch, &_Roll, &_Pitch, &_Yaw, &_Throttle))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::FlightStickReading return_value{ _Timestamp, static_cast<winrt::Windows::Gaming::Input::FlightStickButtons>(_Buttons), static_cast<winrt::Windows::Gaming::Input::GameControllerSwitchPosition>(_HatSwitch), _Roll, _Pitch, _Yaw, _Throttle };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_FlightStickReading(py::wrapper::Windows::Gaming::Input::FlightStickReading* self)
    {
    }

    static PyObject* FlightStickReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Buttons(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Buttons(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::converter<winrt::Windows::Gaming::Input::FlightStickButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_HatSwitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HatSwitch);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_HatSwitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.HatSwitch = py::converter<winrt::Windows::Gaming::Input::GameControllerSwitchPosition>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Roll(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Roll);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Roll(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Roll = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Pitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pitch);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Pitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Pitch = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Yaw(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Yaw);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Yaw(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Yaw = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Throttle(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Throttle);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Throttle(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Throttle = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_FlightStickReading[] = {
        { "timestamp", reinterpret_cast<getter>(FlightStickReading_get_Timestamp), reinterpret_cast<setter>(FlightStickReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(FlightStickReading_get_Buttons), reinterpret_cast<setter>(FlightStickReading_set_Buttons), nullptr, nullptr },
        { "hat_switch", reinterpret_cast<getter>(FlightStickReading_get_HatSwitch), reinterpret_cast<setter>(FlightStickReading_set_HatSwitch), nullptr, nullptr },
        { "roll", reinterpret_cast<getter>(FlightStickReading_get_Roll), reinterpret_cast<setter>(FlightStickReading_set_Roll), nullptr, nullptr },
        { "pitch", reinterpret_cast<getter>(FlightStickReading_get_Pitch), reinterpret_cast<setter>(FlightStickReading_set_Pitch), nullptr, nullptr },
        { "yaw", reinterpret_cast<getter>(FlightStickReading_get_Yaw), reinterpret_cast<setter>(FlightStickReading_set_Yaw), nullptr, nullptr },
        { "throttle", reinterpret_cast<getter>(FlightStickReading_get_Throttle), reinterpret_cast<setter>(FlightStickReading_set_Throttle), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlightStickReading[] = 
    {
        { Py_tp_new, _new_FlightStickReading },
        { Py_tp_dealloc, _dealloc_FlightStickReading },
        { Py_tp_getset, _getset_FlightStickReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FlightStickReading =
    {
        "_winsdk_Windows_Gaming_Input.FlightStickReading",
        sizeof(py::wrapper::Windows::Gaming::Input::FlightStickReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlightStickReading
    };

    // ----- GamepadReading struct --------------------
    constexpr const char* const _type_name_GamepadReading = "GamepadReading";

    PyObject* _new_GamepadReading(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::GamepadReading return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Gaming::Input::GamepadReading>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};
        double _LeftTrigger{};
        double _RightTrigger{};
        double _LeftThumbstickX{};
        double _LeftThumbstickY{};
        double _RightThumbstickX{};
        double _RightThumbstickY{};

        static const char* kwlist[] = {"timestamp", "buttons", "left_trigger", "right_trigger", "left_thumbstick_x", "left_thumbstick_y", "right_thumbstick_x", "right_thumbstick_y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KIdddddd", const_cast<char**>(kwlist), &_Timestamp, &_Buttons, &_LeftTrigger, &_RightTrigger, &_LeftThumbstickX, &_LeftThumbstickY, &_RightThumbstickX, &_RightThumbstickY))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::GamepadReading return_value{ _Timestamp, static_cast<winrt::Windows::Gaming::Input::GamepadButtons>(_Buttons), _LeftTrigger, _RightTrigger, _LeftThumbstickX, _LeftThumbstickY, _RightThumbstickX, _RightThumbstickY };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_GamepadReading(py::wrapper::Windows::Gaming::Input::GamepadReading* self)
    {
    }

    static PyObject* GamepadReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_Buttons(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_Buttons(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::converter<winrt::Windows::Gaming::Input::GamepadButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.LeftTrigger = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RightTrigger = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_LeftThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftThumbstickX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_LeftThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.LeftThumbstickX = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_LeftThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftThumbstickY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_LeftThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.LeftThumbstickY = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_RightThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightThumbstickX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_RightThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RightThumbstickX = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_RightThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightThumbstickY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_RightThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RightThumbstickY = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GamepadReading[] = {
        { "timestamp", reinterpret_cast<getter>(GamepadReading_get_Timestamp), reinterpret_cast<setter>(GamepadReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(GamepadReading_get_Buttons), reinterpret_cast<setter>(GamepadReading_set_Buttons), nullptr, nullptr },
        { "left_trigger", reinterpret_cast<getter>(GamepadReading_get_LeftTrigger), reinterpret_cast<setter>(GamepadReading_set_LeftTrigger), nullptr, nullptr },
        { "right_trigger", reinterpret_cast<getter>(GamepadReading_get_RightTrigger), reinterpret_cast<setter>(GamepadReading_set_RightTrigger), nullptr, nullptr },
        { "left_thumbstick_x", reinterpret_cast<getter>(GamepadReading_get_LeftThumbstickX), reinterpret_cast<setter>(GamepadReading_set_LeftThumbstickX), nullptr, nullptr },
        { "left_thumbstick_y", reinterpret_cast<getter>(GamepadReading_get_LeftThumbstickY), reinterpret_cast<setter>(GamepadReading_set_LeftThumbstickY), nullptr, nullptr },
        { "right_thumbstick_x", reinterpret_cast<getter>(GamepadReading_get_RightThumbstickX), reinterpret_cast<setter>(GamepadReading_set_RightThumbstickX), nullptr, nullptr },
        { "right_thumbstick_y", reinterpret_cast<getter>(GamepadReading_get_RightThumbstickY), reinterpret_cast<setter>(GamepadReading_set_RightThumbstickY), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GamepadReading[] = 
    {
        { Py_tp_new, _new_GamepadReading },
        { Py_tp_dealloc, _dealloc_GamepadReading },
        { Py_tp_getset, _getset_GamepadReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GamepadReading =
    {
        "_winsdk_Windows_Gaming_Input.GamepadReading",
        sizeof(py::wrapper::Windows::Gaming::Input::GamepadReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GamepadReading
    };

    // ----- GamepadVibration struct --------------------
    constexpr const char* const _type_name_GamepadVibration = "GamepadVibration";

    PyObject* _new_GamepadVibration(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::GamepadVibration return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Gaming::Input::GamepadVibration>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        double _LeftMotor{};
        double _RightMotor{};
        double _LeftTrigger{};
        double _RightTrigger{};

        static const char* kwlist[] = {"left_motor", "right_motor", "left_trigger", "right_trigger", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dddd", const_cast<char**>(kwlist), &_LeftMotor, &_RightMotor, &_LeftTrigger, &_RightTrigger))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::GamepadVibration return_value{ _LeftMotor, _RightMotor, _LeftTrigger, _RightTrigger };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_GamepadVibration(py::wrapper::Windows::Gaming::Input::GamepadVibration* self)
    {
    }

    static PyObject* GamepadVibration_get_LeftMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftMotor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_LeftMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.LeftMotor = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadVibration_get_RightMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightMotor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_RightMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RightMotor = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadVibration_get_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.LeftTrigger = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadVibration_get_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RightTrigger = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GamepadVibration[] = {
        { "left_motor", reinterpret_cast<getter>(GamepadVibration_get_LeftMotor), reinterpret_cast<setter>(GamepadVibration_set_LeftMotor), nullptr, nullptr },
        { "right_motor", reinterpret_cast<getter>(GamepadVibration_get_RightMotor), reinterpret_cast<setter>(GamepadVibration_set_RightMotor), nullptr, nullptr },
        { "left_trigger", reinterpret_cast<getter>(GamepadVibration_get_LeftTrigger), reinterpret_cast<setter>(GamepadVibration_set_LeftTrigger), nullptr, nullptr },
        { "right_trigger", reinterpret_cast<getter>(GamepadVibration_get_RightTrigger), reinterpret_cast<setter>(GamepadVibration_set_RightTrigger), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GamepadVibration[] = 
    {
        { Py_tp_new, _new_GamepadVibration },
        { Py_tp_dealloc, _dealloc_GamepadVibration },
        { Py_tp_getset, _getset_GamepadVibration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_GamepadVibration =
    {
        "_winsdk_Windows_Gaming_Input.GamepadVibration",
        sizeof(py::wrapper::Windows::Gaming::Input::GamepadVibration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GamepadVibration
    };

    // ----- RacingWheelReading struct --------------------
    constexpr const char* const _type_name_RacingWheelReading = "RacingWheelReading";

    PyObject* _new_RacingWheelReading(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::RacingWheelReading return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Gaming::Input::RacingWheelReading>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};
        int32_t _PatternShifterGear{};
        double _Wheel{};
        double _Throttle{};
        double _Brake{};
        double _Clutch{};
        double _Handbrake{};

        static const char* kwlist[] = {"timestamp", "buttons", "pattern_shifter_gear", "wheel", "throttle", "brake", "clutch", "handbrake", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KIiddddd", const_cast<char**>(kwlist), &_Timestamp, &_Buttons, &_PatternShifterGear, &_Wheel, &_Throttle, &_Brake, &_Clutch, &_Handbrake))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::RacingWheelReading return_value{ _Timestamp, static_cast<winrt::Windows::Gaming::Input::RacingWheelButtons>(_Buttons), _PatternShifterGear, _Wheel, _Throttle, _Brake, _Clutch, _Handbrake };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_RacingWheelReading(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self)
    {
    }

    static PyObject* RacingWheelReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Buttons(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Buttons(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::converter<winrt::Windows::Gaming::Input::RacingWheelButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_PatternShifterGear(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PatternShifterGear);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_PatternShifterGear(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PatternShifterGear = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Wheel(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Wheel);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Wheel(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Wheel = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Throttle(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Throttle);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Throttle(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Throttle = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Brake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Brake);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Brake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Brake = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Clutch(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Clutch);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Clutch(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Clutch = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Handbrake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handbrake);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Handbrake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Handbrake = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_RacingWheelReading[] = {
        { "timestamp", reinterpret_cast<getter>(RacingWheelReading_get_Timestamp), reinterpret_cast<setter>(RacingWheelReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(RacingWheelReading_get_Buttons), reinterpret_cast<setter>(RacingWheelReading_set_Buttons), nullptr, nullptr },
        { "pattern_shifter_gear", reinterpret_cast<getter>(RacingWheelReading_get_PatternShifterGear), reinterpret_cast<setter>(RacingWheelReading_set_PatternShifterGear), nullptr, nullptr },
        { "wheel", reinterpret_cast<getter>(RacingWheelReading_get_Wheel), reinterpret_cast<setter>(RacingWheelReading_set_Wheel), nullptr, nullptr },
        { "throttle", reinterpret_cast<getter>(RacingWheelReading_get_Throttle), reinterpret_cast<setter>(RacingWheelReading_set_Throttle), nullptr, nullptr },
        { "brake", reinterpret_cast<getter>(RacingWheelReading_get_Brake), reinterpret_cast<setter>(RacingWheelReading_set_Brake), nullptr, nullptr },
        { "clutch", reinterpret_cast<getter>(RacingWheelReading_get_Clutch), reinterpret_cast<setter>(RacingWheelReading_set_Clutch), nullptr, nullptr },
        { "handbrake", reinterpret_cast<getter>(RacingWheelReading_get_Handbrake), reinterpret_cast<setter>(RacingWheelReading_set_Handbrake), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RacingWheelReading[] = 
    {
        { Py_tp_new, _new_RacingWheelReading },
        { Py_tp_dealloc, _dealloc_RacingWheelReading },
        { Py_tp_getset, _getset_RacingWheelReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RacingWheelReading =
    {
        "_winsdk_Windows_Gaming_Input.RacingWheelReading",
        sizeof(py::wrapper::Windows::Gaming::Input::RacingWheelReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RacingWheelReading
    };

    // ----- UINavigationReading struct --------------------
    constexpr const char* const _type_name_UINavigationReading = "UINavigationReading";

    PyObject* _new_UINavigationReading(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::UINavigationReading return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Gaming::Input::UINavigationReading>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _Timestamp{};
        uint32_t _RequiredButtons{};
        uint32_t _OptionalButtons{};

        static const char* kwlist[] = {"timestamp", "required_buttons", "optional_buttons", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KII", const_cast<char**>(kwlist), &_Timestamp, &_RequiredButtons, &_OptionalButtons))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::UINavigationReading return_value{ _Timestamp, static_cast<winrt::Windows::Gaming::Input::RequiredUINavigationButtons>(_RequiredButtons), static_cast<winrt::Windows::Gaming::Input::OptionalUINavigationButtons>(_OptionalButtons) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_UINavigationReading(py::wrapper::Windows::Gaming::Input::UINavigationReading* self)
    {
    }

    static PyObject* UINavigationReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UINavigationReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UINavigationReading_get_RequiredButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequiredButtons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UINavigationReading_set_RequiredButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RequiredButtons = py::converter<winrt::Windows::Gaming::Input::RequiredUINavigationButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UINavigationReading_get_OptionalButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalButtons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UINavigationReading_set_OptionalButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.OptionalButtons = py::converter<winrt::Windows::Gaming::Input::OptionalUINavigationButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_UINavigationReading[] = {
        { "timestamp", reinterpret_cast<getter>(UINavigationReading_get_Timestamp), reinterpret_cast<setter>(UINavigationReading_set_Timestamp), nullptr, nullptr },
        { "required_buttons", reinterpret_cast<getter>(UINavigationReading_get_RequiredButtons), reinterpret_cast<setter>(UINavigationReading_set_RequiredButtons), nullptr, nullptr },
        { "optional_buttons", reinterpret_cast<getter>(UINavigationReading_get_OptionalButtons), reinterpret_cast<setter>(UINavigationReading_set_OptionalButtons), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UINavigationReading[] = 
    {
        { Py_tp_new, _new_UINavigationReading },
        { Py_tp_dealloc, _dealloc_UINavigationReading },
        { Py_tp_getset, _getset_UINavigationReading },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UINavigationReading =
    {
        "_winsdk_Windows_Gaming_Input.UINavigationReading",
        sizeof(py::wrapper::Windows::Gaming::Input::UINavigationReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UINavigationReading
    };

    // ----- Windows.Gaming.Input Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Gaming::Input::ArcadeStick>::python_type = py::register_python_type(module, _type_name_ArcadeStick, &_type_spec_ArcadeStick, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::FlightStick>::python_type = py::register_python_type(module, _type_name_FlightStick, &_type_spec_FlightStick, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::Gamepad>::python_type = py::register_python_type(module, _type_name_Gamepad, &_type_spec_Gamepad, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::Headset>::python_type = py::register_python_type(module, _type_name_Headset, &_type_spec_Headset, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::RacingWheel>::python_type = py::register_python_type(module, _type_name_RacingWheel, &_type_spec_RacingWheel, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::RawGameController>::python_type = py::register_python_type(module, _type_name_RawGameController, &_type_spec_RawGameController, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::UINavigationController>::python_type = py::register_python_type(module, _type_name_UINavigationController, &_type_spec_UINavigationController, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::IGameController>::python_type = py::register_python_type(module, _type_name_IGameController, &_type_spec_IGameController, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>::python_type = py::register_python_type(module, _type_name_IGameControllerBatteryInfo, &_type_spec_IGameControllerBatteryInfo, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::ArcadeStickReading>::python_type = py::register_python_type(module, _type_name_ArcadeStickReading, &_type_spec_ArcadeStickReading, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::FlightStickReading>::python_type = py::register_python_type(module, _type_name_FlightStickReading, &_type_spec_FlightStickReading, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::GamepadReading>::python_type = py::register_python_type(module, _type_name_GamepadReading, &_type_spec_GamepadReading, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::GamepadVibration>::python_type = py::register_python_type(module, _type_name_GamepadVibration, &_type_spec_GamepadVibration, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::RacingWheelReading>::python_type = py::register_python_type(module, _type_name_RacingWheelReading, &_type_spec_RacingWheelReading, bases.get());
            py::winrt_type<winrt::Windows::Gaming::Input::UINavigationReading>::python_type = py::register_python_type(module, _type_name_UINavigationReading, &_type_spec_UINavigationReading, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Gaming.Input");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Gaming_Input",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Gaming::Input

PyMODINIT_FUNC
PyInit__winsdk_Windows_Gaming_Input (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Gaming::Input::module_def);
}
