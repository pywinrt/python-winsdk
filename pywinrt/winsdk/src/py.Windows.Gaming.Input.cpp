// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.5

#include "pybase.h"
#include "py.Windows.Gaming.Input.h"


PyObject* py::converter<winrt::Windows::Gaming::Input::ArcadeStickReading>::convert(winrt::Windows::Gaming::Input::ArcadeStickReading instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Gaming::Input::ArcadeStickReading>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Gaming::Input::ArcadeStickReading py::converter<winrt::Windows::Gaming::Input::ArcadeStickReading>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Gaming::Input::ArcadeStickReading>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::ArcadeStickReading>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Gaming::Input::ArcadeStickReading");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Gaming::Input::FlightStickReading>::convert(winrt::Windows::Gaming::Input::FlightStickReading instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Gaming::Input::FlightStickReading>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Gaming::Input::FlightStickReading py::converter<winrt::Windows::Gaming::Input::FlightStickReading>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Gaming::Input::FlightStickReading>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::FlightStickReading>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Gaming::Input::FlightStickReading");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Gaming::Input::GamepadReading>::convert(winrt::Windows::Gaming::Input::GamepadReading instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Gaming::Input::GamepadReading>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Gaming::Input::GamepadReading py::converter<winrt::Windows::Gaming::Input::GamepadReading>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Gaming::Input::GamepadReading>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadReading>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Gaming::Input::GamepadReading");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Gaming::Input::GamepadVibration>::convert(winrt::Windows::Gaming::Input::GamepadVibration instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Gaming::Input::GamepadVibration>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Gaming::Input::GamepadVibration py::converter<winrt::Windows::Gaming::Input::GamepadVibration>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Gaming::Input::GamepadVibration>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::GamepadVibration>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Gaming::Input::GamepadVibration");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Gaming::Input::RacingWheelReading>::convert(winrt::Windows::Gaming::Input::RacingWheelReading instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Gaming::Input::RacingWheelReading>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Gaming::Input::RacingWheelReading py::converter<winrt::Windows::Gaming::Input::RacingWheelReading>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Gaming::Input::RacingWheelReading>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::RacingWheelReading>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Gaming::Input::RacingWheelReading");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Gaming::Input::UINavigationReading>::convert(winrt::Windows::Gaming::Input::UINavigationReading instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Gaming::Input::UINavigationReading>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Gaming::Input::UINavigationReading py::converter<winrt::Windows::Gaming::Input::UINavigationReading>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Gaming::Input::UINavigationReading>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Gaming::Input::UINavigationReading>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Gaming::Input::UINavigationReading");
    throw python_exception();
}

namespace py::cpp::Windows::Gaming::Input
{
    struct module_state
    {
        PyObject* type_ArcadeStickButtons;
        PyObject* type_FlightStickButtons;
        PyObject* type_GameControllerButtonLabel;
        PyObject* type_GameControllerSwitchKind;
        PyObject* type_GameControllerSwitchPosition;
        PyObject* type_GamepadButtons;
        PyObject* type_OptionalUINavigationButtons;
        PyObject* type_RacingWheelButtons;
        PyObject* type_RequiredUINavigationButtons;
        PyTypeObject* type_ArcadeStick;
        PyTypeObject* type_FlightStick;
        PyTypeObject* type_Gamepad;
        PyTypeObject* type_Headset;
        PyTypeObject* type_RacingWheel;
        PyTypeObject* type_RawGameController;
        PyTypeObject* type_UINavigationController;
        PyTypeObject* type_IGameController;
        PyTypeObject* type_IGameControllerBatteryInfo;
        PyTypeObject* type_ArcadeStickReading;
        PyTypeObject* type_FlightStickReading;
        PyTypeObject* type_GamepadReading;
        PyTypeObject* type_GamepadVibration;
        PyTypeObject* type_RacingWheelReading;
        PyTypeObject* type_UINavigationReading;
    };

    static PyObject* register_ArcadeStickButtons(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ArcadeStickButtons)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ArcadeStickButtons = type;
        Py_INCREF(state->type_ArcadeStickButtons);


        Py_RETURN_NONE;
    }

    static PyObject* register_FlightStickButtons(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_FlightStickButtons)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FlightStickButtons = type;
        Py_INCREF(state->type_FlightStickButtons);


        Py_RETURN_NONE;
    }

    static PyObject* register_GameControllerButtonLabel(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_GameControllerButtonLabel)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_GameControllerButtonLabel = type;
        Py_INCREF(state->type_GameControllerButtonLabel);


        Py_RETURN_NONE;
    }

    static PyObject* register_GameControllerSwitchKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_GameControllerSwitchKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_GameControllerSwitchKind = type;
        Py_INCREF(state->type_GameControllerSwitchKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_GameControllerSwitchPosition(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_GameControllerSwitchPosition)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_GameControllerSwitchPosition = type;
        Py_INCREF(state->type_GameControllerSwitchPosition);


        Py_RETURN_NONE;
    }

    static PyObject* register_GamepadButtons(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_GamepadButtons)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_GamepadButtons = type;
        Py_INCREF(state->type_GamepadButtons);


        Py_RETURN_NONE;
    }

    static PyObject* register_OptionalUINavigationButtons(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_OptionalUINavigationButtons)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_OptionalUINavigationButtons = type;
        Py_INCREF(state->type_OptionalUINavigationButtons);


        Py_RETURN_NONE;
    }

    static PyObject* register_RacingWheelButtons(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_RacingWheelButtons)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_RacingWheelButtons = type;
        Py_INCREF(state->type_RacingWheelButtons);


        Py_RETURN_NONE;
    }

    static PyObject* register_RequiredUINavigationButtons(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_RequiredUINavigationButtons)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_RequiredUINavigationButtons = type;
        Py_INCREF(state->type_RequiredUINavigationButtons);


        Py_RETURN_NONE;
    }

    // ----- ArcadeStick class --------------------
    constexpr const char* const type_name_ArcadeStick = "ArcadeStick";

    static PyObject* _new_ArcadeStick(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ArcadeStick);
        return nullptr;
    }

    static void _dealloc_ArcadeStick(py::wrapper::Windows::Gaming::Input::ArcadeStick* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ArcadeStick_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::ArcadeStick::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_GetButtonLabel(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::ArcadeStickButtons>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_GetCurrentReading(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_Headset(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_IsWireless(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_User(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_get_ArcadeSticks(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Gaming::Input::ArcadeStick::ArcadeSticks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_UserChanged(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_UserChanged(py::wrapper::Windows::Gaming::Input::ArcadeStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_ArcadeStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::ArcadeStick>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_ArcadeStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_add_ArcadeStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::ArcadeStick>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ArcadeStick_remove_ArcadeStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::ArcadeStick::ArcadeStickRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ArcadeStick(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::ArcadeStick>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ArcadeStick[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(ArcadeStick_FromGameController), METH_VARARGS | METH_STATIC, nullptr },
        { "get_button_label", reinterpret_cast<PyCFunction>(ArcadeStick_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(ArcadeStick_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(ArcadeStick_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "get_arcade_sticks", reinterpret_cast<PyCFunction>(ArcadeStick_get_ArcadeSticks), METH_NOARGS | METH_STATIC, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(ArcadeStick_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(ArcadeStick_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(ArcadeStick_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(ArcadeStick_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(ArcadeStick_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(ArcadeStick_remove_UserChanged), METH_O, nullptr },
        { "add_arcade_stick_added", reinterpret_cast<PyCFunction>(ArcadeStick_add_ArcadeStickAdded), METH_O | METH_STATIC, nullptr },
        { "remove_arcade_stick_added", reinterpret_cast<PyCFunction>(ArcadeStick_remove_ArcadeStickAdded), METH_O | METH_STATIC, nullptr },
        { "add_arcade_stick_removed", reinterpret_cast<PyCFunction>(ArcadeStick_add_ArcadeStickRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_arcade_stick_removed", reinterpret_cast<PyCFunction>(ArcadeStick_remove_ArcadeStickRemoved), METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ArcadeStick), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ArcadeStick[] = {
        { "headset", reinterpret_cast<getter>(ArcadeStick_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(ArcadeStick_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ArcadeStick_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ArcadeStick[] = 
    {
        { Py_tp_new, _new_ArcadeStick },
        { Py_tp_dealloc, _dealloc_ArcadeStick },
        { Py_tp_methods, _methods_ArcadeStick },
        { Py_tp_getset, _getset_ArcadeStick },
        { },
    };

    static PyType_Spec type_spec_ArcadeStick =
    {
        "_winsdk_Windows_Gaming_Input.ArcadeStick",
        sizeof(py::wrapper::Windows::Gaming::Input::ArcadeStick),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ArcadeStick
    };

    // ----- FlightStick class --------------------
    constexpr const char* const type_name_FlightStick = "FlightStick";

    static PyObject* _new_FlightStick(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FlightStick);
        return nullptr;
    }

    static void _dealloc_FlightStick(py::wrapper::Windows::Gaming::Input::FlightStick* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FlightStick_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::FlightStick::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_GetButtonLabel(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::FlightStickButtons>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_GetCurrentReading(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_HatSwitchKind(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HatSwitchKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_Headset(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_IsWireless(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_User(py::wrapper::Windows::Gaming::Input::FlightStick* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_get_FlightSticks(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Gaming::Input::FlightStick::FlightSticks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_UserChanged(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_UserChanged(py::wrapper::Windows::Gaming::Input::FlightStick* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_FlightStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::FlightStick>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::FlightStick::FlightStickAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_FlightStickAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::FlightStick::FlightStickAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_add_FlightStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::FlightStick>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::FlightStick::FlightStickRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlightStick_remove_FlightStickRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::FlightStick::FlightStickRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FlightStick(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::FlightStick>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlightStick[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(FlightStick_FromGameController), METH_VARARGS | METH_STATIC, nullptr },
        { "get_button_label", reinterpret_cast<PyCFunction>(FlightStick_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(FlightStick_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(FlightStick_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "get_flight_sticks", reinterpret_cast<PyCFunction>(FlightStick_get_FlightSticks), METH_NOARGS | METH_STATIC, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(FlightStick_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(FlightStick_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(FlightStick_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(FlightStick_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(FlightStick_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(FlightStick_remove_UserChanged), METH_O, nullptr },
        { "add_flight_stick_added", reinterpret_cast<PyCFunction>(FlightStick_add_FlightStickAdded), METH_O | METH_STATIC, nullptr },
        { "remove_flight_stick_added", reinterpret_cast<PyCFunction>(FlightStick_remove_FlightStickAdded), METH_O | METH_STATIC, nullptr },
        { "add_flight_stick_removed", reinterpret_cast<PyCFunction>(FlightStick_add_FlightStickRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_flight_stick_removed", reinterpret_cast<PyCFunction>(FlightStick_remove_FlightStickRemoved), METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FlightStick), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlightStick[] = {
        { "hat_switch_kind", reinterpret_cast<getter>(FlightStick_get_HatSwitchKind), nullptr, nullptr, nullptr },
        { "headset", reinterpret_cast<getter>(FlightStick_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(FlightStick_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FlightStick_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlightStick[] = 
    {
        { Py_tp_new, _new_FlightStick },
        { Py_tp_dealloc, _dealloc_FlightStick },
        { Py_tp_methods, _methods_FlightStick },
        { Py_tp_getset, _getset_FlightStick },
        { },
    };

    static PyType_Spec type_spec_FlightStick =
    {
        "_winsdk_Windows_Gaming_Input.FlightStick",
        sizeof(py::wrapper::Windows::Gaming::Input::FlightStick),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlightStick
    };

    // ----- Gamepad class --------------------
    constexpr const char* const type_name_Gamepad = "Gamepad";

    static PyObject* _new_Gamepad(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Gamepad);
        return nullptr;
    }

    static void _dealloc_Gamepad(py::wrapper::Windows::Gaming::Input::Gamepad* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Gamepad_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::Gamepad::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_GetButtonLabel(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::GamepadButtons>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_GetCurrentReading(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_Headset(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_IsWireless(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_User(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_get_Vibration(py::wrapper::Windows::Gaming::Input::Gamepad* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Vibration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int Gamepad_put_Vibration(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Gaming::Input::GamepadVibration>(arg);

            self->obj.Vibration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* Gamepad_get_Gamepads(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Gaming::Input::Gamepad::Gamepads());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_UserChanged(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_UserChanged(py::wrapper::Windows::Gaming::Input::Gamepad* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_GamepadAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::Gamepad>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::Gamepad::GamepadAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_GamepadAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::Gamepad::GamepadAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_add_GamepadRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::Gamepad>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::Gamepad::GamepadRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Gamepad_remove_GamepadRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::Gamepad::GamepadRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Gamepad(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Gamepad>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Gamepad[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(Gamepad_FromGameController), METH_VARARGS | METH_STATIC, nullptr },
        { "get_button_label", reinterpret_cast<PyCFunction>(Gamepad_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(Gamepad_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(Gamepad_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "get_gamepads", reinterpret_cast<PyCFunction>(Gamepad_get_Gamepads), METH_NOARGS | METH_STATIC, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(Gamepad_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(Gamepad_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(Gamepad_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(Gamepad_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(Gamepad_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(Gamepad_remove_UserChanged), METH_O, nullptr },
        { "add_gamepad_added", reinterpret_cast<PyCFunction>(Gamepad_add_GamepadAdded), METH_O | METH_STATIC, nullptr },
        { "remove_gamepad_added", reinterpret_cast<PyCFunction>(Gamepad_remove_GamepadAdded), METH_O | METH_STATIC, nullptr },
        { "add_gamepad_removed", reinterpret_cast<PyCFunction>(Gamepad_add_GamepadRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_gamepad_removed", reinterpret_cast<PyCFunction>(Gamepad_remove_GamepadRemoved), METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Gamepad), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Gamepad[] = {
        { "headset", reinterpret_cast<getter>(Gamepad_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(Gamepad_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(Gamepad_get_User), nullptr, nullptr, nullptr },
        { "vibration", reinterpret_cast<getter>(Gamepad_get_Vibration), reinterpret_cast<setter>(Gamepad_put_Vibration), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Gamepad[] = 
    {
        { Py_tp_new, _new_Gamepad },
        { Py_tp_dealloc, _dealloc_Gamepad },
        { Py_tp_methods, _methods_Gamepad },
        { Py_tp_getset, _getset_Gamepad },
        { },
    };

    static PyType_Spec type_spec_Gamepad =
    {
        "_winsdk_Windows_Gaming_Input.Gamepad",
        sizeof(py::wrapper::Windows::Gaming::Input::Gamepad),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Gamepad
    };

    // ----- Headset class --------------------
    constexpr const char* const type_name_Headset = "Headset";

    static PyObject* _new_Headset(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Headset);
        return nullptr;
    }

    static void _dealloc_Headset(py::wrapper::Windows::Gaming::Input::Headset* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Headset_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::Headset* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* Headset_get_CaptureDeviceId(py::wrapper::Windows::Gaming::Input::Headset* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CaptureDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Headset_get_RenderDeviceId(py::wrapper::Windows::Gaming::Input::Headset* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RenderDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Headset(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::Headset>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Headset[] = {
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(Headset_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_Headset), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Headset[] = {
        { "capture_device_id", reinterpret_cast<getter>(Headset_get_CaptureDeviceId), nullptr, nullptr, nullptr },
        { "render_device_id", reinterpret_cast<getter>(Headset_get_RenderDeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Headset[] = 
    {
        { Py_tp_new, _new_Headset },
        { Py_tp_dealloc, _dealloc_Headset },
        { Py_tp_methods, _methods_Headset },
        { Py_tp_getset, _getset_Headset },
        { },
    };

    static PyType_Spec type_spec_Headset =
    {
        "_winsdk_Windows_Gaming_Input.Headset",
        sizeof(py::wrapper::Windows::Gaming::Input::Headset),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Headset
    };

    // ----- RacingWheel class --------------------
    constexpr const char* const type_name_RacingWheel = "RacingWheel";

    static PyObject* _new_RacingWheel(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RacingWheel);
        return nullptr;
    }

    static void _dealloc_RacingWheel(py::wrapper::Windows::Gaming::Input::RacingWheel* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RacingWheel_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::RacingWheel::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_GetButtonLabel(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::RacingWheelButtons>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_GetCurrentReading(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_Headset(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_IsWireless(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_User(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_HasClutch(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasClutch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_HasHandbrake(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasHandbrake());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_HasPatternShifter(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasPatternShifter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_MaxPatternShifterGear(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPatternShifterGear());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_MaxWheelAngle(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxWheelAngle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_WheelMotor(py::wrapper::Windows::Gaming::Input::RacingWheel* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WheelMotor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_get_RacingWheels(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Gaming::Input::RacingWheel::RacingWheels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_UserChanged(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_UserChanged(py::wrapper::Windows::Gaming::Input::RacingWheel* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_RacingWheelAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RacingWheel>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::RacingWheel::RacingWheelAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_RacingWheelAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::RacingWheel::RacingWheelAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_add_RacingWheelRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RacingWheel>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::RacingWheel::RacingWheelRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RacingWheel_remove_RacingWheelRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::RacingWheel::RacingWheelRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RacingWheel(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::RacingWheel>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RacingWheel[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(RacingWheel_FromGameController), METH_VARARGS | METH_STATIC, nullptr },
        { "get_button_label", reinterpret_cast<PyCFunction>(RacingWheel_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(RacingWheel_GetCurrentReading), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(RacingWheel_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "get_racing_wheels", reinterpret_cast<PyCFunction>(RacingWheel_get_RacingWheels), METH_NOARGS | METH_STATIC, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(RacingWheel_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(RacingWheel_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(RacingWheel_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(RacingWheel_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(RacingWheel_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(RacingWheel_remove_UserChanged), METH_O, nullptr },
        { "add_racing_wheel_added", reinterpret_cast<PyCFunction>(RacingWheel_add_RacingWheelAdded), METH_O | METH_STATIC, nullptr },
        { "remove_racing_wheel_added", reinterpret_cast<PyCFunction>(RacingWheel_remove_RacingWheelAdded), METH_O | METH_STATIC, nullptr },
        { "add_racing_wheel_removed", reinterpret_cast<PyCFunction>(RacingWheel_add_RacingWheelRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_racing_wheel_removed", reinterpret_cast<PyCFunction>(RacingWheel_remove_RacingWheelRemoved), METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RacingWheel), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RacingWheel[] = {
        { "headset", reinterpret_cast<getter>(RacingWheel_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(RacingWheel_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RacingWheel_get_User), nullptr, nullptr, nullptr },
        { "has_clutch", reinterpret_cast<getter>(RacingWheel_get_HasClutch), nullptr, nullptr, nullptr },
        { "has_handbrake", reinterpret_cast<getter>(RacingWheel_get_HasHandbrake), nullptr, nullptr, nullptr },
        { "has_pattern_shifter", reinterpret_cast<getter>(RacingWheel_get_HasPatternShifter), nullptr, nullptr, nullptr },
        { "max_pattern_shifter_gear", reinterpret_cast<getter>(RacingWheel_get_MaxPatternShifterGear), nullptr, nullptr, nullptr },
        { "max_wheel_angle", reinterpret_cast<getter>(RacingWheel_get_MaxWheelAngle), nullptr, nullptr, nullptr },
        { "wheel_motor", reinterpret_cast<getter>(RacingWheel_get_WheelMotor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RacingWheel[] = 
    {
        { Py_tp_new, _new_RacingWheel },
        { Py_tp_dealloc, _dealloc_RacingWheel },
        { Py_tp_methods, _methods_RacingWheel },
        { Py_tp_getset, _getset_RacingWheel },
        { },
    };

    static PyType_Spec type_spec_RacingWheel =
    {
        "_winsdk_Windows_Gaming_Input.RacingWheel",
        sizeof(py::wrapper::Windows::Gaming::Input::RacingWheel),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RacingWheel
    };

    // ----- RawGameController class --------------------
    constexpr const char* const type_name_RawGameController = "RawGameController";

    static PyObject* _new_RawGameController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RawGameController);
        return nullptr;
    }

    static void _dealloc_RawGameController(py::wrapper::Windows::Gaming::Input::RawGameController* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RawGameController_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::RawGameController::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_GetButtonLabel(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_GetCurrentReading(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0_count = py::convert_to<winrt::com_array<bool>::size_type>(args, 0);
                winrt::com_array<bool> param0 ( param0_count, py::empty_instance<bool>::get() );
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Gaming::Input::GameControllerSwitchPosition>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Gaming::Input::GameControllerSwitchPosition> param1 ( param1_count, py::empty_instance<winrt::Windows::Gaming::Input::GameControllerSwitchPosition>::get() );
                auto param2_count = py::convert_to<winrt::com_array<double>::size_type>(args, 2);
                winrt::com_array<double> param2 ( param2_count, py::empty_instance<double>::get() );

                auto return_value = self->obj.GetCurrentReading(param0, param1, param2);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return PyTuple_Pack(4, out_return_value.get(), out0.get(), out1.get(), out2.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_GetSwitchKind(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.GetSwitchKind(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_Headset(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_IsWireless(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_User(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_AxisCount(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AxisCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_ButtonCount(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ButtonCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_ForceFeedbackMotors(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceFeedbackMotors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_HardwareProductId(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_HardwareVendorId(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_SwitchCount(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SwitchCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_DisplayName(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_NonRoamableId(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NonRoamableId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_SimpleHapticsControllers(py::wrapper::Windows::Gaming::Input::RawGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimpleHapticsControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_get_RawGameControllers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Gaming::Input::RawGameController::RawGameControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_UserChanged(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_UserChanged(py::wrapper::Windows::Gaming::Input::RawGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_RawGameControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RawGameController>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::RawGameController::RawGameControllerAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_RawGameControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::RawGameController::RawGameControllerAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_add_RawGameControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::RawGameController>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::RawGameController::RawGameControllerRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RawGameController_remove_RawGameControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::RawGameController::RawGameControllerRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RawGameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::RawGameController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RawGameController[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(RawGameController_FromGameController), METH_VARARGS | METH_STATIC, nullptr },
        { "get_button_label", reinterpret_cast<PyCFunction>(RawGameController_GetButtonLabel), METH_VARARGS, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(RawGameController_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_switch_kind", reinterpret_cast<PyCFunction>(RawGameController_GetSwitchKind), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(RawGameController_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "get_raw_game_controllers", reinterpret_cast<PyCFunction>(RawGameController_get_RawGameControllers), METH_NOARGS | METH_STATIC, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(RawGameController_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(RawGameController_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(RawGameController_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(RawGameController_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(RawGameController_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(RawGameController_remove_UserChanged), METH_O, nullptr },
        { "add_raw_game_controller_added", reinterpret_cast<PyCFunction>(RawGameController_add_RawGameControllerAdded), METH_O | METH_STATIC, nullptr },
        { "remove_raw_game_controller_added", reinterpret_cast<PyCFunction>(RawGameController_remove_RawGameControllerAdded), METH_O | METH_STATIC, nullptr },
        { "add_raw_game_controller_removed", reinterpret_cast<PyCFunction>(RawGameController_add_RawGameControllerRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_raw_game_controller_removed", reinterpret_cast<PyCFunction>(RawGameController_remove_RawGameControllerRemoved), METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RawGameController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RawGameController[] = {
        { "headset", reinterpret_cast<getter>(RawGameController_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(RawGameController_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RawGameController_get_User), nullptr, nullptr, nullptr },
        { "axis_count", reinterpret_cast<getter>(RawGameController_get_AxisCount), nullptr, nullptr, nullptr },
        { "button_count", reinterpret_cast<getter>(RawGameController_get_ButtonCount), nullptr, nullptr, nullptr },
        { "force_feedback_motors", reinterpret_cast<getter>(RawGameController_get_ForceFeedbackMotors), nullptr, nullptr, nullptr },
        { "hardware_product_id", reinterpret_cast<getter>(RawGameController_get_HardwareProductId), nullptr, nullptr, nullptr },
        { "hardware_vendor_id", reinterpret_cast<getter>(RawGameController_get_HardwareVendorId), nullptr, nullptr, nullptr },
        { "switch_count", reinterpret_cast<getter>(RawGameController_get_SwitchCount), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(RawGameController_get_DisplayName), nullptr, nullptr, nullptr },
        { "non_roamable_id", reinterpret_cast<getter>(RawGameController_get_NonRoamableId), nullptr, nullptr, nullptr },
        { "simple_haptics_controllers", reinterpret_cast<getter>(RawGameController_get_SimpleHapticsControllers), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RawGameController[] = 
    {
        { Py_tp_new, _new_RawGameController },
        { Py_tp_dealloc, _dealloc_RawGameController },
        { Py_tp_methods, _methods_RawGameController },
        { Py_tp_getset, _getset_RawGameController },
        { },
    };

    static PyType_Spec type_spec_RawGameController =
    {
        "_winsdk_Windows_Gaming_Input.RawGameController",
        sizeof(py::wrapper::Windows::Gaming::Input::RawGameController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RawGameController
    };

    // ----- UINavigationController class --------------------
    constexpr const char* const type_name_UINavigationController = "UINavigationController";

    static PyObject* _new_UINavigationController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UINavigationController);
        return nullptr;
    }

    static void _dealloc_UINavigationController(py::wrapper::Windows::Gaming::Input::UINavigationController* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UINavigationController_FromGameController(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::IGameController>(args, 0);

                return py::convert(winrt::Windows::Gaming::Input::UINavigationController::FromGameController(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_GetCurrentReading(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentReading());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_GetOptionalButtonLabel(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::OptionalUINavigationButtons>(args, 0);

                return py::convert(self->obj.GetOptionalButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_GetRequiredButtonLabel(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::RequiredUINavigationButtons>(args, 0);

                return py::convert(self->obj.GetRequiredButtonLabel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_Headset(py::wrapper::Windows::Gaming::Input::UINavigationController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_IsWireless(py::wrapper::Windows::Gaming::Input::UINavigationController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_User(py::wrapper::Windows::Gaming::Input::UINavigationController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_get_UINavigationControllers(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_UserChanged(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_UserChanged(py::wrapper::Windows::Gaming::Input::UINavigationController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_UINavigationControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::UINavigationController>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_UINavigationControllerAdded(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_add_UINavigationControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Gaming::Input::UINavigationController>>(arg);

            return py::convert(winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UINavigationController_remove_UINavigationControllerRemoved(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Gaming::Input::UINavigationController::UINavigationControllerRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UINavigationController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::UINavigationController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UINavigationController[] = {
        { "from_game_controller", reinterpret_cast<PyCFunction>(UINavigationController_FromGameController), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_reading", reinterpret_cast<PyCFunction>(UINavigationController_GetCurrentReading), METH_VARARGS, nullptr },
        { "get_optional_button_label", reinterpret_cast<PyCFunction>(UINavigationController_GetOptionalButtonLabel), METH_VARARGS, nullptr },
        { "get_required_button_label", reinterpret_cast<PyCFunction>(UINavigationController_GetRequiredButtonLabel), METH_VARARGS, nullptr },
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(UINavigationController_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "get_u_i_navigation_controllers", reinterpret_cast<PyCFunction>(UINavigationController_get_UINavigationControllers), METH_NOARGS | METH_STATIC, nullptr },
        { "add_headset_connected", reinterpret_cast<PyCFunction>(UINavigationController_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(UINavigationController_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(UINavigationController_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(UINavigationController_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(UINavigationController_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(UINavigationController_remove_UserChanged), METH_O, nullptr },
        { "add_u_i_navigation_controller_added", reinterpret_cast<PyCFunction>(UINavigationController_add_UINavigationControllerAdded), METH_O | METH_STATIC, nullptr },
        { "remove_u_i_navigation_controller_added", reinterpret_cast<PyCFunction>(UINavigationController_remove_UINavigationControllerAdded), METH_O | METH_STATIC, nullptr },
        { "add_u_i_navigation_controller_removed", reinterpret_cast<PyCFunction>(UINavigationController_add_UINavigationControllerRemoved), METH_O | METH_STATIC, nullptr },
        { "remove_u_i_navigation_controller_removed", reinterpret_cast<PyCFunction>(UINavigationController_remove_UINavigationControllerRemoved), METH_O | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UINavigationController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UINavigationController[] = {
        { "headset", reinterpret_cast<getter>(UINavigationController_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(UINavigationController_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(UINavigationController_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UINavigationController[] = 
    {
        { Py_tp_new, _new_UINavigationController },
        { Py_tp_dealloc, _dealloc_UINavigationController },
        { Py_tp_methods, _methods_UINavigationController },
        { Py_tp_getset, _getset_UINavigationController },
        { },
    };

    static PyType_Spec type_spec_UINavigationController =
    {
        "_winsdk_Windows_Gaming_Input.UINavigationController",
        sizeof(py::wrapper::Windows::Gaming::Input::UINavigationController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UINavigationController
    };

    // ----- IGameController interface --------------------
    constexpr const char* const type_name_IGameController = "IGameController";

    static PyObject* _new_IGameController(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IGameController);
        return nullptr;
    }

    static void _dealloc_IGameController(py::wrapper::Windows::Gaming::Input::IGameController* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGameController_get_Headset(py::wrapper::Windows::Gaming::Input::IGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Headset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_get_IsWireless(py::wrapper::Windows::Gaming::Input::IGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWireless());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_get_User(py::wrapper::Windows::Gaming::Input::IGameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_add_HeadsetConnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetConnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_remove_HeadsetConnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetConnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_add_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::Gaming::Input::Headset>>(arg);

            return py::convert(self->obj.HeadsetDisconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_remove_HeadsetDisconnected(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HeadsetDisconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_add_UserChanged(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Gaming::Input::IGameController, winrt::Windows::System::UserChangedEventArgs>>(arg);

            return py::convert(self->obj.UserChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IGameController_remove_UserChanged(py::wrapper::Windows::Gaming::Input::IGameController* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UserChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IGameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::IGameController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameController[] = {
        { "add_headset_connected", reinterpret_cast<PyCFunction>(IGameController_add_HeadsetConnected), METH_O, nullptr },
        { "remove_headset_connected", reinterpret_cast<PyCFunction>(IGameController_remove_HeadsetConnected), METH_O, nullptr },
        { "add_headset_disconnected", reinterpret_cast<PyCFunction>(IGameController_add_HeadsetDisconnected), METH_O, nullptr },
        { "remove_headset_disconnected", reinterpret_cast<PyCFunction>(IGameController_remove_HeadsetDisconnected), METH_O, nullptr },
        { "add_user_changed", reinterpret_cast<PyCFunction>(IGameController_add_UserChanged), METH_O, nullptr },
        { "remove_user_changed", reinterpret_cast<PyCFunction>(IGameController_remove_UserChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGameController[] = {
        { "headset", reinterpret_cast<getter>(IGameController_get_Headset), nullptr, nullptr, nullptr },
        { "is_wireless", reinterpret_cast<getter>(IGameController_get_IsWireless), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(IGameController_get_User), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IGameController[] = 
    {
        { Py_tp_new, _new_IGameController },
        { Py_tp_dealloc, _dealloc_IGameController },
        { Py_tp_methods, _methods_IGameController },
        { Py_tp_getset, _getset_IGameController },
        { },
    };

    static PyType_Spec type_spec_IGameController =
    {
        "_winsdk_Windows_Gaming_Input.IGameController",
        sizeof(py::wrapper::Windows::Gaming::Input::IGameController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameController
    };

    // ----- IGameControllerBatteryInfo interface --------------------
    constexpr const char* const type_name_IGameControllerBatteryInfo = "IGameControllerBatteryInfo";

    static PyObject* _new_IGameControllerBatteryInfo(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IGameControllerBatteryInfo);
        return nullptr;
    }

    static void _dealloc_IGameControllerBatteryInfo(py::wrapper::Windows::Gaming::Input::IGameControllerBatteryInfo* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IGameControllerBatteryInfo_TryGetBatteryReport(py::wrapper::Windows::Gaming::Input::IGameControllerBatteryInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetBatteryReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IGameControllerBatteryInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGameControllerBatteryInfo[] = {
        { "try_get_battery_report", reinterpret_cast<PyCFunction>(IGameControllerBatteryInfo_TryGetBatteryReport), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IGameControllerBatteryInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGameControllerBatteryInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_IGameControllerBatteryInfo[] = 
    {
        { Py_tp_new, _new_IGameControllerBatteryInfo },
        { Py_tp_dealloc, _dealloc_IGameControllerBatteryInfo },
        { Py_tp_methods, _methods_IGameControllerBatteryInfo },
        { Py_tp_getset, _getset_IGameControllerBatteryInfo },
        { },
    };

    static PyType_Spec type_spec_IGameControllerBatteryInfo =
    {
        "_winsdk_Windows_Gaming_Input.IGameControllerBatteryInfo",
        sizeof(py::wrapper::Windows::Gaming::Input::IGameControllerBatteryInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGameControllerBatteryInfo
    };

    // ----- ArcadeStickReading struct --------------------
    constexpr const char* const type_name_ArcadeStickReading = "ArcadeStickReading";

    PyObject* _new_ArcadeStickReading(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::ArcadeStickReading return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Gaming::Input::ArcadeStickReading>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};

        static const char* kwlist[] = {"timestamp", "buttons", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KI", const_cast<char**>(kwlist), &_Timestamp, &_Buttons))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::ArcadeStickReading return_value{ _Timestamp, static_cast<winrt::Windows::Gaming::Input::ArcadeStickButtons>(_Buttons) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_ArcadeStickReading(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self)
    {
    }

    static PyObject* ArcadeStickReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcadeStickReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ArcadeStickReading_get_Buttons(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ArcadeStickReading_set_Buttons(py::wrapper::Windows::Gaming::Input::ArcadeStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::converter<winrt::Windows::Gaming::Input::ArcadeStickButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_ArcadeStickReading[] = {
        { "timestamp", reinterpret_cast<getter>(ArcadeStickReading_get_Timestamp), reinterpret_cast<setter>(ArcadeStickReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(ArcadeStickReading_get_Buttons), reinterpret_cast<setter>(ArcadeStickReading_set_Buttons), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ArcadeStickReading[] = 
    {
        { Py_tp_new, _new_ArcadeStickReading },
        { Py_tp_dealloc, _dealloc_ArcadeStickReading },
        { Py_tp_getset, _getset_ArcadeStickReading },
        { },
    };

    static PyType_Spec type_spec_ArcadeStickReading =
    {
        "_winsdk_Windows_Gaming_Input.ArcadeStickReading",
        sizeof(py::wrapper::Windows::Gaming::Input::ArcadeStickReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ArcadeStickReading
    };

    // ----- FlightStickReading struct --------------------
    constexpr const char* const type_name_FlightStickReading = "FlightStickReading";

    PyObject* _new_FlightStickReading(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::FlightStickReading return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Gaming::Input::FlightStickReading>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};
        int32_t _HatSwitch{};
        double _Roll{};
        double _Pitch{};
        double _Yaw{};
        double _Throttle{};

        static const char* kwlist[] = {"timestamp", "buttons", "hat_switch", "roll", "pitch", "yaw", "throttle", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KIidddd", const_cast<char**>(kwlist), &_Timestamp, &_Buttons, &_HatSwitch, &_Roll, &_Pitch, &_Yaw, &_Throttle))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::FlightStickReading return_value{ _Timestamp, static_cast<winrt::Windows::Gaming::Input::FlightStickButtons>(_Buttons), static_cast<winrt::Windows::Gaming::Input::GameControllerSwitchPosition>(_HatSwitch), _Roll, _Pitch, _Yaw, _Throttle };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_FlightStickReading(py::wrapper::Windows::Gaming::Input::FlightStickReading* self)
    {
    }

    static PyObject* FlightStickReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Buttons(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Buttons(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::converter<winrt::Windows::Gaming::Input::FlightStickButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_HatSwitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HatSwitch);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_HatSwitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.HatSwitch = py::converter<winrt::Windows::Gaming::Input::GameControllerSwitchPosition>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Roll(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Roll);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Roll(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Roll = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Pitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pitch);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Pitch(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Pitch = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Yaw(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Yaw);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Yaw(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Yaw = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlightStickReading_get_Throttle(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Throttle);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlightStickReading_set_Throttle(py::wrapper::Windows::Gaming::Input::FlightStickReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Throttle = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_FlightStickReading[] = {
        { "timestamp", reinterpret_cast<getter>(FlightStickReading_get_Timestamp), reinterpret_cast<setter>(FlightStickReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(FlightStickReading_get_Buttons), reinterpret_cast<setter>(FlightStickReading_set_Buttons), nullptr, nullptr },
        { "hat_switch", reinterpret_cast<getter>(FlightStickReading_get_HatSwitch), reinterpret_cast<setter>(FlightStickReading_set_HatSwitch), nullptr, nullptr },
        { "roll", reinterpret_cast<getter>(FlightStickReading_get_Roll), reinterpret_cast<setter>(FlightStickReading_set_Roll), nullptr, nullptr },
        { "pitch", reinterpret_cast<getter>(FlightStickReading_get_Pitch), reinterpret_cast<setter>(FlightStickReading_set_Pitch), nullptr, nullptr },
        { "yaw", reinterpret_cast<getter>(FlightStickReading_get_Yaw), reinterpret_cast<setter>(FlightStickReading_set_Yaw), nullptr, nullptr },
        { "throttle", reinterpret_cast<getter>(FlightStickReading_get_Throttle), reinterpret_cast<setter>(FlightStickReading_set_Throttle), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlightStickReading[] = 
    {
        { Py_tp_new, _new_FlightStickReading },
        { Py_tp_dealloc, _dealloc_FlightStickReading },
        { Py_tp_getset, _getset_FlightStickReading },
        { },
    };

    static PyType_Spec type_spec_FlightStickReading =
    {
        "_winsdk_Windows_Gaming_Input.FlightStickReading",
        sizeof(py::wrapper::Windows::Gaming::Input::FlightStickReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlightStickReading
    };

    // ----- GamepadReading struct --------------------
    constexpr const char* const type_name_GamepadReading = "GamepadReading";

    PyObject* _new_GamepadReading(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::GamepadReading return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Gaming::Input::GamepadReading>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};
        double _LeftTrigger{};
        double _RightTrigger{};
        double _LeftThumbstickX{};
        double _LeftThumbstickY{};
        double _RightThumbstickX{};
        double _RightThumbstickY{};

        static const char* kwlist[] = {"timestamp", "buttons", "left_trigger", "right_trigger", "left_thumbstick_x", "left_thumbstick_y", "right_thumbstick_x", "right_thumbstick_y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KIdddddd", const_cast<char**>(kwlist), &_Timestamp, &_Buttons, &_LeftTrigger, &_RightTrigger, &_LeftThumbstickX, &_LeftThumbstickY, &_RightThumbstickX, &_RightThumbstickY))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::GamepadReading return_value{ _Timestamp, static_cast<winrt::Windows::Gaming::Input::GamepadButtons>(_Buttons), _LeftTrigger, _RightTrigger, _LeftThumbstickX, _LeftThumbstickY, _RightThumbstickX, _RightThumbstickY };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_GamepadReading(py::wrapper::Windows::Gaming::Input::GamepadReading* self)
    {
    }

    static PyObject* GamepadReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_Buttons(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_Buttons(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::converter<winrt::Windows::Gaming::Input::GamepadButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.LeftTrigger = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RightTrigger = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_LeftThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftThumbstickX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_LeftThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.LeftThumbstickX = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_LeftThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftThumbstickY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_LeftThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.LeftThumbstickY = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_RightThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightThumbstickX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_RightThumbstickX(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RightThumbstickX = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadReading_get_RightThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightThumbstickY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadReading_set_RightThumbstickY(py::wrapper::Windows::Gaming::Input::GamepadReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RightThumbstickY = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GamepadReading[] = {
        { "timestamp", reinterpret_cast<getter>(GamepadReading_get_Timestamp), reinterpret_cast<setter>(GamepadReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(GamepadReading_get_Buttons), reinterpret_cast<setter>(GamepadReading_set_Buttons), nullptr, nullptr },
        { "left_trigger", reinterpret_cast<getter>(GamepadReading_get_LeftTrigger), reinterpret_cast<setter>(GamepadReading_set_LeftTrigger), nullptr, nullptr },
        { "right_trigger", reinterpret_cast<getter>(GamepadReading_get_RightTrigger), reinterpret_cast<setter>(GamepadReading_set_RightTrigger), nullptr, nullptr },
        { "left_thumbstick_x", reinterpret_cast<getter>(GamepadReading_get_LeftThumbstickX), reinterpret_cast<setter>(GamepadReading_set_LeftThumbstickX), nullptr, nullptr },
        { "left_thumbstick_y", reinterpret_cast<getter>(GamepadReading_get_LeftThumbstickY), reinterpret_cast<setter>(GamepadReading_set_LeftThumbstickY), nullptr, nullptr },
        { "right_thumbstick_x", reinterpret_cast<getter>(GamepadReading_get_RightThumbstickX), reinterpret_cast<setter>(GamepadReading_set_RightThumbstickX), nullptr, nullptr },
        { "right_thumbstick_y", reinterpret_cast<getter>(GamepadReading_get_RightThumbstickY), reinterpret_cast<setter>(GamepadReading_set_RightThumbstickY), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GamepadReading[] = 
    {
        { Py_tp_new, _new_GamepadReading },
        { Py_tp_dealloc, _dealloc_GamepadReading },
        { Py_tp_getset, _getset_GamepadReading },
        { },
    };

    static PyType_Spec type_spec_GamepadReading =
    {
        "_winsdk_Windows_Gaming_Input.GamepadReading",
        sizeof(py::wrapper::Windows::Gaming::Input::GamepadReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GamepadReading
    };

    // ----- GamepadVibration struct --------------------
    constexpr const char* const type_name_GamepadVibration = "GamepadVibration";

    PyObject* _new_GamepadVibration(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::GamepadVibration return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Gaming::Input::GamepadVibration>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        double _LeftMotor{};
        double _RightMotor{};
        double _LeftTrigger{};
        double _RightTrigger{};

        static const char* kwlist[] = {"left_motor", "right_motor", "left_trigger", "right_trigger", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "dddd", const_cast<char**>(kwlist), &_LeftMotor, &_RightMotor, &_LeftTrigger, &_RightTrigger))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::GamepadVibration return_value{ _LeftMotor, _RightMotor, _LeftTrigger, _RightTrigger };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_GamepadVibration(py::wrapper::Windows::Gaming::Input::GamepadVibration* self)
    {
    }

    static PyObject* GamepadVibration_get_LeftMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftMotor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_LeftMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.LeftMotor = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadVibration_get_RightMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightMotor);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_RightMotor(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RightMotor = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadVibration_get_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_LeftTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.LeftTrigger = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* GamepadVibration_get_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightTrigger);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int GamepadVibration_set_RightTrigger(py::wrapper::Windows::Gaming::Input::GamepadVibration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RightTrigger = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_GamepadVibration[] = {
        { "left_motor", reinterpret_cast<getter>(GamepadVibration_get_LeftMotor), reinterpret_cast<setter>(GamepadVibration_set_LeftMotor), nullptr, nullptr },
        { "right_motor", reinterpret_cast<getter>(GamepadVibration_get_RightMotor), reinterpret_cast<setter>(GamepadVibration_set_RightMotor), nullptr, nullptr },
        { "left_trigger", reinterpret_cast<getter>(GamepadVibration_get_LeftTrigger), reinterpret_cast<setter>(GamepadVibration_set_LeftTrigger), nullptr, nullptr },
        { "right_trigger", reinterpret_cast<getter>(GamepadVibration_get_RightTrigger), reinterpret_cast<setter>(GamepadVibration_set_RightTrigger), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_GamepadVibration[] = 
    {
        { Py_tp_new, _new_GamepadVibration },
        { Py_tp_dealloc, _dealloc_GamepadVibration },
        { Py_tp_getset, _getset_GamepadVibration },
        { },
    };

    static PyType_Spec type_spec_GamepadVibration =
    {
        "_winsdk_Windows_Gaming_Input.GamepadVibration",
        sizeof(py::wrapper::Windows::Gaming::Input::GamepadVibration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_GamepadVibration
    };

    // ----- RacingWheelReading struct --------------------
    constexpr const char* const type_name_RacingWheelReading = "RacingWheelReading";

    PyObject* _new_RacingWheelReading(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::RacingWheelReading return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Gaming::Input::RacingWheelReading>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _Timestamp{};
        uint32_t _Buttons{};
        int32_t _PatternShifterGear{};
        double _Wheel{};
        double _Throttle{};
        double _Brake{};
        double _Clutch{};
        double _Handbrake{};

        static const char* kwlist[] = {"timestamp", "buttons", "pattern_shifter_gear", "wheel", "throttle", "brake", "clutch", "handbrake", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KIiddddd", const_cast<char**>(kwlist), &_Timestamp, &_Buttons, &_PatternShifterGear, &_Wheel, &_Throttle, &_Brake, &_Clutch, &_Handbrake))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::RacingWheelReading return_value{ _Timestamp, static_cast<winrt::Windows::Gaming::Input::RacingWheelButtons>(_Buttons), _PatternShifterGear, _Wheel, _Throttle, _Brake, _Clutch, _Handbrake };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_RacingWheelReading(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self)
    {
    }

    static PyObject* RacingWheelReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Buttons(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Buttons(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Buttons = py::converter<winrt::Windows::Gaming::Input::RacingWheelButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_PatternShifterGear(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PatternShifterGear);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_PatternShifterGear(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PatternShifterGear = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Wheel(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Wheel);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Wheel(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Wheel = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Throttle(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Throttle);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Throttle(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Throttle = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Brake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Brake);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Brake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Brake = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Clutch(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Clutch);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Clutch(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Clutch = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RacingWheelReading_get_Handbrake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handbrake);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RacingWheelReading_set_Handbrake(py::wrapper::Windows::Gaming::Input::RacingWheelReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Handbrake = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_RacingWheelReading[] = {
        { "timestamp", reinterpret_cast<getter>(RacingWheelReading_get_Timestamp), reinterpret_cast<setter>(RacingWheelReading_set_Timestamp), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(RacingWheelReading_get_Buttons), reinterpret_cast<setter>(RacingWheelReading_set_Buttons), nullptr, nullptr },
        { "pattern_shifter_gear", reinterpret_cast<getter>(RacingWheelReading_get_PatternShifterGear), reinterpret_cast<setter>(RacingWheelReading_set_PatternShifterGear), nullptr, nullptr },
        { "wheel", reinterpret_cast<getter>(RacingWheelReading_get_Wheel), reinterpret_cast<setter>(RacingWheelReading_set_Wheel), nullptr, nullptr },
        { "throttle", reinterpret_cast<getter>(RacingWheelReading_get_Throttle), reinterpret_cast<setter>(RacingWheelReading_set_Throttle), nullptr, nullptr },
        { "brake", reinterpret_cast<getter>(RacingWheelReading_get_Brake), reinterpret_cast<setter>(RacingWheelReading_set_Brake), nullptr, nullptr },
        { "clutch", reinterpret_cast<getter>(RacingWheelReading_get_Clutch), reinterpret_cast<setter>(RacingWheelReading_set_Clutch), nullptr, nullptr },
        { "handbrake", reinterpret_cast<getter>(RacingWheelReading_get_Handbrake), reinterpret_cast<setter>(RacingWheelReading_set_Handbrake), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RacingWheelReading[] = 
    {
        { Py_tp_new, _new_RacingWheelReading },
        { Py_tp_dealloc, _dealloc_RacingWheelReading },
        { Py_tp_getset, _getset_RacingWheelReading },
        { },
    };

    static PyType_Spec type_spec_RacingWheelReading =
    {
        "_winsdk_Windows_Gaming_Input.RacingWheelReading",
        sizeof(py::wrapper::Windows::Gaming::Input::RacingWheelReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RacingWheelReading
    };

    // ----- UINavigationReading struct --------------------
    constexpr const char* const type_name_UINavigationReading = "UINavigationReading";

    PyObject* _new_UINavigationReading(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Gaming::Input::UINavigationReading return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Gaming::Input::UINavigationReading>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _Timestamp{};
        uint32_t _RequiredButtons{};
        uint32_t _OptionalButtons{};

        static const char* kwlist[] = {"timestamp", "required_buttons", "optional_buttons", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "KII", const_cast<char**>(kwlist), &_Timestamp, &_RequiredButtons, &_OptionalButtons))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Gaming::Input::UINavigationReading return_value{ _Timestamp, static_cast<winrt::Windows::Gaming::Input::RequiredUINavigationButtons>(_RequiredButtons), static_cast<winrt::Windows::Gaming::Input::OptionalUINavigationButtons>(_OptionalButtons) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_UINavigationReading(py::wrapper::Windows::Gaming::Input::UINavigationReading* self)
    {
    }

    static PyObject* UINavigationReading_get_Timestamp(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UINavigationReading_set_Timestamp(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Timestamp = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UINavigationReading_get_RequiredButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequiredButtons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UINavigationReading_set_RequiredButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.RequiredButtons = py::converter<winrt::Windows::Gaming::Input::RequiredUINavigationButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UINavigationReading_get_OptionalButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalButtons);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UINavigationReading_set_OptionalButtons(py::wrapper::Windows::Gaming::Input::UINavigationReading* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.OptionalButtons = py::converter<winrt::Windows::Gaming::Input::OptionalUINavigationButtons>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_UINavigationReading[] = {
        { "timestamp", reinterpret_cast<getter>(UINavigationReading_get_Timestamp), reinterpret_cast<setter>(UINavigationReading_set_Timestamp), nullptr, nullptr },
        { "required_buttons", reinterpret_cast<getter>(UINavigationReading_get_RequiredButtons), reinterpret_cast<setter>(UINavigationReading_set_RequiredButtons), nullptr, nullptr },
        { "optional_buttons", reinterpret_cast<getter>(UINavigationReading_get_OptionalButtons), reinterpret_cast<setter>(UINavigationReading_set_OptionalButtons), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UINavigationReading[] = 
    {
        { Py_tp_new, _new_UINavigationReading },
        { Py_tp_dealloc, _dealloc_UINavigationReading },
        { Py_tp_getset, _getset_UINavigationReading },
        { },
    };

    static PyType_Spec type_spec_UINavigationReading =
    {
        "_winsdk_Windows_Gaming_Input.UINavigationReading",
        sizeof(py::wrapper::Windows::Gaming::Input::UINavigationReading),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UINavigationReading
    };

    // ----- Windows.Gaming.Input Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Gaming::Input");

    static PyMethodDef module_methods[] = {
        {"_register_ArcadeStickButtons", register_ArcadeStickButtons, METH_O, "registers type"},
        {"_register_FlightStickButtons", register_FlightStickButtons, METH_O, "registers type"},
        {"_register_GameControllerButtonLabel", register_GameControllerButtonLabel, METH_O, "registers type"},
        {"_register_GameControllerSwitchKind", register_GameControllerSwitchKind, METH_O, "registers type"},
        {"_register_GameControllerSwitchPosition", register_GameControllerSwitchPosition, METH_O, "registers type"},
        {"_register_GamepadButtons", register_GamepadButtons, METH_O, "registers type"},
        {"_register_OptionalUINavigationButtons", register_OptionalUINavigationButtons, METH_O, "registers type"},
        {"_register_RacingWheelButtons", register_RacingWheelButtons, METH_O, "registers type"},
        {"_register_RequiredUINavigationButtons", register_RequiredUINavigationButtons, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_ArcadeStickButtons);
        Py_VISIT(state->type_FlightStickButtons);
        Py_VISIT(state->type_GameControllerButtonLabel);
        Py_VISIT(state->type_GameControllerSwitchKind);
        Py_VISIT(state->type_GameControllerSwitchPosition);
        Py_VISIT(state->type_GamepadButtons);
        Py_VISIT(state->type_OptionalUINavigationButtons);
        Py_VISIT(state->type_RacingWheelButtons);
        Py_VISIT(state->type_RequiredUINavigationButtons);
        Py_VISIT(state->type_ArcadeStick);
        Py_VISIT(state->type_FlightStick);
        Py_VISIT(state->type_Gamepad);
        Py_VISIT(state->type_Headset);
        Py_VISIT(state->type_RacingWheel);
        Py_VISIT(state->type_RawGameController);
        Py_VISIT(state->type_UINavigationController);
        Py_VISIT(state->type_IGameController);
        Py_VISIT(state->type_IGameControllerBatteryInfo);
        Py_VISIT(state->type_ArcadeStickReading);
        Py_VISIT(state->type_FlightStickReading);
        Py_VISIT(state->type_GamepadReading);
        Py_VISIT(state->type_GamepadVibration);
        Py_VISIT(state->type_RacingWheelReading);
        Py_VISIT(state->type_UINavigationReading);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_ArcadeStickButtons);
        Py_CLEAR(state->type_FlightStickButtons);
        Py_CLEAR(state->type_GameControllerButtonLabel);
        Py_CLEAR(state->type_GameControllerSwitchKind);
        Py_CLEAR(state->type_GameControllerSwitchPosition);
        Py_CLEAR(state->type_GamepadButtons);
        Py_CLEAR(state->type_OptionalUINavigationButtons);
        Py_CLEAR(state->type_RacingWheelButtons);
        Py_CLEAR(state->type_RequiredUINavigationButtons);
        Py_CLEAR(state->type_ArcadeStick);
        Py_CLEAR(state->type_FlightStick);
        Py_CLEAR(state->type_Gamepad);
        Py_CLEAR(state->type_Headset);
        Py_CLEAR(state->type_RacingWheel);
        Py_CLEAR(state->type_RawGameController);
        Py_CLEAR(state->type_UINavigationController);
        Py_CLEAR(state->type_IGameController);
        Py_CLEAR(state->type_IGameControllerBatteryInfo);
        Py_CLEAR(state->type_ArcadeStickReading);
        Py_CLEAR(state->type_FlightStickReading);
        Py_CLEAR(state->type_GamepadReading);
        Py_CLEAR(state->type_GamepadVibration);
        Py_CLEAR(state->type_RacingWheelReading);
        Py_CLEAR(state->type_UINavigationReading);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Gaming_Input",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Gaming::Input

PyMODINIT_FUNC PyInit__winsdk_Windows_Gaming_Input(void) noexcept
{
    using namespace py::cpp::Windows::Gaming::Input;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_ArcadeStick = py::register_python_type(module.get(), type_name_ArcadeStick, &type_spec_ArcadeStick, bases.get());
    if (!state->type_ArcadeStick)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ArcadeStick);

    state->type_FlightStick = py::register_python_type(module.get(), type_name_FlightStick, &type_spec_FlightStick, bases.get());
    if (!state->type_FlightStick)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FlightStick);

    state->type_Gamepad = py::register_python_type(module.get(), type_name_Gamepad, &type_spec_Gamepad, bases.get());
    if (!state->type_Gamepad)
    {
        return nullptr;
    }

    Py_INCREF(state->type_Gamepad);

    state->type_Headset = py::register_python_type(module.get(), type_name_Headset, &type_spec_Headset, bases.get());
    if (!state->type_Headset)
    {
        return nullptr;
    }

    Py_INCREF(state->type_Headset);

    state->type_RacingWheel = py::register_python_type(module.get(), type_name_RacingWheel, &type_spec_RacingWheel, bases.get());
    if (!state->type_RacingWheel)
    {
        return nullptr;
    }

    Py_INCREF(state->type_RacingWheel);

    state->type_RawGameController = py::register_python_type(module.get(), type_name_RawGameController, &type_spec_RawGameController, bases.get());
    if (!state->type_RawGameController)
    {
        return nullptr;
    }

    Py_INCREF(state->type_RawGameController);

    state->type_UINavigationController = py::register_python_type(module.get(), type_name_UINavigationController, &type_spec_UINavigationController, bases.get());
    if (!state->type_UINavigationController)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UINavigationController);

    state->type_IGameController = py::register_python_type(module.get(), type_name_IGameController, &type_spec_IGameController, bases.get());
    if (!state->type_IGameController)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IGameController);

    state->type_IGameControllerBatteryInfo = py::register_python_type(module.get(), type_name_IGameControllerBatteryInfo, &type_spec_IGameControllerBatteryInfo, bases.get());
    if (!state->type_IGameControllerBatteryInfo)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IGameControllerBatteryInfo);

    state->type_ArcadeStickReading = py::register_python_type(module.get(), type_name_ArcadeStickReading, &type_spec_ArcadeStickReading, bases.get());
    if (!state->type_ArcadeStickReading)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ArcadeStickReading);

    state->type_FlightStickReading = py::register_python_type(module.get(), type_name_FlightStickReading, &type_spec_FlightStickReading, bases.get());
    if (!state->type_FlightStickReading)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FlightStickReading);

    state->type_GamepadReading = py::register_python_type(module.get(), type_name_GamepadReading, &type_spec_GamepadReading, bases.get());
    if (!state->type_GamepadReading)
    {
        return nullptr;
    }

    Py_INCREF(state->type_GamepadReading);

    state->type_GamepadVibration = py::register_python_type(module.get(), type_name_GamepadVibration, &type_spec_GamepadVibration, bases.get());
    if (!state->type_GamepadVibration)
    {
        return nullptr;
    }

    Py_INCREF(state->type_GamepadVibration);

    state->type_RacingWheelReading = py::register_python_type(module.get(), type_name_RacingWheelReading, &type_spec_RacingWheelReading, bases.get());
    if (!state->type_RacingWheelReading)
    {
        return nullptr;
    }

    Py_INCREF(state->type_RacingWheelReading);

    state->type_UINavigationReading = py::register_python_type(module.get(), type_name_UINavigationReading, &type_spec_UINavigationReading, bases.get());
    if (!state->type_UINavigationReading)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UINavigationReading);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Gaming::Input::ArcadeStickButtons>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ArcadeStickButtons;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::ArcadeStickButtons is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Gaming::Input::FlightStickButtons>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FlightStickButtons;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::FlightStickButtons is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Gaming::Input::GameControllerButtonLabel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GameControllerButtonLabel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::GameControllerButtonLabel is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Gaming::Input::GameControllerSwitchKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GameControllerSwitchKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::GameControllerSwitchKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Gaming::Input::GameControllerSwitchPosition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GameControllerSwitchPosition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::GameControllerSwitchPosition is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Gaming::Input::GamepadButtons>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GamepadButtons;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::GamepadButtons is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Gaming::Input::OptionalUINavigationButtons>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_OptionalUINavigationButtons;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::OptionalUINavigationButtons is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Gaming::Input::RacingWheelButtons>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RacingWheelButtons;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::RacingWheelButtons is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Gaming::Input::RequiredUINavigationButtons>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RequiredUINavigationButtons;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::RequiredUINavigationButtons is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::ArcadeStick>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ArcadeStick;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::ArcadeStick is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::FlightStick>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FlightStick;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::FlightStick is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Gamepad>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Gamepad;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Gamepad is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::Headset>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Headset;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::Headset is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::RacingWheel>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RacingWheel;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::RacingWheel is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::RawGameController>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RawGameController;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::RawGameController is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::UINavigationController>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UINavigationController;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::UINavigationController is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::IGameController>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IGameController;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::IGameController is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::IGameControllerBatteryInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IGameControllerBatteryInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::IGameControllerBatteryInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::ArcadeStickReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ArcadeStickReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::ArcadeStickReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::FlightStickReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FlightStickReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::FlightStickReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::GamepadReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GamepadReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::GamepadReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::GamepadVibration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_GamepadVibration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::GamepadVibration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::RacingWheelReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RacingWheelReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::RacingWheelReading is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Gaming::Input::UINavigationReading>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Gaming::Input;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Gaming::Input");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UINavigationReading;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Gaming::Input::UINavigationReading is not registered");
        return nullptr;
    }

    return python_type;
}
