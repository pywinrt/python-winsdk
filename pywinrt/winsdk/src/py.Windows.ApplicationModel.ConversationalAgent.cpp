// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.ApplicationModel.ConversationalAgent.h"

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo>::python_type;

namespace py::cpp::Windows::ApplicationModel::ConversationalAgent
{
    // ----- ActivationSignalDetectionConfiguration class --------------------
    constexpr const char* const _type_name_ActivationSignalDetectionConfiguration = "ActivationSignalDetectionConfiguration";

    static PyObject* _new_ActivationSignalDetectionConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ActivationSignalDetectionConfiguration);
        return nullptr;
    }

    static void _dealloc_ActivationSignalDetectionConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ActivationSignalDetectionConfiguration_ApplyTrainingData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionTrainingDataFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.ApplyTrainingData(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ApplyTrainingDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionTrainingDataFormat>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.ApplyTrainingDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearModelData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ClearModelData();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearModelDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearModelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearTrainingData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ClearTrainingData();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_ClearTrainingDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearTrainingDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_Close(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetModelData());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetModelDataAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelDataType(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetModelDataType());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_GetModelDataTypeAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetModelDataTypeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabled(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.SetEnabled(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabledAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetEnabledAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabledWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetEnabledWithResult(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetEnabledWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetEnabledWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelData(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                self->obj.SetModelData(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelDataAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.SetModelDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelDataWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.SetModelDataWithResult(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_SetModelDataWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IInputStream>(args, 1);

                return py::convert(self->obj.SetModelDataWithResultAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_AvailabilityInfo(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AvailabilityInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_DisplayName(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_IsActive(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_ModelId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ModelId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_SignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingDataFormat(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrainingDataFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingStepsCompleted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrainingStepsCompleted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingStepsRemaining(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrainingStepsRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_get_TrainingStepCompletionMaxAllowedTime(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrainingStepCompletionMaxAllowedTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_add_AvailabilityChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration, winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>>(arg);

            return py::convert(self->obj.AvailabilityChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfiguration_remove_AvailabilityChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AvailabilityChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ActivationSignalDetectionConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ActivationSignalDetectionConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ActivationSignalDetectionConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivationSignalDetectionConfiguration[] = {
        { "apply_training_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ApplyTrainingData), METH_VARARGS, nullptr },
        { "apply_training_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ApplyTrainingDataAsync), METH_VARARGS, nullptr },
        { "clear_model_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ClearModelData), METH_VARARGS, nullptr },
        { "clear_model_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ClearModelDataAsync), METH_VARARGS, nullptr },
        { "clear_training_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ClearTrainingData), METH_VARARGS, nullptr },
        { "clear_training_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_ClearTrainingDataAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_Close), METH_VARARGS, nullptr },
        { "get_model_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_GetModelData), METH_VARARGS, nullptr },
        { "get_model_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_GetModelDataAsync), METH_VARARGS, nullptr },
        { "get_model_data_type", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_GetModelDataType), METH_VARARGS, nullptr },
        { "get_model_data_type_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_GetModelDataTypeAsync), METH_VARARGS, nullptr },
        { "set_enabled", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetEnabled), METH_VARARGS, nullptr },
        { "set_enabled_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetEnabledAsync), METH_VARARGS, nullptr },
        { "set_enabled_with_result", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetEnabledWithResult), METH_VARARGS, nullptr },
        { "set_enabled_with_result_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetEnabledWithResultAsync), METH_VARARGS, nullptr },
        { "set_model_data", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetModelData), METH_VARARGS, nullptr },
        { "set_model_data_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetModelDataAsync), METH_VARARGS, nullptr },
        { "set_model_data_with_result", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetModelDataWithResult), METH_VARARGS, nullptr },
        { "set_model_data_with_result_async", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_SetModelDataWithResultAsync), METH_VARARGS, nullptr },
        { "add_availability_changed", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_add_AvailabilityChanged), METH_O, nullptr },
        { "remove_availability_changed", reinterpret_cast<PyCFunction>(ActivationSignalDetectionConfiguration_remove_AvailabilityChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivationSignalDetectionConfiguration), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ActivationSignalDetectionConfiguration), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ActivationSignalDetectionConfiguration), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivationSignalDetectionConfiguration[] = {
        { "availability_info", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_AvailabilityInfo), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_DisplayName), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_IsActive), nullptr, nullptr, nullptr },
        { "model_id", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_ModelId), nullptr, nullptr, nullptr },
        { "signal_id", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_SignalId), nullptr, nullptr, nullptr },
        { "training_data_format", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_TrainingDataFormat), nullptr, nullptr, nullptr },
        { "training_steps_completed", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_TrainingStepsCompleted), nullptr, nullptr, nullptr },
        { "training_steps_remaining", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_TrainingStepsRemaining), nullptr, nullptr, nullptr },
        { "training_step_completion_max_allowed_time", reinterpret_cast<getter>(ActivationSignalDetectionConfiguration_get_TrainingStepCompletionMaxAllowedTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivationSignalDetectionConfiguration[] = 
    {
        { Py_tp_new, _new_ActivationSignalDetectionConfiguration },
        { Py_tp_dealloc, _dealloc_ActivationSignalDetectionConfiguration },
        { Py_tp_methods, _methods_ActivationSignalDetectionConfiguration },
        { Py_tp_getset, _getset_ActivationSignalDetectionConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ActivationSignalDetectionConfiguration =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ActivationSignalDetectionConfiguration",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivationSignalDetectionConfiguration
    };

    // ----- ActivationSignalDetectionConfigurationCreationResult class --------------------
    constexpr const char* const _type_name_ActivationSignalDetectionConfigurationCreationResult = "ActivationSignalDetectionConfigurationCreationResult";

    static PyObject* _new_ActivationSignalDetectionConfigurationCreationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ActivationSignalDetectionConfigurationCreationResult);
        return nullptr;
    }

    static void _dealloc_ActivationSignalDetectionConfigurationCreationResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ActivationSignalDetectionConfigurationCreationResult_get_Configuration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetectionConfigurationCreationResult_get_Status(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ActivationSignalDetectionConfigurationCreationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivationSignalDetectionConfigurationCreationResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivationSignalDetectionConfigurationCreationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivationSignalDetectionConfigurationCreationResult[] = {
        { "configuration", reinterpret_cast<getter>(ActivationSignalDetectionConfigurationCreationResult_get_Configuration), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ActivationSignalDetectionConfigurationCreationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivationSignalDetectionConfigurationCreationResult[] = 
    {
        { Py_tp_new, _new_ActivationSignalDetectionConfigurationCreationResult },
        { Py_tp_dealloc, _dealloc_ActivationSignalDetectionConfigurationCreationResult },
        { Py_tp_methods, _methods_ActivationSignalDetectionConfigurationCreationResult },
        { Py_tp_getset, _getset_ActivationSignalDetectionConfigurationCreationResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ActivationSignalDetectionConfigurationCreationResult =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ActivationSignalDetectionConfigurationCreationResult",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivationSignalDetectionConfigurationCreationResult
    };

    // ----- ActivationSignalDetector class --------------------
    constexpr const char* const _type_name_ActivationSignalDetector = "ActivationSignalDetector";

    static PyObject* _new_ActivationSignalDetector(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ActivationSignalDetector);
        return nullptr;
    }

    static void _dealloc_ActivationSignalDetector(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ActivationSignalDetector_CreateConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                self->obj.CreateConfiguration(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_CreateConfigurationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateConfigurationAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_CreateConfigurationWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateConfigurationWithResult(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_CreateConfigurationWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.CreateConfigurationWithResultAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetAvailableModelIdsForSignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAvailableModelIdsForSignalId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetAvailableModelIdsForSignalIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetAvailableModelIdsForSignalIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetConfiguration(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfigurationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetConfigurationAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfigurations(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConfigurations());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetConfigurationsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConfigurationsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetSupportedModelIdsForSignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetSupportedModelIdsForSignalId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_GetSupportedModelIdsForSignalIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetSupportedModelIdsForSignalIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfiguration(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.RemoveConfiguration(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfigurationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RemoveConfigurationAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfigurationWithResult(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RemoveConfigurationWithResult(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_RemoveConfigurationWithResultAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.RemoveConfigurationWithResultAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_CanCreateConfigurations(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanCreateConfigurations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_Kind(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_ProviderId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_SupportedModelDataTypes(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModelDataTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_SupportedPowerStates(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedPowerStates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_SupportedTrainingDataFormats(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedTrainingDataFormats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ActivationSignalDetector_get_DetectorId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ActivationSignalDetector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ActivationSignalDetector[] = {
        { "create_configuration", reinterpret_cast<PyCFunction>(ActivationSignalDetector_CreateConfiguration), METH_VARARGS, nullptr },
        { "create_configuration_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_CreateConfigurationAsync), METH_VARARGS, nullptr },
        { "create_configuration_with_result", reinterpret_cast<PyCFunction>(ActivationSignalDetector_CreateConfigurationWithResult), METH_VARARGS, nullptr },
        { "create_configuration_with_result_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_CreateConfigurationWithResultAsync), METH_VARARGS, nullptr },
        { "get_available_model_ids_for_signal_id", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetAvailableModelIdsForSignalId), METH_VARARGS, nullptr },
        { "get_available_model_ids_for_signal_id_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetAvailableModelIdsForSignalIdAsync), METH_VARARGS, nullptr },
        { "get_configuration", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetConfiguration), METH_VARARGS, nullptr },
        { "get_configuration_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetConfigurationAsync), METH_VARARGS, nullptr },
        { "get_configurations", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetConfigurations), METH_VARARGS, nullptr },
        { "get_configurations_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetConfigurationsAsync), METH_VARARGS, nullptr },
        { "get_supported_model_ids_for_signal_id", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetSupportedModelIdsForSignalId), METH_VARARGS, nullptr },
        { "get_supported_model_ids_for_signal_id_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_GetSupportedModelIdsForSignalIdAsync), METH_VARARGS, nullptr },
        { "remove_configuration", reinterpret_cast<PyCFunction>(ActivationSignalDetector_RemoveConfiguration), METH_VARARGS, nullptr },
        { "remove_configuration_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_RemoveConfigurationAsync), METH_VARARGS, nullptr },
        { "remove_configuration_with_result", reinterpret_cast<PyCFunction>(ActivationSignalDetector_RemoveConfigurationWithResult), METH_VARARGS, nullptr },
        { "remove_configuration_with_result_async", reinterpret_cast<PyCFunction>(ActivationSignalDetector_RemoveConfigurationWithResultAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ActivationSignalDetector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ActivationSignalDetector[] = {
        { "can_create_configurations", reinterpret_cast<getter>(ActivationSignalDetector_get_CanCreateConfigurations), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ActivationSignalDetector_get_Kind), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(ActivationSignalDetector_get_ProviderId), nullptr, nullptr, nullptr },
        { "supported_model_data_types", reinterpret_cast<getter>(ActivationSignalDetector_get_SupportedModelDataTypes), nullptr, nullptr, nullptr },
        { "supported_power_states", reinterpret_cast<getter>(ActivationSignalDetector_get_SupportedPowerStates), nullptr, nullptr, nullptr },
        { "supported_training_data_formats", reinterpret_cast<getter>(ActivationSignalDetector_get_SupportedTrainingDataFormats), nullptr, nullptr, nullptr },
        { "detector_id", reinterpret_cast<getter>(ActivationSignalDetector_get_DetectorId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ActivationSignalDetector[] = 
    {
        { Py_tp_new, _new_ActivationSignalDetector },
        { Py_tp_dealloc, _dealloc_ActivationSignalDetector },
        { Py_tp_methods, _methods_ActivationSignalDetector },
        { Py_tp_getset, _getset_ActivationSignalDetector },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ActivationSignalDetector =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ActivationSignalDetector",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ActivationSignalDetector
    };

    // ----- ConversationalAgentDetectorManager class --------------------
    constexpr const char* const _type_name_ConversationalAgentDetectorManager = "ConversationalAgentDetectorManager";

    static PyObject* _new_ConversationalAgentDetectorManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConversationalAgentDetectorManager);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentDetectorManager(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectorFromId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectorFromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectorFromIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectorFromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectors(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectorKind>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectors(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetActivationSignalDetectorsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectorKind>(args, 0);

                return py::convert(self->obj.GetActivationSignalDetectorsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetAllActivationSignalDetectors(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAllActivationSignalDetectors());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_GetAllActivationSignalDetectorsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAllActivationSignalDetectorsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentDetectorManager_get_Default(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager::Default());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConversationalAgentDetectorManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentDetectorManager[] = {
        { "get_activation_signal_detector_from_id", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetActivationSignalDetectorFromId), METH_VARARGS, nullptr },
        { "get_activation_signal_detector_from_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetActivationSignalDetectorFromIdAsync), METH_VARARGS, nullptr },
        { "get_activation_signal_detectors", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetActivationSignalDetectors), METH_VARARGS, nullptr },
        { "get_activation_signal_detectors_async", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetActivationSignalDetectorsAsync), METH_VARARGS, nullptr },
        { "get_all_activation_signal_detectors", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetAllActivationSignalDetectors), METH_VARARGS, nullptr },
        { "get_all_activation_signal_detectors_async", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_GetAllActivationSignalDetectorsAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(ConversationalAgentDetectorManager_get_Default), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentDetectorManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentDetectorManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentDetectorManager[] = 
    {
        { Py_tp_new, _new_ConversationalAgentDetectorManager },
        { Py_tp_dealloc, _dealloc_ConversationalAgentDetectorManager },
        { Py_tp_methods, _methods_ConversationalAgentDetectorManager },
        { Py_tp_getset, _getset_ConversationalAgentDetectorManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConversationalAgentDetectorManager =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentDetectorManager",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentDetectorManager
    };

    // ----- ConversationalAgentSession class --------------------
    constexpr const char* const _type_name_ConversationalAgentSession = "ConversationalAgentSession";

    static PyObject* _new_ConversationalAgentSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConversationalAgentSession);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSession(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConversationalAgentSession_Close(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_CreateAudioDeviceInputNode(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                return py::convert(self->obj.CreateAudioDeviceInputNode(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_CreateAudioDeviceInputNodeAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Audio::AudioGraph>(args, 0);

                return py::convert(self->obj.CreateAudioDeviceInputNodeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioCaptureDeviceId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioCaptureDeviceId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioCaptureDeviceIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioCaptureDeviceIdAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioClient(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioClient());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioClientAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioClientAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioRenderDeviceId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioRenderDeviceId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetAudioRenderDeviceIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioRenderDeviceIdAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetCurrentSessionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession::GetCurrentSessionAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetCurrentSessionSync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession::GetCurrentSessionSync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetMissingPrerequisites(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMissingPrerequisites());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetMissingPrerequisitesAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetMissingPrerequisitesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSignalModelId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSignalModelId());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSignalModelIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSignalModelIdAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSupportedSignalModelIds(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSupportedSignalModelIds());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_GetSupportedSignalModelIdsAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSupportedSignalModelIdsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestActivation(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentActivationKind>(args, 0);

                return py::convert(self->obj.RequestActivation(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestActivationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentActivationKind>(args, 0);

                return py::convert(self->obj.RequestActivationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestAgentStateChange(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentState>(args, 0);

                return py::convert(self->obj.RequestAgentStateChange(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestAgentStateChangeAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentState>(args, 0);

                return py::convert(self->obj.RequestAgentStateChangeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestForegroundActivation(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestForegroundActivation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestForegroundActivationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestForegroundActivationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestInterruptible(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.RequestInterruptible(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_RequestInterruptibleAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.RequestInterruptibleAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSignalModelId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetSignalModelId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSignalModelIdAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetSignalModelIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSupportLockScreenActivation(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.SetSupportLockScreenActivation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_SetSupportLockScreenActivationAsync(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetSupportLockScreenActivationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_AgentState(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AgentState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsIndicatorLightAvailable(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsIndicatorLightAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsInterrupted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInterrupted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsInterruptible(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInterruptible());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsScreenAvailable(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsScreenAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsUserAuthenticated(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsUserAuthenticated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_IsVoiceActivationAvailable(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVoiceActivationAvailable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_get_Signal(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Signal());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_add_SessionInterrupted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession, winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>>(arg);

            return py::convert(self->obj.SessionInterrupted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_remove_SessionInterrupted(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SessionInterrupted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_add_SignalDetected(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession, winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>>(arg);

            return py::convert(self->obj.SignalDetected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_remove_SignalDetected(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SignalDetected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_add_SystemStateChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession, winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>>(arg);

            return py::convert(self->obj.SystemStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSession_remove_SystemStateChanged(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SystemStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConversationalAgentSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ConversationalAgentSession(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ConversationalAgentSession(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSession[] = {
        { "close", reinterpret_cast<PyCFunction>(ConversationalAgentSession_Close), METH_VARARGS, nullptr },
        { "create_audio_device_input_node", reinterpret_cast<PyCFunction>(ConversationalAgentSession_CreateAudioDeviceInputNode), METH_VARARGS, nullptr },
        { "create_audio_device_input_node_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_CreateAudioDeviceInputNodeAsync), METH_VARARGS, nullptr },
        { "get_audio_capture_device_id", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioCaptureDeviceId), METH_VARARGS, nullptr },
        { "get_audio_capture_device_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioCaptureDeviceIdAsync), METH_VARARGS, nullptr },
        { "get_audio_client", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioClient), METH_VARARGS, nullptr },
        { "get_audio_client_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioClientAsync), METH_VARARGS, nullptr },
        { "get_audio_render_device_id", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioRenderDeviceId), METH_VARARGS, nullptr },
        { "get_audio_render_device_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetAudioRenderDeviceIdAsync), METH_VARARGS, nullptr },
        { "get_current_session_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetCurrentSessionAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_session_sync", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetCurrentSessionSync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_missing_prerequisites", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetMissingPrerequisites), METH_VARARGS, nullptr },
        { "get_missing_prerequisites_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetMissingPrerequisitesAsync), METH_VARARGS, nullptr },
        { "get_signal_model_id", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetSignalModelId), METH_VARARGS, nullptr },
        { "get_signal_model_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetSignalModelIdAsync), METH_VARARGS, nullptr },
        { "get_supported_signal_model_ids", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetSupportedSignalModelIds), METH_VARARGS, nullptr },
        { "get_supported_signal_model_ids_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_GetSupportedSignalModelIdsAsync), METH_VARARGS, nullptr },
        { "request_activation", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestActivation), METH_VARARGS, nullptr },
        { "request_activation_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestActivationAsync), METH_VARARGS, nullptr },
        { "request_agent_state_change", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestAgentStateChange), METH_VARARGS, nullptr },
        { "request_agent_state_change_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestAgentStateChangeAsync), METH_VARARGS, nullptr },
        { "request_foreground_activation", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestForegroundActivation), METH_VARARGS, nullptr },
        { "request_foreground_activation_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestForegroundActivationAsync), METH_VARARGS, nullptr },
        { "request_interruptible", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestInterruptible), METH_VARARGS, nullptr },
        { "request_interruptible_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_RequestInterruptibleAsync), METH_VARARGS, nullptr },
        { "set_signal_model_id", reinterpret_cast<PyCFunction>(ConversationalAgentSession_SetSignalModelId), METH_VARARGS, nullptr },
        { "set_signal_model_id_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_SetSignalModelIdAsync), METH_VARARGS, nullptr },
        { "set_support_lock_screen_activation", reinterpret_cast<PyCFunction>(ConversationalAgentSession_SetSupportLockScreenActivation), METH_VARARGS, nullptr },
        { "set_support_lock_screen_activation_async", reinterpret_cast<PyCFunction>(ConversationalAgentSession_SetSupportLockScreenActivationAsync), METH_VARARGS, nullptr },
        { "add_session_interrupted", reinterpret_cast<PyCFunction>(ConversationalAgentSession_add_SessionInterrupted), METH_O, nullptr },
        { "remove_session_interrupted", reinterpret_cast<PyCFunction>(ConversationalAgentSession_remove_SessionInterrupted), METH_O, nullptr },
        { "add_signal_detected", reinterpret_cast<PyCFunction>(ConversationalAgentSession_add_SignalDetected), METH_O, nullptr },
        { "remove_signal_detected", reinterpret_cast<PyCFunction>(ConversationalAgentSession_remove_SignalDetected), METH_O, nullptr },
        { "add_system_state_changed", reinterpret_cast<PyCFunction>(ConversationalAgentSession_add_SystemStateChanged), METH_O, nullptr },
        { "remove_system_state_changed", reinterpret_cast<PyCFunction>(ConversationalAgentSession_remove_SystemStateChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ConversationalAgentSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ConversationalAgentSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSession[] = {
        { "agent_state", reinterpret_cast<getter>(ConversationalAgentSession_get_AgentState), nullptr, nullptr, nullptr },
        { "is_indicator_light_available", reinterpret_cast<getter>(ConversationalAgentSession_get_IsIndicatorLightAvailable), nullptr, nullptr, nullptr },
        { "is_interrupted", reinterpret_cast<getter>(ConversationalAgentSession_get_IsInterrupted), nullptr, nullptr, nullptr },
        { "is_interruptible", reinterpret_cast<getter>(ConversationalAgentSession_get_IsInterruptible), nullptr, nullptr, nullptr },
        { "is_screen_available", reinterpret_cast<getter>(ConversationalAgentSession_get_IsScreenAvailable), nullptr, nullptr, nullptr },
        { "is_user_authenticated", reinterpret_cast<getter>(ConversationalAgentSession_get_IsUserAuthenticated), nullptr, nullptr, nullptr },
        { "is_voice_activation_available", reinterpret_cast<getter>(ConversationalAgentSession_get_IsVoiceActivationAvailable), nullptr, nullptr, nullptr },
        { "signal", reinterpret_cast<getter>(ConversationalAgentSession_get_Signal), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSession[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSession },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSession },
        { Py_tp_methods, _methods_ConversationalAgentSession },
        { Py_tp_getset, _getset_ConversationalAgentSession },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConversationalAgentSession =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSession",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSession
    };

    // ----- ConversationalAgentSessionInterruptedEventArgs class --------------------
    constexpr const char* const _type_name_ConversationalAgentSessionInterruptedEventArgs = "ConversationalAgentSessionInterruptedEventArgs";

    static PyObject* _new_ConversationalAgentSessionInterruptedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConversationalAgentSessionInterruptedEventArgs);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSessionInterruptedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ConversationalAgentSessionInterruptedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSessionInterruptedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSessionInterruptedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSessionInterruptedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSessionInterruptedEventArgs[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSessionInterruptedEventArgs },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSessionInterruptedEventArgs },
        { Py_tp_methods, _methods_ConversationalAgentSessionInterruptedEventArgs },
        { Py_tp_getset, _getset_ConversationalAgentSessionInterruptedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConversationalAgentSessionInterruptedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSessionInterruptedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSessionInterruptedEventArgs
    };

    // ----- ConversationalAgentSignal class --------------------
    constexpr const char* const _type_name_ConversationalAgentSignal = "ConversationalAgentSignal";

    static PyObject* _new_ConversationalAgentSignal(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConversationalAgentSignal);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSignal(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConversationalAgentSignal_get_SignalStart(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalStart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalStart(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.SignalStart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalName(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalName(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SignalName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.SignalId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalEnd(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalEnd());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalEnd(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.SignalEnd(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_SignalContext(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_SignalContext(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);

            self->obj.SignalContext(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_IsSignalVerificationRequired(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSignalVerificationRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConversationalAgentSignal_put_IsSignalVerificationRequired(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsSignalVerificationRequired(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConversationalAgentSignal_get_DetectorId(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConversationalAgentSignal_get_DetectorKind(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetectorKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConversationalAgentSignal(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSignal[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSignal), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSignal[] = {
        { "signal_start", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalStart), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalStart), nullptr, nullptr },
        { "signal_name", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalName), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalName), nullptr, nullptr },
        { "signal_id", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalId), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalId), nullptr, nullptr },
        { "signal_end", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalEnd), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalEnd), nullptr, nullptr },
        { "signal_context", reinterpret_cast<getter>(ConversationalAgentSignal_get_SignalContext), reinterpret_cast<setter>(ConversationalAgentSignal_put_SignalContext), nullptr, nullptr },
        { "is_signal_verification_required", reinterpret_cast<getter>(ConversationalAgentSignal_get_IsSignalVerificationRequired), reinterpret_cast<setter>(ConversationalAgentSignal_put_IsSignalVerificationRequired), nullptr, nullptr },
        { "detector_id", reinterpret_cast<getter>(ConversationalAgentSignal_get_DetectorId), nullptr, nullptr, nullptr },
        { "detector_kind", reinterpret_cast<getter>(ConversationalAgentSignal_get_DetectorKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSignal[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSignal },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSignal },
        { Py_tp_methods, _methods_ConversationalAgentSignal },
        { Py_tp_getset, _getset_ConversationalAgentSignal },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConversationalAgentSignal =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSignal",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSignal
    };

    // ----- ConversationalAgentSignalDetectedEventArgs class --------------------
    constexpr const char* const _type_name_ConversationalAgentSignalDetectedEventArgs = "ConversationalAgentSignalDetectedEventArgs";

    static PyObject* _new_ConversationalAgentSignalDetectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConversationalAgentSignalDetectedEventArgs);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSignalDetectedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_ConversationalAgentSignalDetectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSignalDetectedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSignalDetectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSignalDetectedEventArgs[] = {
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSignalDetectedEventArgs[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSignalDetectedEventArgs },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSignalDetectedEventArgs },
        { Py_tp_methods, _methods_ConversationalAgentSignalDetectedEventArgs },
        { Py_tp_getset, _getset_ConversationalAgentSignalDetectedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConversationalAgentSignalDetectedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSignalDetectedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSignalDetectedEventArgs
    };

    // ----- ConversationalAgentSystemStateChangedEventArgs class --------------------
    constexpr const char* const _type_name_ConversationalAgentSystemStateChangedEventArgs = "ConversationalAgentSystemStateChangedEventArgs";

    static PyObject* _new_ConversationalAgentSystemStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConversationalAgentSystemStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_ConversationalAgentSystemStateChangedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConversationalAgentSystemStateChangedEventArgs_get_SystemStateChangeType(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemStateChangeType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConversationalAgentSystemStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConversationalAgentSystemStateChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ConversationalAgentSystemStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConversationalAgentSystemStateChangedEventArgs[] = {
        { "system_state_change_type", reinterpret_cast<getter>(ConversationalAgentSystemStateChangedEventArgs_get_SystemStateChangeType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConversationalAgentSystemStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_ConversationalAgentSystemStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_ConversationalAgentSystemStateChangedEventArgs },
        { Py_tp_methods, _methods_ConversationalAgentSystemStateChangedEventArgs },
        { Py_tp_getset, _getset_ConversationalAgentSystemStateChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConversationalAgentSystemStateChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.ConversationalAgentSystemStateChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConversationalAgentSystemStateChangedEventArgs
    };

    // ----- DetectionConfigurationAvailabilityChangedEventArgs class --------------------
    constexpr const char* const _type_name_DetectionConfigurationAvailabilityChangedEventArgs = "DetectionConfigurationAvailabilityChangedEventArgs";

    static PyObject* _new_DetectionConfigurationAvailabilityChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DetectionConfigurationAvailabilityChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_DetectionConfigurationAvailabilityChangedEventArgs(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DetectionConfigurationAvailabilityChangedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DetectionConfigurationAvailabilityChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DetectionConfigurationAvailabilityChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DetectionConfigurationAvailabilityChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DetectionConfigurationAvailabilityChangedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(DetectionConfigurationAvailabilityChangedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DetectionConfigurationAvailabilityChangedEventArgs[] = 
    {
        { Py_tp_new, _new_DetectionConfigurationAvailabilityChangedEventArgs },
        { Py_tp_dealloc, _dealloc_DetectionConfigurationAvailabilityChangedEventArgs },
        { Py_tp_methods, _methods_DetectionConfigurationAvailabilityChangedEventArgs },
        { Py_tp_getset, _getset_DetectionConfigurationAvailabilityChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DetectionConfigurationAvailabilityChangedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.DetectionConfigurationAvailabilityChangedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DetectionConfigurationAvailabilityChangedEventArgs
    };

    // ----- DetectionConfigurationAvailabilityInfo class --------------------
    constexpr const char* const _type_name_DetectionConfigurationAvailabilityInfo = "DetectionConfigurationAvailabilityInfo";

    static PyObject* _new_DetectionConfigurationAvailabilityInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DetectionConfigurationAvailabilityInfo);
        return nullptr;
    }

    static void _dealloc_DetectionConfigurationAvailabilityInfo(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_HasLockScreenPermission(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasLockScreenPermission());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_HasPermission(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasPermission());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_HasSystemResourceAccess(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasSystemResourceAccess());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_IsEnabled(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DetectionConfigurationAvailabilityInfo_get_UnavailableSystemResources(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UnavailableSystemResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DetectionConfigurationAvailabilityInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DetectionConfigurationAvailabilityInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DetectionConfigurationAvailabilityInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DetectionConfigurationAvailabilityInfo[] = {
        { "has_lock_screen_permission", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_HasLockScreenPermission), nullptr, nullptr, nullptr },
        { "has_permission", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_HasPermission), nullptr, nullptr, nullptr },
        { "has_system_resource_access", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_HasSystemResourceAccess), nullptr, nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_IsEnabled), nullptr, nullptr, nullptr },
        { "unavailable_system_resources", reinterpret_cast<getter>(DetectionConfigurationAvailabilityInfo_get_UnavailableSystemResources), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DetectionConfigurationAvailabilityInfo[] = 
    {
        { Py_tp_new, _new_DetectionConfigurationAvailabilityInfo },
        { Py_tp_dealloc, _dealloc_DetectionConfigurationAvailabilityInfo },
        { Py_tp_methods, _methods_DetectionConfigurationAvailabilityInfo },
        { Py_tp_getset, _getset_DetectionConfigurationAvailabilityInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DetectionConfigurationAvailabilityInfo =
    {
        "_winsdk_Windows_ApplicationModel_ConversationalAgent.DetectionConfigurationAvailabilityInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DetectionConfigurationAvailabilityInfo
    };

    // ----- Windows.ApplicationModel.ConversationalAgent Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfiguration>::python_type = py::register_python_type(module, _type_name_ActivationSignalDetectionConfiguration, &_type_spec_ActivationSignalDetectionConfiguration, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetectionConfigurationCreationResult>::python_type = py::register_python_type(module, _type_name_ActivationSignalDetectionConfigurationCreationResult, &_type_spec_ActivationSignalDetectionConfigurationCreationResult, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ActivationSignalDetector>::python_type = py::register_python_type(module, _type_name_ActivationSignalDetector, &_type_spec_ActivationSignalDetector, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentDetectorManager>::python_type = py::register_python_type(module, _type_name_ConversationalAgentDetectorManager, &_type_spec_ConversationalAgentDetectorManager, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSession>::python_type = py::register_python_type(module, _type_name_ConversationalAgentSession, &_type_spec_ConversationalAgentSession, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSessionInterruptedEventArgs>::python_type = py::register_python_type(module, _type_name_ConversationalAgentSessionInterruptedEventArgs, &_type_spec_ConversationalAgentSessionInterruptedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignal>::python_type = py::register_python_type(module, _type_name_ConversationalAgentSignal, &_type_spec_ConversationalAgentSignal, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSignalDetectedEventArgs>::python_type = py::register_python_type(module, _type_name_ConversationalAgentSignalDetectedEventArgs, &_type_spec_ConversationalAgentSignalDetectedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::ConversationalAgentSystemStateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_ConversationalAgentSystemStateChangedEventArgs, &_type_spec_ConversationalAgentSystemStateChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityChangedEventArgs>::python_type = py::register_python_type(module, _type_name_DetectionConfigurationAvailabilityChangedEventArgs, &_type_spec_DetectionConfigurationAvailabilityChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::ApplicationModel::ConversationalAgent::DetectionConfigurationAvailabilityInfo>::python_type = py::register_python_type(module, _type_name_DetectionConfigurationAvailabilityInfo, &_type_spec_DetectionConfigurationAvailabilityInfo, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.ApplicationModel.ConversationalAgent");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_ConversationalAgent",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::ApplicationModel::ConversationalAgent

PyMODINIT_FUNC
PyInit__winsdk_Windows_ApplicationModel_ConversationalAgent (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::ApplicationModel::ConversationalAgent::module_def);
}
