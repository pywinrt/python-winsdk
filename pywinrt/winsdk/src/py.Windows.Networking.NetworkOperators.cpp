// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.5

#include "pybase.h"
#include "py.Windows.Networking.NetworkOperators.h"


PyObject* py::converter<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>::convert(winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress py::converter<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::Networking::NetworkOperators::ProfileUsage>::convert(winrt::Windows::Networking::NetworkOperators::ProfileUsage instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::Networking::NetworkOperators::ProfileUsage>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::Networking::NetworkOperators::ProfileUsage py::converter<winrt::Windows::Networking::NetworkOperators::ProfileUsage>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::Networking::NetworkOperators::ProfileUsage>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::NetworkOperators::ProfileUsage>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::Networking::NetworkOperators::ProfileUsage");
    throw python_exception();
}

namespace py::cpp::Windows::Networking::NetworkOperators
{
    struct module_state
    {
        PyObject* type_DataClasses;
        PyObject* type_ESimAuthenticationPreference;
        PyObject* type_ESimDiscoverResultKind;
        PyObject* type_ESimOperationStatus;
        PyObject* type_ESimProfileClass;
        PyObject* type_ESimProfileMetadataState;
        PyObject* type_ESimProfileState;
        PyObject* type_ESimState;
        PyObject* type_ESimWatcherStatus;
        PyObject* type_HotspotAuthenticationResponseCode;
        PyObject* type_MobileBroadbandAccountWatcherStatus;
        PyObject* type_MobileBroadbandDeviceType;
        PyObject* type_MobileBroadbandModemStatus;
        PyObject* type_MobileBroadbandPinFormat;
        PyObject* type_MobileBroadbandPinLockState;
        PyObject* type_MobileBroadbandPinType;
        PyObject* type_MobileBroadbandRadioState;
        PyObject* type_MobileBroadbandSlotState;
        PyObject* type_MobileBroadbandUiccAppOperationStatus;
        PyObject* type_NetworkDeviceStatus;
        PyObject* type_NetworkOperatorDataUsageNotificationKind;
        PyObject* type_NetworkOperatorEventMessageType;
        PyObject* type_NetworkRegistrationState;
        PyObject* type_ProfileMediaType;
        PyObject* type_TetheringCapability;
        PyObject* type_TetheringOperationStatus;
        PyObject* type_TetheringOperationalState;
        PyObject* type_TetheringWiFiBand;
        PyObject* type_UiccAccessCondition;
        PyObject* type_UiccAppKind;
        PyObject* type_UiccAppRecordKind;
        PyObject* type_UssdResultCode;
        PyTypeObject* type_ESim;
        PyTypeObject* type_ESimAddedEventArgs;
        PyTypeObject* type_ESimDiscoverEvent;
        PyTypeObject* type_ESimDiscoverResult;
        PyTypeObject* type_ESimDownloadProfileMetadataResult;
        PyTypeObject* type_ESimManager;
        PyTypeObject* type_ESimOperationResult;
        PyTypeObject* type_ESimPolicy;
        PyTypeObject* type_ESimProfile;
        PyTypeObject* type_ESimProfileMetadata;
        PyTypeObject* type_ESimProfilePolicy;
        PyTypeObject* type_ESimRemovedEventArgs;
        PyTypeObject* type_ESimServiceInfo;
        PyTypeObject* type_ESimUpdatedEventArgs;
        PyTypeObject* type_ESimWatcher;
        PyTypeObject* type_HotspotAuthenticationContext;
        PyTypeObject* type_HotspotAuthenticationEventDetails;
        PyTypeObject* type_HotspotCredentialsAuthenticationResult;
        PyTypeObject* type_KnownCSimFilePaths;
        PyTypeObject* type_KnownRuimFilePaths;
        PyTypeObject* type_KnownSimFilePaths;
        PyTypeObject* type_KnownUSimFilePaths;
        PyTypeObject* type_MobileBroadbandAccount;
        PyTypeObject* type_MobileBroadbandAccountEventArgs;
        PyTypeObject* type_MobileBroadbandAccountUpdatedEventArgs;
        PyTypeObject* type_MobileBroadbandAccountWatcher;
        PyTypeObject* type_MobileBroadbandAntennaSar;
        PyTypeObject* type_MobileBroadbandCellCdma;
        PyTypeObject* type_MobileBroadbandCellGsm;
        PyTypeObject* type_MobileBroadbandCellLte;
        PyTypeObject* type_MobileBroadbandCellNR;
        PyTypeObject* type_MobileBroadbandCellTdscdma;
        PyTypeObject* type_MobileBroadbandCellUmts;
        PyTypeObject* type_MobileBroadbandCellsInfo;
        PyTypeObject* type_MobileBroadbandCurrentSlotIndexChangedEventArgs;
        PyTypeObject* type_MobileBroadbandDeviceInformation;
        PyTypeObject* type_MobileBroadbandDeviceService;
        PyTypeObject* type_MobileBroadbandDeviceServiceCommandResult;
        PyTypeObject* type_MobileBroadbandDeviceServiceCommandSession;
        PyTypeObject* type_MobileBroadbandDeviceServiceDataReceivedEventArgs;
        PyTypeObject* type_MobileBroadbandDeviceServiceDataSession;
        PyTypeObject* type_MobileBroadbandDeviceServiceInformation;
        PyTypeObject* type_MobileBroadbandDeviceServiceTriggerDetails;
        PyTypeObject* type_MobileBroadbandModem;
        PyTypeObject* type_MobileBroadbandModemConfiguration;
        PyTypeObject* type_MobileBroadbandModemIsolation;
        PyTypeObject* type_MobileBroadbandNetwork;
        PyTypeObject* type_MobileBroadbandNetworkRegistrationStateChange;
        PyTypeObject* type_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails;
        PyTypeObject* type_MobileBroadbandPco;
        PyTypeObject* type_MobileBroadbandPcoDataChangeTriggerDetails;
        PyTypeObject* type_MobileBroadbandPin;
        PyTypeObject* type_MobileBroadbandPinLockStateChange;
        PyTypeObject* type_MobileBroadbandPinLockStateChangeTriggerDetails;
        PyTypeObject* type_MobileBroadbandPinManager;
        PyTypeObject* type_MobileBroadbandPinOperationResult;
        PyTypeObject* type_MobileBroadbandRadioStateChange;
        PyTypeObject* type_MobileBroadbandRadioStateChangeTriggerDetails;
        PyTypeObject* type_MobileBroadbandSarManager;
        PyTypeObject* type_MobileBroadbandSlotInfo;
        PyTypeObject* type_MobileBroadbandSlotInfoChangedEventArgs;
        PyTypeObject* type_MobileBroadbandSlotManager;
        PyTypeObject* type_MobileBroadbandTransmissionStateChangedEventArgs;
        PyTypeObject* type_MobileBroadbandUicc;
        PyTypeObject* type_MobileBroadbandUiccApp;
        PyTypeObject* type_MobileBroadbandUiccAppReadRecordResult;
        PyTypeObject* type_MobileBroadbandUiccAppRecordDetailsResult;
        PyTypeObject* type_MobileBroadbandUiccAppsResult;
        PyTypeObject* type_NetworkOperatorDataUsageTriggerDetails;
        PyTypeObject* type_NetworkOperatorTetheringAccessPointConfiguration;
        PyTypeObject* type_NetworkOperatorTetheringClient;
        PyTypeObject* type_NetworkOperatorTetheringManager;
        PyTypeObject* type_NetworkOperatorTetheringOperationResult;
        PyTypeObject* type_ProvisionFromXmlDocumentResults;
        PyTypeObject* type_ProvisionedProfile;
        PyTypeObject* type_ProvisioningAgent;
        PyTypeObject* type_TetheringEntitlementCheckTriggerDetails;
        PyTypeObject* type_UssdMessage;
        PyTypeObject* type_UssdReply;
        PyTypeObject* type_UssdSession;
        PyTypeObject* type_ESimProfileInstallProgress;
        PyTypeObject* type_ProfileUsage;
    };

    static PyObject* register_DataClasses(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_DataClasses)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_DataClasses = type;
        Py_INCREF(state->type_DataClasses);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimAuthenticationPreference(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimAuthenticationPreference)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimAuthenticationPreference = type;
        Py_INCREF(state->type_ESimAuthenticationPreference);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimDiscoverResultKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimDiscoverResultKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimDiscoverResultKind = type;
        Py_INCREF(state->type_ESimDiscoverResultKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimOperationStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimOperationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimOperationStatus = type;
        Py_INCREF(state->type_ESimOperationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimProfileClass(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimProfileClass)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimProfileClass = type;
        Py_INCREF(state->type_ESimProfileClass);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimProfileMetadataState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimProfileMetadataState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimProfileMetadataState = type;
        Py_INCREF(state->type_ESimProfileMetadataState);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimProfileState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimProfileState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimProfileState = type;
        Py_INCREF(state->type_ESimProfileState);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimState = type;
        Py_INCREF(state->type_ESimState);


        Py_RETURN_NONE;
    }

    static PyObject* register_ESimWatcherStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ESimWatcherStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ESimWatcherStatus = type;
        Py_INCREF(state->type_ESimWatcherStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_HotspotAuthenticationResponseCode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_HotspotAuthenticationResponseCode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_HotspotAuthenticationResponseCode = type;
        Py_INCREF(state->type_HotspotAuthenticationResponseCode);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandAccountWatcherStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandAccountWatcherStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandAccountWatcherStatus = type;
        Py_INCREF(state->type_MobileBroadbandAccountWatcherStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandDeviceType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandDeviceType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandDeviceType = type;
        Py_INCREF(state->type_MobileBroadbandDeviceType);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandModemStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandModemStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandModemStatus = type;
        Py_INCREF(state->type_MobileBroadbandModemStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandPinFormat(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandPinFormat)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandPinFormat = type;
        Py_INCREF(state->type_MobileBroadbandPinFormat);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandPinLockState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandPinLockState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandPinLockState = type;
        Py_INCREF(state->type_MobileBroadbandPinLockState);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandPinType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandPinType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandPinType = type;
        Py_INCREF(state->type_MobileBroadbandPinType);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandRadioState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandRadioState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandRadioState = type;
        Py_INCREF(state->type_MobileBroadbandRadioState);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandSlotState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandSlotState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandSlotState = type;
        Py_INCREF(state->type_MobileBroadbandSlotState);


        Py_RETURN_NONE;
    }

    static PyObject* register_MobileBroadbandUiccAppOperationStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MobileBroadbandUiccAppOperationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MobileBroadbandUiccAppOperationStatus = type;
        Py_INCREF(state->type_MobileBroadbandUiccAppOperationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_NetworkDeviceStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_NetworkDeviceStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NetworkDeviceStatus = type;
        Py_INCREF(state->type_NetworkDeviceStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_NetworkOperatorDataUsageNotificationKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_NetworkOperatorDataUsageNotificationKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NetworkOperatorDataUsageNotificationKind = type;
        Py_INCREF(state->type_NetworkOperatorDataUsageNotificationKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_NetworkOperatorEventMessageType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_NetworkOperatorEventMessageType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NetworkOperatorEventMessageType = type;
        Py_INCREF(state->type_NetworkOperatorEventMessageType);


        Py_RETURN_NONE;
    }

    static PyObject* register_NetworkRegistrationState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_NetworkRegistrationState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_NetworkRegistrationState = type;
        Py_INCREF(state->type_NetworkRegistrationState);


        Py_RETURN_NONE;
    }

    static PyObject* register_ProfileMediaType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ProfileMediaType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ProfileMediaType = type;
        Py_INCREF(state->type_ProfileMediaType);


        Py_RETURN_NONE;
    }

    static PyObject* register_TetheringCapability(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TetheringCapability)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TetheringCapability = type;
        Py_INCREF(state->type_TetheringCapability);


        Py_RETURN_NONE;
    }

    static PyObject* register_TetheringOperationStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TetheringOperationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TetheringOperationStatus = type;
        Py_INCREF(state->type_TetheringOperationStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_TetheringOperationalState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TetheringOperationalState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TetheringOperationalState = type;
        Py_INCREF(state->type_TetheringOperationalState);


        Py_RETURN_NONE;
    }

    static PyObject* register_TetheringWiFiBand(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_TetheringWiFiBand)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_TetheringWiFiBand = type;
        Py_INCREF(state->type_TetheringWiFiBand);


        Py_RETURN_NONE;
    }

    static PyObject* register_UiccAccessCondition(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UiccAccessCondition)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UiccAccessCondition = type;
        Py_INCREF(state->type_UiccAccessCondition);


        Py_RETURN_NONE;
    }

    static PyObject* register_UiccAppKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UiccAppKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UiccAppKind = type;
        Py_INCREF(state->type_UiccAppKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_UiccAppRecordKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UiccAppRecordKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UiccAppRecordKind = type;
        Py_INCREF(state->type_UiccAppRecordKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_UssdResultCode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UssdResultCode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UssdResultCode = type;
        Py_INCREF(state->type_UssdResultCode);


        Py_RETURN_NONE;
    }

    // ----- ESim class --------------------
    constexpr const char* const type_name_ESim = "ESim";

    static PyObject* _new_ESim(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESim);
        return nullptr;
    }

    static void _dealloc_ESim(py::wrapper::Windows::Networking::NetworkOperators::ESim* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESim_DeleteProfileAsync(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteProfileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_Discover(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Discover());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.Discover(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_DiscoverAsync(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DiscoverAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.DiscoverAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_DownloadProfileMetadataAsync(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DownloadProfileMetadataAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_GetProfiles(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetProfiles());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_ResetAsync(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ResetAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESim_get_AvailableMemoryInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AvailableMemoryInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_Eid(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Eid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_FirmwareVersion(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FirmwareVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_MobileBroadbandModemDeviceId(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MobileBroadbandModemDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_Policy(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Policy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_get_State(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_add_ProfileChanged(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESim, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ProfileChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESim_remove_ProfileChanged(py::wrapper::Windows::Networking::NetworkOperators::ESim* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ProfileChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ESim(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESim>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESim[] = {
        { "delete_profile_async", reinterpret_cast<PyCFunction>(ESim_DeleteProfileAsync), METH_VARARGS, nullptr },
        { "discover", reinterpret_cast<PyCFunction>(ESim_Discover), METH_VARARGS, nullptr },
        { "discover_async", reinterpret_cast<PyCFunction>(ESim_DiscoverAsync), METH_VARARGS, nullptr },
        { "download_profile_metadata_async", reinterpret_cast<PyCFunction>(ESim_DownloadProfileMetadataAsync), METH_VARARGS, nullptr },
        { "get_profiles", reinterpret_cast<PyCFunction>(ESim_GetProfiles), METH_VARARGS, nullptr },
        { "reset_async", reinterpret_cast<PyCFunction>(ESim_ResetAsync), METH_VARARGS, nullptr },
        { "add_profile_changed", reinterpret_cast<PyCFunction>(ESim_add_ProfileChanged), METH_O, nullptr },
        { "remove_profile_changed", reinterpret_cast<PyCFunction>(ESim_remove_ProfileChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESim), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESim[] = {
        { "available_memory_in_bytes", reinterpret_cast<getter>(ESim_get_AvailableMemoryInBytes), nullptr, nullptr, nullptr },
        { "eid", reinterpret_cast<getter>(ESim_get_Eid), nullptr, nullptr, nullptr },
        { "firmware_version", reinterpret_cast<getter>(ESim_get_FirmwareVersion), nullptr, nullptr, nullptr },
        { "mobile_broadband_modem_device_id", reinterpret_cast<getter>(ESim_get_MobileBroadbandModemDeviceId), nullptr, nullptr, nullptr },
        { "policy", reinterpret_cast<getter>(ESim_get_Policy), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(ESim_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESim[] = 
    {
        { Py_tp_new, _new_ESim },
        { Py_tp_dealloc, _dealloc_ESim },
        { Py_tp_methods, _methods_ESim },
        { Py_tp_getset, _getset_ESim },
        { },
    };

    static PyType_Spec type_spec_ESim =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESim",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESim),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESim
    };

    // ----- ESimAddedEventArgs class --------------------
    constexpr const char* const type_name_ESimAddedEventArgs = "ESimAddedEventArgs";

    static PyObject* _new_ESimAddedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimAddedEventArgs);
        return nullptr;
    }

    static void _dealloc_ESimAddedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::ESimAddedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimAddedEventArgs_get_ESim(py::wrapper::Windows::Networking::NetworkOperators::ESimAddedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ESim());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ESimAddedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimAddedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimAddedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimAddedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimAddedEventArgs[] = {
        { "e_sim", reinterpret_cast<getter>(ESimAddedEventArgs_get_ESim), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimAddedEventArgs[] = 
    {
        { Py_tp_new, _new_ESimAddedEventArgs },
        { Py_tp_dealloc, _dealloc_ESimAddedEventArgs },
        { Py_tp_methods, _methods_ESimAddedEventArgs },
        { Py_tp_getset, _getset_ESimAddedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ESimAddedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimAddedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimAddedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimAddedEventArgs
    };

    // ----- ESimDiscoverEvent class --------------------
    constexpr const char* const type_name_ESimDiscoverEvent = "ESimDiscoverEvent";

    static PyObject* _new_ESimDiscoverEvent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimDiscoverEvent);
        return nullptr;
    }

    static void _dealloc_ESimDiscoverEvent(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverEvent* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimDiscoverEvent_get_MatchingId(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverEvent* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MatchingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDiscoverEvent_get_RspServerAddress(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverEvent* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RspServerAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ESimDiscoverEvent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimDiscoverEvent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimDiscoverEvent[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimDiscoverEvent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimDiscoverEvent[] = {
        { "matching_id", reinterpret_cast<getter>(ESimDiscoverEvent_get_MatchingId), nullptr, nullptr, nullptr },
        { "rsp_server_address", reinterpret_cast<getter>(ESimDiscoverEvent_get_RspServerAddress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimDiscoverEvent[] = 
    {
        { Py_tp_new, _new_ESimDiscoverEvent },
        { Py_tp_dealloc, _dealloc_ESimDiscoverEvent },
        { Py_tp_methods, _methods_ESimDiscoverEvent },
        { Py_tp_getset, _getset_ESimDiscoverEvent },
        { },
    };

    static PyType_Spec type_spec_ESimDiscoverEvent =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimDiscoverEvent",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverEvent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimDiscoverEvent
    };

    // ----- ESimDiscoverResult class --------------------
    constexpr const char* const type_name_ESimDiscoverResult = "ESimDiscoverResult";

    static PyObject* _new_ESimDiscoverResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimDiscoverResult);
        return nullptr;
    }

    static void _dealloc_ESimDiscoverResult(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimDiscoverResult_get_Events(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Events());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDiscoverResult_get_Kind(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDiscoverResult_get_ProfileMetadata(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProfileMetadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDiscoverResult_get_Result(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ESimDiscoverResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimDiscoverResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimDiscoverResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimDiscoverResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimDiscoverResult[] = {
        { "events", reinterpret_cast<getter>(ESimDiscoverResult_get_Events), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ESimDiscoverResult_get_Kind), nullptr, nullptr, nullptr },
        { "profile_metadata", reinterpret_cast<getter>(ESimDiscoverResult_get_ProfileMetadata), nullptr, nullptr, nullptr },
        { "result", reinterpret_cast<getter>(ESimDiscoverResult_get_Result), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimDiscoverResult[] = 
    {
        { Py_tp_new, _new_ESimDiscoverResult },
        { Py_tp_dealloc, _dealloc_ESimDiscoverResult },
        { Py_tp_methods, _methods_ESimDiscoverResult },
        { Py_tp_getset, _getset_ESimDiscoverResult },
        { },
    };

    static PyType_Spec type_spec_ESimDiscoverResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimDiscoverResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimDiscoverResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimDiscoverResult
    };

    // ----- ESimDownloadProfileMetadataResult class --------------------
    constexpr const char* const type_name_ESimDownloadProfileMetadataResult = "ESimDownloadProfileMetadataResult";

    static PyObject* _new_ESimDownloadProfileMetadataResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimDownloadProfileMetadataResult);
        return nullptr;
    }

    static void _dealloc_ESimDownloadProfileMetadataResult(py::wrapper::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimDownloadProfileMetadataResult_get_ProfileMetadata(py::wrapper::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProfileMetadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimDownloadProfileMetadataResult_get_Result(py::wrapper::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ESimDownloadProfileMetadataResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimDownloadProfileMetadataResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimDownloadProfileMetadataResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimDownloadProfileMetadataResult[] = {
        { "profile_metadata", reinterpret_cast<getter>(ESimDownloadProfileMetadataResult_get_ProfileMetadata), nullptr, nullptr, nullptr },
        { "result", reinterpret_cast<getter>(ESimDownloadProfileMetadataResult_get_Result), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimDownloadProfileMetadataResult[] = 
    {
        { Py_tp_new, _new_ESimDownloadProfileMetadataResult },
        { Py_tp_dealloc, _dealloc_ESimDownloadProfileMetadataResult },
        { Py_tp_methods, _methods_ESimDownloadProfileMetadataResult },
        { Py_tp_getset, _getset_ESimDownloadProfileMetadataResult },
        { },
    };

    static PyType_Spec type_spec_ESimDownloadProfileMetadataResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimDownloadProfileMetadataResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimDownloadProfileMetadataResult
    };

    // ----- ESimManager class --------------------
    constexpr const char* const type_name_ESimManager = "ESimManager";

    static PyObject* _new_ESimManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimManager);
        return nullptr;
    }

    static PyObject* ESimManager_TryCreateESimWatcher(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::ESimManager::TryCreateESimWatcher());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimManager_get_ServiceInfo(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::ESimManager::ServiceInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimManager_add_ServiceInfoChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::EventHandler<winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(winrt::Windows::Networking::NetworkOperators::ESimManager::ServiceInfoChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimManager_remove_ServiceInfoChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Networking::NetworkOperators::ESimManager::ServiceInfoChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimManager[] = {
        { "try_create_e_sim_watcher", reinterpret_cast<PyCFunction>(ESimManager_TryCreateESimWatcher), METH_VARARGS | METH_STATIC, nullptr },
        { "get_service_info", reinterpret_cast<PyCFunction>(ESimManager_get_ServiceInfo), METH_NOARGS | METH_STATIC, nullptr },
        { "add_service_info_changed", reinterpret_cast<PyCFunction>(ESimManager_add_ServiceInfoChanged), METH_O | METH_STATIC, nullptr },
        { "remove_service_info_changed", reinterpret_cast<PyCFunction>(ESimManager_remove_ServiceInfoChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ESimManager[] = 
    {
        { Py_tp_new, _new_ESimManager },
        { Py_tp_methods, _methods_ESimManager },
        { Py_tp_getset, _getset_ESimManager },
        { },
    };

    static PyType_Spec type_spec_ESimManager =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimManager
    };

    // ----- ESimOperationResult class --------------------
    constexpr const char* const type_name_ESimOperationResult = "ESimOperationResult";

    static PyObject* _new_ESimOperationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimOperationResult);
        return nullptr;
    }

    static void _dealloc_ESimOperationResult(py::wrapper::Windows::Networking::NetworkOperators::ESimOperationResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimOperationResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::ESimOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ESimOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimOperationResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimOperationResult[] = {
        { "status", reinterpret_cast<getter>(ESimOperationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimOperationResult[] = 
    {
        { Py_tp_new, _new_ESimOperationResult },
        { Py_tp_dealloc, _dealloc_ESimOperationResult },
        { Py_tp_methods, _methods_ESimOperationResult },
        { Py_tp_getset, _getset_ESimOperationResult },
        { },
    };

    static PyType_Spec type_spec_ESimOperationResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimOperationResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimOperationResult
    };

    // ----- ESimPolicy class --------------------
    constexpr const char* const type_name_ESimPolicy = "ESimPolicy";

    static PyObject* _new_ESimPolicy(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimPolicy);
        return nullptr;
    }

    static void _dealloc_ESimPolicy(py::wrapper::Windows::Networking::NetworkOperators::ESimPolicy* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimPolicy_get_ShouldEnableManagingUi(py::wrapper::Windows::Networking::NetworkOperators::ESimPolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShouldEnableManagingUi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ESimPolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimPolicy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimPolicy[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimPolicy), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimPolicy[] = {
        { "should_enable_managing_ui", reinterpret_cast<getter>(ESimPolicy_get_ShouldEnableManagingUi), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimPolicy[] = 
    {
        { Py_tp_new, _new_ESimPolicy },
        { Py_tp_dealloc, _dealloc_ESimPolicy },
        { Py_tp_methods, _methods_ESimPolicy },
        { Py_tp_getset, _getset_ESimPolicy },
        { },
    };

    static PyType_Spec type_spec_ESimPolicy =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimPolicy",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimPolicy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimPolicy
    };

    // ----- ESimProfile class --------------------
    constexpr const char* const type_name_ESimProfile = "ESimProfile";

    static PyObject* _new_ESimProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimProfile);
        return nullptr;
    }

    static void _dealloc_ESimProfile(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimProfile_DisableAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DisableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfile_EnableAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.EnableAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfile_SetNicknameAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.SetNicknameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_Class(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Class());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_Id(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_Nickname(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Nickname());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_Policy(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Policy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_ProviderIcon(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderIcon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_ProviderName(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfile_get_State(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ESimProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimProfile[] = {
        { "disable_async", reinterpret_cast<PyCFunction>(ESimProfile_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(ESimProfile_EnableAsync), METH_VARARGS, nullptr },
        { "set_nickname_async", reinterpret_cast<PyCFunction>(ESimProfile_SetNicknameAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimProfile[] = {
        { "class_", reinterpret_cast<getter>(ESimProfile_get_Class), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(ESimProfile_get_Id), nullptr, nullptr, nullptr },
        { "nickname", reinterpret_cast<getter>(ESimProfile_get_Nickname), nullptr, nullptr, nullptr },
        { "policy", reinterpret_cast<getter>(ESimProfile_get_Policy), nullptr, nullptr, nullptr },
        { "provider_icon", reinterpret_cast<getter>(ESimProfile_get_ProviderIcon), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(ESimProfile_get_ProviderId), nullptr, nullptr, nullptr },
        { "provider_name", reinterpret_cast<getter>(ESimProfile_get_ProviderName), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(ESimProfile_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimProfile[] = 
    {
        { Py_tp_new, _new_ESimProfile },
        { Py_tp_dealloc, _dealloc_ESimProfile },
        { Py_tp_methods, _methods_ESimProfile },
        { Py_tp_getset, _getset_ESimProfile },
        { },
    };

    static PyType_Spec type_spec_ESimProfile =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimProfile",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimProfile
    };

    // ----- ESimProfileMetadata class --------------------
    constexpr const char* const type_name_ESimProfileMetadata = "ESimProfileMetadata";

    static PyObject* _new_ESimProfileMetadata(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimProfileMetadata);
        return nullptr;
    }

    static void _dealloc_ESimProfileMetadata(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimProfileMetadata_ConfirmInstallAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ConfirmInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ConfirmInstallAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_DenyInstallAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DenyInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_PostponeInstallAsync(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PostponeInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_Id(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_IsConfirmationCodeRequired(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsConfirmationCodeRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_Policy(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Policy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_ProviderIcon(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderIcon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_ProviderName(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_get_State(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_add_StateChanged(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimProfileMetadata, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfileMetadata_remove_StateChanged(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ESimProfileMetadata(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimProfileMetadata>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimProfileMetadata[] = {
        { "confirm_install_async", reinterpret_cast<PyCFunction>(ESimProfileMetadata_ConfirmInstallAsync), METH_VARARGS, nullptr },
        { "deny_install_async", reinterpret_cast<PyCFunction>(ESimProfileMetadata_DenyInstallAsync), METH_VARARGS, nullptr },
        { "postpone_install_async", reinterpret_cast<PyCFunction>(ESimProfileMetadata_PostponeInstallAsync), METH_VARARGS, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(ESimProfileMetadata_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(ESimProfileMetadata_remove_StateChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimProfileMetadata), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimProfileMetadata[] = {
        { "id", reinterpret_cast<getter>(ESimProfileMetadata_get_Id), nullptr, nullptr, nullptr },
        { "is_confirmation_code_required", reinterpret_cast<getter>(ESimProfileMetadata_get_IsConfirmationCodeRequired), nullptr, nullptr, nullptr },
        { "policy", reinterpret_cast<getter>(ESimProfileMetadata_get_Policy), nullptr, nullptr, nullptr },
        { "provider_icon", reinterpret_cast<getter>(ESimProfileMetadata_get_ProviderIcon), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(ESimProfileMetadata_get_ProviderId), nullptr, nullptr, nullptr },
        { "provider_name", reinterpret_cast<getter>(ESimProfileMetadata_get_ProviderName), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(ESimProfileMetadata_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimProfileMetadata[] = 
    {
        { Py_tp_new, _new_ESimProfileMetadata },
        { Py_tp_dealloc, _dealloc_ESimProfileMetadata },
        { Py_tp_methods, _methods_ESimProfileMetadata },
        { Py_tp_getset, _getset_ESimProfileMetadata },
        { },
    };

    static PyType_Spec type_spec_ESimProfileMetadata =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimProfileMetadata",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileMetadata),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimProfileMetadata
    };

    // ----- ESimProfilePolicy class --------------------
    constexpr const char* const type_name_ESimProfilePolicy = "ESimProfilePolicy";

    static PyObject* _new_ESimProfilePolicy(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimProfilePolicy);
        return nullptr;
    }

    static void _dealloc_ESimProfilePolicy(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimProfilePolicy_get_CanDelete(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanDelete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfilePolicy_get_CanDisable(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanDisable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimProfilePolicy_get_IsManagedByEnterprise(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsManagedByEnterprise());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ESimProfilePolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimProfilePolicy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimProfilePolicy[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimProfilePolicy), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimProfilePolicy[] = {
        { "can_delete", reinterpret_cast<getter>(ESimProfilePolicy_get_CanDelete), nullptr, nullptr, nullptr },
        { "can_disable", reinterpret_cast<getter>(ESimProfilePolicy_get_CanDisable), nullptr, nullptr, nullptr },
        { "is_managed_by_enterprise", reinterpret_cast<getter>(ESimProfilePolicy_get_IsManagedByEnterprise), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimProfilePolicy[] = 
    {
        { Py_tp_new, _new_ESimProfilePolicy },
        { Py_tp_dealloc, _dealloc_ESimProfilePolicy },
        { Py_tp_methods, _methods_ESimProfilePolicy },
        { Py_tp_getset, _getset_ESimProfilePolicy },
        { },
    };

    static PyType_Spec type_spec_ESimProfilePolicy =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimProfilePolicy",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimProfilePolicy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimProfilePolicy
    };

    // ----- ESimRemovedEventArgs class --------------------
    constexpr const char* const type_name_ESimRemovedEventArgs = "ESimRemovedEventArgs";

    static PyObject* _new_ESimRemovedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimRemovedEventArgs);
        return nullptr;
    }

    static void _dealloc_ESimRemovedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::ESimRemovedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimRemovedEventArgs_get_ESim(py::wrapper::Windows::Networking::NetworkOperators::ESimRemovedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ESim());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ESimRemovedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimRemovedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimRemovedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimRemovedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimRemovedEventArgs[] = {
        { "e_sim", reinterpret_cast<getter>(ESimRemovedEventArgs_get_ESim), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimRemovedEventArgs[] = 
    {
        { Py_tp_new, _new_ESimRemovedEventArgs },
        { Py_tp_dealloc, _dealloc_ESimRemovedEventArgs },
        { Py_tp_methods, _methods_ESimRemovedEventArgs },
        { Py_tp_getset, _getset_ESimRemovedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ESimRemovedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimRemovedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimRemovedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimRemovedEventArgs
    };

    // ----- ESimServiceInfo class --------------------
    constexpr const char* const type_name_ESimServiceInfo = "ESimServiceInfo";

    static PyObject* _new_ESimServiceInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimServiceInfo);
        return nullptr;
    }

    static void _dealloc_ESimServiceInfo(py::wrapper::Windows::Networking::NetworkOperators::ESimServiceInfo* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimServiceInfo_get_AuthenticationPreference(py::wrapper::Windows::Networking::NetworkOperators::ESimServiceInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthenticationPreference());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimServiceInfo_get_IsESimUiEnabled(py::wrapper::Windows::Networking::NetworkOperators::ESimServiceInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsESimUiEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ESimServiceInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimServiceInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimServiceInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimServiceInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimServiceInfo[] = {
        { "authentication_preference", reinterpret_cast<getter>(ESimServiceInfo_get_AuthenticationPreference), nullptr, nullptr, nullptr },
        { "is_e_sim_ui_enabled", reinterpret_cast<getter>(ESimServiceInfo_get_IsESimUiEnabled), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimServiceInfo[] = 
    {
        { Py_tp_new, _new_ESimServiceInfo },
        { Py_tp_dealloc, _dealloc_ESimServiceInfo },
        { Py_tp_methods, _methods_ESimServiceInfo },
        { Py_tp_getset, _getset_ESimServiceInfo },
        { },
    };

    static PyType_Spec type_spec_ESimServiceInfo =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimServiceInfo",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimServiceInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimServiceInfo
    };

    // ----- ESimUpdatedEventArgs class --------------------
    constexpr const char* const type_name_ESimUpdatedEventArgs = "ESimUpdatedEventArgs";

    static PyObject* _new_ESimUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ESimUpdatedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimUpdatedEventArgs_get_ESim(py::wrapper::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ESim());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ESimUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimUpdatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimUpdatedEventArgs[] = {
        { "e_sim", reinterpret_cast<getter>(ESimUpdatedEventArgs_get_ESim), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimUpdatedEventArgs[] = 
    {
        { Py_tp_new, _new_ESimUpdatedEventArgs },
        { Py_tp_dealloc, _dealloc_ESimUpdatedEventArgs },
        { Py_tp_methods, _methods_ESimUpdatedEventArgs },
        { Py_tp_getset, _getset_ESimUpdatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ESimUpdatedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimUpdatedEventArgs
    };

    // ----- ESimWatcher class --------------------
    constexpr const char* const type_name_ESimWatcher = "ESimWatcher";

    static PyObject* _new_ESimWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ESimWatcher);
        return nullptr;
    }

    static void _dealloc_ESimWatcher(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ESimWatcher_Start(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_Stop(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_get_Status(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_Added(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Networking::NetworkOperators::ESimAddedEventArgs>>(arg);

            return py::convert(self->obj.Added(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_Added(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Added(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_EnumerationCompleted(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_Removed(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Networking::NetworkOperators::ESimRemovedEventArgs>>(arg);

            return py::convert(self->obj.Removed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_Removed(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Removed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_Stopped(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_Stopped(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_add_Updated(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::ESimWatcher, winrt::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs>>(arg);

            return py::convert(self->obj.Updated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ESimWatcher_remove_Updated(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Updated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ESimWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ESimWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ESimWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(ESimWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(ESimWatcher_Stop), METH_VARARGS, nullptr },
        { "add_added", reinterpret_cast<PyCFunction>(ESimWatcher_add_Added), METH_O, nullptr },
        { "remove_added", reinterpret_cast<PyCFunction>(ESimWatcher_remove_Added), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(ESimWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(ESimWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_removed", reinterpret_cast<PyCFunction>(ESimWatcher_add_Removed), METH_O, nullptr },
        { "remove_removed", reinterpret_cast<PyCFunction>(ESimWatcher_remove_Removed), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(ESimWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(ESimWatcher_remove_Stopped), METH_O, nullptr },
        { "add_updated", reinterpret_cast<PyCFunction>(ESimWatcher_add_Updated), METH_O, nullptr },
        { "remove_updated", reinterpret_cast<PyCFunction>(ESimWatcher_remove_Updated), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ESimWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ESimWatcher[] = {
        { "status", reinterpret_cast<getter>(ESimWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimWatcher[] = 
    {
        { Py_tp_new, _new_ESimWatcher },
        { Py_tp_dealloc, _dealloc_ESimWatcher },
        { Py_tp_methods, _methods_ESimWatcher },
        { Py_tp_getset, _getset_ESimWatcher },
        { },
    };

    static PyType_Spec type_spec_ESimWatcher =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimWatcher",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimWatcher
    };

    // ----- HotspotAuthenticationContext class --------------------
    constexpr const char* const type_name_HotspotAuthenticationContext = "HotspotAuthenticationContext";

    static PyObject* _new_HotspotAuthenticationContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HotspotAuthenticationContext);
        return nullptr;
    }

    static void _dealloc_HotspotAuthenticationContext(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HotspotAuthenticationContext_AbortAuthentication(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.AbortAuthentication(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_IssueCredentials(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<bool>(args, 3);

                self->obj.IssueCredentials(param0, param1, param2, param3);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_IssueCredentialsAsync(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<bool>(args, 3);

                return py::convert(self->obj.IssueCredentialsAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_SkipAuthentication(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.SkipAuthentication();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_TriggerAttentionRequired(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                self->obj.TriggerAttentionRequired(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_TryGetAuthenticationContext(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext param1 { nullptr };

                auto return_value = winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext::TryGetAuthenticationContext(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_AuthenticationUrl(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthenticationUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_NetworkAdapter(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_RedirectMessageUrl(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RedirectMessageUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_RedirectMessageXml(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RedirectMessageXml());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotAuthenticationContext_get_WirelessNetworkId(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WirelessNetworkId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HotspotAuthenticationContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HotspotAuthenticationContext[] = {
        { "abort_authentication", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_AbortAuthentication), METH_VARARGS, nullptr },
        { "issue_credentials", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_IssueCredentials), METH_VARARGS, nullptr },
        { "issue_credentials_async", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_IssueCredentialsAsync), METH_VARARGS, nullptr },
        { "skip_authentication", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_SkipAuthentication), METH_VARARGS, nullptr },
        { "trigger_attention_required", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_TriggerAttentionRequired), METH_VARARGS, nullptr },
        { "try_get_authentication_context", reinterpret_cast<PyCFunction>(HotspotAuthenticationContext_TryGetAuthenticationContext), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_HotspotAuthenticationContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HotspotAuthenticationContext[] = {
        { "authentication_url", reinterpret_cast<getter>(HotspotAuthenticationContext_get_AuthenticationUrl), nullptr, nullptr, nullptr },
        { "network_adapter", reinterpret_cast<getter>(HotspotAuthenticationContext_get_NetworkAdapter), nullptr, nullptr, nullptr },
        { "redirect_message_url", reinterpret_cast<getter>(HotspotAuthenticationContext_get_RedirectMessageUrl), nullptr, nullptr, nullptr },
        { "redirect_message_xml", reinterpret_cast<getter>(HotspotAuthenticationContext_get_RedirectMessageXml), nullptr, nullptr, nullptr },
        { "wireless_network_id", reinterpret_cast<getter>(HotspotAuthenticationContext_get_WirelessNetworkId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HotspotAuthenticationContext[] = 
    {
        { Py_tp_new, _new_HotspotAuthenticationContext },
        { Py_tp_dealloc, _dealloc_HotspotAuthenticationContext },
        { Py_tp_methods, _methods_HotspotAuthenticationContext },
        { Py_tp_getset, _getset_HotspotAuthenticationContext },
        { },
    };

    static PyType_Spec type_spec_HotspotAuthenticationContext =
    {
        "_winsdk_Windows_Networking_NetworkOperators.HotspotAuthenticationContext",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HotspotAuthenticationContext
    };

    // ----- HotspotAuthenticationEventDetails class --------------------
    constexpr const char* const type_name_HotspotAuthenticationEventDetails = "HotspotAuthenticationEventDetails";

    static PyObject* _new_HotspotAuthenticationEventDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HotspotAuthenticationEventDetails);
        return nullptr;
    }

    static void _dealloc_HotspotAuthenticationEventDetails(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HotspotAuthenticationEventDetails_get_EventToken(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EventToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HotspotAuthenticationEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HotspotAuthenticationEventDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_HotspotAuthenticationEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HotspotAuthenticationEventDetails[] = {
        { "event_token", reinterpret_cast<getter>(HotspotAuthenticationEventDetails_get_EventToken), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HotspotAuthenticationEventDetails[] = 
    {
        { Py_tp_new, _new_HotspotAuthenticationEventDetails },
        { Py_tp_dealloc, _dealloc_HotspotAuthenticationEventDetails },
        { Py_tp_methods, _methods_HotspotAuthenticationEventDetails },
        { Py_tp_getset, _getset_HotspotAuthenticationEventDetails },
        { },
    };

    static PyType_Spec type_spec_HotspotAuthenticationEventDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.HotspotAuthenticationEventDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HotspotAuthenticationEventDetails
    };

    // ----- HotspotCredentialsAuthenticationResult class --------------------
    constexpr const char* const type_name_HotspotCredentialsAuthenticationResult = "HotspotCredentialsAuthenticationResult";

    static PyObject* _new_HotspotCredentialsAuthenticationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_HotspotCredentialsAuthenticationResult);
        return nullptr;
    }

    static void _dealloc_HotspotCredentialsAuthenticationResult(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* HotspotCredentialsAuthenticationResult_get_AuthenticationReplyXml(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthenticationReplyXml());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotCredentialsAuthenticationResult_get_HasNetworkErrorOccurred(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNetworkErrorOccurred());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotCredentialsAuthenticationResult_get_LogoffUrl(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LogoffUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HotspotCredentialsAuthenticationResult_get_ResponseCode(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HotspotCredentialsAuthenticationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HotspotCredentialsAuthenticationResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_HotspotCredentialsAuthenticationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HotspotCredentialsAuthenticationResult[] = {
        { "authentication_reply_xml", reinterpret_cast<getter>(HotspotCredentialsAuthenticationResult_get_AuthenticationReplyXml), nullptr, nullptr, nullptr },
        { "has_network_error_occurred", reinterpret_cast<getter>(HotspotCredentialsAuthenticationResult_get_HasNetworkErrorOccurred), nullptr, nullptr, nullptr },
        { "logoff_url", reinterpret_cast<getter>(HotspotCredentialsAuthenticationResult_get_LogoffUrl), nullptr, nullptr, nullptr },
        { "response_code", reinterpret_cast<getter>(HotspotCredentialsAuthenticationResult_get_ResponseCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HotspotCredentialsAuthenticationResult[] = 
    {
        { Py_tp_new, _new_HotspotCredentialsAuthenticationResult },
        { Py_tp_dealloc, _dealloc_HotspotCredentialsAuthenticationResult },
        { Py_tp_methods, _methods_HotspotCredentialsAuthenticationResult },
        { Py_tp_getset, _getset_HotspotCredentialsAuthenticationResult },
        { },
    };

    static PyType_Spec type_spec_HotspotCredentialsAuthenticationResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.HotspotCredentialsAuthenticationResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HotspotCredentialsAuthenticationResult
    };

    // ----- KnownCSimFilePaths class --------------------
    constexpr const char* const type_name_KnownCSimFilePaths = "KnownCSimFilePaths";

    static PyObject* _new_KnownCSimFilePaths(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownCSimFilePaths);
        return nullptr;
    }

    static PyObject* KnownCSimFilePaths_get_EFSpn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths::EFSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCSimFilePaths_get_Gid1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths::Gid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownCSimFilePaths_get_Gid2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths::Gid2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownCSimFilePaths[] = {
        { "get_e_f_spn", reinterpret_cast<PyCFunction>(KnownCSimFilePaths_get_EFSpn), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gid1", reinterpret_cast<PyCFunction>(KnownCSimFilePaths_get_Gid1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gid2", reinterpret_cast<PyCFunction>(KnownCSimFilePaths_get_Gid2), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KnownCSimFilePaths[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownCSimFilePaths[] = 
    {
        { Py_tp_new, _new_KnownCSimFilePaths },
        { Py_tp_methods, _methods_KnownCSimFilePaths },
        { Py_tp_getset, _getset_KnownCSimFilePaths },
        { },
    };

    static PyType_Spec type_spec_KnownCSimFilePaths =
    {
        "_winsdk_Windows_Networking_NetworkOperators.KnownCSimFilePaths",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownCSimFilePaths
    };

    // ----- KnownRuimFilePaths class --------------------
    constexpr const char* const type_name_KnownRuimFilePaths = "KnownRuimFilePaths";

    static PyObject* _new_KnownRuimFilePaths(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownRuimFilePaths);
        return nullptr;
    }

    static PyObject* KnownRuimFilePaths_get_EFSpn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths::EFSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRuimFilePaths_get_Gid1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths::Gid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownRuimFilePaths_get_Gid2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths::Gid2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownRuimFilePaths[] = {
        { "get_e_f_spn", reinterpret_cast<PyCFunction>(KnownRuimFilePaths_get_EFSpn), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gid1", reinterpret_cast<PyCFunction>(KnownRuimFilePaths_get_Gid1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gid2", reinterpret_cast<PyCFunction>(KnownRuimFilePaths_get_Gid2), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KnownRuimFilePaths[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownRuimFilePaths[] = 
    {
        { Py_tp_new, _new_KnownRuimFilePaths },
        { Py_tp_methods, _methods_KnownRuimFilePaths },
        { Py_tp_getset, _getset_KnownRuimFilePaths },
        { },
    };

    static PyType_Spec type_spec_KnownRuimFilePaths =
    {
        "_winsdk_Windows_Networking_NetworkOperators.KnownRuimFilePaths",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownRuimFilePaths
    };

    // ----- KnownSimFilePaths class --------------------
    constexpr const char* const type_name_KnownSimFilePaths = "KnownSimFilePaths";

    static PyObject* _new_KnownSimFilePaths(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownSimFilePaths);
        return nullptr;
    }

    static PyObject* KnownSimFilePaths_get_EFOns(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths::EFOns());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownSimFilePaths_get_EFSpn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths::EFSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownSimFilePaths_get_Gid1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths::Gid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownSimFilePaths_get_Gid2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths::Gid2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownSimFilePaths[] = {
        { "get_e_f_ons", reinterpret_cast<PyCFunction>(KnownSimFilePaths_get_EFOns), METH_NOARGS | METH_STATIC, nullptr },
        { "get_e_f_spn", reinterpret_cast<PyCFunction>(KnownSimFilePaths_get_EFSpn), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gid1", reinterpret_cast<PyCFunction>(KnownSimFilePaths_get_Gid1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gid2", reinterpret_cast<PyCFunction>(KnownSimFilePaths_get_Gid2), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KnownSimFilePaths[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownSimFilePaths[] = 
    {
        { Py_tp_new, _new_KnownSimFilePaths },
        { Py_tp_methods, _methods_KnownSimFilePaths },
        { Py_tp_getset, _getset_KnownSimFilePaths },
        { },
    };

    static PyType_Spec type_spec_KnownSimFilePaths =
    {
        "_winsdk_Windows_Networking_NetworkOperators.KnownSimFilePaths",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownSimFilePaths
    };

    // ----- KnownUSimFilePaths class --------------------
    constexpr const char* const type_name_KnownUSimFilePaths = "KnownUSimFilePaths";

    static PyObject* _new_KnownUSimFilePaths(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_KnownUSimFilePaths);
        return nullptr;
    }

    static PyObject* KnownUSimFilePaths_get_EFOpl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::EFOpl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUSimFilePaths_get_EFPnn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::EFPnn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUSimFilePaths_get_EFSpn(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::EFSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUSimFilePaths_get_Gid1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::Gid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* KnownUSimFilePaths_get_Gid2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths::Gid2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_KnownUSimFilePaths[] = {
        { "get_e_f_opl", reinterpret_cast<PyCFunction>(KnownUSimFilePaths_get_EFOpl), METH_NOARGS | METH_STATIC, nullptr },
        { "get_e_f_pnn", reinterpret_cast<PyCFunction>(KnownUSimFilePaths_get_EFPnn), METH_NOARGS | METH_STATIC, nullptr },
        { "get_e_f_spn", reinterpret_cast<PyCFunction>(KnownUSimFilePaths_get_EFSpn), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gid1", reinterpret_cast<PyCFunction>(KnownUSimFilePaths_get_Gid1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gid2", reinterpret_cast<PyCFunction>(KnownUSimFilePaths_get_Gid2), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_KnownUSimFilePaths[] = {
        { }
    };

    static PyType_Slot _type_slots_KnownUSimFilePaths[] = 
    {
        { Py_tp_new, _new_KnownUSimFilePaths },
        { Py_tp_methods, _methods_KnownUSimFilePaths },
        { Py_tp_getset, _getset_KnownUSimFilePaths },
        { },
    };

    static PyType_Spec type_spec_KnownUSimFilePaths =
    {
        "_winsdk_Windows_Networking_NetworkOperators.KnownUSimFilePaths",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_KnownUSimFilePaths
    };

    // ----- MobileBroadbandAccount class --------------------
    constexpr const char* const type_name_MobileBroadbandAccount = "MobileBroadbandAccount";

    static PyObject* _new_MobileBroadbandAccount(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandAccount);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandAccount(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAccount_CreateFromNetworkAccountId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount::CreateFromNetworkAccountId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_GetConnectionProfiles(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConnectionProfiles());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_CurrentDeviceInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentDeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_CurrentNetwork(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentNetwork());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_NetworkAccountId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_ServiceProviderGuid(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceProviderGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_ServiceProviderName(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_AccountExperienceUrl(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccountExperienceUrl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccount_get_AvailableNetworkAccountIds(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount::AvailableNetworkAccountIds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandAccount(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAccount[] = {
        { "create_from_network_account_id", reinterpret_cast<PyCFunction>(MobileBroadbandAccount_CreateFromNetworkAccountId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_connection_profiles", reinterpret_cast<PyCFunction>(MobileBroadbandAccount_GetConnectionProfiles), METH_VARARGS, nullptr },
        { "get_available_network_account_ids", reinterpret_cast<PyCFunction>(MobileBroadbandAccount_get_AvailableNetworkAccountIds), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAccount), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAccount[] = {
        { "current_device_information", reinterpret_cast<getter>(MobileBroadbandAccount_get_CurrentDeviceInformation), nullptr, nullptr, nullptr },
        { "current_network", reinterpret_cast<getter>(MobileBroadbandAccount_get_CurrentNetwork), nullptr, nullptr, nullptr },
        { "network_account_id", reinterpret_cast<getter>(MobileBroadbandAccount_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { "service_provider_guid", reinterpret_cast<getter>(MobileBroadbandAccount_get_ServiceProviderGuid), nullptr, nullptr, nullptr },
        { "service_provider_name", reinterpret_cast<getter>(MobileBroadbandAccount_get_ServiceProviderName), nullptr, nullptr, nullptr },
        { "account_experience_url", reinterpret_cast<getter>(MobileBroadbandAccount_get_AccountExperienceUrl), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAccount[] = 
    {
        { Py_tp_new, _new_MobileBroadbandAccount },
        { Py_tp_dealloc, _dealloc_MobileBroadbandAccount },
        { Py_tp_methods, _methods_MobileBroadbandAccount },
        { Py_tp_getset, _getset_MobileBroadbandAccount },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAccount =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandAccount",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccount),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAccount
    };

    // ----- MobileBroadbandAccountEventArgs class --------------------
    constexpr const char* const type_name_MobileBroadbandAccountEventArgs = "MobileBroadbandAccountEventArgs";

    static PyObject* _new_MobileBroadbandAccountEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandAccountEventArgs);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandAccountEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAccountEventArgs_get_NetworkAccountId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandAccountEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAccountEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAccountEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAccountEventArgs[] = {
        { "network_account_id", reinterpret_cast<getter>(MobileBroadbandAccountEventArgs_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAccountEventArgs[] = 
    {
        { Py_tp_new, _new_MobileBroadbandAccountEventArgs },
        { Py_tp_dealloc, _dealloc_MobileBroadbandAccountEventArgs },
        { Py_tp_methods, _methods_MobileBroadbandAccountEventArgs },
        { Py_tp_getset, _getset_MobileBroadbandAccountEventArgs },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAccountEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandAccountEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAccountEventArgs
    };

    // ----- MobileBroadbandAccountUpdatedEventArgs class --------------------
    constexpr const char* const type_name_MobileBroadbandAccountUpdatedEventArgs = "MobileBroadbandAccountUpdatedEventArgs";

    static PyObject* _new_MobileBroadbandAccountUpdatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandAccountUpdatedEventArgs);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandAccountUpdatedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAccountUpdatedEventArgs_get_HasDeviceInformationChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasDeviceInformationChanged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountUpdatedEventArgs_get_HasNetworkChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNetworkChanged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountUpdatedEventArgs_get_NetworkAccountId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandAccountUpdatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAccountUpdatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAccountUpdatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAccountUpdatedEventArgs[] = {
        { "has_device_information_changed", reinterpret_cast<getter>(MobileBroadbandAccountUpdatedEventArgs_get_HasDeviceInformationChanged), nullptr, nullptr, nullptr },
        { "has_network_changed", reinterpret_cast<getter>(MobileBroadbandAccountUpdatedEventArgs_get_HasNetworkChanged), nullptr, nullptr, nullptr },
        { "network_account_id", reinterpret_cast<getter>(MobileBroadbandAccountUpdatedEventArgs_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAccountUpdatedEventArgs[] = 
    {
        { Py_tp_new, _new_MobileBroadbandAccountUpdatedEventArgs },
        { Py_tp_dealloc, _dealloc_MobileBroadbandAccountUpdatedEventArgs },
        { Py_tp_methods, _methods_MobileBroadbandAccountUpdatedEventArgs },
        { Py_tp_getset, _getset_MobileBroadbandAccountUpdatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAccountUpdatedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandAccountUpdatedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAccountUpdatedEventArgs
    };

    // ----- MobileBroadbandAccountWatcher class --------------------
    constexpr const char* const type_name_MobileBroadbandAccountWatcher = "MobileBroadbandAccountWatcher";

    static PyObject* _new_MobileBroadbandAccountWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandAccountWatcher(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAccountWatcher_Start(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_Stop(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_get_Status(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_AccountAdded(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>>(arg);

            return py::convert(self->obj.AccountAdded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_AccountAdded(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccountAdded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_AccountRemoved(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>>(arg);

            return py::convert(self->obj.AccountRemoved(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_AccountRemoved(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccountRemoved(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_AccountUpdated(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs>>(arg);

            return py::convert(self->obj.AccountUpdated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_AccountUpdated(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AccountUpdated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_EnumerationCompleted(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.EnumerationCompleted(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_EnumerationCompleted(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.EnumerationCompleted(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_add_Stopped(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Stopped(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAccountWatcher_remove_Stopped(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Stopped(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandAccountWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAccountWatcher[] = {
        { "start", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_Stop), METH_VARARGS, nullptr },
        { "add_account_added", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_AccountAdded), METH_O, nullptr },
        { "remove_account_added", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_AccountAdded), METH_O, nullptr },
        { "add_account_removed", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_AccountRemoved), METH_O, nullptr },
        { "remove_account_removed", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_AccountRemoved), METH_O, nullptr },
        { "add_account_updated", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_AccountUpdated), METH_O, nullptr },
        { "remove_account_updated", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_AccountUpdated), METH_O, nullptr },
        { "add_enumeration_completed", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_EnumerationCompleted), METH_O, nullptr },
        { "remove_enumeration_completed", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_EnumerationCompleted), METH_O, nullptr },
        { "add_stopped", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_add_Stopped), METH_O, nullptr },
        { "remove_stopped", reinterpret_cast<PyCFunction>(MobileBroadbandAccountWatcher_remove_Stopped), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAccountWatcher), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAccountWatcher[] = {
        { "status", reinterpret_cast<getter>(MobileBroadbandAccountWatcher_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAccountWatcher[] = 
    {
        { Py_tp_new, _new_MobileBroadbandAccountWatcher },
        { Py_tp_dealloc, _dealloc_MobileBroadbandAccountWatcher },
        { Py_tp_methods, _methods_MobileBroadbandAccountWatcher },
        { Py_tp_getset, _getset_MobileBroadbandAccountWatcher },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAccountWatcher =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandAccountWatcher",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAccountWatcher
    };

    // ----- MobileBroadbandAntennaSar class --------------------
    constexpr const char* const type_name_MobileBroadbandAntennaSar = "MobileBroadbandAntennaSar";

    static PyObject* _new_MobileBroadbandAntennaSar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandAntennaSar(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandAntennaSar_get_AntennaIndex(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AntennaIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandAntennaSar_get_SarBackoffIndex(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SarBackoffIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandAntennaSar(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandAntennaSar[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandAntennaSar), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandAntennaSar[] = {
        { "antenna_index", reinterpret_cast<getter>(MobileBroadbandAntennaSar_get_AntennaIndex), nullptr, nullptr, nullptr },
        { "sar_backoff_index", reinterpret_cast<getter>(MobileBroadbandAntennaSar_get_SarBackoffIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandAntennaSar[] = 
    {
        { Py_tp_new, _new_MobileBroadbandAntennaSar },
        { Py_tp_dealloc, _dealloc_MobileBroadbandAntennaSar },
        { Py_tp_methods, _methods_MobileBroadbandAntennaSar },
        { Py_tp_getset, _getset_MobileBroadbandAntennaSar },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandAntennaSar =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandAntennaSar",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandAntennaSar
    };

    // ----- MobileBroadbandCellCdma class --------------------
    constexpr const char* const type_name_MobileBroadbandCellCdma = "MobileBroadbandCellCdma";

    static PyObject* _new_MobileBroadbandCellCdma(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCellCdma);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellCdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BaseStationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationLastBroadcastGpsTime(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BaseStationLastBroadcastGpsTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationLatitude(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BaseStationLatitude());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationLongitude(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BaseStationLongitude());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_BaseStationPNCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BaseStationPNCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_NetworkId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_PilotSignalStrengthInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PilotSignalStrengthInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellCdma_get_SystemId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SystemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandCellCdma(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellCdma[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellCdma), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellCdma[] = {
        { "base_station_id", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationId), nullptr, nullptr, nullptr },
        { "base_station_last_broadcast_gps_time", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationLastBroadcastGpsTime), nullptr, nullptr, nullptr },
        { "base_station_latitude", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationLatitude), nullptr, nullptr, nullptr },
        { "base_station_longitude", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationLongitude), nullptr, nullptr, nullptr },
        { "base_station_p_n_code", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_BaseStationPNCode), nullptr, nullptr, nullptr },
        { "network_id", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_NetworkId), nullptr, nullptr, nullptr },
        { "pilot_signal_strength_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_PilotSignalStrengthInDB), nullptr, nullptr, nullptr },
        { "system_id", reinterpret_cast<getter>(MobileBroadbandCellCdma_get_SystemId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellCdma[] = 
    {
        { Py_tp_new, _new_MobileBroadbandCellCdma },
        { Py_tp_dealloc, _dealloc_MobileBroadbandCellCdma },
        { Py_tp_methods, _methods_MobileBroadbandCellCdma },
        { Py_tp_getset, _getset_MobileBroadbandCellCdma },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellCdma =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCellCdma",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellCdma
    };

    // ----- MobileBroadbandCellGsm class --------------------
    constexpr const char* const type_name_MobileBroadbandCellGsm = "MobileBroadbandCellGsm";

    static PyObject* _new_MobileBroadbandCellGsm(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCellGsm);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellGsm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellGsm_get_BaseStationId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BaseStationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_LocationAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocationAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_ReceivedSignalStrengthInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReceivedSignalStrengthInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellGsm_get_TimingAdvanceInBitPeriods(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimingAdvanceInBitPeriods());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandCellGsm(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellGsm[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellGsm), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellGsm[] = {
        { "base_station_id", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_BaseStationId), nullptr, nullptr, nullptr },
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_CellId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "location_area_code", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_LocationAreaCode), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_ProviderId), nullptr, nullptr, nullptr },
        { "received_signal_strength_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_ReceivedSignalStrengthInDBm), nullptr, nullptr, nullptr },
        { "timing_advance_in_bit_periods", reinterpret_cast<getter>(MobileBroadbandCellGsm_get_TimingAdvanceInBitPeriods), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellGsm[] = 
    {
        { Py_tp_new, _new_MobileBroadbandCellGsm },
        { Py_tp_dealloc, _dealloc_MobileBroadbandCellGsm },
        { Py_tp_methods, _methods_MobileBroadbandCellGsm },
        { Py_tp_getset, _getset_MobileBroadbandCellGsm },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellGsm =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCellGsm",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellGsm
    };

    // ----- MobileBroadbandCellLte class --------------------
    constexpr const char* const type_name_MobileBroadbandCellLte = "MobileBroadbandCellLte";

    static PyObject* _new_MobileBroadbandCellLte(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCellLte);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellLte(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellLte_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_PhysicalCellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalCellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_ReferenceSignalReceivedPowerInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReferenceSignalReceivedPowerInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_ReferenceSignalReceivedQualityInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReferenceSignalReceivedQualityInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_TimingAdvanceInBitPeriods(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimingAdvanceInBitPeriods());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellLte_get_TrackingAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackingAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandCellLte(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellLte>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellLte[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellLte), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellLte[] = {
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellLte_get_CellId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellLte_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "physical_cell_id", reinterpret_cast<getter>(MobileBroadbandCellLte_get_PhysicalCellId), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellLte_get_ProviderId), nullptr, nullptr, nullptr },
        { "reference_signal_received_power_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellLte_get_ReferenceSignalReceivedPowerInDBm), nullptr, nullptr, nullptr },
        { "reference_signal_received_quality_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellLte_get_ReferenceSignalReceivedQualityInDBm), nullptr, nullptr, nullptr },
        { "timing_advance_in_bit_periods", reinterpret_cast<getter>(MobileBroadbandCellLte_get_TimingAdvanceInBitPeriods), nullptr, nullptr, nullptr },
        { "tracking_area_code", reinterpret_cast<getter>(MobileBroadbandCellLte_get_TrackingAreaCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellLte[] = 
    {
        { Py_tp_new, _new_MobileBroadbandCellLte },
        { Py_tp_dealloc, _dealloc_MobileBroadbandCellLte },
        { Py_tp_methods, _methods_MobileBroadbandCellLte },
        { Py_tp_getset, _getset_MobileBroadbandCellLte },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellLte =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCellLte",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellLte),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellLte
    };

    // ----- MobileBroadbandCellNR class --------------------
    constexpr const char* const type_name_MobileBroadbandCellNR = "MobileBroadbandCellNR";

    static PyObject* _new_MobileBroadbandCellNR(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCellNR);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellNR(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellNR_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_PhysicalCellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalCellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_ReferenceSignalReceivedPowerInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReferenceSignalReceivedPowerInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_ReferenceSignalReceivedQualityInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReferenceSignalReceivedQualityInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_SignalToNoiseRatioInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalToNoiseRatioInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_TimingAdvanceInNanoseconds(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimingAdvanceInNanoseconds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellNR_get_TrackingAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackingAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandCellNR(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellNR>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellNR[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellNR), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellNR[] = {
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellNR_get_CellId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellNR_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "physical_cell_id", reinterpret_cast<getter>(MobileBroadbandCellNR_get_PhysicalCellId), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellNR_get_ProviderId), nullptr, nullptr, nullptr },
        { "reference_signal_received_power_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellNR_get_ReferenceSignalReceivedPowerInDBm), nullptr, nullptr, nullptr },
        { "reference_signal_received_quality_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellNR_get_ReferenceSignalReceivedQualityInDBm), nullptr, nullptr, nullptr },
        { "signal_to_noise_ratio_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellNR_get_SignalToNoiseRatioInDB), nullptr, nullptr, nullptr },
        { "timing_advance_in_nanoseconds", reinterpret_cast<getter>(MobileBroadbandCellNR_get_TimingAdvanceInNanoseconds), nullptr, nullptr, nullptr },
        { "tracking_area_code", reinterpret_cast<getter>(MobileBroadbandCellNR_get_TrackingAreaCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellNR[] = 
    {
        { Py_tp_new, _new_MobileBroadbandCellNR },
        { Py_tp_dealloc, _dealloc_MobileBroadbandCellNR },
        { Py_tp_methods, _methods_MobileBroadbandCellNR },
        { Py_tp_getset, _getset_MobileBroadbandCellNR },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellNR =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCellNR",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellNR),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellNR
    };

    // ----- MobileBroadbandCellTdscdma class --------------------
    constexpr const char* const type_name_MobileBroadbandCellTdscdma = "MobileBroadbandCellTdscdma";

    static PyObject* _new_MobileBroadbandCellTdscdma(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCellTdscdma);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellTdscdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellTdscdma_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_CellParameterId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellParameterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_LocationAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocationAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_PathLossInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PathLossInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_ReceivedSignalCodePowerInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReceivedSignalCodePowerInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellTdscdma_get_TimingAdvanceInBitPeriods(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimingAdvanceInBitPeriods());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandCellTdscdma(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellTdscdma[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellTdscdma), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellTdscdma[] = {
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_CellId), nullptr, nullptr, nullptr },
        { "cell_parameter_id", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_CellParameterId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "location_area_code", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_LocationAreaCode), nullptr, nullptr, nullptr },
        { "path_loss_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_PathLossInDB), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_ProviderId), nullptr, nullptr, nullptr },
        { "received_signal_code_power_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_ReceivedSignalCodePowerInDBm), nullptr, nullptr, nullptr },
        { "timing_advance_in_bit_periods", reinterpret_cast<getter>(MobileBroadbandCellTdscdma_get_TimingAdvanceInBitPeriods), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellTdscdma[] = 
    {
        { Py_tp_new, _new_MobileBroadbandCellTdscdma },
        { Py_tp_dealloc, _dealloc_MobileBroadbandCellTdscdma },
        { Py_tp_methods, _methods_MobileBroadbandCellTdscdma },
        { Py_tp_getset, _getset_MobileBroadbandCellTdscdma },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellTdscdma =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCellTdscdma",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellTdscdma
    };

    // ----- MobileBroadbandCellUmts class --------------------
    constexpr const char* const type_name_MobileBroadbandCellUmts = "MobileBroadbandCellUmts";

    static PyObject* _new_MobileBroadbandCellUmts(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCellUmts);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellUmts(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellUmts_get_CellId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_ChannelNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChannelNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_LocationAreaCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocationAreaCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_PathLossInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PathLossInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_PrimaryScramblingCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrimaryScramblingCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_ProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_ReceivedSignalCodePowerInDBm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReceivedSignalCodePowerInDBm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellUmts_get_SignalToNoiseRatioInDB(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SignalToNoiseRatioInDB());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandCellUmts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellUmts[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellUmts), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellUmts[] = {
        { "cell_id", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_CellId), nullptr, nullptr, nullptr },
        { "channel_number", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_ChannelNumber), nullptr, nullptr, nullptr },
        { "location_area_code", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_LocationAreaCode), nullptr, nullptr, nullptr },
        { "path_loss_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_PathLossInDB), nullptr, nullptr, nullptr },
        { "primary_scrambling_code", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_PrimaryScramblingCode), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_ProviderId), nullptr, nullptr, nullptr },
        { "received_signal_code_power_in_d_bm", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_ReceivedSignalCodePowerInDBm), nullptr, nullptr, nullptr },
        { "signal_to_noise_ratio_in_d_b", reinterpret_cast<getter>(MobileBroadbandCellUmts_get_SignalToNoiseRatioInDB), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellUmts[] = 
    {
        { Py_tp_new, _new_MobileBroadbandCellUmts },
        { Py_tp_dealloc, _dealloc_MobileBroadbandCellUmts },
        { Py_tp_methods, _methods_MobileBroadbandCellUmts },
        { Py_tp_getset, _getset_MobileBroadbandCellUmts },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellUmts =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCellUmts",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellUmts
    };

    // ----- MobileBroadbandCellsInfo class --------------------
    constexpr const char* const type_name_MobileBroadbandCellsInfo = "MobileBroadbandCellsInfo";

    static PyObject* _new_MobileBroadbandCellsInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCellsInfo);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCellsInfo(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsCdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NeighboringCellsCdma());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsGsm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NeighboringCellsGsm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsLte(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NeighboringCellsLte());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsTdscdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NeighboringCellsTdscdma());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsUmts(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NeighboringCellsUmts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsCdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServingCellsCdma());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsGsm(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServingCellsGsm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsLte(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServingCellsLte());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsTdscdma(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServingCellsTdscdma());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsUmts(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServingCellsUmts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_NeighboringCellsNR(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NeighboringCellsNR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandCellsInfo_get_ServingCellsNR(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServingCellsNR());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandCellsInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCellsInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCellsInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCellsInfo[] = {
        { "neighboring_cells_cdma", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsCdma), nullptr, nullptr, nullptr },
        { "neighboring_cells_gsm", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsGsm), nullptr, nullptr, nullptr },
        { "neighboring_cells_lte", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsLte), nullptr, nullptr, nullptr },
        { "neighboring_cells_tdscdma", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsTdscdma), nullptr, nullptr, nullptr },
        { "neighboring_cells_umts", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsUmts), nullptr, nullptr, nullptr },
        { "serving_cells_cdma", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsCdma), nullptr, nullptr, nullptr },
        { "serving_cells_gsm", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsGsm), nullptr, nullptr, nullptr },
        { "serving_cells_lte", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsLte), nullptr, nullptr, nullptr },
        { "serving_cells_tdscdma", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsTdscdma), nullptr, nullptr, nullptr },
        { "serving_cells_umts", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsUmts), nullptr, nullptr, nullptr },
        { "neighboring_cells_n_r", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_NeighboringCellsNR), nullptr, nullptr, nullptr },
        { "serving_cells_n_r", reinterpret_cast<getter>(MobileBroadbandCellsInfo_get_ServingCellsNR), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCellsInfo[] = 
    {
        { Py_tp_new, _new_MobileBroadbandCellsInfo },
        { Py_tp_dealloc, _dealloc_MobileBroadbandCellsInfo },
        { Py_tp_methods, _methods_MobileBroadbandCellsInfo },
        { Py_tp_getset, _getset_MobileBroadbandCellsInfo },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCellsInfo =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCellsInfo",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCellsInfo
    };

    // ----- MobileBroadbandCurrentSlotIndexChangedEventArgs class --------------------
    constexpr const char* const type_name_MobileBroadbandCurrentSlotIndexChangedEventArgs = "MobileBroadbandCurrentSlotIndexChangedEventArgs";

    static PyObject* _new_MobileBroadbandCurrentSlotIndexChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandCurrentSlotIndexChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandCurrentSlotIndexChangedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandCurrentSlotIndexChangedEventArgs_get_CurrentSlotIndex(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentSlotIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandCurrentSlotIndexChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandCurrentSlotIndexChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandCurrentSlotIndexChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandCurrentSlotIndexChangedEventArgs[] = {
        { "current_slot_index", reinterpret_cast<getter>(MobileBroadbandCurrentSlotIndexChangedEventArgs_get_CurrentSlotIndex), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandCurrentSlotIndexChangedEventArgs[] = 
    {
        { Py_tp_new, _new_MobileBroadbandCurrentSlotIndexChangedEventArgs },
        { Py_tp_dealloc, _dealloc_MobileBroadbandCurrentSlotIndexChangedEventArgs },
        { Py_tp_methods, _methods_MobileBroadbandCurrentSlotIndexChangedEventArgs },
        { Py_tp_getset, _getset_MobileBroadbandCurrentSlotIndexChangedEventArgs },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandCurrentSlotIndexChangedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandCurrentSlotIndexChangedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandCurrentSlotIndexChangedEventArgs
    };

    // ----- MobileBroadbandDeviceInformation class --------------------
    constexpr const char* const type_name_MobileBroadbandDeviceInformation = "MobileBroadbandDeviceInformation";

    static PyObject* _new_MobileBroadbandDeviceInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceInformation);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceInformation_get_CellularClass(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CellularClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_CurrentRadioState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentRadioState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_CustomDataClass(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomDataClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_DataClasses(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataClasses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_DeviceType(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_FirmwareInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FirmwareInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_Manufacturer(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Manufacturer());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_MobileEquipmentId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MobileEquipmentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_Model(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Model());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_NetworkDeviceStatus(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkDeviceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SimIccId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SubscriberId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubscriberId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_TelephoneNumbers(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TelephoneNumbers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_PinManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PinManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_Revision(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Revision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SerialNumber(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SerialNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SimGid1(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimGid1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SimPnn(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimPnn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SimSpn(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimSpn());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceInformation_get_SlotManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SlotManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandDeviceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceInformation[] = {
        { "cellular_class", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_CellularClass), nullptr, nullptr, nullptr },
        { "current_radio_state", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_CurrentRadioState), nullptr, nullptr, nullptr },
        { "custom_data_class", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_CustomDataClass), nullptr, nullptr, nullptr },
        { "data_classes", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_DataClasses), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_type", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_DeviceType), nullptr, nullptr, nullptr },
        { "firmware_information", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_FirmwareInformation), nullptr, nullptr, nullptr },
        { "manufacturer", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_Manufacturer), nullptr, nullptr, nullptr },
        { "mobile_equipment_id", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_MobileEquipmentId), nullptr, nullptr, nullptr },
        { "model", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_Model), nullptr, nullptr, nullptr },
        { "network_device_status", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_NetworkDeviceStatus), nullptr, nullptr, nullptr },
        { "sim_icc_id", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SimIccId), nullptr, nullptr, nullptr },
        { "subscriber_id", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SubscriberId), nullptr, nullptr, nullptr },
        { "telephone_numbers", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_TelephoneNumbers), nullptr, nullptr, nullptr },
        { "pin_manager", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_PinManager), nullptr, nullptr, nullptr },
        { "revision", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_Revision), nullptr, nullptr, nullptr },
        { "serial_number", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SerialNumber), nullptr, nullptr, nullptr },
        { "sim_gid1", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SimGid1), nullptr, nullptr, nullptr },
        { "sim_pnn", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SimPnn), nullptr, nullptr, nullptr },
        { "sim_spn", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SimSpn), nullptr, nullptr, nullptr },
        { "slot_manager", reinterpret_cast<getter>(MobileBroadbandDeviceInformation_get_SlotManager), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceInformation[] = 
    {
        { Py_tp_new, _new_MobileBroadbandDeviceInformation },
        { Py_tp_dealloc, _dealloc_MobileBroadbandDeviceInformation },
        { Py_tp_methods, _methods_MobileBroadbandDeviceInformation },
        { Py_tp_getset, _getset_MobileBroadbandDeviceInformation },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceInformation =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceInformation",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceInformation
    };

    // ----- MobileBroadbandDeviceService class --------------------
    constexpr const char* const type_name_MobileBroadbandDeviceService = "MobileBroadbandDeviceService";

    static PyObject* _new_MobileBroadbandDeviceService(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceService);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceService(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceService_OpenCommandSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenCommandSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceService_OpenDataSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.OpenDataSession());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceService_get_DeviceServiceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceService_get_SupportedCommands(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCommands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandDeviceService(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceService[] = {
        { "open_command_session", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceService_OpenCommandSession), METH_VARARGS, nullptr },
        { "open_data_session", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceService_OpenDataSession), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceService), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceService[] = {
        { "device_service_id", reinterpret_cast<getter>(MobileBroadbandDeviceService_get_DeviceServiceId), nullptr, nullptr, nullptr },
        { "supported_commands", reinterpret_cast<getter>(MobileBroadbandDeviceService_get_SupportedCommands), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceService[] = 
    {
        { Py_tp_new, _new_MobileBroadbandDeviceService },
        { Py_tp_dealloc, _dealloc_MobileBroadbandDeviceService },
        { Py_tp_methods, _methods_MobileBroadbandDeviceService },
        { Py_tp_getset, _getset_MobileBroadbandDeviceService },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceService =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceService",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceService
    };

    // ----- MobileBroadbandDeviceServiceCommandResult class --------------------
    constexpr const char* const type_name_MobileBroadbandDeviceServiceCommandResult = "MobileBroadbandDeviceServiceCommandResult";

    static PyObject* _new_MobileBroadbandDeviceServiceCommandResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceServiceCommandResult);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceCommandResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceCommandResult_get_ResponseData(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResponseData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceCommandResult_get_StatusCode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandDeviceServiceCommandResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceCommandResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceCommandResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceCommandResult[] = {
        { "response_data", reinterpret_cast<getter>(MobileBroadbandDeviceServiceCommandResult_get_ResponseData), nullptr, nullptr, nullptr },
        { "status_code", reinterpret_cast<getter>(MobileBroadbandDeviceServiceCommandResult_get_StatusCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceCommandResult[] = 
    {
        { Py_tp_new, _new_MobileBroadbandDeviceServiceCommandResult },
        { Py_tp_dealloc, _dealloc_MobileBroadbandDeviceServiceCommandResult },
        { Py_tp_methods, _methods_MobileBroadbandDeviceServiceCommandResult },
        { Py_tp_getset, _getset_MobileBroadbandDeviceServiceCommandResult },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceCommandResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceServiceCommandResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceCommandResult
    };

    // ----- MobileBroadbandDeviceServiceCommandSession class --------------------
    constexpr const char* const type_name_MobileBroadbandDeviceServiceCommandSession = "MobileBroadbandDeviceServiceCommandSession";

    static PyObject* _new_MobileBroadbandDeviceServiceCommandSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceServiceCommandSession);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceCommandSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceCommandSession_CloseSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.CloseSession();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceCommandSession_SendQueryCommandAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.SendQueryCommandAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceCommandSession_SendSetCommandAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.SendSetCommandAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandDeviceServiceCommandSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceCommandSession[] = {
        { "close_session", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceCommandSession_CloseSession), METH_VARARGS, nullptr },
        { "send_query_command_async", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceCommandSession_SendQueryCommandAsync), METH_VARARGS, nullptr },
        { "send_set_command_async", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceCommandSession_SendSetCommandAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceCommandSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceCommandSession[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceCommandSession[] = 
    {
        { Py_tp_new, _new_MobileBroadbandDeviceServiceCommandSession },
        { Py_tp_dealloc, _dealloc_MobileBroadbandDeviceServiceCommandSession },
        { Py_tp_methods, _methods_MobileBroadbandDeviceServiceCommandSession },
        { Py_tp_getset, _getset_MobileBroadbandDeviceServiceCommandSession },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceCommandSession =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceServiceCommandSession",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceCommandSession
    };

    // ----- MobileBroadbandDeviceServiceDataReceivedEventArgs class --------------------
    constexpr const char* const type_name_MobileBroadbandDeviceServiceDataReceivedEventArgs = "MobileBroadbandDeviceServiceDataReceivedEventArgs";

    static PyObject* _new_MobileBroadbandDeviceServiceDataReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceServiceDataReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceDataReceivedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceDataReceivedEventArgs_get_ReceivedData(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReceivedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandDeviceServiceDataReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceDataReceivedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceDataReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceDataReceivedEventArgs[] = {
        { "received_data", reinterpret_cast<getter>(MobileBroadbandDeviceServiceDataReceivedEventArgs_get_ReceivedData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceDataReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MobileBroadbandDeviceServiceDataReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MobileBroadbandDeviceServiceDataReceivedEventArgs },
        { Py_tp_methods, _methods_MobileBroadbandDeviceServiceDataReceivedEventArgs },
        { Py_tp_getset, _getset_MobileBroadbandDeviceServiceDataReceivedEventArgs },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceDataReceivedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceServiceDataReceivedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceDataReceivedEventArgs
    };

    // ----- MobileBroadbandDeviceServiceDataSession class --------------------
    constexpr const char* const type_name_MobileBroadbandDeviceServiceDataSession = "MobileBroadbandDeviceServiceDataSession";

    static PyObject* _new_MobileBroadbandDeviceServiceDataSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceServiceDataSession);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceDataSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceDataSession_CloseSession(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.CloseSession();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceDataSession_WriteDataAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteDataAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceDataSession_add_DataReceived(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession, winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs>>(arg);

            return py::convert(self->obj.DataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceDataSession_remove_DataReceived(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandDeviceServiceDataSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceDataSession[] = {
        { "close_session", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceDataSession_CloseSession), METH_VARARGS, nullptr },
        { "write_data_async", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceDataSession_WriteDataAsync), METH_VARARGS, nullptr },
        { "add_data_received", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceDataSession_add_DataReceived), METH_O, nullptr },
        { "remove_data_received", reinterpret_cast<PyCFunction>(MobileBroadbandDeviceServiceDataSession_remove_DataReceived), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceDataSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceDataSession[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceDataSession[] = 
    {
        { Py_tp_new, _new_MobileBroadbandDeviceServiceDataSession },
        { Py_tp_dealloc, _dealloc_MobileBroadbandDeviceServiceDataSession },
        { Py_tp_methods, _methods_MobileBroadbandDeviceServiceDataSession },
        { Py_tp_getset, _getset_MobileBroadbandDeviceServiceDataSession },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceDataSession =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceServiceDataSession",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceDataSession
    };

    // ----- MobileBroadbandDeviceServiceInformation class --------------------
    constexpr const char* const type_name_MobileBroadbandDeviceServiceInformation = "MobileBroadbandDeviceServiceInformation";

    static PyObject* _new_MobileBroadbandDeviceServiceInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceServiceInformation);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceInformation_get_DeviceServiceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceInformation_get_IsDataReadSupported(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDataReadSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceInformation_get_IsDataWriteSupported(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDataWriteSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandDeviceServiceInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceInformation[] = {
        { "device_service_id", reinterpret_cast<getter>(MobileBroadbandDeviceServiceInformation_get_DeviceServiceId), nullptr, nullptr, nullptr },
        { "is_data_read_supported", reinterpret_cast<getter>(MobileBroadbandDeviceServiceInformation_get_IsDataReadSupported), nullptr, nullptr, nullptr },
        { "is_data_write_supported", reinterpret_cast<getter>(MobileBroadbandDeviceServiceInformation_get_IsDataWriteSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceInformation[] = 
    {
        { Py_tp_new, _new_MobileBroadbandDeviceServiceInformation },
        { Py_tp_dealloc, _dealloc_MobileBroadbandDeviceServiceInformation },
        { Py_tp_methods, _methods_MobileBroadbandDeviceServiceInformation },
        { Py_tp_getset, _getset_MobileBroadbandDeviceServiceInformation },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceInformation =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceServiceInformation",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceInformation
    };

    // ----- MobileBroadbandDeviceServiceTriggerDetails class --------------------
    constexpr const char* const type_name_MobileBroadbandDeviceServiceTriggerDetails = "MobileBroadbandDeviceServiceTriggerDetails";

    static PyObject* _new_MobileBroadbandDeviceServiceTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandDeviceServiceTriggerDetails);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandDeviceServiceTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandDeviceServiceTriggerDetails_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceTriggerDetails_get_DeviceServiceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandDeviceServiceTriggerDetails_get_ReceivedData(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReceivedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandDeviceServiceTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandDeviceServiceTriggerDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandDeviceServiceTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandDeviceServiceTriggerDetails[] = {
        { "device_id", reinterpret_cast<getter>(MobileBroadbandDeviceServiceTriggerDetails_get_DeviceId), nullptr, nullptr, nullptr },
        { "device_service_id", reinterpret_cast<getter>(MobileBroadbandDeviceServiceTriggerDetails_get_DeviceServiceId), nullptr, nullptr, nullptr },
        { "received_data", reinterpret_cast<getter>(MobileBroadbandDeviceServiceTriggerDetails_get_ReceivedData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandDeviceServiceTriggerDetails[] = 
    {
        { Py_tp_new, _new_MobileBroadbandDeviceServiceTriggerDetails },
        { Py_tp_dealloc, _dealloc_MobileBroadbandDeviceServiceTriggerDetails },
        { Py_tp_methods, _methods_MobileBroadbandDeviceServiceTriggerDetails },
        { Py_tp_getset, _getset_MobileBroadbandDeviceServiceTriggerDetails },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandDeviceServiceTriggerDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandDeviceServiceTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandDeviceServiceTriggerDetails
    };

    // ----- MobileBroadbandModem class --------------------
    constexpr const char* const type_name_MobileBroadbandModem = "MobileBroadbandModem";

    static PyObject* _new_MobileBroadbandModem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandModem);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandModem(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandModem_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetCurrentConfigurationAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentConfigurationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetDeviceService(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetDeviceService(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_GetIsPassthroughEnabledAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetIsPassthroughEnabledAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_ResetAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ResetAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_SetIsPassthroughEnabledAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetIsPassthroughEnabledAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_TryGetPcoAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetPcoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_CurrentAccount(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentAccount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_CurrentNetwork(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentNetwork());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_DeviceInformation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_DeviceServices(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceServices());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_IsResetSupported(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsResetSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_MaxDeviceServiceCommandSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxDeviceServiceCommandSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_MaxDeviceServiceDataSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxDeviceServiceDataSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_get_IsInEmergencyCallMode(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInEmergencyCallMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_add_IsInEmergencyCallModeChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.IsInEmergencyCallModeChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModem_remove_IsInEmergencyCallModeChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.IsInEmergencyCallModeChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandModem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandModem[] = {
        { "from_id", reinterpret_cast<PyCFunction>(MobileBroadbandModem_FromId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_configuration_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetCurrentConfigurationAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_service", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetDeviceService), METH_VARARGS, nullptr },
        { "get_is_passthrough_enabled_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_GetIsPassthroughEnabledAsync), METH_VARARGS, nullptr },
        { "reset_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_ResetAsync), METH_VARARGS, nullptr },
        { "set_is_passthrough_enabled_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_SetIsPassthroughEnabledAsync), METH_VARARGS, nullptr },
        { "try_get_pco_async", reinterpret_cast<PyCFunction>(MobileBroadbandModem_TryGetPcoAsync), METH_VARARGS, nullptr },
        { "add_is_in_emergency_call_mode_changed", reinterpret_cast<PyCFunction>(MobileBroadbandModem_add_IsInEmergencyCallModeChanged), METH_O, nullptr },
        { "remove_is_in_emergency_call_mode_changed", reinterpret_cast<PyCFunction>(MobileBroadbandModem_remove_IsInEmergencyCallModeChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandModem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandModem[] = {
        { "current_account", reinterpret_cast<getter>(MobileBroadbandModem_get_CurrentAccount), nullptr, nullptr, nullptr },
        { "current_network", reinterpret_cast<getter>(MobileBroadbandModem_get_CurrentNetwork), nullptr, nullptr, nullptr },
        { "device_information", reinterpret_cast<getter>(MobileBroadbandModem_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "device_services", reinterpret_cast<getter>(MobileBroadbandModem_get_DeviceServices), nullptr, nullptr, nullptr },
        { "is_reset_supported", reinterpret_cast<getter>(MobileBroadbandModem_get_IsResetSupported), nullptr, nullptr, nullptr },
        { "max_device_service_command_size_in_bytes", reinterpret_cast<getter>(MobileBroadbandModem_get_MaxDeviceServiceCommandSizeInBytes), nullptr, nullptr, nullptr },
        { "max_device_service_data_size_in_bytes", reinterpret_cast<getter>(MobileBroadbandModem_get_MaxDeviceServiceDataSizeInBytes), nullptr, nullptr, nullptr },
        { "is_in_emergency_call_mode", reinterpret_cast<getter>(MobileBroadbandModem_get_IsInEmergencyCallMode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandModem[] = 
    {
        { Py_tp_new, _new_MobileBroadbandModem },
        { Py_tp_dealloc, _dealloc_MobileBroadbandModem },
        { Py_tp_methods, _methods_MobileBroadbandModem },
        { Py_tp_getset, _getset_MobileBroadbandModem },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandModem =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandModem",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandModem
    };

    // ----- MobileBroadbandModemConfiguration class --------------------
    constexpr const char* const type_name_MobileBroadbandModemConfiguration = "MobileBroadbandModemConfiguration";

    static PyObject* _new_MobileBroadbandModemConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandModemConfiguration);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandModemConfiguration(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandModemConfiguration_get_HomeProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HomeProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemConfiguration_get_HomeProviderName(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HomeProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemConfiguration_get_Uicc(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uicc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemConfiguration_get_SarManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SarManager());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandModemConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandModemConfiguration[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandModemConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandModemConfiguration[] = {
        { "home_provider_id", reinterpret_cast<getter>(MobileBroadbandModemConfiguration_get_HomeProviderId), nullptr, nullptr, nullptr },
        { "home_provider_name", reinterpret_cast<getter>(MobileBroadbandModemConfiguration_get_HomeProviderName), nullptr, nullptr, nullptr },
        { "uicc", reinterpret_cast<getter>(MobileBroadbandModemConfiguration_get_Uicc), nullptr, nullptr, nullptr },
        { "sar_manager", reinterpret_cast<getter>(MobileBroadbandModemConfiguration_get_SarManager), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandModemConfiguration[] = 
    {
        { Py_tp_new, _new_MobileBroadbandModemConfiguration },
        { Py_tp_dealloc, _dealloc_MobileBroadbandModemConfiguration },
        { Py_tp_methods, _methods_MobileBroadbandModemConfiguration },
        { Py_tp_getset, _getset_MobileBroadbandModemConfiguration },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandModemConfiguration =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandModemConfiguration",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandModemConfiguration
    };

    // ----- MobileBroadbandModemIsolation class --------------------
    constexpr const char* const type_name_MobileBroadbandModemIsolation = "MobileBroadbandModemIsolation";

    static PyObject* _new_MobileBroadbandModemIsolation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MobileBroadbandModemIsolation(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandModemIsolation_AddAllowedHost(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);

                self->obj.AddAllowedHost(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemIsolation_AddAllowedHostRange(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::HostName>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostName>(args, 1);

                self->obj.AddAllowedHostRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemIsolation_ApplyConfigurationAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ApplyConfigurationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandModemIsolation_ClearConfigurationAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearConfigurationAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandModemIsolation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandModemIsolation[] = {
        { "add_allowed_host", reinterpret_cast<PyCFunction>(MobileBroadbandModemIsolation_AddAllowedHost), METH_VARARGS, nullptr },
        { "add_allowed_host_range", reinterpret_cast<PyCFunction>(MobileBroadbandModemIsolation_AddAllowedHostRange), METH_VARARGS, nullptr },
        { "apply_configuration_async", reinterpret_cast<PyCFunction>(MobileBroadbandModemIsolation_ApplyConfigurationAsync), METH_VARARGS, nullptr },
        { "clear_configuration_async", reinterpret_cast<PyCFunction>(MobileBroadbandModemIsolation_ClearConfigurationAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandModemIsolation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandModemIsolation[] = {
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandModemIsolation[] = 
    {
        { Py_tp_new, _new_MobileBroadbandModemIsolation },
        { Py_tp_dealloc, _dealloc_MobileBroadbandModemIsolation },
        { Py_tp_methods, _methods_MobileBroadbandModemIsolation },
        { Py_tp_getset, _getset_MobileBroadbandModemIsolation },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandModemIsolation =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandModemIsolation",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandModemIsolation
    };

    // ----- MobileBroadbandNetwork class --------------------
    constexpr const char* const type_name_MobileBroadbandNetwork = "MobileBroadbandNetwork";

    static PyObject* _new_MobileBroadbandNetwork(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandNetwork);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandNetwork(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandNetwork_GetCellsInfoAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCellsInfoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_GetVoiceCallSupportAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetVoiceCallSupportAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_ShowConnectionUI(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ShowConnectionUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_AccessPointName(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccessPointName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_ActivationNetworkError(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivationNetworkError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_NetworkAdapter(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_NetworkRegistrationState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkRegistrationState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_PacketAttachNetworkError(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PacketAttachNetworkError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegisteredDataClass(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RegisteredDataClass());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegisteredProviderId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RegisteredProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegisteredProviderName(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RegisteredProviderName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegistrationNetworkError(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RegistrationNetworkError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetwork_get_RegistrationUiccApps(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RegistrationUiccApps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandNetwork(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetwork>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandNetwork[] = {
        { "get_cells_info_async", reinterpret_cast<PyCFunction>(MobileBroadbandNetwork_GetCellsInfoAsync), METH_VARARGS, nullptr },
        { "get_voice_call_support_async", reinterpret_cast<PyCFunction>(MobileBroadbandNetwork_GetVoiceCallSupportAsync), METH_VARARGS, nullptr },
        { "show_connection_u_i", reinterpret_cast<PyCFunction>(MobileBroadbandNetwork_ShowConnectionUI), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandNetwork), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandNetwork[] = {
        { "access_point_name", reinterpret_cast<getter>(MobileBroadbandNetwork_get_AccessPointName), nullptr, nullptr, nullptr },
        { "activation_network_error", reinterpret_cast<getter>(MobileBroadbandNetwork_get_ActivationNetworkError), nullptr, nullptr, nullptr },
        { "network_adapter", reinterpret_cast<getter>(MobileBroadbandNetwork_get_NetworkAdapter), nullptr, nullptr, nullptr },
        { "network_registration_state", reinterpret_cast<getter>(MobileBroadbandNetwork_get_NetworkRegistrationState), nullptr, nullptr, nullptr },
        { "packet_attach_network_error", reinterpret_cast<getter>(MobileBroadbandNetwork_get_PacketAttachNetworkError), nullptr, nullptr, nullptr },
        { "registered_data_class", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegisteredDataClass), nullptr, nullptr, nullptr },
        { "registered_provider_id", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegisteredProviderId), nullptr, nullptr, nullptr },
        { "registered_provider_name", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegisteredProviderName), nullptr, nullptr, nullptr },
        { "registration_network_error", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegistrationNetworkError), nullptr, nullptr, nullptr },
        { "registration_uicc_apps", reinterpret_cast<getter>(MobileBroadbandNetwork_get_RegistrationUiccApps), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandNetwork[] = 
    {
        { Py_tp_new, _new_MobileBroadbandNetwork },
        { Py_tp_dealloc, _dealloc_MobileBroadbandNetwork },
        { Py_tp_methods, _methods_MobileBroadbandNetwork },
        { Py_tp_getset, _getset_MobileBroadbandNetwork },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandNetwork =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandNetwork",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetwork),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandNetwork
    };

    // ----- MobileBroadbandNetworkRegistrationStateChange class --------------------
    constexpr const char* const type_name_MobileBroadbandNetworkRegistrationStateChange = "MobileBroadbandNetworkRegistrationStateChange";

    static PyObject* _new_MobileBroadbandNetworkRegistrationStateChange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandNetworkRegistrationStateChange);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandNetworkRegistrationStateChange(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandNetworkRegistrationStateChange_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandNetworkRegistrationStateChange_get_Network(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Network());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandNetworkRegistrationStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandNetworkRegistrationStateChange[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandNetworkRegistrationStateChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandNetworkRegistrationStateChange[] = {
        { "device_id", reinterpret_cast<getter>(MobileBroadbandNetworkRegistrationStateChange_get_DeviceId), nullptr, nullptr, nullptr },
        { "network", reinterpret_cast<getter>(MobileBroadbandNetworkRegistrationStateChange_get_Network), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandNetworkRegistrationStateChange[] = 
    {
        { Py_tp_new, _new_MobileBroadbandNetworkRegistrationStateChange },
        { Py_tp_dealloc, _dealloc_MobileBroadbandNetworkRegistrationStateChange },
        { Py_tp_methods, _methods_MobileBroadbandNetworkRegistrationStateChange },
        { Py_tp_getset, _getset_MobileBroadbandNetworkRegistrationStateChange },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandNetworkRegistrationStateChange =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandNetworkRegistrationStateChange",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandNetworkRegistrationStateChange
    };

    // ----- MobileBroadbandNetworkRegistrationStateChangeTriggerDetails class --------------------
    constexpr const char* const type_name_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails = "MobileBroadbandNetworkRegistrationStateChangeTriggerDetails";

    static PyObject* _new_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandNetworkRegistrationStateChangeTriggerDetails_get_NetworkRegistrationStateChanges(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkRegistrationStateChanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails[] = {
        { "network_registration_state_changes", reinterpret_cast<getter>(MobileBroadbandNetworkRegistrationStateChangeTriggerDetails_get_NetworkRegistrationStateChanges), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails[] = 
    {
        { Py_tp_new, _new_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails },
        { Py_tp_dealloc, _dealloc_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails },
        { Py_tp_methods, _methods_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails },
        { Py_tp_getset, _getset_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandNetworkRegistrationStateChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails
    };

    // ----- MobileBroadbandPco class --------------------
    constexpr const char* const type_name_MobileBroadbandPco = "MobileBroadbandPco";

    static PyObject* _new_MobileBroadbandPco(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandPco);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPco(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPco_get_Data(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPco_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPco_get_IsComplete(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComplete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandPco(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPco>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPco[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPco), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPco[] = {
        { "data", reinterpret_cast<getter>(MobileBroadbandPco_get_Data), nullptr, nullptr, nullptr },
        { "device_id", reinterpret_cast<getter>(MobileBroadbandPco_get_DeviceId), nullptr, nullptr, nullptr },
        { "is_complete", reinterpret_cast<getter>(MobileBroadbandPco_get_IsComplete), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPco[] = 
    {
        { Py_tp_new, _new_MobileBroadbandPco },
        { Py_tp_dealloc, _dealloc_MobileBroadbandPco },
        { Py_tp_methods, _methods_MobileBroadbandPco },
        { Py_tp_getset, _getset_MobileBroadbandPco },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPco =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandPco",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPco),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPco
    };

    // ----- MobileBroadbandPcoDataChangeTriggerDetails class --------------------
    constexpr const char* const type_name_MobileBroadbandPcoDataChangeTriggerDetails = "MobileBroadbandPcoDataChangeTriggerDetails";

    static PyObject* _new_MobileBroadbandPcoDataChangeTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandPcoDataChangeTriggerDetails);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPcoDataChangeTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPcoDataChangeTriggerDetails_get_UpdatedData(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdatedData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandPcoDataChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPcoDataChangeTriggerDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPcoDataChangeTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPcoDataChangeTriggerDetails[] = {
        { "updated_data", reinterpret_cast<getter>(MobileBroadbandPcoDataChangeTriggerDetails_get_UpdatedData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPcoDataChangeTriggerDetails[] = 
    {
        { Py_tp_new, _new_MobileBroadbandPcoDataChangeTriggerDetails },
        { Py_tp_dealloc, _dealloc_MobileBroadbandPcoDataChangeTriggerDetails },
        { Py_tp_methods, _methods_MobileBroadbandPcoDataChangeTriggerDetails },
        { Py_tp_getset, _getset_MobileBroadbandPcoDataChangeTriggerDetails },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPcoDataChangeTriggerDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandPcoDataChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPcoDataChangeTriggerDetails
    };

    // ----- MobileBroadbandPin class --------------------
    constexpr const char* const type_name_MobileBroadbandPin = "MobileBroadbandPin";

    static PyObject* _new_MobileBroadbandPin(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandPin);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPin(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPin_ChangeAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.ChangeAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_DisableAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DisableAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_EnableAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.EnableAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_EnterAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.EnterAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_UnblockAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.UnblockAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_AttemptsRemaining(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttemptsRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_Enabled(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_Format(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_LockState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LockState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_MaxLength(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_MinLength(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPin_get_Type(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandPin(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPin>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPin[] = {
        { "change_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_ChangeAsync), METH_VARARGS, nullptr },
        { "disable_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_DisableAsync), METH_VARARGS, nullptr },
        { "enable_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_EnableAsync), METH_VARARGS, nullptr },
        { "enter_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_EnterAsync), METH_VARARGS, nullptr },
        { "unblock_async", reinterpret_cast<PyCFunction>(MobileBroadbandPin_UnblockAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPin), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPin[] = {
        { "attempts_remaining", reinterpret_cast<getter>(MobileBroadbandPin_get_AttemptsRemaining), nullptr, nullptr, nullptr },
        { "enabled", reinterpret_cast<getter>(MobileBroadbandPin_get_Enabled), nullptr, nullptr, nullptr },
        { "format", reinterpret_cast<getter>(MobileBroadbandPin_get_Format), nullptr, nullptr, nullptr },
        { "lock_state", reinterpret_cast<getter>(MobileBroadbandPin_get_LockState), nullptr, nullptr, nullptr },
        { "max_length", reinterpret_cast<getter>(MobileBroadbandPin_get_MaxLength), nullptr, nullptr, nullptr },
        { "min_length", reinterpret_cast<getter>(MobileBroadbandPin_get_MinLength), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MobileBroadbandPin_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPin[] = 
    {
        { Py_tp_new, _new_MobileBroadbandPin },
        { Py_tp_dealloc, _dealloc_MobileBroadbandPin },
        { Py_tp_methods, _methods_MobileBroadbandPin },
        { Py_tp_getset, _getset_MobileBroadbandPin },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPin =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandPin",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPin),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPin
    };

    // ----- MobileBroadbandPinLockStateChange class --------------------
    constexpr const char* const type_name_MobileBroadbandPinLockStateChange = "MobileBroadbandPinLockStateChange";

    static PyObject* _new_MobileBroadbandPinLockStateChange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandPinLockStateChange);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPinLockStateChange(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPinLockStateChange_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPinLockStateChange_get_PinLockState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PinLockState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPinLockStateChange_get_PinType(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PinType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandPinLockStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinLockStateChange[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPinLockStateChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPinLockStateChange[] = {
        { "device_id", reinterpret_cast<getter>(MobileBroadbandPinLockStateChange_get_DeviceId), nullptr, nullptr, nullptr },
        { "pin_lock_state", reinterpret_cast<getter>(MobileBroadbandPinLockStateChange_get_PinLockState), nullptr, nullptr, nullptr },
        { "pin_type", reinterpret_cast<getter>(MobileBroadbandPinLockStateChange_get_PinType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinLockStateChange[] = 
    {
        { Py_tp_new, _new_MobileBroadbandPinLockStateChange },
        { Py_tp_dealloc, _dealloc_MobileBroadbandPinLockStateChange },
        { Py_tp_methods, _methods_MobileBroadbandPinLockStateChange },
        { Py_tp_getset, _getset_MobileBroadbandPinLockStateChange },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPinLockStateChange =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandPinLockStateChange",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinLockStateChange
    };

    // ----- MobileBroadbandPinLockStateChangeTriggerDetails class --------------------
    constexpr const char* const type_name_MobileBroadbandPinLockStateChangeTriggerDetails = "MobileBroadbandPinLockStateChangeTriggerDetails";

    static PyObject* _new_MobileBroadbandPinLockStateChangeTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandPinLockStateChangeTriggerDetails);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPinLockStateChangeTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPinLockStateChangeTriggerDetails_get_PinLockStateChanges(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PinLockStateChanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandPinLockStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinLockStateChangeTriggerDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPinLockStateChangeTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPinLockStateChangeTriggerDetails[] = {
        { "pin_lock_state_changes", reinterpret_cast<getter>(MobileBroadbandPinLockStateChangeTriggerDetails_get_PinLockStateChanges), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinLockStateChangeTriggerDetails[] = 
    {
        { Py_tp_new, _new_MobileBroadbandPinLockStateChangeTriggerDetails },
        { Py_tp_dealloc, _dealloc_MobileBroadbandPinLockStateChangeTriggerDetails },
        { Py_tp_methods, _methods_MobileBroadbandPinLockStateChangeTriggerDetails },
        { Py_tp_getset, _getset_MobileBroadbandPinLockStateChangeTriggerDetails },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPinLockStateChangeTriggerDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandPinLockStateChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinLockStateChangeTriggerDetails
    };

    // ----- MobileBroadbandPinManager class --------------------
    constexpr const char* const type_name_MobileBroadbandPinManager = "MobileBroadbandPinManager";

    static PyObject* _new_MobileBroadbandPinManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandPinManager);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPinManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinManager* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPinManager_GetPin(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinType>(args, 0);

                return py::convert(self->obj.GetPin(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPinManager_get_SupportedPins(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedPins());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandPinManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinManager[] = {
        { "get_pin", reinterpret_cast<PyCFunction>(MobileBroadbandPinManager_GetPin), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPinManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPinManager[] = {
        { "supported_pins", reinterpret_cast<getter>(MobileBroadbandPinManager_get_SupportedPins), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinManager[] = 
    {
        { Py_tp_new, _new_MobileBroadbandPinManager },
        { Py_tp_dealloc, _dealloc_MobileBroadbandPinManager },
        { Py_tp_methods, _methods_MobileBroadbandPinManager },
        { Py_tp_getset, _getset_MobileBroadbandPinManager },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPinManager =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandPinManager",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinManager
    };

    // ----- MobileBroadbandPinOperationResult class --------------------
    constexpr const char* const type_name_MobileBroadbandPinOperationResult = "MobileBroadbandPinOperationResult";

    static PyObject* _new_MobileBroadbandPinOperationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandPinOperationResult);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandPinOperationResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandPinOperationResult_get_AttemptsRemaining(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttemptsRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandPinOperationResult_get_IsSuccessful(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSuccessful());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandPinOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandPinOperationResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandPinOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandPinOperationResult[] = {
        { "attempts_remaining", reinterpret_cast<getter>(MobileBroadbandPinOperationResult_get_AttemptsRemaining), nullptr, nullptr, nullptr },
        { "is_successful", reinterpret_cast<getter>(MobileBroadbandPinOperationResult_get_IsSuccessful), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandPinOperationResult[] = 
    {
        { Py_tp_new, _new_MobileBroadbandPinOperationResult },
        { Py_tp_dealloc, _dealloc_MobileBroadbandPinOperationResult },
        { Py_tp_methods, _methods_MobileBroadbandPinOperationResult },
        { Py_tp_getset, _getset_MobileBroadbandPinOperationResult },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandPinOperationResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandPinOperationResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandPinOperationResult
    };

    // ----- MobileBroadbandRadioStateChange class --------------------
    constexpr const char* const type_name_MobileBroadbandRadioStateChange = "MobileBroadbandRadioStateChange";

    static PyObject* _new_MobileBroadbandRadioStateChange(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandRadioStateChange);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandRadioStateChange(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandRadioStateChange_get_DeviceId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandRadioStateChange_get_RadioState(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RadioState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandRadioStateChange(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandRadioStateChange[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandRadioStateChange), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandRadioStateChange[] = {
        { "device_id", reinterpret_cast<getter>(MobileBroadbandRadioStateChange_get_DeviceId), nullptr, nullptr, nullptr },
        { "radio_state", reinterpret_cast<getter>(MobileBroadbandRadioStateChange_get_RadioState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandRadioStateChange[] = 
    {
        { Py_tp_new, _new_MobileBroadbandRadioStateChange },
        { Py_tp_dealloc, _dealloc_MobileBroadbandRadioStateChange },
        { Py_tp_methods, _methods_MobileBroadbandRadioStateChange },
        { Py_tp_getset, _getset_MobileBroadbandRadioStateChange },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandRadioStateChange =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandRadioStateChange",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandRadioStateChange
    };

    // ----- MobileBroadbandRadioStateChangeTriggerDetails class --------------------
    constexpr const char* const type_name_MobileBroadbandRadioStateChangeTriggerDetails = "MobileBroadbandRadioStateChangeTriggerDetails";

    static PyObject* _new_MobileBroadbandRadioStateChangeTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandRadioStateChangeTriggerDetails);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandRadioStateChangeTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandRadioStateChangeTriggerDetails_get_RadioStateChanges(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RadioStateChanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandRadioStateChangeTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandRadioStateChangeTriggerDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandRadioStateChangeTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandRadioStateChangeTriggerDetails[] = {
        { "radio_state_changes", reinterpret_cast<getter>(MobileBroadbandRadioStateChangeTriggerDetails_get_RadioStateChanges), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandRadioStateChangeTriggerDetails[] = 
    {
        { Py_tp_new, _new_MobileBroadbandRadioStateChangeTriggerDetails },
        { Py_tp_dealloc, _dealloc_MobileBroadbandRadioStateChangeTriggerDetails },
        { Py_tp_methods, _methods_MobileBroadbandRadioStateChangeTriggerDetails },
        { Py_tp_getset, _getset_MobileBroadbandRadioStateChangeTriggerDetails },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandRadioStateChangeTriggerDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandRadioStateChangeTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandRadioStateChangeTriggerDetails
    };

    // ----- MobileBroadbandSarManager class --------------------
    constexpr const char* const type_name_MobileBroadbandSarManager = "MobileBroadbandSarManager";

    static PyObject* _new_MobileBroadbandSarManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandSarManager);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandSarManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandSarManager_DisableBackoffAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.DisableBackoffAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_EnableBackoffAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.EnableBackoffAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_GetIsTransmittingAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetIsTransmittingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_RevertSarToHardwareControlAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RevertSarToHardwareControlAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_SetConfigurationAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar>>(args, 0);

                return py::convert(self->obj.SetConfigurationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_SetTransmissionStateChangedHysteresisAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.SetTransmissionStateChangedHysteresisAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_StartTransmissionStateMonitoring(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.StartTransmissionStateMonitoring();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_StopTransmissionStateMonitoring(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.StopTransmissionStateMonitoring();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_Antennas(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Antennas());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_HysteresisTimerPeriod(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HysteresisTimerPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_IsBackoffEnabled(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBackoffEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_IsSarControlledByHardware(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSarControlledByHardware());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_get_IsWiFiHardwareIntegrated(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWiFiHardwareIntegrated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_add_TransmissionStateChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSarManager, winrt::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs>>(arg);

            return py::convert(self->obj.TransmissionStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSarManager_remove_TransmissionStateChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TransmissionStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandSarManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSarManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandSarManager[] = {
        { "disable_backoff_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_DisableBackoffAsync), METH_VARARGS, nullptr },
        { "enable_backoff_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_EnableBackoffAsync), METH_VARARGS, nullptr },
        { "get_is_transmitting_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_GetIsTransmittingAsync), METH_VARARGS, nullptr },
        { "revert_sar_to_hardware_control_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_RevertSarToHardwareControlAsync), METH_VARARGS, nullptr },
        { "set_configuration_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_SetConfigurationAsync), METH_VARARGS, nullptr },
        { "set_transmission_state_changed_hysteresis_async", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_SetTransmissionStateChangedHysteresisAsync), METH_VARARGS, nullptr },
        { "start_transmission_state_monitoring", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_StartTransmissionStateMonitoring), METH_VARARGS, nullptr },
        { "stop_transmission_state_monitoring", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_StopTransmissionStateMonitoring), METH_VARARGS, nullptr },
        { "add_transmission_state_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_add_TransmissionStateChanged), METH_O, nullptr },
        { "remove_transmission_state_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSarManager_remove_TransmissionStateChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandSarManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandSarManager[] = {
        { "antennas", reinterpret_cast<getter>(MobileBroadbandSarManager_get_Antennas), nullptr, nullptr, nullptr },
        { "hysteresis_timer_period", reinterpret_cast<getter>(MobileBroadbandSarManager_get_HysteresisTimerPeriod), nullptr, nullptr, nullptr },
        { "is_backoff_enabled", reinterpret_cast<getter>(MobileBroadbandSarManager_get_IsBackoffEnabled), nullptr, nullptr, nullptr },
        { "is_sar_controlled_by_hardware", reinterpret_cast<getter>(MobileBroadbandSarManager_get_IsSarControlledByHardware), nullptr, nullptr, nullptr },
        { "is_wi_fi_hardware_integrated", reinterpret_cast<getter>(MobileBroadbandSarManager_get_IsWiFiHardwareIntegrated), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandSarManager[] = 
    {
        { Py_tp_new, _new_MobileBroadbandSarManager },
        { Py_tp_dealloc, _dealloc_MobileBroadbandSarManager },
        { Py_tp_methods, _methods_MobileBroadbandSarManager },
        { Py_tp_getset, _getset_MobileBroadbandSarManager },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandSarManager =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandSarManager",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSarManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandSarManager
    };

    // ----- MobileBroadbandSlotInfo class --------------------
    constexpr const char* const type_name_MobileBroadbandSlotInfo = "MobileBroadbandSlotInfo";

    static PyObject* _new_MobileBroadbandSlotInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandSlotInfo);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandSlotInfo(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandSlotInfo_get_Index(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Index());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotInfo_get_State(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandSlotInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandSlotInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandSlotInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandSlotInfo[] = {
        { "index", reinterpret_cast<getter>(MobileBroadbandSlotInfo_get_Index), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(MobileBroadbandSlotInfo_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandSlotInfo[] = 
    {
        { Py_tp_new, _new_MobileBroadbandSlotInfo },
        { Py_tp_dealloc, _dealloc_MobileBroadbandSlotInfo },
        { Py_tp_methods, _methods_MobileBroadbandSlotInfo },
        { Py_tp_getset, _getset_MobileBroadbandSlotInfo },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandSlotInfo =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandSlotInfo",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandSlotInfo
    };

    // ----- MobileBroadbandSlotInfoChangedEventArgs class --------------------
    constexpr const char* const type_name_MobileBroadbandSlotInfoChangedEventArgs = "MobileBroadbandSlotInfoChangedEventArgs";

    static PyObject* _new_MobileBroadbandSlotInfoChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandSlotInfoChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandSlotInfoChangedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandSlotInfoChangedEventArgs_get_SlotInfo(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SlotInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandSlotInfoChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandSlotInfoChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandSlotInfoChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandSlotInfoChangedEventArgs[] = {
        { "slot_info", reinterpret_cast<getter>(MobileBroadbandSlotInfoChangedEventArgs_get_SlotInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandSlotInfoChangedEventArgs[] = 
    {
        { Py_tp_new, _new_MobileBroadbandSlotInfoChangedEventArgs },
        { Py_tp_dealloc, _dealloc_MobileBroadbandSlotInfoChangedEventArgs },
        { Py_tp_methods, _methods_MobileBroadbandSlotInfoChangedEventArgs },
        { Py_tp_getset, _getset_MobileBroadbandSlotInfoChangedEventArgs },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandSlotInfoChangedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandSlotInfoChangedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandSlotInfoChangedEventArgs
    };

    // ----- MobileBroadbandSlotManager class --------------------
    constexpr const char* const type_name_MobileBroadbandSlotManager = "MobileBroadbandSlotManager";

    static PyObject* _new_MobileBroadbandSlotManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandSlotManager);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandSlotManager(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandSlotManager_SetCurrentSlot(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.SetCurrentSlot(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_SetCurrentSlotAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                return py::convert(self->obj.SetCurrentSlotAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_get_CurrentSlotIndex(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentSlotIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_get_SlotInfos(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SlotInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_add_CurrentSlotIndexChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager, winrt::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs>>(arg);

            return py::convert(self->obj.CurrentSlotIndexChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_remove_CurrentSlotIndexChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CurrentSlotIndexChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_add_SlotInfoChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager, winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs>>(arg);

            return py::convert(self->obj.SlotInfoChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandSlotManager_remove_SlotInfoChanged(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SlotInfoChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandSlotManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandSlotManager[] = {
        { "set_current_slot", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_SetCurrentSlot), METH_VARARGS, nullptr },
        { "set_current_slot_async", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_SetCurrentSlotAsync), METH_VARARGS, nullptr },
        { "add_current_slot_index_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_add_CurrentSlotIndexChanged), METH_O, nullptr },
        { "remove_current_slot_index_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_remove_CurrentSlotIndexChanged), METH_O, nullptr },
        { "add_slot_info_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_add_SlotInfoChanged), METH_O, nullptr },
        { "remove_slot_info_changed", reinterpret_cast<PyCFunction>(MobileBroadbandSlotManager_remove_SlotInfoChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandSlotManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandSlotManager[] = {
        { "current_slot_index", reinterpret_cast<getter>(MobileBroadbandSlotManager_get_CurrentSlotIndex), nullptr, nullptr, nullptr },
        { "slot_infos", reinterpret_cast<getter>(MobileBroadbandSlotManager_get_SlotInfos), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandSlotManager[] = 
    {
        { Py_tp_new, _new_MobileBroadbandSlotManager },
        { Py_tp_dealloc, _dealloc_MobileBroadbandSlotManager },
        { Py_tp_methods, _methods_MobileBroadbandSlotManager },
        { Py_tp_getset, _getset_MobileBroadbandSlotManager },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandSlotManager =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandSlotManager",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandSlotManager
    };

    // ----- MobileBroadbandTransmissionStateChangedEventArgs class --------------------
    constexpr const char* const type_name_MobileBroadbandTransmissionStateChangedEventArgs = "MobileBroadbandTransmissionStateChangedEventArgs";

    static PyObject* _new_MobileBroadbandTransmissionStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandTransmissionStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandTransmissionStateChangedEventArgs(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandTransmissionStateChangedEventArgs_get_IsTransmitting(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTransmitting());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandTransmissionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandTransmissionStateChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandTransmissionStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandTransmissionStateChangedEventArgs[] = {
        { "is_transmitting", reinterpret_cast<getter>(MobileBroadbandTransmissionStateChangedEventArgs_get_IsTransmitting), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandTransmissionStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_MobileBroadbandTransmissionStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_MobileBroadbandTransmissionStateChangedEventArgs },
        { Py_tp_methods, _methods_MobileBroadbandTransmissionStateChangedEventArgs },
        { Py_tp_getset, _getset_MobileBroadbandTransmissionStateChangedEventArgs },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandTransmissionStateChangedEventArgs =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandTransmissionStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandTransmissionStateChangedEventArgs
    };

    // ----- MobileBroadbandUicc class --------------------
    constexpr const char* const type_name_MobileBroadbandUicc = "MobileBroadbandUicc";

    static PyObject* _new_MobileBroadbandUicc(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandUicc);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUicc(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUicc* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUicc_GetUiccAppsAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUicc* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetUiccAppsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUicc_get_SimIccId(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUicc* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SimIccId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandUicc(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUicc>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUicc[] = {
        { "get_uicc_apps_async", reinterpret_cast<PyCFunction>(MobileBroadbandUicc_GetUiccAppsAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUicc), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUicc[] = {
        { "sim_icc_id", reinterpret_cast<getter>(MobileBroadbandUicc_get_SimIccId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUicc[] = 
    {
        { Py_tp_new, _new_MobileBroadbandUicc },
        { Py_tp_dealloc, _dealloc_MobileBroadbandUicc },
        { Py_tp_methods, _methods_MobileBroadbandUicc },
        { Py_tp_getset, _getset_MobileBroadbandUicc },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUicc =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandUicc",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUicc),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUicc
    };

    // ----- MobileBroadbandUiccApp class --------------------
    constexpr const char* const type_name_MobileBroadbandUiccApp = "MobileBroadbandUiccApp";

    static PyObject* _new_MobileBroadbandUiccApp(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandUiccApp);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUiccApp(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUiccApp_GetRecordDetailsAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 0);

                return py::convert(self->obj.GetRecordDetailsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccApp_ReadRecordAsync(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<uint32_t>>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.ReadRecordAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccApp_get_Id(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccApp_get_Kind(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandUiccApp(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUiccApp[] = {
        { "get_record_details_async", reinterpret_cast<PyCFunction>(MobileBroadbandUiccApp_GetRecordDetailsAsync), METH_VARARGS, nullptr },
        { "read_record_async", reinterpret_cast<PyCFunction>(MobileBroadbandUiccApp_ReadRecordAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUiccApp), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUiccApp[] = {
        { "id", reinterpret_cast<getter>(MobileBroadbandUiccApp_get_Id), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(MobileBroadbandUiccApp_get_Kind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUiccApp[] = 
    {
        { Py_tp_new, _new_MobileBroadbandUiccApp },
        { Py_tp_dealloc, _dealloc_MobileBroadbandUiccApp },
        { Py_tp_methods, _methods_MobileBroadbandUiccApp },
        { Py_tp_getset, _getset_MobileBroadbandUiccApp },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUiccApp =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandUiccApp",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUiccApp
    };

    // ----- MobileBroadbandUiccAppReadRecordResult class --------------------
    constexpr const char* const type_name_MobileBroadbandUiccAppReadRecordResult = "MobileBroadbandUiccAppReadRecordResult";

    static PyObject* _new_MobileBroadbandUiccAppReadRecordResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandUiccAppReadRecordResult);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUiccAppReadRecordResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUiccAppReadRecordResult_get_Data(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppReadRecordResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandUiccAppReadRecordResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUiccAppReadRecordResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUiccAppReadRecordResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUiccAppReadRecordResult[] = {
        { "data", reinterpret_cast<getter>(MobileBroadbandUiccAppReadRecordResult_get_Data), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MobileBroadbandUiccAppReadRecordResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUiccAppReadRecordResult[] = 
    {
        { Py_tp_new, _new_MobileBroadbandUiccAppReadRecordResult },
        { Py_tp_dealloc, _dealloc_MobileBroadbandUiccAppReadRecordResult },
        { Py_tp_methods, _methods_MobileBroadbandUiccAppReadRecordResult },
        { Py_tp_getset, _getset_MobileBroadbandUiccAppReadRecordResult },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUiccAppReadRecordResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandUiccAppReadRecordResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUiccAppReadRecordResult
    };

    // ----- MobileBroadbandUiccAppRecordDetailsResult class --------------------
    constexpr const char* const type_name_MobileBroadbandUiccAppRecordDetailsResult = "MobileBroadbandUiccAppRecordDetailsResult";

    static PyObject* _new_MobileBroadbandUiccAppRecordDetailsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandUiccAppRecordDetailsResult);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUiccAppRecordDetailsResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_Kind(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_ReadAccessCondition(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadAccessCondition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_RecordCount(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecordCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_RecordSize(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecordSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppRecordDetailsResult_get_WriteAccessCondition(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WriteAccessCondition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandUiccAppRecordDetailsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUiccAppRecordDetailsResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUiccAppRecordDetailsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUiccAppRecordDetailsResult[] = {
        { "kind", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_Kind), nullptr, nullptr, nullptr },
        { "read_access_condition", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_ReadAccessCondition), nullptr, nullptr, nullptr },
        { "record_count", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_RecordCount), nullptr, nullptr, nullptr },
        { "record_size", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_RecordSize), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_Status), nullptr, nullptr, nullptr },
        { "write_access_condition", reinterpret_cast<getter>(MobileBroadbandUiccAppRecordDetailsResult_get_WriteAccessCondition), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUiccAppRecordDetailsResult[] = 
    {
        { Py_tp_new, _new_MobileBroadbandUiccAppRecordDetailsResult },
        { Py_tp_dealloc, _dealloc_MobileBroadbandUiccAppRecordDetailsResult },
        { Py_tp_methods, _methods_MobileBroadbandUiccAppRecordDetailsResult },
        { Py_tp_getset, _getset_MobileBroadbandUiccAppRecordDetailsResult },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUiccAppRecordDetailsResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandUiccAppRecordDetailsResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUiccAppRecordDetailsResult
    };

    // ----- MobileBroadbandUiccAppsResult class --------------------
    constexpr const char* const type_name_MobileBroadbandUiccAppsResult = "MobileBroadbandUiccAppsResult";

    static PyObject* _new_MobileBroadbandUiccAppsResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MobileBroadbandUiccAppsResult);
        return nullptr;
    }

    static void _dealloc_MobileBroadbandUiccAppsResult(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MobileBroadbandUiccAppsResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MobileBroadbandUiccAppsResult_get_UiccApps(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UiccApps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MobileBroadbandUiccAppsResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MobileBroadbandUiccAppsResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MobileBroadbandUiccAppsResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MobileBroadbandUiccAppsResult[] = {
        { "status", reinterpret_cast<getter>(MobileBroadbandUiccAppsResult_get_Status), nullptr, nullptr, nullptr },
        { "uicc_apps", reinterpret_cast<getter>(MobileBroadbandUiccAppsResult_get_UiccApps), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MobileBroadbandUiccAppsResult[] = 
    {
        { Py_tp_new, _new_MobileBroadbandUiccAppsResult },
        { Py_tp_dealloc, _dealloc_MobileBroadbandUiccAppsResult },
        { Py_tp_methods, _methods_MobileBroadbandUiccAppsResult },
        { Py_tp_getset, _getset_MobileBroadbandUiccAppsResult },
        { },
    };

    static PyType_Spec type_spec_MobileBroadbandUiccAppsResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.MobileBroadbandUiccAppsResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MobileBroadbandUiccAppsResult
    };

    // ----- NetworkOperatorDataUsageTriggerDetails class --------------------
    constexpr const char* const type_name_NetworkOperatorDataUsageTriggerDetails = "NetworkOperatorDataUsageTriggerDetails";

    static PyObject* _new_NetworkOperatorDataUsageTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkOperatorDataUsageTriggerDetails);
        return nullptr;
    }

    static void _dealloc_NetworkOperatorDataUsageTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorDataUsageTriggerDetails_get_NotificationKind(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NotificationKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkOperatorDataUsageTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorDataUsageTriggerDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorDataUsageTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorDataUsageTriggerDetails[] = {
        { "notification_kind", reinterpret_cast<getter>(NetworkOperatorDataUsageTriggerDetails_get_NotificationKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorDataUsageTriggerDetails[] = 
    {
        { Py_tp_new, _new_NetworkOperatorDataUsageTriggerDetails },
        { Py_tp_dealloc, _dealloc_NetworkOperatorDataUsageTriggerDetails },
        { Py_tp_methods, _methods_NetworkOperatorDataUsageTriggerDetails },
        { Py_tp_getset, _getset_NetworkOperatorDataUsageTriggerDetails },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorDataUsageTriggerDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.NetworkOperatorDataUsageTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorDataUsageTriggerDetails
    };

    // ----- NetworkOperatorTetheringAccessPointConfiguration class --------------------
    constexpr const char* const type_name_NetworkOperatorTetheringAccessPointConfiguration = "NetworkOperatorTetheringAccessPointConfiguration";

    static PyObject* _new_NetworkOperatorTetheringAccessPointConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_NetworkOperatorTetheringAccessPointConfiguration(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_IsBandSupported(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::TetheringWiFiBand>(args, 0);

                return py::convert(self->obj.IsBandSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_IsBandSupportedAsync(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::TetheringWiFiBand>(args, 0);

                return py::convert(self->obj.IsBandSupportedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_get_Ssid(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Ssid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkOperatorTetheringAccessPointConfiguration_put_Ssid(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Ssid(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_get_Passphrase(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Passphrase());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkOperatorTetheringAccessPointConfiguration_put_Passphrase(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Passphrase(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NetworkOperatorTetheringAccessPointConfiguration_get_Band(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Band());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkOperatorTetheringAccessPointConfiguration_put_Band(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::TetheringWiFiBand>(arg);

            self->obj.Band(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_NetworkOperatorTetheringAccessPointConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorTetheringAccessPointConfiguration[] = {
        { "is_band_supported", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringAccessPointConfiguration_IsBandSupported), METH_VARARGS, nullptr },
        { "is_band_supported_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringAccessPointConfiguration_IsBandSupportedAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorTetheringAccessPointConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorTetheringAccessPointConfiguration[] = {
        { "ssid", reinterpret_cast<getter>(NetworkOperatorTetheringAccessPointConfiguration_get_Ssid), reinterpret_cast<setter>(NetworkOperatorTetheringAccessPointConfiguration_put_Ssid), nullptr, nullptr },
        { "passphrase", reinterpret_cast<getter>(NetworkOperatorTetheringAccessPointConfiguration_get_Passphrase), reinterpret_cast<setter>(NetworkOperatorTetheringAccessPointConfiguration_put_Passphrase), nullptr, nullptr },
        { "band", reinterpret_cast<getter>(NetworkOperatorTetheringAccessPointConfiguration_get_Band), reinterpret_cast<setter>(NetworkOperatorTetheringAccessPointConfiguration_put_Band), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorTetheringAccessPointConfiguration[] = 
    {
        { Py_tp_new, _new_NetworkOperatorTetheringAccessPointConfiguration },
        { Py_tp_dealloc, _dealloc_NetworkOperatorTetheringAccessPointConfiguration },
        { Py_tp_methods, _methods_NetworkOperatorTetheringAccessPointConfiguration },
        { Py_tp_getset, _getset_NetworkOperatorTetheringAccessPointConfiguration },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorTetheringAccessPointConfiguration =
    {
        "_winsdk_Windows_Networking_NetworkOperators.NetworkOperatorTetheringAccessPointConfiguration",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorTetheringAccessPointConfiguration
    };

    // ----- NetworkOperatorTetheringClient class --------------------
    constexpr const char* const type_name_NetworkOperatorTetheringClient = "NetworkOperatorTetheringClient";

    static PyObject* _new_NetworkOperatorTetheringClient(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkOperatorTetheringClient);
        return nullptr;
    }

    static void _dealloc_NetworkOperatorTetheringClient(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorTetheringClient_get_HostNames(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HostNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringClient_get_MacAddress(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MacAddress());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkOperatorTetheringClient(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorTetheringClient[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorTetheringClient), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorTetheringClient[] = {
        { "host_names", reinterpret_cast<getter>(NetworkOperatorTetheringClient_get_HostNames), nullptr, nullptr, nullptr },
        { "mac_address", reinterpret_cast<getter>(NetworkOperatorTetheringClient_get_MacAddress), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorTetheringClient[] = 
    {
        { Py_tp_new, _new_NetworkOperatorTetheringClient },
        { Py_tp_dealloc, _dealloc_NetworkOperatorTetheringClient },
        { Py_tp_methods, _methods_NetworkOperatorTetheringClient },
        { Py_tp_getset, _getset_NetworkOperatorTetheringClient },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorTetheringClient =
    {
        "_winsdk_Windows_Networking_NetworkOperators.NetworkOperatorTetheringClient",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorTetheringClient
    };

    // ----- NetworkOperatorTetheringManager class --------------------
    constexpr const char* const type_name_NetworkOperatorTetheringManager = "NetworkOperatorTetheringManager";

    static PyObject* _new_NetworkOperatorTetheringManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkOperatorTetheringManager);
        return nullptr;
    }

    static void _dealloc_NetworkOperatorTetheringManager(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorTetheringManager_ConfigureAccessPointAsync(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration>(args, 0);

                return py::convert(self->obj.ConfigureAccessPointAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_CreateFromConnectionProfile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfile>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::CreateFromConnectionProfile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkAdapter>(args, 1);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::CreateFromConnectionProfile(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_CreateFromNetworkAccountId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::CreateFromNetworkAccountId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_DisableNoConnectionsTimeout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::DisableNoConnectionsTimeout();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_DisableNoConnectionsTimeoutAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::DisableNoConnectionsTimeoutAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_EnableNoConnectionsTimeout(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::EnableNoConnectionsTimeout();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_EnableNoConnectionsTimeoutAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::EnableNoConnectionsTimeoutAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_GetCurrentAccessPointConfiguration(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentAccessPointConfiguration());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_GetTetheringCapability(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::GetTetheringCapability(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_GetTetheringCapabilityFromConnectionProfile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfile>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::GetTetheringCapabilityFromConnectionProfile(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_GetTetheringClients(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetTetheringClients());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_IsNoConnectionsTimeoutEnabled(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager::IsNoConnectionsTimeoutEnabled());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_StartTetheringAsync(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartTetheringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_StopTetheringAsync(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopTetheringAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_get_ClientCount(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_get_MaxClientCount(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxClientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringManager_get_TetheringOperationalState(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TetheringOperationalState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkOperatorTetheringManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorTetheringManager[] = {
        { "configure_access_point_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_ConfigureAccessPointAsync), METH_VARARGS, nullptr },
        { "create_from_connection_profile", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_CreateFromConnectionProfile), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_network_account_id", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_CreateFromNetworkAccountId), METH_VARARGS | METH_STATIC, nullptr },
        { "disable_no_connections_timeout", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_DisableNoConnectionsTimeout), METH_VARARGS | METH_STATIC, nullptr },
        { "disable_no_connections_timeout_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_DisableNoConnectionsTimeoutAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "enable_no_connections_timeout", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_EnableNoConnectionsTimeout), METH_VARARGS | METH_STATIC, nullptr },
        { "enable_no_connections_timeout_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_EnableNoConnectionsTimeoutAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_current_access_point_configuration", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_GetCurrentAccessPointConfiguration), METH_VARARGS, nullptr },
        { "get_tethering_capability", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_GetTetheringCapability), METH_VARARGS | METH_STATIC, nullptr },
        { "get_tethering_capability_from_connection_profile", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_GetTetheringCapabilityFromConnectionProfile), METH_VARARGS | METH_STATIC, nullptr },
        { "get_tethering_clients", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_GetTetheringClients), METH_VARARGS, nullptr },
        { "is_no_connections_timeout_enabled", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_IsNoConnectionsTimeoutEnabled), METH_VARARGS | METH_STATIC, nullptr },
        { "start_tethering_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_StartTetheringAsync), METH_VARARGS, nullptr },
        { "stop_tethering_async", reinterpret_cast<PyCFunction>(NetworkOperatorTetheringManager_StopTetheringAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorTetheringManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorTetheringManager[] = {
        { "client_count", reinterpret_cast<getter>(NetworkOperatorTetheringManager_get_ClientCount), nullptr, nullptr, nullptr },
        { "max_client_count", reinterpret_cast<getter>(NetworkOperatorTetheringManager_get_MaxClientCount), nullptr, nullptr, nullptr },
        { "tethering_operational_state", reinterpret_cast<getter>(NetworkOperatorTetheringManager_get_TetheringOperationalState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorTetheringManager[] = 
    {
        { Py_tp_new, _new_NetworkOperatorTetheringManager },
        { Py_tp_dealloc, _dealloc_NetworkOperatorTetheringManager },
        { Py_tp_methods, _methods_NetworkOperatorTetheringManager },
        { Py_tp_getset, _getset_NetworkOperatorTetheringManager },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorTetheringManager =
    {
        "_winsdk_Windows_Networking_NetworkOperators.NetworkOperatorTetheringManager",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorTetheringManager
    };

    // ----- NetworkOperatorTetheringOperationResult class --------------------
    constexpr const char* const type_name_NetworkOperatorTetheringOperationResult = "NetworkOperatorTetheringOperationResult";

    static PyObject* _new_NetworkOperatorTetheringOperationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_NetworkOperatorTetheringOperationResult);
        return nullptr;
    }

    static void _dealloc_NetworkOperatorTetheringOperationResult(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* NetworkOperatorTetheringOperationResult_get_AdditionalErrorMessage(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdditionalErrorMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkOperatorTetheringOperationResult_get_Status(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkOperatorTetheringOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkOperatorTetheringOperationResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkOperatorTetheringOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkOperatorTetheringOperationResult[] = {
        { "additional_error_message", reinterpret_cast<getter>(NetworkOperatorTetheringOperationResult_get_AdditionalErrorMessage), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(NetworkOperatorTetheringOperationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkOperatorTetheringOperationResult[] = 
    {
        { Py_tp_new, _new_NetworkOperatorTetheringOperationResult },
        { Py_tp_dealloc, _dealloc_NetworkOperatorTetheringOperationResult },
        { Py_tp_methods, _methods_NetworkOperatorTetheringOperationResult },
        { Py_tp_getset, _getset_NetworkOperatorTetheringOperationResult },
        { },
    };

    static PyType_Spec type_spec_NetworkOperatorTetheringOperationResult =
    {
        "_winsdk_Windows_Networking_NetworkOperators.NetworkOperatorTetheringOperationResult",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkOperatorTetheringOperationResult
    };

    // ----- ProvisionFromXmlDocumentResults class --------------------
    constexpr const char* const type_name_ProvisionFromXmlDocumentResults = "ProvisionFromXmlDocumentResults";

    static PyObject* _new_ProvisionFromXmlDocumentResults(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProvisionFromXmlDocumentResults);
        return nullptr;
    }

    static void _dealloc_ProvisionFromXmlDocumentResults(py::wrapper::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProvisionFromXmlDocumentResults_get_AllElementsProvisioned(py::wrapper::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllElementsProvisioned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProvisionFromXmlDocumentResults_get_ProvisionResultsXml(py::wrapper::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProvisionResultsXml());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProvisionFromXmlDocumentResults(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProvisionFromXmlDocumentResults[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ProvisionFromXmlDocumentResults), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProvisionFromXmlDocumentResults[] = {
        { "all_elements_provisioned", reinterpret_cast<getter>(ProvisionFromXmlDocumentResults_get_AllElementsProvisioned), nullptr, nullptr, nullptr },
        { "provision_results_xml", reinterpret_cast<getter>(ProvisionFromXmlDocumentResults_get_ProvisionResultsXml), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProvisionFromXmlDocumentResults[] = 
    {
        { Py_tp_new, _new_ProvisionFromXmlDocumentResults },
        { Py_tp_dealloc, _dealloc_ProvisionFromXmlDocumentResults },
        { Py_tp_methods, _methods_ProvisionFromXmlDocumentResults },
        { Py_tp_getset, _getset_ProvisionFromXmlDocumentResults },
        { },
    };

    static PyType_Spec type_spec_ProvisionFromXmlDocumentResults =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ProvisionFromXmlDocumentResults",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProvisionFromXmlDocumentResults
    };

    // ----- ProvisionedProfile class --------------------
    constexpr const char* const type_name_ProvisionedProfile = "ProvisionedProfile";

    static PyObject* _new_ProvisionedProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProvisionedProfile);
        return nullptr;
    }

    static void _dealloc_ProvisionedProfile(py::wrapper::Windows::Networking::NetworkOperators::ProvisionedProfile* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProvisionedProfile_UpdateCost(py::wrapper::Windows::Networking::NetworkOperators::ProvisionedProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkCostType>(args, 0);

                self->obj.UpdateCost(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProvisionedProfile_UpdateUsage(py::wrapper::Windows::Networking::NetworkOperators::ProvisionedProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::ProfileUsage>(args, 0);

                self->obj.UpdateUsage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ProvisionedProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ProvisionedProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProvisionedProfile[] = {
        { "update_cost", reinterpret_cast<PyCFunction>(ProvisionedProfile_UpdateCost), METH_VARARGS, nullptr },
        { "update_usage", reinterpret_cast<PyCFunction>(ProvisionedProfile_UpdateUsage), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProvisionedProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProvisionedProfile[] = {
        { }
    };

    static PyType_Slot _type_slots_ProvisionedProfile[] = 
    {
        { Py_tp_new, _new_ProvisionedProfile },
        { Py_tp_dealloc, _dealloc_ProvisionedProfile },
        { Py_tp_methods, _methods_ProvisionedProfile },
        { Py_tp_getset, _getset_ProvisionedProfile },
        { },
    };

    static PyType_Spec type_spec_ProvisionedProfile =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ProvisionedProfile",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ProvisionedProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProvisionedProfile
    };

    // ----- ProvisioningAgent class --------------------
    constexpr const char* const type_name_ProvisioningAgent = "ProvisioningAgent";

    static PyObject* _new_ProvisioningAgent(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::ProvisioningAgent instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ProvisioningAgent(py::wrapper::Windows::Networking::NetworkOperators::ProvisioningAgent* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProvisioningAgent_CreateFromNetworkAccountId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::ProvisioningAgent::CreateFromNetworkAccountId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProvisioningAgent_GetProvisionedProfile(py::wrapper::Windows::Networking::NetworkOperators::ProvisioningAgent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::ProfileMediaType>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetProvisionedProfile(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProvisioningAgent_ProvisionFromXmlDocumentAsync(py::wrapper::Windows::Networking::NetworkOperators::ProvisioningAgent* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ProvisionFromXmlDocumentAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ProvisioningAgent(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::ProvisioningAgent>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProvisioningAgent[] = {
        { "create_from_network_account_id", reinterpret_cast<PyCFunction>(ProvisioningAgent_CreateFromNetworkAccountId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_provisioned_profile", reinterpret_cast<PyCFunction>(ProvisioningAgent_GetProvisionedProfile), METH_VARARGS, nullptr },
        { "provision_from_xml_document_async", reinterpret_cast<PyCFunction>(ProvisioningAgent_ProvisionFromXmlDocumentAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProvisioningAgent), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProvisioningAgent[] = {
        { }
    };

    static PyType_Slot _type_slots_ProvisioningAgent[] = 
    {
        { Py_tp_new, _new_ProvisioningAgent },
        { Py_tp_dealloc, _dealloc_ProvisioningAgent },
        { Py_tp_methods, _methods_ProvisioningAgent },
        { Py_tp_getset, _getset_ProvisioningAgent },
        { },
    };

    static PyType_Spec type_spec_ProvisioningAgent =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ProvisioningAgent",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ProvisioningAgent),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProvisioningAgent
    };

    // ----- TetheringEntitlementCheckTriggerDetails class --------------------
    constexpr const char* const type_name_TetheringEntitlementCheckTriggerDetails = "TetheringEntitlementCheckTriggerDetails";

    static PyObject* _new_TetheringEntitlementCheckTriggerDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TetheringEntitlementCheckTriggerDetails);
        return nullptr;
    }

    static void _dealloc_TetheringEntitlementCheckTriggerDetails(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TetheringEntitlementCheckTriggerDetails_AllowTethering(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.AllowTethering();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TetheringEntitlementCheckTriggerDetails_DenyTethering(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.DenyTethering(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TetheringEntitlementCheckTriggerDetails_get_NetworkAccountId(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAccountId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TetheringEntitlementCheckTriggerDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TetheringEntitlementCheckTriggerDetails[] = {
        { "allow_tethering", reinterpret_cast<PyCFunction>(TetheringEntitlementCheckTriggerDetails_AllowTethering), METH_VARARGS, nullptr },
        { "deny_tethering", reinterpret_cast<PyCFunction>(TetheringEntitlementCheckTriggerDetails_DenyTethering), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TetheringEntitlementCheckTriggerDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TetheringEntitlementCheckTriggerDetails[] = {
        { "network_account_id", reinterpret_cast<getter>(TetheringEntitlementCheckTriggerDetails_get_NetworkAccountId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TetheringEntitlementCheckTriggerDetails[] = 
    {
        { Py_tp_new, _new_TetheringEntitlementCheckTriggerDetails },
        { Py_tp_dealloc, _dealloc_TetheringEntitlementCheckTriggerDetails },
        { Py_tp_methods, _methods_TetheringEntitlementCheckTriggerDetails },
        { Py_tp_getset, _getset_TetheringEntitlementCheckTriggerDetails },
        { },
    };

    static PyType_Spec type_spec_TetheringEntitlementCheckTriggerDetails =
    {
        "_winsdk_Windows_Networking_NetworkOperators.TetheringEntitlementCheckTriggerDetails",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TetheringEntitlementCheckTriggerDetails
    };

    // ----- UssdMessage class --------------------
    constexpr const char* const type_name_UssdMessage = "UssdMessage";

    static PyObject* _new_UssdMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Networking::NetworkOperators::UssdMessage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UssdMessage(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UssdMessage_GetPayload(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPayload());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdMessage_SetPayload(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetPayload(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdMessage_get_PayloadAsText(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PayloadAsText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UssdMessage_put_PayloadAsText(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.PayloadAsText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UssdMessage_get_DataCodingScheme(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataCodingScheme());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UssdMessage_put_DataCodingScheme(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.DataCodingScheme(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_UssdMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::UssdMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UssdMessage[] = {
        { "get_payload", reinterpret_cast<PyCFunction>(UssdMessage_GetPayload), METH_VARARGS, nullptr },
        { "set_payload", reinterpret_cast<PyCFunction>(UssdMessage_SetPayload), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UssdMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UssdMessage[] = {
        { "payload_as_text", reinterpret_cast<getter>(UssdMessage_get_PayloadAsText), reinterpret_cast<setter>(UssdMessage_put_PayloadAsText), nullptr, nullptr },
        { "data_coding_scheme", reinterpret_cast<getter>(UssdMessage_get_DataCodingScheme), reinterpret_cast<setter>(UssdMessage_put_DataCodingScheme), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UssdMessage[] = 
    {
        { Py_tp_new, _new_UssdMessage },
        { Py_tp_dealloc, _dealloc_UssdMessage },
        { Py_tp_methods, _methods_UssdMessage },
        { Py_tp_getset, _getset_UssdMessage },
        { },
    };

    static PyType_Spec type_spec_UssdMessage =
    {
        "_winsdk_Windows_Networking_NetworkOperators.UssdMessage",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::UssdMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UssdMessage
    };

    // ----- UssdReply class --------------------
    constexpr const char* const type_name_UssdReply = "UssdReply";

    static PyObject* _new_UssdReply(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UssdReply);
        return nullptr;
    }

    static void _dealloc_UssdReply(py::wrapper::Windows::Networking::NetworkOperators::UssdReply* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UssdReply_get_Message(py::wrapper::Windows::Networking::NetworkOperators::UssdReply* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UssdReply_get_ResultCode(py::wrapper::Windows::Networking::NetworkOperators::UssdReply* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ResultCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UssdReply(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::UssdReply>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UssdReply[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UssdReply), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UssdReply[] = {
        { "message", reinterpret_cast<getter>(UssdReply_get_Message), nullptr, nullptr, nullptr },
        { "result_code", reinterpret_cast<getter>(UssdReply_get_ResultCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UssdReply[] = 
    {
        { Py_tp_new, _new_UssdReply },
        { Py_tp_dealloc, _dealloc_UssdReply },
        { Py_tp_methods, _methods_UssdReply },
        { Py_tp_getset, _getset_UssdReply },
        { },
    };

    static PyType_Spec type_spec_UssdReply =
    {
        "_winsdk_Windows_Networking_NetworkOperators.UssdReply",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::UssdReply),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UssdReply
    };

    // ----- UssdSession class --------------------
    constexpr const char* const type_name_UssdSession = "UssdSession";

    static PyObject* _new_UssdSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UssdSession);
        return nullptr;
    }

    static void _dealloc_UssdSession(py::wrapper::Windows::Networking::NetworkOperators::UssdSession* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UssdSession_Close(py::wrapper::Windows::Networking::NetworkOperators::UssdSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdSession_CreateFromNetworkAccountId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::UssdSession::CreateFromNetworkAccountId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdSession_CreateFromNetworkInterfaceId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Networking::NetworkOperators::UssdSession::CreateFromNetworkInterfaceId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UssdSession_SendMessageAndGetReplyAsync(py::wrapper::Windows::Networking::NetworkOperators::UssdSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::NetworkOperators::UssdMessage>(args, 0);

                return py::convert(self->obj.SendMessageAndGetReplyAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_UssdSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::NetworkOperators::UssdSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UssdSession[] = {
        { "close", reinterpret_cast<PyCFunction>(UssdSession_Close), METH_VARARGS, nullptr },
        { "create_from_network_account_id", reinterpret_cast<PyCFunction>(UssdSession_CreateFromNetworkAccountId), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_network_interface_id", reinterpret_cast<PyCFunction>(UssdSession_CreateFromNetworkInterfaceId), METH_VARARGS | METH_STATIC, nullptr },
        { "send_message_and_get_reply_async", reinterpret_cast<PyCFunction>(UssdSession_SendMessageAndGetReplyAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UssdSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UssdSession[] = {
        { }
    };

    static PyType_Slot _type_slots_UssdSession[] = 
    {
        { Py_tp_new, _new_UssdSession },
        { Py_tp_dealloc, _dealloc_UssdSession },
        { Py_tp_methods, _methods_UssdSession },
        { Py_tp_getset, _getset_UssdSession },
        { },
    };

    static PyType_Spec type_spec_UssdSession =
    {
        "_winsdk_Windows_Networking_NetworkOperators.UssdSession",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::UssdSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UssdSession
    };

    // ----- ESimProfileInstallProgress struct --------------------
    constexpr const char* const type_name_ESimProfileInstallProgress = "ESimProfileInstallProgress";

    PyObject* _new_ESimProfileInstallProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _TotalSizeInBytes{};
        int32_t _InstalledSizeInBytes{};

        static const char* kwlist[] = {"total_size_in_bytes", "installed_size_in_bytes", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_TotalSizeInBytes, &_InstalledSizeInBytes))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress return_value{ _TotalSizeInBytes, _InstalledSizeInBytes };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_ESimProfileInstallProgress(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self)
    {
    }

    static PyObject* ESimProfileInstallProgress_get_TotalSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalSizeInBytes);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ESimProfileInstallProgress_set_TotalSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.TotalSizeInBytes = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ESimProfileInstallProgress_get_InstalledSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstalledSizeInBytes);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ESimProfileInstallProgress_set_InstalledSizeInBytes(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.InstalledSizeInBytes = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_ESimProfileInstallProgress[] = {
        { "total_size_in_bytes", reinterpret_cast<getter>(ESimProfileInstallProgress_get_TotalSizeInBytes), reinterpret_cast<setter>(ESimProfileInstallProgress_set_TotalSizeInBytes), nullptr, nullptr },
        { "installed_size_in_bytes", reinterpret_cast<getter>(ESimProfileInstallProgress_get_InstalledSizeInBytes), reinterpret_cast<setter>(ESimProfileInstallProgress_set_InstalledSizeInBytes), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ESimProfileInstallProgress[] = 
    {
        { Py_tp_new, _new_ESimProfileInstallProgress },
        { Py_tp_dealloc, _dealloc_ESimProfileInstallProgress },
        { Py_tp_getset, _getset_ESimProfileInstallProgress },
        { },
    };

    static PyType_Spec type_spec_ESimProfileInstallProgress =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ESimProfileInstallProgress",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ESimProfileInstallProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ESimProfileInstallProgress
    };

    // ----- ProfileUsage struct --------------------
    constexpr const char* const type_name_ProfileUsage = "ProfileUsage";

    PyObject* _new_ProfileUsage(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::NetworkOperators::ProfileUsage return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Networking::NetworkOperators::ProfileUsage>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _UsageInMegabytes{};
        PyObject* _LastSyncTime{};

        static const char* kwlist[] = {"usage_in_megabytes", "last_sync_time", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IO", const_cast<char**>(kwlist), &_UsageInMegabytes, &_LastSyncTime))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::NetworkOperators::ProfileUsage return_value{ _UsageInMegabytes, py::converter<winrt::Windows::Foundation::DateTime>::convert_to(_LastSyncTime) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_ProfileUsage(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self)
    {
    }

    static PyObject* ProfileUsage_get_UsageInMegabytes(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsageInMegabytes);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProfileUsage_set_UsageInMegabytes(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.UsageInMegabytes = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ProfileUsage_get_LastSyncTime(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastSyncTime);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ProfileUsage_set_LastSyncTime(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.LastSyncTime = py::converter<winrt::Windows::Foundation::DateTime>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_ProfileUsage[] = {
        { "usage_in_megabytes", reinterpret_cast<getter>(ProfileUsage_get_UsageInMegabytes), reinterpret_cast<setter>(ProfileUsage_set_UsageInMegabytes), nullptr, nullptr },
        { "last_sync_time", reinterpret_cast<getter>(ProfileUsage_get_LastSyncTime), reinterpret_cast<setter>(ProfileUsage_set_LastSyncTime), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProfileUsage[] = 
    {
        { Py_tp_new, _new_ProfileUsage },
        { Py_tp_dealloc, _dealloc_ProfileUsage },
        { Py_tp_getset, _getset_ProfileUsage },
        { },
    };

    static PyType_Spec type_spec_ProfileUsage =
    {
        "_winsdk_Windows_Networking_NetworkOperators.ProfileUsage",
        sizeof(py::wrapper::Windows::Networking::NetworkOperators::ProfileUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProfileUsage
    };

    // ----- Windows.Networking.NetworkOperators Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Networking::NetworkOperators");

    static PyMethodDef module_methods[] = {
        {"_register_DataClasses", register_DataClasses, METH_O, "registers type"},
        {"_register_ESimAuthenticationPreference", register_ESimAuthenticationPreference, METH_O, "registers type"},
        {"_register_ESimDiscoverResultKind", register_ESimDiscoverResultKind, METH_O, "registers type"},
        {"_register_ESimOperationStatus", register_ESimOperationStatus, METH_O, "registers type"},
        {"_register_ESimProfileClass", register_ESimProfileClass, METH_O, "registers type"},
        {"_register_ESimProfileMetadataState", register_ESimProfileMetadataState, METH_O, "registers type"},
        {"_register_ESimProfileState", register_ESimProfileState, METH_O, "registers type"},
        {"_register_ESimState", register_ESimState, METH_O, "registers type"},
        {"_register_ESimWatcherStatus", register_ESimWatcherStatus, METH_O, "registers type"},
        {"_register_HotspotAuthenticationResponseCode", register_HotspotAuthenticationResponseCode, METH_O, "registers type"},
        {"_register_MobileBroadbandAccountWatcherStatus", register_MobileBroadbandAccountWatcherStatus, METH_O, "registers type"},
        {"_register_MobileBroadbandDeviceType", register_MobileBroadbandDeviceType, METH_O, "registers type"},
        {"_register_MobileBroadbandModemStatus", register_MobileBroadbandModemStatus, METH_O, "registers type"},
        {"_register_MobileBroadbandPinFormat", register_MobileBroadbandPinFormat, METH_O, "registers type"},
        {"_register_MobileBroadbandPinLockState", register_MobileBroadbandPinLockState, METH_O, "registers type"},
        {"_register_MobileBroadbandPinType", register_MobileBroadbandPinType, METH_O, "registers type"},
        {"_register_MobileBroadbandRadioState", register_MobileBroadbandRadioState, METH_O, "registers type"},
        {"_register_MobileBroadbandSlotState", register_MobileBroadbandSlotState, METH_O, "registers type"},
        {"_register_MobileBroadbandUiccAppOperationStatus", register_MobileBroadbandUiccAppOperationStatus, METH_O, "registers type"},
        {"_register_NetworkDeviceStatus", register_NetworkDeviceStatus, METH_O, "registers type"},
        {"_register_NetworkOperatorDataUsageNotificationKind", register_NetworkOperatorDataUsageNotificationKind, METH_O, "registers type"},
        {"_register_NetworkOperatorEventMessageType", register_NetworkOperatorEventMessageType, METH_O, "registers type"},
        {"_register_NetworkRegistrationState", register_NetworkRegistrationState, METH_O, "registers type"},
        {"_register_ProfileMediaType", register_ProfileMediaType, METH_O, "registers type"},
        {"_register_TetheringCapability", register_TetheringCapability, METH_O, "registers type"},
        {"_register_TetheringOperationStatus", register_TetheringOperationStatus, METH_O, "registers type"},
        {"_register_TetheringOperationalState", register_TetheringOperationalState, METH_O, "registers type"},
        {"_register_TetheringWiFiBand", register_TetheringWiFiBand, METH_O, "registers type"},
        {"_register_UiccAccessCondition", register_UiccAccessCondition, METH_O, "registers type"},
        {"_register_UiccAppKind", register_UiccAppKind, METH_O, "registers type"},
        {"_register_UiccAppRecordKind", register_UiccAppRecordKind, METH_O, "registers type"},
        {"_register_UssdResultCode", register_UssdResultCode, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_DataClasses);
        Py_VISIT(state->type_ESimAuthenticationPreference);
        Py_VISIT(state->type_ESimDiscoverResultKind);
        Py_VISIT(state->type_ESimOperationStatus);
        Py_VISIT(state->type_ESimProfileClass);
        Py_VISIT(state->type_ESimProfileMetadataState);
        Py_VISIT(state->type_ESimProfileState);
        Py_VISIT(state->type_ESimState);
        Py_VISIT(state->type_ESimWatcherStatus);
        Py_VISIT(state->type_HotspotAuthenticationResponseCode);
        Py_VISIT(state->type_MobileBroadbandAccountWatcherStatus);
        Py_VISIT(state->type_MobileBroadbandDeviceType);
        Py_VISIT(state->type_MobileBroadbandModemStatus);
        Py_VISIT(state->type_MobileBroadbandPinFormat);
        Py_VISIT(state->type_MobileBroadbandPinLockState);
        Py_VISIT(state->type_MobileBroadbandPinType);
        Py_VISIT(state->type_MobileBroadbandRadioState);
        Py_VISIT(state->type_MobileBroadbandSlotState);
        Py_VISIT(state->type_MobileBroadbandUiccAppOperationStatus);
        Py_VISIT(state->type_NetworkDeviceStatus);
        Py_VISIT(state->type_NetworkOperatorDataUsageNotificationKind);
        Py_VISIT(state->type_NetworkOperatorEventMessageType);
        Py_VISIT(state->type_NetworkRegistrationState);
        Py_VISIT(state->type_ProfileMediaType);
        Py_VISIT(state->type_TetheringCapability);
        Py_VISIT(state->type_TetheringOperationStatus);
        Py_VISIT(state->type_TetheringOperationalState);
        Py_VISIT(state->type_TetheringWiFiBand);
        Py_VISIT(state->type_UiccAccessCondition);
        Py_VISIT(state->type_UiccAppKind);
        Py_VISIT(state->type_UiccAppRecordKind);
        Py_VISIT(state->type_UssdResultCode);
        Py_VISIT(state->type_ESim);
        Py_VISIT(state->type_ESimAddedEventArgs);
        Py_VISIT(state->type_ESimDiscoverEvent);
        Py_VISIT(state->type_ESimDiscoverResult);
        Py_VISIT(state->type_ESimDownloadProfileMetadataResult);
        Py_VISIT(state->type_ESimManager);
        Py_VISIT(state->type_ESimOperationResult);
        Py_VISIT(state->type_ESimPolicy);
        Py_VISIT(state->type_ESimProfile);
        Py_VISIT(state->type_ESimProfileMetadata);
        Py_VISIT(state->type_ESimProfilePolicy);
        Py_VISIT(state->type_ESimRemovedEventArgs);
        Py_VISIT(state->type_ESimServiceInfo);
        Py_VISIT(state->type_ESimUpdatedEventArgs);
        Py_VISIT(state->type_ESimWatcher);
        Py_VISIT(state->type_HotspotAuthenticationContext);
        Py_VISIT(state->type_HotspotAuthenticationEventDetails);
        Py_VISIT(state->type_HotspotCredentialsAuthenticationResult);
        Py_VISIT(state->type_KnownCSimFilePaths);
        Py_VISIT(state->type_KnownRuimFilePaths);
        Py_VISIT(state->type_KnownSimFilePaths);
        Py_VISIT(state->type_KnownUSimFilePaths);
        Py_VISIT(state->type_MobileBroadbandAccount);
        Py_VISIT(state->type_MobileBroadbandAccountEventArgs);
        Py_VISIT(state->type_MobileBroadbandAccountUpdatedEventArgs);
        Py_VISIT(state->type_MobileBroadbandAccountWatcher);
        Py_VISIT(state->type_MobileBroadbandAntennaSar);
        Py_VISIT(state->type_MobileBroadbandCellCdma);
        Py_VISIT(state->type_MobileBroadbandCellGsm);
        Py_VISIT(state->type_MobileBroadbandCellLte);
        Py_VISIT(state->type_MobileBroadbandCellNR);
        Py_VISIT(state->type_MobileBroadbandCellTdscdma);
        Py_VISIT(state->type_MobileBroadbandCellUmts);
        Py_VISIT(state->type_MobileBroadbandCellsInfo);
        Py_VISIT(state->type_MobileBroadbandCurrentSlotIndexChangedEventArgs);
        Py_VISIT(state->type_MobileBroadbandDeviceInformation);
        Py_VISIT(state->type_MobileBroadbandDeviceService);
        Py_VISIT(state->type_MobileBroadbandDeviceServiceCommandResult);
        Py_VISIT(state->type_MobileBroadbandDeviceServiceCommandSession);
        Py_VISIT(state->type_MobileBroadbandDeviceServiceDataReceivedEventArgs);
        Py_VISIT(state->type_MobileBroadbandDeviceServiceDataSession);
        Py_VISIT(state->type_MobileBroadbandDeviceServiceInformation);
        Py_VISIT(state->type_MobileBroadbandDeviceServiceTriggerDetails);
        Py_VISIT(state->type_MobileBroadbandModem);
        Py_VISIT(state->type_MobileBroadbandModemConfiguration);
        Py_VISIT(state->type_MobileBroadbandModemIsolation);
        Py_VISIT(state->type_MobileBroadbandNetwork);
        Py_VISIT(state->type_MobileBroadbandNetworkRegistrationStateChange);
        Py_VISIT(state->type_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails);
        Py_VISIT(state->type_MobileBroadbandPco);
        Py_VISIT(state->type_MobileBroadbandPcoDataChangeTriggerDetails);
        Py_VISIT(state->type_MobileBroadbandPin);
        Py_VISIT(state->type_MobileBroadbandPinLockStateChange);
        Py_VISIT(state->type_MobileBroadbandPinLockStateChangeTriggerDetails);
        Py_VISIT(state->type_MobileBroadbandPinManager);
        Py_VISIT(state->type_MobileBroadbandPinOperationResult);
        Py_VISIT(state->type_MobileBroadbandRadioStateChange);
        Py_VISIT(state->type_MobileBroadbandRadioStateChangeTriggerDetails);
        Py_VISIT(state->type_MobileBroadbandSarManager);
        Py_VISIT(state->type_MobileBroadbandSlotInfo);
        Py_VISIT(state->type_MobileBroadbandSlotInfoChangedEventArgs);
        Py_VISIT(state->type_MobileBroadbandSlotManager);
        Py_VISIT(state->type_MobileBroadbandTransmissionStateChangedEventArgs);
        Py_VISIT(state->type_MobileBroadbandUicc);
        Py_VISIT(state->type_MobileBroadbandUiccApp);
        Py_VISIT(state->type_MobileBroadbandUiccAppReadRecordResult);
        Py_VISIT(state->type_MobileBroadbandUiccAppRecordDetailsResult);
        Py_VISIT(state->type_MobileBroadbandUiccAppsResult);
        Py_VISIT(state->type_NetworkOperatorDataUsageTriggerDetails);
        Py_VISIT(state->type_NetworkOperatorTetheringAccessPointConfiguration);
        Py_VISIT(state->type_NetworkOperatorTetheringClient);
        Py_VISIT(state->type_NetworkOperatorTetheringManager);
        Py_VISIT(state->type_NetworkOperatorTetheringOperationResult);
        Py_VISIT(state->type_ProvisionFromXmlDocumentResults);
        Py_VISIT(state->type_ProvisionedProfile);
        Py_VISIT(state->type_ProvisioningAgent);
        Py_VISIT(state->type_TetheringEntitlementCheckTriggerDetails);
        Py_VISIT(state->type_UssdMessage);
        Py_VISIT(state->type_UssdReply);
        Py_VISIT(state->type_UssdSession);
        Py_VISIT(state->type_ESimProfileInstallProgress);
        Py_VISIT(state->type_ProfileUsage);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_DataClasses);
        Py_CLEAR(state->type_ESimAuthenticationPreference);
        Py_CLEAR(state->type_ESimDiscoverResultKind);
        Py_CLEAR(state->type_ESimOperationStatus);
        Py_CLEAR(state->type_ESimProfileClass);
        Py_CLEAR(state->type_ESimProfileMetadataState);
        Py_CLEAR(state->type_ESimProfileState);
        Py_CLEAR(state->type_ESimState);
        Py_CLEAR(state->type_ESimWatcherStatus);
        Py_CLEAR(state->type_HotspotAuthenticationResponseCode);
        Py_CLEAR(state->type_MobileBroadbandAccountWatcherStatus);
        Py_CLEAR(state->type_MobileBroadbandDeviceType);
        Py_CLEAR(state->type_MobileBroadbandModemStatus);
        Py_CLEAR(state->type_MobileBroadbandPinFormat);
        Py_CLEAR(state->type_MobileBroadbandPinLockState);
        Py_CLEAR(state->type_MobileBroadbandPinType);
        Py_CLEAR(state->type_MobileBroadbandRadioState);
        Py_CLEAR(state->type_MobileBroadbandSlotState);
        Py_CLEAR(state->type_MobileBroadbandUiccAppOperationStatus);
        Py_CLEAR(state->type_NetworkDeviceStatus);
        Py_CLEAR(state->type_NetworkOperatorDataUsageNotificationKind);
        Py_CLEAR(state->type_NetworkOperatorEventMessageType);
        Py_CLEAR(state->type_NetworkRegistrationState);
        Py_CLEAR(state->type_ProfileMediaType);
        Py_CLEAR(state->type_TetheringCapability);
        Py_CLEAR(state->type_TetheringOperationStatus);
        Py_CLEAR(state->type_TetheringOperationalState);
        Py_CLEAR(state->type_TetheringWiFiBand);
        Py_CLEAR(state->type_UiccAccessCondition);
        Py_CLEAR(state->type_UiccAppKind);
        Py_CLEAR(state->type_UiccAppRecordKind);
        Py_CLEAR(state->type_UssdResultCode);
        Py_CLEAR(state->type_ESim);
        Py_CLEAR(state->type_ESimAddedEventArgs);
        Py_CLEAR(state->type_ESimDiscoverEvent);
        Py_CLEAR(state->type_ESimDiscoverResult);
        Py_CLEAR(state->type_ESimDownloadProfileMetadataResult);
        Py_CLEAR(state->type_ESimManager);
        Py_CLEAR(state->type_ESimOperationResult);
        Py_CLEAR(state->type_ESimPolicy);
        Py_CLEAR(state->type_ESimProfile);
        Py_CLEAR(state->type_ESimProfileMetadata);
        Py_CLEAR(state->type_ESimProfilePolicy);
        Py_CLEAR(state->type_ESimRemovedEventArgs);
        Py_CLEAR(state->type_ESimServiceInfo);
        Py_CLEAR(state->type_ESimUpdatedEventArgs);
        Py_CLEAR(state->type_ESimWatcher);
        Py_CLEAR(state->type_HotspotAuthenticationContext);
        Py_CLEAR(state->type_HotspotAuthenticationEventDetails);
        Py_CLEAR(state->type_HotspotCredentialsAuthenticationResult);
        Py_CLEAR(state->type_KnownCSimFilePaths);
        Py_CLEAR(state->type_KnownRuimFilePaths);
        Py_CLEAR(state->type_KnownSimFilePaths);
        Py_CLEAR(state->type_KnownUSimFilePaths);
        Py_CLEAR(state->type_MobileBroadbandAccount);
        Py_CLEAR(state->type_MobileBroadbandAccountEventArgs);
        Py_CLEAR(state->type_MobileBroadbandAccountUpdatedEventArgs);
        Py_CLEAR(state->type_MobileBroadbandAccountWatcher);
        Py_CLEAR(state->type_MobileBroadbandAntennaSar);
        Py_CLEAR(state->type_MobileBroadbandCellCdma);
        Py_CLEAR(state->type_MobileBroadbandCellGsm);
        Py_CLEAR(state->type_MobileBroadbandCellLte);
        Py_CLEAR(state->type_MobileBroadbandCellNR);
        Py_CLEAR(state->type_MobileBroadbandCellTdscdma);
        Py_CLEAR(state->type_MobileBroadbandCellUmts);
        Py_CLEAR(state->type_MobileBroadbandCellsInfo);
        Py_CLEAR(state->type_MobileBroadbandCurrentSlotIndexChangedEventArgs);
        Py_CLEAR(state->type_MobileBroadbandDeviceInformation);
        Py_CLEAR(state->type_MobileBroadbandDeviceService);
        Py_CLEAR(state->type_MobileBroadbandDeviceServiceCommandResult);
        Py_CLEAR(state->type_MobileBroadbandDeviceServiceCommandSession);
        Py_CLEAR(state->type_MobileBroadbandDeviceServiceDataReceivedEventArgs);
        Py_CLEAR(state->type_MobileBroadbandDeviceServiceDataSession);
        Py_CLEAR(state->type_MobileBroadbandDeviceServiceInformation);
        Py_CLEAR(state->type_MobileBroadbandDeviceServiceTriggerDetails);
        Py_CLEAR(state->type_MobileBroadbandModem);
        Py_CLEAR(state->type_MobileBroadbandModemConfiguration);
        Py_CLEAR(state->type_MobileBroadbandModemIsolation);
        Py_CLEAR(state->type_MobileBroadbandNetwork);
        Py_CLEAR(state->type_MobileBroadbandNetworkRegistrationStateChange);
        Py_CLEAR(state->type_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails);
        Py_CLEAR(state->type_MobileBroadbandPco);
        Py_CLEAR(state->type_MobileBroadbandPcoDataChangeTriggerDetails);
        Py_CLEAR(state->type_MobileBroadbandPin);
        Py_CLEAR(state->type_MobileBroadbandPinLockStateChange);
        Py_CLEAR(state->type_MobileBroadbandPinLockStateChangeTriggerDetails);
        Py_CLEAR(state->type_MobileBroadbandPinManager);
        Py_CLEAR(state->type_MobileBroadbandPinOperationResult);
        Py_CLEAR(state->type_MobileBroadbandRadioStateChange);
        Py_CLEAR(state->type_MobileBroadbandRadioStateChangeTriggerDetails);
        Py_CLEAR(state->type_MobileBroadbandSarManager);
        Py_CLEAR(state->type_MobileBroadbandSlotInfo);
        Py_CLEAR(state->type_MobileBroadbandSlotInfoChangedEventArgs);
        Py_CLEAR(state->type_MobileBroadbandSlotManager);
        Py_CLEAR(state->type_MobileBroadbandTransmissionStateChangedEventArgs);
        Py_CLEAR(state->type_MobileBroadbandUicc);
        Py_CLEAR(state->type_MobileBroadbandUiccApp);
        Py_CLEAR(state->type_MobileBroadbandUiccAppReadRecordResult);
        Py_CLEAR(state->type_MobileBroadbandUiccAppRecordDetailsResult);
        Py_CLEAR(state->type_MobileBroadbandUiccAppsResult);
        Py_CLEAR(state->type_NetworkOperatorDataUsageTriggerDetails);
        Py_CLEAR(state->type_NetworkOperatorTetheringAccessPointConfiguration);
        Py_CLEAR(state->type_NetworkOperatorTetheringClient);
        Py_CLEAR(state->type_NetworkOperatorTetheringManager);
        Py_CLEAR(state->type_NetworkOperatorTetheringOperationResult);
        Py_CLEAR(state->type_ProvisionFromXmlDocumentResults);
        Py_CLEAR(state->type_ProvisionedProfile);
        Py_CLEAR(state->type_ProvisioningAgent);
        Py_CLEAR(state->type_TetheringEntitlementCheckTriggerDetails);
        Py_CLEAR(state->type_UssdMessage);
        Py_CLEAR(state->type_UssdReply);
        Py_CLEAR(state->type_UssdSession);
        Py_CLEAR(state->type_ESimProfileInstallProgress);
        Py_CLEAR(state->type_ProfileUsage);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Networking_NetworkOperators",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Networking::NetworkOperators

PyMODINIT_FUNC PyInit__winsdk_Windows_Networking_NetworkOperators(void) noexcept
{
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_ESim = py::register_python_type(module.get(), type_name_ESim, &type_spec_ESim, bases.get());
    if (!state->type_ESim)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESim);

    state->type_ESimAddedEventArgs = py::register_python_type(module.get(), type_name_ESimAddedEventArgs, &type_spec_ESimAddedEventArgs, bases.get());
    if (!state->type_ESimAddedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimAddedEventArgs);

    state->type_ESimDiscoverEvent = py::register_python_type(module.get(), type_name_ESimDiscoverEvent, &type_spec_ESimDiscoverEvent, bases.get());
    if (!state->type_ESimDiscoverEvent)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimDiscoverEvent);

    state->type_ESimDiscoverResult = py::register_python_type(module.get(), type_name_ESimDiscoverResult, &type_spec_ESimDiscoverResult, bases.get());
    if (!state->type_ESimDiscoverResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimDiscoverResult);

    state->type_ESimDownloadProfileMetadataResult = py::register_python_type(module.get(), type_name_ESimDownloadProfileMetadataResult, &type_spec_ESimDownloadProfileMetadataResult, bases.get());
    if (!state->type_ESimDownloadProfileMetadataResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimDownloadProfileMetadataResult);

    state->type_ESimManager = py::register_python_type(module.get(), type_name_ESimManager, &type_spec_ESimManager, nullptr);
    if (!state->type_ESimManager)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimManager);

    state->type_ESimOperationResult = py::register_python_type(module.get(), type_name_ESimOperationResult, &type_spec_ESimOperationResult, bases.get());
    if (!state->type_ESimOperationResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimOperationResult);

    state->type_ESimPolicy = py::register_python_type(module.get(), type_name_ESimPolicy, &type_spec_ESimPolicy, bases.get());
    if (!state->type_ESimPolicy)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimPolicy);

    state->type_ESimProfile = py::register_python_type(module.get(), type_name_ESimProfile, &type_spec_ESimProfile, bases.get());
    if (!state->type_ESimProfile)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimProfile);

    state->type_ESimProfileMetadata = py::register_python_type(module.get(), type_name_ESimProfileMetadata, &type_spec_ESimProfileMetadata, bases.get());
    if (!state->type_ESimProfileMetadata)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimProfileMetadata);

    state->type_ESimProfilePolicy = py::register_python_type(module.get(), type_name_ESimProfilePolicy, &type_spec_ESimProfilePolicy, bases.get());
    if (!state->type_ESimProfilePolicy)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimProfilePolicy);

    state->type_ESimRemovedEventArgs = py::register_python_type(module.get(), type_name_ESimRemovedEventArgs, &type_spec_ESimRemovedEventArgs, bases.get());
    if (!state->type_ESimRemovedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimRemovedEventArgs);

    state->type_ESimServiceInfo = py::register_python_type(module.get(), type_name_ESimServiceInfo, &type_spec_ESimServiceInfo, bases.get());
    if (!state->type_ESimServiceInfo)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimServiceInfo);

    state->type_ESimUpdatedEventArgs = py::register_python_type(module.get(), type_name_ESimUpdatedEventArgs, &type_spec_ESimUpdatedEventArgs, bases.get());
    if (!state->type_ESimUpdatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimUpdatedEventArgs);

    state->type_ESimWatcher = py::register_python_type(module.get(), type_name_ESimWatcher, &type_spec_ESimWatcher, bases.get());
    if (!state->type_ESimWatcher)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimWatcher);

    state->type_HotspotAuthenticationContext = py::register_python_type(module.get(), type_name_HotspotAuthenticationContext, &type_spec_HotspotAuthenticationContext, bases.get());
    if (!state->type_HotspotAuthenticationContext)
    {
        return nullptr;
    }

    Py_INCREF(state->type_HotspotAuthenticationContext);

    state->type_HotspotAuthenticationEventDetails = py::register_python_type(module.get(), type_name_HotspotAuthenticationEventDetails, &type_spec_HotspotAuthenticationEventDetails, bases.get());
    if (!state->type_HotspotAuthenticationEventDetails)
    {
        return nullptr;
    }

    Py_INCREF(state->type_HotspotAuthenticationEventDetails);

    state->type_HotspotCredentialsAuthenticationResult = py::register_python_type(module.get(), type_name_HotspotCredentialsAuthenticationResult, &type_spec_HotspotCredentialsAuthenticationResult, bases.get());
    if (!state->type_HotspotCredentialsAuthenticationResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_HotspotCredentialsAuthenticationResult);

    state->type_KnownCSimFilePaths = py::register_python_type(module.get(), type_name_KnownCSimFilePaths, &type_spec_KnownCSimFilePaths, nullptr);
    if (!state->type_KnownCSimFilePaths)
    {
        return nullptr;
    }

    Py_INCREF(state->type_KnownCSimFilePaths);

    state->type_KnownRuimFilePaths = py::register_python_type(module.get(), type_name_KnownRuimFilePaths, &type_spec_KnownRuimFilePaths, nullptr);
    if (!state->type_KnownRuimFilePaths)
    {
        return nullptr;
    }

    Py_INCREF(state->type_KnownRuimFilePaths);

    state->type_KnownSimFilePaths = py::register_python_type(module.get(), type_name_KnownSimFilePaths, &type_spec_KnownSimFilePaths, nullptr);
    if (!state->type_KnownSimFilePaths)
    {
        return nullptr;
    }

    Py_INCREF(state->type_KnownSimFilePaths);

    state->type_KnownUSimFilePaths = py::register_python_type(module.get(), type_name_KnownUSimFilePaths, &type_spec_KnownUSimFilePaths, nullptr);
    if (!state->type_KnownUSimFilePaths)
    {
        return nullptr;
    }

    Py_INCREF(state->type_KnownUSimFilePaths);

    state->type_MobileBroadbandAccount = py::register_python_type(module.get(), type_name_MobileBroadbandAccount, &type_spec_MobileBroadbandAccount, bases.get());
    if (!state->type_MobileBroadbandAccount)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandAccount);

    state->type_MobileBroadbandAccountEventArgs = py::register_python_type(module.get(), type_name_MobileBroadbandAccountEventArgs, &type_spec_MobileBroadbandAccountEventArgs, bases.get());
    if (!state->type_MobileBroadbandAccountEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandAccountEventArgs);

    state->type_MobileBroadbandAccountUpdatedEventArgs = py::register_python_type(module.get(), type_name_MobileBroadbandAccountUpdatedEventArgs, &type_spec_MobileBroadbandAccountUpdatedEventArgs, bases.get());
    if (!state->type_MobileBroadbandAccountUpdatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandAccountUpdatedEventArgs);

    state->type_MobileBroadbandAccountWatcher = py::register_python_type(module.get(), type_name_MobileBroadbandAccountWatcher, &type_spec_MobileBroadbandAccountWatcher, bases.get());
    if (!state->type_MobileBroadbandAccountWatcher)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandAccountWatcher);

    state->type_MobileBroadbandAntennaSar = py::register_python_type(module.get(), type_name_MobileBroadbandAntennaSar, &type_spec_MobileBroadbandAntennaSar, bases.get());
    if (!state->type_MobileBroadbandAntennaSar)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandAntennaSar);

    state->type_MobileBroadbandCellCdma = py::register_python_type(module.get(), type_name_MobileBroadbandCellCdma, &type_spec_MobileBroadbandCellCdma, bases.get());
    if (!state->type_MobileBroadbandCellCdma)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandCellCdma);

    state->type_MobileBroadbandCellGsm = py::register_python_type(module.get(), type_name_MobileBroadbandCellGsm, &type_spec_MobileBroadbandCellGsm, bases.get());
    if (!state->type_MobileBroadbandCellGsm)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandCellGsm);

    state->type_MobileBroadbandCellLte = py::register_python_type(module.get(), type_name_MobileBroadbandCellLte, &type_spec_MobileBroadbandCellLte, bases.get());
    if (!state->type_MobileBroadbandCellLte)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandCellLte);

    state->type_MobileBroadbandCellNR = py::register_python_type(module.get(), type_name_MobileBroadbandCellNR, &type_spec_MobileBroadbandCellNR, bases.get());
    if (!state->type_MobileBroadbandCellNR)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandCellNR);

    state->type_MobileBroadbandCellTdscdma = py::register_python_type(module.get(), type_name_MobileBroadbandCellTdscdma, &type_spec_MobileBroadbandCellTdscdma, bases.get());
    if (!state->type_MobileBroadbandCellTdscdma)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandCellTdscdma);

    state->type_MobileBroadbandCellUmts = py::register_python_type(module.get(), type_name_MobileBroadbandCellUmts, &type_spec_MobileBroadbandCellUmts, bases.get());
    if (!state->type_MobileBroadbandCellUmts)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandCellUmts);

    state->type_MobileBroadbandCellsInfo = py::register_python_type(module.get(), type_name_MobileBroadbandCellsInfo, &type_spec_MobileBroadbandCellsInfo, bases.get());
    if (!state->type_MobileBroadbandCellsInfo)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandCellsInfo);

    state->type_MobileBroadbandCurrentSlotIndexChangedEventArgs = py::register_python_type(module.get(), type_name_MobileBroadbandCurrentSlotIndexChangedEventArgs, &type_spec_MobileBroadbandCurrentSlotIndexChangedEventArgs, bases.get());
    if (!state->type_MobileBroadbandCurrentSlotIndexChangedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandCurrentSlotIndexChangedEventArgs);

    state->type_MobileBroadbandDeviceInformation = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceInformation, &type_spec_MobileBroadbandDeviceInformation, bases.get());
    if (!state->type_MobileBroadbandDeviceInformation)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandDeviceInformation);

    state->type_MobileBroadbandDeviceService = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceService, &type_spec_MobileBroadbandDeviceService, bases.get());
    if (!state->type_MobileBroadbandDeviceService)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandDeviceService);

    state->type_MobileBroadbandDeviceServiceCommandResult = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceServiceCommandResult, &type_spec_MobileBroadbandDeviceServiceCommandResult, bases.get());
    if (!state->type_MobileBroadbandDeviceServiceCommandResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandDeviceServiceCommandResult);

    state->type_MobileBroadbandDeviceServiceCommandSession = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceServiceCommandSession, &type_spec_MobileBroadbandDeviceServiceCommandSession, bases.get());
    if (!state->type_MobileBroadbandDeviceServiceCommandSession)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandDeviceServiceCommandSession);

    state->type_MobileBroadbandDeviceServiceDataReceivedEventArgs = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceServiceDataReceivedEventArgs, &type_spec_MobileBroadbandDeviceServiceDataReceivedEventArgs, bases.get());
    if (!state->type_MobileBroadbandDeviceServiceDataReceivedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandDeviceServiceDataReceivedEventArgs);

    state->type_MobileBroadbandDeviceServiceDataSession = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceServiceDataSession, &type_spec_MobileBroadbandDeviceServiceDataSession, bases.get());
    if (!state->type_MobileBroadbandDeviceServiceDataSession)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandDeviceServiceDataSession);

    state->type_MobileBroadbandDeviceServiceInformation = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceServiceInformation, &type_spec_MobileBroadbandDeviceServiceInformation, bases.get());
    if (!state->type_MobileBroadbandDeviceServiceInformation)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandDeviceServiceInformation);

    state->type_MobileBroadbandDeviceServiceTriggerDetails = py::register_python_type(module.get(), type_name_MobileBroadbandDeviceServiceTriggerDetails, &type_spec_MobileBroadbandDeviceServiceTriggerDetails, bases.get());
    if (!state->type_MobileBroadbandDeviceServiceTriggerDetails)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandDeviceServiceTriggerDetails);

    state->type_MobileBroadbandModem = py::register_python_type(module.get(), type_name_MobileBroadbandModem, &type_spec_MobileBroadbandModem, bases.get());
    if (!state->type_MobileBroadbandModem)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandModem);

    state->type_MobileBroadbandModemConfiguration = py::register_python_type(module.get(), type_name_MobileBroadbandModemConfiguration, &type_spec_MobileBroadbandModemConfiguration, bases.get());
    if (!state->type_MobileBroadbandModemConfiguration)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandModemConfiguration);

    state->type_MobileBroadbandModemIsolation = py::register_python_type(module.get(), type_name_MobileBroadbandModemIsolation, &type_spec_MobileBroadbandModemIsolation, bases.get());
    if (!state->type_MobileBroadbandModemIsolation)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandModemIsolation);

    state->type_MobileBroadbandNetwork = py::register_python_type(module.get(), type_name_MobileBroadbandNetwork, &type_spec_MobileBroadbandNetwork, bases.get());
    if (!state->type_MobileBroadbandNetwork)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandNetwork);

    state->type_MobileBroadbandNetworkRegistrationStateChange = py::register_python_type(module.get(), type_name_MobileBroadbandNetworkRegistrationStateChange, &type_spec_MobileBroadbandNetworkRegistrationStateChange, bases.get());
    if (!state->type_MobileBroadbandNetworkRegistrationStateChange)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandNetworkRegistrationStateChange);

    state->type_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails = py::register_python_type(module.get(), type_name_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails, &type_spec_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails, bases.get());
    if (!state->type_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails);

    state->type_MobileBroadbandPco = py::register_python_type(module.get(), type_name_MobileBroadbandPco, &type_spec_MobileBroadbandPco, bases.get());
    if (!state->type_MobileBroadbandPco)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandPco);

    state->type_MobileBroadbandPcoDataChangeTriggerDetails = py::register_python_type(module.get(), type_name_MobileBroadbandPcoDataChangeTriggerDetails, &type_spec_MobileBroadbandPcoDataChangeTriggerDetails, bases.get());
    if (!state->type_MobileBroadbandPcoDataChangeTriggerDetails)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandPcoDataChangeTriggerDetails);

    state->type_MobileBroadbandPin = py::register_python_type(module.get(), type_name_MobileBroadbandPin, &type_spec_MobileBroadbandPin, bases.get());
    if (!state->type_MobileBroadbandPin)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandPin);

    state->type_MobileBroadbandPinLockStateChange = py::register_python_type(module.get(), type_name_MobileBroadbandPinLockStateChange, &type_spec_MobileBroadbandPinLockStateChange, bases.get());
    if (!state->type_MobileBroadbandPinLockStateChange)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandPinLockStateChange);

    state->type_MobileBroadbandPinLockStateChangeTriggerDetails = py::register_python_type(module.get(), type_name_MobileBroadbandPinLockStateChangeTriggerDetails, &type_spec_MobileBroadbandPinLockStateChangeTriggerDetails, bases.get());
    if (!state->type_MobileBroadbandPinLockStateChangeTriggerDetails)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandPinLockStateChangeTriggerDetails);

    state->type_MobileBroadbandPinManager = py::register_python_type(module.get(), type_name_MobileBroadbandPinManager, &type_spec_MobileBroadbandPinManager, bases.get());
    if (!state->type_MobileBroadbandPinManager)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandPinManager);

    state->type_MobileBroadbandPinOperationResult = py::register_python_type(module.get(), type_name_MobileBroadbandPinOperationResult, &type_spec_MobileBroadbandPinOperationResult, bases.get());
    if (!state->type_MobileBroadbandPinOperationResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandPinOperationResult);

    state->type_MobileBroadbandRadioStateChange = py::register_python_type(module.get(), type_name_MobileBroadbandRadioStateChange, &type_spec_MobileBroadbandRadioStateChange, bases.get());
    if (!state->type_MobileBroadbandRadioStateChange)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandRadioStateChange);

    state->type_MobileBroadbandRadioStateChangeTriggerDetails = py::register_python_type(module.get(), type_name_MobileBroadbandRadioStateChangeTriggerDetails, &type_spec_MobileBroadbandRadioStateChangeTriggerDetails, bases.get());
    if (!state->type_MobileBroadbandRadioStateChangeTriggerDetails)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandRadioStateChangeTriggerDetails);

    state->type_MobileBroadbandSarManager = py::register_python_type(module.get(), type_name_MobileBroadbandSarManager, &type_spec_MobileBroadbandSarManager, bases.get());
    if (!state->type_MobileBroadbandSarManager)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandSarManager);

    state->type_MobileBroadbandSlotInfo = py::register_python_type(module.get(), type_name_MobileBroadbandSlotInfo, &type_spec_MobileBroadbandSlotInfo, bases.get());
    if (!state->type_MobileBroadbandSlotInfo)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandSlotInfo);

    state->type_MobileBroadbandSlotInfoChangedEventArgs = py::register_python_type(module.get(), type_name_MobileBroadbandSlotInfoChangedEventArgs, &type_spec_MobileBroadbandSlotInfoChangedEventArgs, bases.get());
    if (!state->type_MobileBroadbandSlotInfoChangedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandSlotInfoChangedEventArgs);

    state->type_MobileBroadbandSlotManager = py::register_python_type(module.get(), type_name_MobileBroadbandSlotManager, &type_spec_MobileBroadbandSlotManager, bases.get());
    if (!state->type_MobileBroadbandSlotManager)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandSlotManager);

    state->type_MobileBroadbandTransmissionStateChangedEventArgs = py::register_python_type(module.get(), type_name_MobileBroadbandTransmissionStateChangedEventArgs, &type_spec_MobileBroadbandTransmissionStateChangedEventArgs, bases.get());
    if (!state->type_MobileBroadbandTransmissionStateChangedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandTransmissionStateChangedEventArgs);

    state->type_MobileBroadbandUicc = py::register_python_type(module.get(), type_name_MobileBroadbandUicc, &type_spec_MobileBroadbandUicc, bases.get());
    if (!state->type_MobileBroadbandUicc)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandUicc);

    state->type_MobileBroadbandUiccApp = py::register_python_type(module.get(), type_name_MobileBroadbandUiccApp, &type_spec_MobileBroadbandUiccApp, bases.get());
    if (!state->type_MobileBroadbandUiccApp)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandUiccApp);

    state->type_MobileBroadbandUiccAppReadRecordResult = py::register_python_type(module.get(), type_name_MobileBroadbandUiccAppReadRecordResult, &type_spec_MobileBroadbandUiccAppReadRecordResult, bases.get());
    if (!state->type_MobileBroadbandUiccAppReadRecordResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandUiccAppReadRecordResult);

    state->type_MobileBroadbandUiccAppRecordDetailsResult = py::register_python_type(module.get(), type_name_MobileBroadbandUiccAppRecordDetailsResult, &type_spec_MobileBroadbandUiccAppRecordDetailsResult, bases.get());
    if (!state->type_MobileBroadbandUiccAppRecordDetailsResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandUiccAppRecordDetailsResult);

    state->type_MobileBroadbandUiccAppsResult = py::register_python_type(module.get(), type_name_MobileBroadbandUiccAppsResult, &type_spec_MobileBroadbandUiccAppsResult, bases.get());
    if (!state->type_MobileBroadbandUiccAppsResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MobileBroadbandUiccAppsResult);

    state->type_NetworkOperatorDataUsageTriggerDetails = py::register_python_type(module.get(), type_name_NetworkOperatorDataUsageTriggerDetails, &type_spec_NetworkOperatorDataUsageTriggerDetails, bases.get());
    if (!state->type_NetworkOperatorDataUsageTriggerDetails)
    {
        return nullptr;
    }

    Py_INCREF(state->type_NetworkOperatorDataUsageTriggerDetails);

    state->type_NetworkOperatorTetheringAccessPointConfiguration = py::register_python_type(module.get(), type_name_NetworkOperatorTetheringAccessPointConfiguration, &type_spec_NetworkOperatorTetheringAccessPointConfiguration, bases.get());
    if (!state->type_NetworkOperatorTetheringAccessPointConfiguration)
    {
        return nullptr;
    }

    Py_INCREF(state->type_NetworkOperatorTetheringAccessPointConfiguration);

    state->type_NetworkOperatorTetheringClient = py::register_python_type(module.get(), type_name_NetworkOperatorTetheringClient, &type_spec_NetworkOperatorTetheringClient, bases.get());
    if (!state->type_NetworkOperatorTetheringClient)
    {
        return nullptr;
    }

    Py_INCREF(state->type_NetworkOperatorTetheringClient);

    state->type_NetworkOperatorTetheringManager = py::register_python_type(module.get(), type_name_NetworkOperatorTetheringManager, &type_spec_NetworkOperatorTetheringManager, bases.get());
    if (!state->type_NetworkOperatorTetheringManager)
    {
        return nullptr;
    }

    Py_INCREF(state->type_NetworkOperatorTetheringManager);

    state->type_NetworkOperatorTetheringOperationResult = py::register_python_type(module.get(), type_name_NetworkOperatorTetheringOperationResult, &type_spec_NetworkOperatorTetheringOperationResult, bases.get());
    if (!state->type_NetworkOperatorTetheringOperationResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_NetworkOperatorTetheringOperationResult);

    state->type_ProvisionFromXmlDocumentResults = py::register_python_type(module.get(), type_name_ProvisionFromXmlDocumentResults, &type_spec_ProvisionFromXmlDocumentResults, bases.get());
    if (!state->type_ProvisionFromXmlDocumentResults)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ProvisionFromXmlDocumentResults);

    state->type_ProvisionedProfile = py::register_python_type(module.get(), type_name_ProvisionedProfile, &type_spec_ProvisionedProfile, bases.get());
    if (!state->type_ProvisionedProfile)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ProvisionedProfile);

    state->type_ProvisioningAgent = py::register_python_type(module.get(), type_name_ProvisioningAgent, &type_spec_ProvisioningAgent, bases.get());
    if (!state->type_ProvisioningAgent)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ProvisioningAgent);

    state->type_TetheringEntitlementCheckTriggerDetails = py::register_python_type(module.get(), type_name_TetheringEntitlementCheckTriggerDetails, &type_spec_TetheringEntitlementCheckTriggerDetails, bases.get());
    if (!state->type_TetheringEntitlementCheckTriggerDetails)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TetheringEntitlementCheckTriggerDetails);

    state->type_UssdMessage = py::register_python_type(module.get(), type_name_UssdMessage, &type_spec_UssdMessage, bases.get());
    if (!state->type_UssdMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UssdMessage);

    state->type_UssdReply = py::register_python_type(module.get(), type_name_UssdReply, &type_spec_UssdReply, bases.get());
    if (!state->type_UssdReply)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UssdReply);

    state->type_UssdSession = py::register_python_type(module.get(), type_name_UssdSession, &type_spec_UssdSession, bases.get());
    if (!state->type_UssdSession)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UssdSession);

    state->type_ESimProfileInstallProgress = py::register_python_type(module.get(), type_name_ESimProfileInstallProgress, &type_spec_ESimProfileInstallProgress, bases.get());
    if (!state->type_ESimProfileInstallProgress)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ESimProfileInstallProgress);

    state->type_ProfileUsage = py::register_python_type(module.get(), type_name_ProfileUsage, &type_spec_ProfileUsage, bases.get());
    if (!state->type_ProfileUsage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ProfileUsage);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::DataClasses>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DataClasses;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::DataClasses is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimAuthenticationPreference>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimAuthenticationPreference;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimAuthenticationPreference is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimDiscoverResultKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimDiscoverResultKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimDiscoverResultKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimOperationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimOperationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimOperationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimProfileClass>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimProfileClass;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimProfileClass is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimProfileMetadataState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimProfileMetadataState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimProfileMetadataState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimProfileState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimProfileState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimProfileState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ESimWatcherStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimWatcherStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimWatcherStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationResponseCode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HotspotAuthenticationResponseCode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationResponseCode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcherStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandAccountWatcherStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcherStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandModemStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinLockState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandRadioState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandSlotState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppOperationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandUiccAppOperationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppOperationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkDeviceStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkDeviceStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkDeviceStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageNotificationKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorDataUsageNotificationKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageNotificationKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorEventMessageType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorEventMessageType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorEventMessageType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::NetworkRegistrationState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkRegistrationState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkRegistrationState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::ProfileMediaType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProfileMediaType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ProfileMediaType is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::TetheringCapability>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TetheringCapability;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::TetheringCapability is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::TetheringOperationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TetheringOperationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::TetheringOperationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::TetheringOperationalState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TetheringOperationalState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::TetheringOperationalState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::TetheringWiFiBand>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TetheringWiFiBand;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::TetheringWiFiBand is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::UiccAccessCondition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UiccAccessCondition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::UiccAccessCondition is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::UiccAppKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UiccAppKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::UiccAppKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::UiccAppRecordKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UiccAppRecordKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::UiccAppRecordKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Networking::NetworkOperators::UssdResultCode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UssdResultCode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::UssdResultCode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESim>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESim;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESim is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimAddedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimAddedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimAddedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimDiscoverEvent>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimDiscoverEvent;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimDiscoverEvent is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimDiscoverResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimDiscoverResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimDiscoverResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimDownloadProfileMetadataResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimDownloadProfileMetadataResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimOperationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimOperationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimOperationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimPolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimProfile>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimProfile;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimProfile is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimProfileMetadata>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimProfileMetadata;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimProfileMetadata is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimProfilePolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimProfilePolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimProfilePolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimRemovedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimRemovedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimRemovedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimServiceInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimServiceInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimServiceInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimUpdatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimUpdatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HotspotAuthenticationContext;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationContext is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HotspotAuthenticationEventDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::HotspotAuthenticationEventDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_HotspotCredentialsAuthenticationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::HotspotCredentialsAuthenticationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownCSimFilePaths;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::KnownCSimFilePaths is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownRuimFilePaths;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::KnownRuimFilePaths is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownSimFilePaths;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::KnownSimFilePaths is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_KnownUSimFilePaths;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::KnownUSimFilePaths is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandAccount;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccount is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandAccountEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandAccountUpdatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountUpdatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandAccountWatcher;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandAccountWatcher is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandAntennaSar;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandAntennaSar is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCellCdma;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellCdma is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCellGsm;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellGsm is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellLte>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCellLte;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellLte is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellNR>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCellNR;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellNR is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCellTdscdma;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellTdscdma is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCellUmts;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellUmts is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCellsInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCellsInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandCurrentSlotIndexChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandCurrentSlotIndexChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceService;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceService is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceServiceCommandResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceServiceCommandSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceCommandSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceServiceDataReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceServiceDataSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceDataSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceServiceInformation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceInformation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandDeviceServiceTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandDeviceServiceTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandModem;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandModem is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandModemConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandModemIsolation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandModemIsolation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetwork>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandNetwork;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetwork is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandNetworkRegistrationStateChange;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChange is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandNetworkRegistrationStateChangeTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandNetworkRegistrationStateChangeTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPco>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPco;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPco is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPcoDataChangeTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPcoDataChangeTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPin>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPin;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPin is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinLockStateChange;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChange is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinLockStateChangeTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinLockStateChangeTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandPinOperationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandPinOperationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandRadioStateChange;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChange is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandRadioStateChangeTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandRadioStateChangeTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSarManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandSarManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandSarManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandSlotInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandSlotInfoChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotInfoChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandSlotManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandSlotManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandTransmissionStateChangedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandTransmissionStateChangedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUicc>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandUicc;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandUicc is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandUiccApp;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccApp is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandUiccAppReadRecordResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppReadRecordResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandUiccAppRecordDetailsResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppRecordDetailsResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MobileBroadbandUiccAppsResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::MobileBroadbandUiccAppsResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorDataUsageTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorDataUsageTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorTetheringAccessPointConfiguration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringAccessPointConfiguration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorTetheringClient;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringClient is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorTetheringManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_NetworkOperatorTetheringOperationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::NetworkOperatorTetheringOperationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProvisionFromXmlDocumentResults;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ProvisionFromXmlDocumentResults is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ProvisionedProfile>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProvisionedProfile;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ProvisionedProfile is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ProvisioningAgent>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProvisioningAgent;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ProvisioningAgent is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TetheringEntitlementCheckTriggerDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::TetheringEntitlementCheckTriggerDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::UssdMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UssdMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::UssdMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::UssdReply>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UssdReply;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::UssdReply is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::UssdSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UssdSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::UssdSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ESimProfileInstallProgress;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ESimProfileInstallProgress is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Networking::NetworkOperators::ProfileUsage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Networking::NetworkOperators;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Networking::NetworkOperators");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProfileUsage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Networking::NetworkOperators::ProfileUsage is not registered");
        return nullptr;
    }

    return python_type;
}
