// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.5

#include "pybase.h"
#include "py.Windows.UI.UIAutomation.Core.h"


PyObject* py::converter<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>::convert(winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration py::converter<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration");
    throw python_exception();
}

PyObject* py::converter<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>::convert(winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId instance) noexcept
{
    auto type = py::get_python_type<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>();
    if (!type)
    {
        return nullptr;
    }

    return py::wrap_struct(instance, type);
}
winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId py::converter<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    auto type =  py::get_python_type<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>();

    if (!type) {
        throw python_exception();
    }

    if (Py_TYPE(obj) == type)
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>*>(obj)->obj;
    }

    PyErr_SetString(PyExc_TypeError, "expecting winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId");
    throw python_exception();
}

namespace py::cpp::Windows::UI::UIAutomation::Core
{
    struct module_state
    {
        PyObject* type_AutomationRemoteOperationStatus;
        PyTypeObject* type_AutomationRemoteOperationResult;
        PyTypeObject* type_CoreAutomationRegistrar;
        PyTypeObject* type_CoreAutomationRemoteOperation;
        PyTypeObject* type_CoreAutomationRemoteOperationContext;
        PyTypeObject* type_RemoteAutomationClientSession;
        PyTypeObject* type_RemoteAutomationConnectionRequestedEventArgs;
        PyTypeObject* type_RemoteAutomationDisconnectedEventArgs;
        PyTypeObject* type_RemoteAutomationServer;
        PyTypeObject* type_RemoteAutomationWindow;
        PyTypeObject* type_ICoreAutomationConnectionBoundObjectProvider;
        PyTypeObject* type_ICoreAutomationRemoteOperationExtensionProvider;
        PyTypeObject* type_AutomationAnnotationTypeRegistration;
        PyTypeObject* type_AutomationRemoteOperationOperandId;
    };

    static PyObject* register_AutomationRemoteOperationStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AutomationRemoteOperationStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AutomationRemoteOperationStatus = type;
        Py_INCREF(state->type_AutomationRemoteOperationStatus);


        Py_RETURN_NONE;
    }

    // ----- AutomationRemoteOperationResult class --------------------
    constexpr const char* const type_name_AutomationRemoteOperationResult = "AutomationRemoteOperationResult";

    static PyObject* _new_AutomationRemoteOperationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AutomationRemoteOperationResult);
        return nullptr;
    }

    static void _dealloc_AutomationRemoteOperationResult(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AutomationRemoteOperationResult_GetOperand(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);

                return py::convert(self->obj.GetOperand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationRemoteOperationResult_HasOperand(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);

                return py::convert(self->obj.HasOperand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutomationRemoteOperationResult_get_ErrorLocation(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationRemoteOperationResult_get_ExtendedError(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutomationRemoteOperationResult_get_Status(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AutomationRemoteOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutomationRemoteOperationResult[] = {
        { "get_operand", reinterpret_cast<PyCFunction>(AutomationRemoteOperationResult_GetOperand), METH_VARARGS, nullptr },
        { "has_operand", reinterpret_cast<PyCFunction>(AutomationRemoteOperationResult_HasOperand), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutomationRemoteOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutomationRemoteOperationResult[] = {
        { "error_location", reinterpret_cast<getter>(AutomationRemoteOperationResult_get_ErrorLocation), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(AutomationRemoteOperationResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(AutomationRemoteOperationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationRemoteOperationResult[] = 
    {
        { Py_tp_new, _new_AutomationRemoteOperationResult },
        { Py_tp_dealloc, _dealloc_AutomationRemoteOperationResult },
        { Py_tp_methods, _methods_AutomationRemoteOperationResult },
        { Py_tp_getset, _getset_AutomationRemoteOperationResult },
        { },
    };

    static PyType_Spec type_spec_AutomationRemoteOperationResult =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.AutomationRemoteOperationResult",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationRemoteOperationResult
    };

    // ----- CoreAutomationRegistrar class --------------------
    constexpr const char* const type_name_CoreAutomationRegistrar = "CoreAutomationRegistrar";

    static PyObject* _new_CoreAutomationRegistrar(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreAutomationRegistrar);
        return nullptr;
    }

    static PyObject* CoreAutomationRegistrar_RegisterAnnotationType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::UI::UIAutomation::Core::CoreAutomationRegistrar::RegisterAnnotationType(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRegistrar_UnregisterAnnotationType(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>(args, 0);

                winrt::Windows::UI::UIAutomation::Core::CoreAutomationRegistrar::UnregisterAnnotationType(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreAutomationRegistrar[] = {
        { "register_annotation_type", reinterpret_cast<PyCFunction>(CoreAutomationRegistrar_RegisterAnnotationType), METH_VARARGS | METH_STATIC, nullptr },
        { "unregister_annotation_type", reinterpret_cast<PyCFunction>(CoreAutomationRegistrar_UnregisterAnnotationType), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreAutomationRegistrar[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreAutomationRegistrar[] = 
    {
        { Py_tp_new, _new_CoreAutomationRegistrar },
        { Py_tp_methods, _methods_CoreAutomationRegistrar },
        { Py_tp_getset, _getset_CoreAutomationRegistrar },
        { },
    };

    static PyType_Spec type_spec_CoreAutomationRegistrar =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.CoreAutomationRegistrar",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreAutomationRegistrar
    };

    // ----- CoreAutomationRemoteOperation class --------------------
    constexpr const char* const type_name_CoreAutomationRemoteOperation = "CoreAutomationRemoteOperation";

    static PyObject* _new_CoreAutomationRemoteOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CoreAutomationRemoteOperation(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreAutomationRemoteOperation_AddToResults(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);

                self->obj.AddToResults(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_Execute(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(self->obj.Execute(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_ImportConnectionBoundObject(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::UIAutomation::AutomationConnectionBoundObject>(args, 1);

                self->obj.ImportConnectionBoundObject(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_ImportElement(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::UIAutomation::AutomationElement>(args, 1);

                self->obj.ImportElement(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_ImportTextRange(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::UIAutomation::AutomationTextRange>(args, 1);

                self->obj.ImportTextRange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperation_IsOpcodeSupported(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.IsOpcodeSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_CoreAutomationRemoteOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreAutomationRemoteOperation[] = {
        { "add_to_results", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_AddToResults), METH_VARARGS, nullptr },
        { "execute", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_Execute), METH_VARARGS, nullptr },
        { "import_connection_bound_object", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_ImportConnectionBoundObject), METH_VARARGS, nullptr },
        { "import_element", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_ImportElement), METH_VARARGS, nullptr },
        { "import_text_range", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_ImportTextRange), METH_VARARGS, nullptr },
        { "is_opcode_supported", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperation_IsOpcodeSupported), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreAutomationRemoteOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreAutomationRemoteOperation[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreAutomationRemoteOperation[] = 
    {
        { Py_tp_new, _new_CoreAutomationRemoteOperation },
        { Py_tp_dealloc, _dealloc_CoreAutomationRemoteOperation },
        { Py_tp_methods, _methods_CoreAutomationRemoteOperation },
        { Py_tp_getset, _getset_CoreAutomationRemoteOperation },
        { },
    };

    static PyType_Spec type_spec_CoreAutomationRemoteOperation =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.CoreAutomationRemoteOperation",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreAutomationRemoteOperation
    };

    // ----- CoreAutomationRemoteOperationContext class --------------------
    constexpr const char* const type_name_CoreAutomationRemoteOperationContext = "CoreAutomationRemoteOperationContext";

    static PyObject* _new_CoreAutomationRemoteOperationContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CoreAutomationRemoteOperationContext);
        return nullptr;
    }

    static void _dealloc_CoreAutomationRemoteOperationContext(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CoreAutomationRemoteOperationContext_GetOperand(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);

                return py::convert(self->obj.GetOperand(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CoreAutomationRemoteOperationContext_SetOperand(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetOperand(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                self->obj.SetOperand(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_CoreAutomationRemoteOperationContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CoreAutomationRemoteOperationContext[] = {
        { "get_operand", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperationContext_GetOperand), METH_VARARGS, nullptr },
        { "set_operand", reinterpret_cast<PyCFunction>(CoreAutomationRemoteOperationContext_SetOperand), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CoreAutomationRemoteOperationContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CoreAutomationRemoteOperationContext[] = {
        { }
    };

    static PyType_Slot _type_slots_CoreAutomationRemoteOperationContext[] = 
    {
        { Py_tp_new, _new_CoreAutomationRemoteOperationContext },
        { Py_tp_dealloc, _dealloc_CoreAutomationRemoteOperationContext },
        { Py_tp_methods, _methods_CoreAutomationRemoteOperationContext },
        { Py_tp_getset, _getset_CoreAutomationRemoteOperationContext },
        { },
    };

    static PyType_Spec type_spec_CoreAutomationRemoteOperationContext =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.CoreAutomationRemoteOperationContext",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CoreAutomationRemoteOperationContext
    };

    // ----- RemoteAutomationClientSession class --------------------
    constexpr const char* const type_name_RemoteAutomationClientSession = "RemoteAutomationClientSession";

    static PyObject* _new_RemoteAutomationClientSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RemoteAutomationClientSession(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteAutomationClientSession_CreateWindowAsync(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                return py::convert(self->obj.CreateWindowAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_Start(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_Stop(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_get_SessionId(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SessionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_add_ConnectionRequested(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession, winrt::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs>>(arg);

            return py::convert(self->obj.ConnectionRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_remove_ConnectionRequested(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ConnectionRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_add_Disconnected(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession, winrt::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs>>(arg);

            return py::convert(self->obj.Disconnected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationClientSession_remove_Disconnected(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Disconnected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RemoteAutomationClientSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationClientSession[] = {
        { "create_window_async", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_CreateWindowAsync), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_Stop), METH_VARARGS, nullptr },
        { "add_connection_requested", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_add_ConnectionRequested), METH_O, nullptr },
        { "remove_connection_requested", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_remove_ConnectionRequested), METH_O, nullptr },
        { "add_disconnected", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_add_Disconnected), METH_O, nullptr },
        { "remove_disconnected", reinterpret_cast<PyCFunction>(RemoteAutomationClientSession_remove_Disconnected), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteAutomationClientSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationClientSession[] = {
        { "session_id", reinterpret_cast<getter>(RemoteAutomationClientSession_get_SessionId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationClientSession[] = 
    {
        { Py_tp_new, _new_RemoteAutomationClientSession },
        { Py_tp_dealloc, _dealloc_RemoteAutomationClientSession },
        { Py_tp_methods, _methods_RemoteAutomationClientSession },
        { Py_tp_getset, _getset_RemoteAutomationClientSession },
        { },
    };

    static PyType_Spec type_spec_RemoteAutomationClientSession =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.RemoteAutomationClientSession",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationClientSession
    };

    // ----- RemoteAutomationConnectionRequestedEventArgs class --------------------
    constexpr const char* const type_name_RemoteAutomationConnectionRequestedEventArgs = "RemoteAutomationConnectionRequestedEventArgs";

    static PyObject* _new_RemoteAutomationConnectionRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteAutomationConnectionRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteAutomationConnectionRequestedEventArgs(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteAutomationConnectionRequestedEventArgs_get_LocalPipeName(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalPipeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationConnectionRequestedEventArgs_get_RemoteProcessId(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteProcessId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RemoteAutomationConnectionRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationConnectionRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteAutomationConnectionRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationConnectionRequestedEventArgs[] = {
        { "local_pipe_name", reinterpret_cast<getter>(RemoteAutomationConnectionRequestedEventArgs_get_LocalPipeName), nullptr, nullptr, nullptr },
        { "remote_process_id", reinterpret_cast<getter>(RemoteAutomationConnectionRequestedEventArgs_get_RemoteProcessId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationConnectionRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_RemoteAutomationConnectionRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_RemoteAutomationConnectionRequestedEventArgs },
        { Py_tp_methods, _methods_RemoteAutomationConnectionRequestedEventArgs },
        { Py_tp_getset, _getset_RemoteAutomationConnectionRequestedEventArgs },
        { },
    };

    static PyType_Spec type_spec_RemoteAutomationConnectionRequestedEventArgs =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.RemoteAutomationConnectionRequestedEventArgs",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationConnectionRequestedEventArgs
    };

    // ----- RemoteAutomationDisconnectedEventArgs class --------------------
    constexpr const char* const type_name_RemoteAutomationDisconnectedEventArgs = "RemoteAutomationDisconnectedEventArgs";

    static PyObject* _new_RemoteAutomationDisconnectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteAutomationDisconnectedEventArgs);
        return nullptr;
    }

    static void _dealloc_RemoteAutomationDisconnectedEventArgs(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteAutomationDisconnectedEventArgs_get_LocalPipeName(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalPipeName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RemoteAutomationDisconnectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationDisconnectedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteAutomationDisconnectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationDisconnectedEventArgs[] = {
        { "local_pipe_name", reinterpret_cast<getter>(RemoteAutomationDisconnectedEventArgs_get_LocalPipeName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationDisconnectedEventArgs[] = 
    {
        { Py_tp_new, _new_RemoteAutomationDisconnectedEventArgs },
        { Py_tp_dealloc, _dealloc_RemoteAutomationDisconnectedEventArgs },
        { Py_tp_methods, _methods_RemoteAutomationDisconnectedEventArgs },
        { Py_tp_getset, _getset_RemoteAutomationDisconnectedEventArgs },
        { },
    };

    static PyType_Spec type_spec_RemoteAutomationDisconnectedEventArgs =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.RemoteAutomationDisconnectedEventArgs",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationDisconnectedEventArgs
    };

    // ----- RemoteAutomationServer class --------------------
    constexpr const char* const type_name_RemoteAutomationServer = "RemoteAutomationServer";

    static PyObject* _new_RemoteAutomationServer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteAutomationServer);
        return nullptr;
    }

    static PyObject* RemoteAutomationServer_ReportSession(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                winrt::Windows::UI::UIAutomation::Core::RemoteAutomationServer::ReportSession(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationServer[] = {
        { "report_session", reinterpret_cast<PyCFunction>(RemoteAutomationServer_ReportSession), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationServer[] = {
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationServer[] = 
    {
        { Py_tp_new, _new_RemoteAutomationServer },
        { Py_tp_methods, _methods_RemoteAutomationServer },
        { Py_tp_getset, _getset_RemoteAutomationServer },
        { },
    };

    static PyType_Spec type_spec_RemoteAutomationServer =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.RemoteAutomationServer",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationServer
    };

    // ----- RemoteAutomationWindow class --------------------
    constexpr const char* const type_name_RemoteAutomationWindow = "RemoteAutomationWindow";

    static PyObject* _new_RemoteAutomationWindow(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RemoteAutomationWindow);
        return nullptr;
    }

    static void _dealloc_RemoteAutomationWindow(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationWindow* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RemoteAutomationWindow_UnregisterAsync(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationWindow* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.UnregisterAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RemoteAutomationWindow_get_AutomationProvider(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationWindow* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutomationProvider());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RemoteAutomationWindow(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationWindow>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RemoteAutomationWindow[] = {
        { "unregister_async", reinterpret_cast<PyCFunction>(RemoteAutomationWindow_UnregisterAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RemoteAutomationWindow), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RemoteAutomationWindow[] = {
        { "automation_provider", reinterpret_cast<getter>(RemoteAutomationWindow_get_AutomationProvider), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RemoteAutomationWindow[] = 
    {
        { Py_tp_new, _new_RemoteAutomationWindow },
        { Py_tp_dealloc, _dealloc_RemoteAutomationWindow },
        { Py_tp_methods, _methods_RemoteAutomationWindow },
        { Py_tp_getset, _getset_RemoteAutomationWindow },
        { },
    };

    static PyType_Spec type_spec_RemoteAutomationWindow =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.RemoteAutomationWindow",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::RemoteAutomationWindow),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RemoteAutomationWindow
    };

    // ----- ICoreAutomationConnectionBoundObjectProvider interface --------------------
    constexpr const char* const type_name_ICoreAutomationConnectionBoundObjectProvider = "ICoreAutomationConnectionBoundObjectProvider";

    static PyObject* _new_ICoreAutomationConnectionBoundObjectProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_ICoreAutomationConnectionBoundObjectProvider);
        return nullptr;
    }

    static void _dealloc_ICoreAutomationConnectionBoundObjectProvider(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreAutomationConnectionBoundObjectProvider_get_IsComThreadingRequired(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsComThreadingRequired());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ICoreAutomationConnectionBoundObjectProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreAutomationConnectionBoundObjectProvider[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreAutomationConnectionBoundObjectProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreAutomationConnectionBoundObjectProvider[] = {
        { "is_com_threading_required", reinterpret_cast<getter>(ICoreAutomationConnectionBoundObjectProvider_get_IsComThreadingRequired), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICoreAutomationConnectionBoundObjectProvider[] = 
    {
        { Py_tp_new, _new_ICoreAutomationConnectionBoundObjectProvider },
        { Py_tp_dealloc, _dealloc_ICoreAutomationConnectionBoundObjectProvider },
        { Py_tp_methods, _methods_ICoreAutomationConnectionBoundObjectProvider },
        { Py_tp_getset, _getset_ICoreAutomationConnectionBoundObjectProvider },
        { },
    };

    static PyType_Spec type_spec_ICoreAutomationConnectionBoundObjectProvider =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.ICoreAutomationConnectionBoundObjectProvider",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreAutomationConnectionBoundObjectProvider
    };

    // ----- ICoreAutomationRemoteOperationExtensionProvider interface --------------------
    constexpr const char* const type_name_ICoreAutomationRemoteOperationExtensionProvider = "ICoreAutomationRemoteOperationExtensionProvider";

    static PyObject* _new_ICoreAutomationRemoteOperationExtensionProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_ICoreAutomationRemoteOperationExtensionProvider);
        return nullptr;
    }

    static void _dealloc_ICoreAutomationRemoteOperationExtensionProvider(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICoreAutomationRemoteOperationExtensionProvider_CallExtension(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext>(args, 1);
                auto param2 = py::convert_to<winrt::array_view<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>>(args, 2);

                self->obj.CallExtension(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ICoreAutomationRemoteOperationExtensionProvider_IsExtensionSupported(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.IsExtensionSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ICoreAutomationRemoteOperationExtensionProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICoreAutomationRemoteOperationExtensionProvider[] = {
        { "call_extension", reinterpret_cast<PyCFunction>(ICoreAutomationRemoteOperationExtensionProvider_CallExtension), METH_VARARGS, nullptr },
        { "is_extension_supported", reinterpret_cast<PyCFunction>(ICoreAutomationRemoteOperationExtensionProvider_IsExtensionSupported), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ICoreAutomationRemoteOperationExtensionProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICoreAutomationRemoteOperationExtensionProvider[] = {
        { }
    };

    static PyType_Slot _type_slots_ICoreAutomationRemoteOperationExtensionProvider[] = 
    {
        { Py_tp_new, _new_ICoreAutomationRemoteOperationExtensionProvider },
        { Py_tp_dealloc, _dealloc_ICoreAutomationRemoteOperationExtensionProvider },
        { Py_tp_methods, _methods_ICoreAutomationRemoteOperationExtensionProvider },
        { Py_tp_getset, _getset_ICoreAutomationRemoteOperationExtensionProvider },
        { },
    };

    static PyType_Spec type_spec_ICoreAutomationRemoteOperationExtensionProvider =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.ICoreAutomationRemoteOperationExtensionProvider",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICoreAutomationRemoteOperationExtensionProvider
    };

    // ----- AutomationAnnotationTypeRegistration struct --------------------
    constexpr const char* const type_name_AutomationAnnotationTypeRegistration = "AutomationAnnotationTypeRegistration";

    PyObject* _new_AutomationAnnotationTypeRegistration(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _LocalId{};

        static const char* kwlist[] = {"local_id", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "i", const_cast<char**>(kwlist), &_LocalId))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration return_value{ _LocalId };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_AutomationAnnotationTypeRegistration(py::wrapper::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration* self)
    {
    }

    static PyObject* AutomationAnnotationTypeRegistration_get_LocalId(py::wrapper::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalId);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationAnnotationTypeRegistration_set_LocalId(py::wrapper::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.LocalId = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_AutomationAnnotationTypeRegistration[] = {
        { "local_id", reinterpret_cast<getter>(AutomationAnnotationTypeRegistration_get_LocalId), reinterpret_cast<setter>(AutomationAnnotationTypeRegistration_set_LocalId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationAnnotationTypeRegistration[] = 
    {
        { Py_tp_new, _new_AutomationAnnotationTypeRegistration },
        { Py_tp_dealloc, _dealloc_AutomationAnnotationTypeRegistration },
        { Py_tp_getset, _getset_AutomationAnnotationTypeRegistration },
        { },
    };

    static PyType_Spec type_spec_AutomationAnnotationTypeRegistration =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.AutomationAnnotationTypeRegistration",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationAnnotationTypeRegistration
    };

    // ----- AutomationRemoteOperationOperandId struct --------------------
    constexpr const char* const type_name_AutomationRemoteOperationOperandId = "AutomationRemoteOperationOperandId";

    PyObject* _new_AutomationRemoteOperationOperandId(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _Value{};

        static const char* kwlist[] = {"value", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "i", const_cast<char**>(kwlist), &_Value))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId return_value{ _Value };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_AutomationRemoteOperationOperandId(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId* self)
    {
    }

    static PyObject* AutomationRemoteOperationOperandId_get_Value(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutomationRemoteOperationOperandId_set_Value(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Value = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_AutomationRemoteOperationOperandId[] = {
        { "value", reinterpret_cast<getter>(AutomationRemoteOperationOperandId_get_Value), reinterpret_cast<setter>(AutomationRemoteOperationOperandId_set_Value), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutomationRemoteOperationOperandId[] = 
    {
        { Py_tp_new, _new_AutomationRemoteOperationOperandId },
        { Py_tp_dealloc, _dealloc_AutomationRemoteOperationOperandId },
        { Py_tp_getset, _getset_AutomationRemoteOperationOperandId },
        { },
    };

    static PyType_Spec type_spec_AutomationRemoteOperationOperandId =
    {
        "_winsdk_Windows_UI_UIAutomation_Core.AutomationRemoteOperationOperandId",
        sizeof(py::wrapper::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutomationRemoteOperationOperandId
    };

    // ----- Windows.UI.UIAutomation.Core Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::UI::UIAutomation::Core");

    static PyMethodDef module_methods[] = {
        {"_register_AutomationRemoteOperationStatus", register_AutomationRemoteOperationStatus, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AutomationRemoteOperationStatus);
        Py_VISIT(state->type_AutomationRemoteOperationResult);
        Py_VISIT(state->type_CoreAutomationRegistrar);
        Py_VISIT(state->type_CoreAutomationRemoteOperation);
        Py_VISIT(state->type_CoreAutomationRemoteOperationContext);
        Py_VISIT(state->type_RemoteAutomationClientSession);
        Py_VISIT(state->type_RemoteAutomationConnectionRequestedEventArgs);
        Py_VISIT(state->type_RemoteAutomationDisconnectedEventArgs);
        Py_VISIT(state->type_RemoteAutomationServer);
        Py_VISIT(state->type_RemoteAutomationWindow);
        Py_VISIT(state->type_ICoreAutomationConnectionBoundObjectProvider);
        Py_VISIT(state->type_ICoreAutomationRemoteOperationExtensionProvider);
        Py_VISIT(state->type_AutomationAnnotationTypeRegistration);
        Py_VISIT(state->type_AutomationRemoteOperationOperandId);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AutomationRemoteOperationStatus);
        Py_CLEAR(state->type_AutomationRemoteOperationResult);
        Py_CLEAR(state->type_CoreAutomationRegistrar);
        Py_CLEAR(state->type_CoreAutomationRemoteOperation);
        Py_CLEAR(state->type_CoreAutomationRemoteOperationContext);
        Py_CLEAR(state->type_RemoteAutomationClientSession);
        Py_CLEAR(state->type_RemoteAutomationConnectionRequestedEventArgs);
        Py_CLEAR(state->type_RemoteAutomationDisconnectedEventArgs);
        Py_CLEAR(state->type_RemoteAutomationServer);
        Py_CLEAR(state->type_RemoteAutomationWindow);
        Py_CLEAR(state->type_ICoreAutomationConnectionBoundObjectProvider);
        Py_CLEAR(state->type_ICoreAutomationRemoteOperationExtensionProvider);
        Py_CLEAR(state->type_AutomationAnnotationTypeRegistration);
        Py_CLEAR(state->type_AutomationRemoteOperationOperandId);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_UI_UIAutomation_Core",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::UI::UIAutomation::Core

PyMODINIT_FUNC PyInit__winsdk_Windows_UI_UIAutomation_Core(void) noexcept
{
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AutomationRemoteOperationResult = py::register_python_type(module.get(), type_name_AutomationRemoteOperationResult, &type_spec_AutomationRemoteOperationResult, bases.get());
    if (!state->type_AutomationRemoteOperationResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AutomationRemoteOperationResult);

    state->type_CoreAutomationRegistrar = py::register_python_type(module.get(), type_name_CoreAutomationRegistrar, &type_spec_CoreAutomationRegistrar, nullptr);
    if (!state->type_CoreAutomationRegistrar)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CoreAutomationRegistrar);

    state->type_CoreAutomationRemoteOperation = py::register_python_type(module.get(), type_name_CoreAutomationRemoteOperation, &type_spec_CoreAutomationRemoteOperation, bases.get());
    if (!state->type_CoreAutomationRemoteOperation)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CoreAutomationRemoteOperation);

    state->type_CoreAutomationRemoteOperationContext = py::register_python_type(module.get(), type_name_CoreAutomationRemoteOperationContext, &type_spec_CoreAutomationRemoteOperationContext, bases.get());
    if (!state->type_CoreAutomationRemoteOperationContext)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CoreAutomationRemoteOperationContext);

    state->type_RemoteAutomationClientSession = py::register_python_type(module.get(), type_name_RemoteAutomationClientSession, &type_spec_RemoteAutomationClientSession, bases.get());
    if (!state->type_RemoteAutomationClientSession)
    {
        return nullptr;
    }

    Py_INCREF(state->type_RemoteAutomationClientSession);

    state->type_RemoteAutomationConnectionRequestedEventArgs = py::register_python_type(module.get(), type_name_RemoteAutomationConnectionRequestedEventArgs, &type_spec_RemoteAutomationConnectionRequestedEventArgs, bases.get());
    if (!state->type_RemoteAutomationConnectionRequestedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_RemoteAutomationConnectionRequestedEventArgs);

    state->type_RemoteAutomationDisconnectedEventArgs = py::register_python_type(module.get(), type_name_RemoteAutomationDisconnectedEventArgs, &type_spec_RemoteAutomationDisconnectedEventArgs, bases.get());
    if (!state->type_RemoteAutomationDisconnectedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_RemoteAutomationDisconnectedEventArgs);

    state->type_RemoteAutomationServer = py::register_python_type(module.get(), type_name_RemoteAutomationServer, &type_spec_RemoteAutomationServer, nullptr);
    if (!state->type_RemoteAutomationServer)
    {
        return nullptr;
    }

    Py_INCREF(state->type_RemoteAutomationServer);

    state->type_RemoteAutomationWindow = py::register_python_type(module.get(), type_name_RemoteAutomationWindow, &type_spec_RemoteAutomationWindow, bases.get());
    if (!state->type_RemoteAutomationWindow)
    {
        return nullptr;
    }

    Py_INCREF(state->type_RemoteAutomationWindow);

    state->type_ICoreAutomationConnectionBoundObjectProvider = py::register_python_type(module.get(), type_name_ICoreAutomationConnectionBoundObjectProvider, &type_spec_ICoreAutomationConnectionBoundObjectProvider, bases.get());
    if (!state->type_ICoreAutomationConnectionBoundObjectProvider)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ICoreAutomationConnectionBoundObjectProvider);

    state->type_ICoreAutomationRemoteOperationExtensionProvider = py::register_python_type(module.get(), type_name_ICoreAutomationRemoteOperationExtensionProvider, &type_spec_ICoreAutomationRemoteOperationExtensionProvider, bases.get());
    if (!state->type_ICoreAutomationRemoteOperationExtensionProvider)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ICoreAutomationRemoteOperationExtensionProvider);

    state->type_AutomationAnnotationTypeRegistration = py::register_python_type(module.get(), type_name_AutomationAnnotationTypeRegistration, &type_spec_AutomationAnnotationTypeRegistration, bases.get());
    if (!state->type_AutomationAnnotationTypeRegistration)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AutomationAnnotationTypeRegistration);

    state->type_AutomationRemoteOperationOperandId = py::register_python_type(module.get(), type_name_AutomationRemoteOperationOperandId, &type_spec_AutomationRemoteOperationOperandId, bases.get());
    if (!state->type_AutomationRemoteOperationOperandId)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AutomationRemoteOperationOperandId);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AutomationRemoteOperationStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AutomationRemoteOperationResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRegistrar>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreAutomationRegistrar;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::CoreAutomationRegistrar is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreAutomationRemoteOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CoreAutomationRemoteOperationContext;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::CoreAutomationRemoteOperationContext is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RemoteAutomationClientSession;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::RemoteAutomationClientSession is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RemoteAutomationConnectionRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::RemoteAutomationConnectionRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RemoteAutomationDisconnectedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::RemoteAutomationDisconnectedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationServer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RemoteAutomationServer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::RemoteAutomationServer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::RemoteAutomationWindow>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RemoteAutomationWindow;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::RemoteAutomationWindow is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICoreAutomationConnectionBoundObjectProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::ICoreAutomationConnectionBoundObjectProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICoreAutomationRemoteOperationExtensionProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::ICoreAutomationRemoteOperationExtensionProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AutomationAnnotationTypeRegistration;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::AutomationAnnotationTypeRegistration is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId>::get_python_type() noexcept {
    using namespace py::cpp::Windows::UI::UIAutomation::Core;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::UI::UIAutomation::Core");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AutomationRemoteOperationOperandId;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::UI::UIAutomation::Core::AutomationRemoteOperationOperandId is not registered");
        return nullptr;
    }

    return python_type;
}
