// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Graphics.h"

PyTypeObject* py::winrt_type<winrt::Windows::Graphics::IGeometrySource2D>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::DisplayAdapterId>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::DisplayId>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::PointInt32>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::RectInt32>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Graphics::SizeInt32>::python_type;

PyObject* py::converter<winrt::Windows::Graphics::DisplayAdapterId>::convert(winrt::Windows::Graphics::DisplayAdapterId instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Graphics::DisplayAdapterId>());
}
winrt::Windows::Graphics::DisplayAdapterId py::converter<winrt::Windows::Graphics::DisplayAdapterId>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Graphics::DisplayAdapterId>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::DisplayAdapterId>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Graphics::DisplayAdapterId return_value{};

    PyObject* py_LowPart = PyDict_GetItemString(obj, "low_part");
    if (!py_LowPart) { throw winrt::hresult_invalid_argument(); }
    return_value.LowPart = converter<uint32_t>::convert_to(py_LowPart);

    PyObject* py_HighPart = PyDict_GetItemString(obj, "high_part");
    if (!py_HighPart) { throw winrt::hresult_invalid_argument(); }
    return_value.HighPart = converter<int32_t>::convert_to(py_HighPart);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Graphics::DisplayId>::convert(winrt::Windows::Graphics::DisplayId instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Graphics::DisplayId>());
}
winrt::Windows::Graphics::DisplayId py::converter<winrt::Windows::Graphics::DisplayId>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Graphics::DisplayId>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::DisplayId>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Graphics::DisplayId return_value{};

    PyObject* py_Value = PyDict_GetItemString(obj, "value");
    if (!py_Value) { throw winrt::hresult_invalid_argument(); }
    return_value.Value = converter<uint64_t>::convert_to(py_Value);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Graphics::PointInt32>::convert(winrt::Windows::Graphics::PointInt32 instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Graphics::PointInt32>());
}
winrt::Windows::Graphics::PointInt32 py::converter<winrt::Windows::Graphics::PointInt32>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Graphics::PointInt32>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::PointInt32>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Graphics::PointInt32 return_value{};

    PyObject* py_X = PyDict_GetItemString(obj, "x");
    if (!py_X) { throw winrt::hresult_invalid_argument(); }
    return_value.X = converter<int32_t>::convert_to(py_X);

    PyObject* py_Y = PyDict_GetItemString(obj, "y");
    if (!py_Y) { throw winrt::hresult_invalid_argument(); }
    return_value.Y = converter<int32_t>::convert_to(py_Y);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Graphics::RectInt32>::convert(winrt::Windows::Graphics::RectInt32 instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Graphics::RectInt32>());
}
winrt::Windows::Graphics::RectInt32 py::converter<winrt::Windows::Graphics::RectInt32>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Graphics::RectInt32>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::RectInt32>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Graphics::RectInt32 return_value{};

    PyObject* py_X = PyDict_GetItemString(obj, "x");
    if (!py_X) { throw winrt::hresult_invalid_argument(); }
    return_value.X = converter<int32_t>::convert_to(py_X);

    PyObject* py_Y = PyDict_GetItemString(obj, "y");
    if (!py_Y) { throw winrt::hresult_invalid_argument(); }
    return_value.Y = converter<int32_t>::convert_to(py_Y);

    PyObject* py_Width = PyDict_GetItemString(obj, "width");
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    return_value.Width = converter<int32_t>::convert_to(py_Width);

    PyObject* py_Height = PyDict_GetItemString(obj, "height");
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    return_value.Height = converter<int32_t>::convert_to(py_Height);

    return return_value;
}

PyObject* py::converter<winrt::Windows::Graphics::SizeInt32>::convert(winrt::Windows::Graphics::SizeInt32 instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Graphics::SizeInt32>());
}
winrt::Windows::Graphics::SizeInt32 py::converter<winrt::Windows::Graphics::SizeInt32>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Graphics::SizeInt32>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Graphics::SizeInt32>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Graphics::SizeInt32 return_value{};

    PyObject* py_Width = PyDict_GetItemString(obj, "width");
    if (!py_Width) { throw winrt::hresult_invalid_argument(); }
    return_value.Width = converter<int32_t>::convert_to(py_Width);

    PyObject* py_Height = PyDict_GetItemString(obj, "height");
    if (!py_Height) { throw winrt::hresult_invalid_argument(); }
    return_value.Height = converter<int32_t>::convert_to(py_Height);

    return return_value;
}

namespace py::cpp::Windows::Graphics
{
    // ----- IGeometrySource2D interface --------------------
    constexpr const char* const _type_name_IGeometrySource2D = "IGeometrySource2D";

    static PyObject* _new_IGeometrySource2D(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IGeometrySource2D);
        return nullptr;
    }

    static void _dealloc_IGeometrySource2D(py::wrapper::Windows::Graphics::IGeometrySource2D* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_IGeometrySource2D(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Graphics::IGeometrySource2D>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IGeometrySource2D[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IGeometrySource2D), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IGeometrySource2D[] = {
        { }
    };

    static PyType_Slot _type_slots_IGeometrySource2D[] = 
    {
        { Py_tp_new, _new_IGeometrySource2D },
        { Py_tp_dealloc, _dealloc_IGeometrySource2D },
        { Py_tp_methods, _methods_IGeometrySource2D },
        { Py_tp_getset, _getset_IGeometrySource2D },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IGeometrySource2D =
    {
        "_winsdk_Windows_Graphics.IGeometrySource2D",
        sizeof(py::wrapper::Windows::Graphics::IGeometrySource2D),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IGeometrySource2D
    };

    // ----- DisplayAdapterId struct --------------------
    constexpr const char* const _type_name_DisplayAdapterId = "DisplayAdapterId";

    PyObject* _new_DisplayAdapterId(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Graphics::DisplayAdapterId return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Graphics::DisplayAdapterId>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _LowPart{};
        int32_t _HighPart{};

        static const char* kwlist[] = {"low_part", "high_part", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "Ii", const_cast<char**>(kwlist), &_LowPart, &_HighPart))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Graphics::DisplayAdapterId return_value{ _LowPart, _HighPart };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_DisplayAdapterId(py::wrapper::Windows::Graphics::DisplayAdapterId* self)
    {
    }

    static PyObject* DisplayAdapterId_get_LowPart(py::wrapper::Windows::Graphics::DisplayAdapterId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LowPart);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayAdapterId_set_LowPart(py::wrapper::Windows::Graphics::DisplayAdapterId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.LowPart = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayAdapterId_get_HighPart(py::wrapper::Windows::Graphics::DisplayAdapterId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HighPart);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayAdapterId_set_HighPart(py::wrapper::Windows::Graphics::DisplayAdapterId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.HighPart = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_DisplayAdapterId[] = {
        { "low_part", reinterpret_cast<getter>(DisplayAdapterId_get_LowPart), reinterpret_cast<setter>(DisplayAdapterId_set_LowPart), nullptr, nullptr },
        { "high_part", reinterpret_cast<getter>(DisplayAdapterId_get_HighPart), reinterpret_cast<setter>(DisplayAdapterId_set_HighPart), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayAdapterId[] = 
    {
        { Py_tp_new, _new_DisplayAdapterId },
        { Py_tp_dealloc, _dealloc_DisplayAdapterId },
        { Py_tp_getset, _getset_DisplayAdapterId },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayAdapterId =
    {
        "_winsdk_Windows_Graphics.DisplayAdapterId",
        sizeof(py::wrapper::Windows::Graphics::DisplayAdapterId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayAdapterId
    };

    // ----- DisplayId struct --------------------
    constexpr const char* const _type_name_DisplayId = "DisplayId";

    PyObject* _new_DisplayId(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Graphics::DisplayId return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Graphics::DisplayId>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint64_t _Value{};

        static const char* kwlist[] = {"value", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "K", const_cast<char**>(kwlist), &_Value))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Graphics::DisplayId return_value{ _Value };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_DisplayId(py::wrapper::Windows::Graphics::DisplayId* self)
    {
    }

    static PyObject* DisplayId_get_Value(py::wrapper::Windows::Graphics::DisplayId* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayId_set_Value(py::wrapper::Windows::Graphics::DisplayId* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Value = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_DisplayId[] = {
        { "value", reinterpret_cast<getter>(DisplayId_get_Value), reinterpret_cast<setter>(DisplayId_set_Value), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayId[] = 
    {
        { Py_tp_new, _new_DisplayId },
        { Py_tp_dealloc, _dealloc_DisplayId },
        { Py_tp_getset, _getset_DisplayId },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayId =
    {
        "_winsdk_Windows_Graphics.DisplayId",
        sizeof(py::wrapper::Windows::Graphics::DisplayId),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayId
    };

    // ----- PointInt32 struct --------------------
    constexpr const char* const _type_name_PointInt32 = "PointInt32";

    PyObject* _new_PointInt32(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Graphics::PointInt32 return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Graphics::PointInt32>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _X{};
        int32_t _Y{};

        static const char* kwlist[] = {"x", "y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_X, &_Y))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Graphics::PointInt32 return_value{ _X, _Y };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_PointInt32(py::wrapper::Windows::Graphics::PointInt32* self)
    {
    }

    static PyObject* PointInt32_get_X(py::wrapper::Windows::Graphics::PointInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointInt32_set_X(py::wrapper::Windows::Graphics::PointInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PointInt32_get_Y(py::wrapper::Windows::Graphics::PointInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PointInt32_set_Y(py::wrapper::Windows::Graphics::PointInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_PointInt32[] = {
        { "x", reinterpret_cast<getter>(PointInt32_get_X), reinterpret_cast<setter>(PointInt32_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(PointInt32_get_Y), reinterpret_cast<setter>(PointInt32_set_Y), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PointInt32[] = 
    {
        { Py_tp_new, _new_PointInt32 },
        { Py_tp_dealloc, _dealloc_PointInt32 },
        { Py_tp_getset, _getset_PointInt32 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PointInt32 =
    {
        "_winsdk_Windows_Graphics.PointInt32",
        sizeof(py::wrapper::Windows::Graphics::PointInt32),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PointInt32
    };

    // ----- RectInt32 struct --------------------
    constexpr const char* const _type_name_RectInt32 = "RectInt32";

    PyObject* _new_RectInt32(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Graphics::RectInt32 return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Graphics::RectInt32>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _X{};
        int32_t _Y{};
        int32_t _Width{};
        int32_t _Height{};

        static const char* kwlist[] = {"x", "y", "width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iiii", const_cast<char**>(kwlist), &_X, &_Y, &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Graphics::RectInt32 return_value{ _X, _Y, _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_RectInt32(py::wrapper::Windows::Graphics::RectInt32* self)
    {
    }

    static PyObject* RectInt32_get_X(py::wrapper::Windows::Graphics::RectInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.X);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RectInt32_set_X(py::wrapper::Windows::Graphics::RectInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.X = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RectInt32_get_Y(py::wrapper::Windows::Graphics::RectInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Y);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RectInt32_set_Y(py::wrapper::Windows::Graphics::RectInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Y = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RectInt32_get_Width(py::wrapper::Windows::Graphics::RectInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RectInt32_set_Width(py::wrapper::Windows::Graphics::RectInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RectInt32_get_Height(py::wrapper::Windows::Graphics::RectInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RectInt32_set_Height(py::wrapper::Windows::Graphics::RectInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_RectInt32[] = {
        { "x", reinterpret_cast<getter>(RectInt32_get_X), reinterpret_cast<setter>(RectInt32_set_X), nullptr, nullptr },
        { "y", reinterpret_cast<getter>(RectInt32_get_Y), reinterpret_cast<setter>(RectInt32_set_Y), nullptr, nullptr },
        { "width", reinterpret_cast<getter>(RectInt32_get_Width), reinterpret_cast<setter>(RectInt32_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(RectInt32_get_Height), reinterpret_cast<setter>(RectInt32_set_Height), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RectInt32[] = 
    {
        { Py_tp_new, _new_RectInt32 },
        { Py_tp_dealloc, _dealloc_RectInt32 },
        { Py_tp_getset, _getset_RectInt32 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RectInt32 =
    {
        "_winsdk_Windows_Graphics.RectInt32",
        sizeof(py::wrapper::Windows::Graphics::RectInt32),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RectInt32
    };

    // ----- SizeInt32 struct --------------------
    constexpr const char* const _type_name_SizeInt32 = "SizeInt32";

    PyObject* _new_SizeInt32(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Graphics::SizeInt32 return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Graphics::SizeInt32>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _Width{};
        int32_t _Height{};

        static const char* kwlist[] = {"width", "height", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_Width, &_Height))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Graphics::SizeInt32 return_value{ _Width, _Height };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_SizeInt32(py::wrapper::Windows::Graphics::SizeInt32* self)
    {
    }

    static PyObject* SizeInt32_get_Width(py::wrapper::Windows::Graphics::SizeInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SizeInt32_set_Width(py::wrapper::Windows::Graphics::SizeInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Width = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SizeInt32_get_Height(py::wrapper::Windows::Graphics::SizeInt32* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SizeInt32_set_Height(py::wrapper::Windows::Graphics::SizeInt32* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Height = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_SizeInt32[] = {
        { "width", reinterpret_cast<getter>(SizeInt32_get_Width), reinterpret_cast<setter>(SizeInt32_set_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(SizeInt32_get_Height), reinterpret_cast<setter>(SizeInt32_set_Height), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SizeInt32[] = 
    {
        { Py_tp_new, _new_SizeInt32 },
        { Py_tp_dealloc, _dealloc_SizeInt32 },
        { Py_tp_getset, _getset_SizeInt32 },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SizeInt32 =
    {
        "_winsdk_Windows_Graphics.SizeInt32",
        sizeof(py::wrapper::Windows::Graphics::SizeInt32),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SizeInt32
    };

    // ----- Windows.Graphics Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Graphics::IGeometrySource2D>::python_type = py::register_python_type(module, _type_name_IGeometrySource2D, &_type_spec_IGeometrySource2D, bases.get());
            py::winrt_type<winrt::Windows::Graphics::DisplayAdapterId>::python_type = py::register_python_type(module, _type_name_DisplayAdapterId, &_type_spec_DisplayAdapterId, bases.get());
            py::winrt_type<winrt::Windows::Graphics::DisplayId>::python_type = py::register_python_type(module, _type_name_DisplayId, &_type_spec_DisplayId, bases.get());
            py::winrt_type<winrt::Windows::Graphics::PointInt32>::python_type = py::register_python_type(module, _type_name_PointInt32, &_type_spec_PointInt32, bases.get());
            py::winrt_type<winrt::Windows::Graphics::RectInt32>::python_type = py::register_python_type(module, _type_name_RectInt32, &_type_spec_RectInt32, bases.get());
            py::winrt_type<winrt::Windows::Graphics::SizeInt32>::python_type = py::register_python_type(module, _type_name_SizeInt32, &_type_spec_SizeInt32, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Graphics");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Graphics",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Graphics

PyMODINIT_FUNC
PyInit__winsdk_Windows_Graphics (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Graphics::module_def);
}
