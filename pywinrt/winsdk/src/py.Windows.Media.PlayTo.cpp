// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Media.PlayTo.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::CurrentTimeChangeRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::MuteChangeRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToReceiver>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::PlaybackRateChangeRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::SourceChangeRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::PlayTo::VolumeChangeRequestedEventArgs>::python_type;

namespace py::cpp::Windows::Media::PlayTo
{
    // ----- CurrentTimeChangeRequestedEventArgs class --------------------
    constexpr const char* const _type_name_CurrentTimeChangeRequestedEventArgs = "CurrentTimeChangeRequestedEventArgs";

    static PyObject* _new_CurrentTimeChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CurrentTimeChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_CurrentTimeChangeRequestedEventArgs(py::wrapper::Windows::Media::PlayTo::CurrentTimeChangeRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CurrentTimeChangeRequestedEventArgs_get_Time(py::wrapper::Windows::Media::PlayTo::CurrentTimeChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Time());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CurrentTimeChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::CurrentTimeChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CurrentTimeChangeRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CurrentTimeChangeRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CurrentTimeChangeRequestedEventArgs[] = {
        { "time", reinterpret_cast<getter>(CurrentTimeChangeRequestedEventArgs_get_Time), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CurrentTimeChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_CurrentTimeChangeRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_CurrentTimeChangeRequestedEventArgs },
        { Py_tp_methods, _methods_CurrentTimeChangeRequestedEventArgs },
        { Py_tp_getset, _getset_CurrentTimeChangeRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CurrentTimeChangeRequestedEventArgs =
    {
        "_winsdk_Windows_Media_PlayTo.CurrentTimeChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::CurrentTimeChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CurrentTimeChangeRequestedEventArgs
    };

    // ----- MuteChangeRequestedEventArgs class --------------------
    constexpr const char* const _type_name_MuteChangeRequestedEventArgs = "MuteChangeRequestedEventArgs";

    static PyObject* _new_MuteChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MuteChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_MuteChangeRequestedEventArgs(py::wrapper::Windows::Media::PlayTo::MuteChangeRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MuteChangeRequestedEventArgs_get_Mute(py::wrapper::Windows::Media::PlayTo::MuteChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mute());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MuteChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::MuteChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MuteChangeRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MuteChangeRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MuteChangeRequestedEventArgs[] = {
        { "mute", reinterpret_cast<getter>(MuteChangeRequestedEventArgs_get_Mute), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MuteChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_MuteChangeRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_MuteChangeRequestedEventArgs },
        { Py_tp_methods, _methods_MuteChangeRequestedEventArgs },
        { Py_tp_getset, _getset_MuteChangeRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MuteChangeRequestedEventArgs =
    {
        "_winsdk_Windows_Media_PlayTo.MuteChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::MuteChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MuteChangeRequestedEventArgs
    };

    // ----- PlayToConnection class --------------------
    constexpr const char* const _type_name_PlayToConnection = "PlayToConnection";

    static PyObject* _new_PlayToConnection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToConnection);
        return nullptr;
    }

    static void _dealloc_PlayToConnection(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToConnection_get_State(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnection_add_Error(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToConnection, winrt::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs>>(arg);

            return py::convert(self->obj.Error(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnection_remove_Error(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Error(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnection_add_StateChanged(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToConnection, winrt::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnection_remove_StateChanged(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnection_add_Transferred(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToConnection, winrt::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs>>(arg);

            return py::convert(self->obj.Transferred(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnection_remove_Transferred(py::wrapper::Windows::Media::PlayTo::PlayToConnection* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Transferred(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToConnection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToConnection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToConnection[] = {
        { "add_error", reinterpret_cast<PyCFunction>(PlayToConnection_add_Error), METH_O, nullptr },
        { "remove_error", reinterpret_cast<PyCFunction>(PlayToConnection_remove_Error), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(PlayToConnection_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(PlayToConnection_remove_StateChanged), METH_O, nullptr },
        { "add_transferred", reinterpret_cast<PyCFunction>(PlayToConnection_add_Transferred), METH_O, nullptr },
        { "remove_transferred", reinterpret_cast<PyCFunction>(PlayToConnection_remove_Transferred), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayToConnection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayToConnection[] = {
        { "state", reinterpret_cast<getter>(PlayToConnection_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayToConnection[] = 
    {
        { Py_tp_new, _new_PlayToConnection },
        { Py_tp_dealloc, _dealloc_PlayToConnection },
        { Py_tp_methods, _methods_PlayToConnection },
        { Py_tp_getset, _getset_PlayToConnection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToConnection =
    {
        "_winsdk_Windows_Media_PlayTo.PlayToConnection",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToConnection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToConnection
    };

    // ----- PlayToConnectionErrorEventArgs class --------------------
    constexpr const char* const _type_name_PlayToConnectionErrorEventArgs = "PlayToConnectionErrorEventArgs";

    static PyObject* _new_PlayToConnectionErrorEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToConnectionErrorEventArgs);
        return nullptr;
    }

    static void _dealloc_PlayToConnectionErrorEventArgs(py::wrapper::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToConnectionErrorEventArgs_get_Code(py::wrapper::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Code());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnectionErrorEventArgs_get_Message(py::wrapper::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToConnectionErrorEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToConnectionErrorEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayToConnectionErrorEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayToConnectionErrorEventArgs[] = {
        { "code", reinterpret_cast<getter>(PlayToConnectionErrorEventArgs_get_Code), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(PlayToConnectionErrorEventArgs_get_Message), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayToConnectionErrorEventArgs[] = 
    {
        { Py_tp_new, _new_PlayToConnectionErrorEventArgs },
        { Py_tp_dealloc, _dealloc_PlayToConnectionErrorEventArgs },
        { Py_tp_methods, _methods_PlayToConnectionErrorEventArgs },
        { Py_tp_getset, _getset_PlayToConnectionErrorEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToConnectionErrorEventArgs =
    {
        "_winsdk_Windows_Media_PlayTo.PlayToConnectionErrorEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToConnectionErrorEventArgs
    };

    // ----- PlayToConnectionStateChangedEventArgs class --------------------
    constexpr const char* const _type_name_PlayToConnectionStateChangedEventArgs = "PlayToConnectionStateChangedEventArgs";

    static PyObject* _new_PlayToConnectionStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToConnectionStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_PlayToConnectionStateChangedEventArgs(py::wrapper::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToConnectionStateChangedEventArgs_get_CurrentState(py::wrapper::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnectionStateChangedEventArgs_get_PreviousState(py::wrapper::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToConnectionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToConnectionStateChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayToConnectionStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayToConnectionStateChangedEventArgs[] = {
        { "current_state", reinterpret_cast<getter>(PlayToConnectionStateChangedEventArgs_get_CurrentState), nullptr, nullptr, nullptr },
        { "previous_state", reinterpret_cast<getter>(PlayToConnectionStateChangedEventArgs_get_PreviousState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayToConnectionStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_PlayToConnectionStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_PlayToConnectionStateChangedEventArgs },
        { Py_tp_methods, _methods_PlayToConnectionStateChangedEventArgs },
        { Py_tp_getset, _getset_PlayToConnectionStateChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToConnectionStateChangedEventArgs =
    {
        "_winsdk_Windows_Media_PlayTo.PlayToConnectionStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToConnectionStateChangedEventArgs
    };

    // ----- PlayToConnectionTransferredEventArgs class --------------------
    constexpr const char* const _type_name_PlayToConnectionTransferredEventArgs = "PlayToConnectionTransferredEventArgs";

    static PyObject* _new_PlayToConnectionTransferredEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToConnectionTransferredEventArgs);
        return nullptr;
    }

    static void _dealloc_PlayToConnectionTransferredEventArgs(py::wrapper::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToConnectionTransferredEventArgs_get_CurrentSource(py::wrapper::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToConnectionTransferredEventArgs_get_PreviousSource(py::wrapper::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToConnectionTransferredEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToConnectionTransferredEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayToConnectionTransferredEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayToConnectionTransferredEventArgs[] = {
        { "current_source", reinterpret_cast<getter>(PlayToConnectionTransferredEventArgs_get_CurrentSource), nullptr, nullptr, nullptr },
        { "previous_source", reinterpret_cast<getter>(PlayToConnectionTransferredEventArgs_get_PreviousSource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayToConnectionTransferredEventArgs[] = 
    {
        { Py_tp_new, _new_PlayToConnectionTransferredEventArgs },
        { Py_tp_dealloc, _dealloc_PlayToConnectionTransferredEventArgs },
        { Py_tp_methods, _methods_PlayToConnectionTransferredEventArgs },
        { Py_tp_getset, _getset_PlayToConnectionTransferredEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToConnectionTransferredEventArgs =
    {
        "_winsdk_Windows_Media_PlayTo.PlayToConnectionTransferredEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToConnectionTransferredEventArgs
    };

    // ----- PlayToManager class --------------------
    constexpr const char* const _type_name_PlayToManager = "PlayToManager";

    static PyObject* _new_PlayToManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToManager);
        return nullptr;
    }

    static void _dealloc_PlayToManager(py::wrapper::Windows::Media::PlayTo::PlayToManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToManager_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::PlayTo::PlayToManager::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToManager_ShowPlayToUI(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::PlayTo::PlayToManager::ShowPlayToUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToManager_get_DefaultSourceSelection(py::wrapper::Windows::Media::PlayTo::PlayToManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DefaultSourceSelection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayToManager_put_DefaultSourceSelection(py::wrapper::Windows::Media::PlayTo::PlayToManager* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DefaultSourceSelection(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayToManager_add_SourceRequested(py::wrapper::Windows::Media::PlayTo::PlayToManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToManager, winrt::Windows::Media::PlayTo::PlayToSourceRequestedEventArgs>>(arg);

            return py::convert(self->obj.SourceRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToManager_remove_SourceRequested(py::wrapper::Windows::Media::PlayTo::PlayToManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToManager_add_SourceSelected(py::wrapper::Windows::Media::PlayTo::PlayToManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToManager, winrt::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs>>(arg);

            return py::convert(self->obj.SourceSelected(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToManager_remove_SourceSelected(py::wrapper::Windows::Media::PlayTo::PlayToManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceSelected(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToManager[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(PlayToManager_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "show_play_to_u_i", reinterpret_cast<PyCFunction>(PlayToManager_ShowPlayToUI), METH_VARARGS | METH_STATIC, nullptr },
        { "add_source_requested", reinterpret_cast<PyCFunction>(PlayToManager_add_SourceRequested), METH_O, nullptr },
        { "remove_source_requested", reinterpret_cast<PyCFunction>(PlayToManager_remove_SourceRequested), METH_O, nullptr },
        { "add_source_selected", reinterpret_cast<PyCFunction>(PlayToManager_add_SourceSelected), METH_O, nullptr },
        { "remove_source_selected", reinterpret_cast<PyCFunction>(PlayToManager_remove_SourceSelected), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayToManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayToManager[] = {
        { "default_source_selection", reinterpret_cast<getter>(PlayToManager_get_DefaultSourceSelection), reinterpret_cast<setter>(PlayToManager_put_DefaultSourceSelection), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayToManager[] = 
    {
        { Py_tp_new, _new_PlayToManager },
        { Py_tp_dealloc, _dealloc_PlayToManager },
        { Py_tp_methods, _methods_PlayToManager },
        { Py_tp_getset, _getset_PlayToManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToManager =
    {
        "_winsdk_Windows_Media_PlayTo.PlayToManager",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToManager
    };

    // ----- PlayToReceiver class --------------------
    constexpr const char* const _type_name_PlayToReceiver = "PlayToReceiver";

    static PyObject* _new_PlayToReceiver(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::PlayTo::PlayToReceiver instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PlayToReceiver(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToReceiver_NotifyDurationChange(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.NotifyDurationChange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyEnded(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyEnded();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyError(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyError();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyLoadedMetadata(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyLoadedMetadata();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyPaused(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyPaused();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyPlaying(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyPlaying();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyRateChange(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                self->obj.NotifyRateChange(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifySeeked(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifySeeked();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifySeeking(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifySeeking();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyStopped(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.NotifyStopped();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyTimeUpdate(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                self->obj.NotifyTimeUpdate(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_NotifyVolumeChange(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                self->obj.NotifyVolumeChange(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_StartAsync(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_StopAsync(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_get_SupportsVideo(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsVideo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayToReceiver_put_SupportsVideo(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SupportsVideo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayToReceiver_get_SupportsImage(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayToReceiver_put_SupportsImage(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SupportsImage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayToReceiver_get_SupportsAudio(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsAudio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayToReceiver_put_SupportsAudio(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.SupportsAudio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayToReceiver_get_FriendlyName(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayToReceiver_put_FriendlyName(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FriendlyName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayToReceiver_get_Properties(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_CurrentTimeChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Media::PlayTo::CurrentTimeChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.CurrentTimeChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_CurrentTimeChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CurrentTimeChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_MuteChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Media::PlayTo::MuteChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.MuteChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_MuteChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MuteChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_PauseRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PauseRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_PauseRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PauseRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_PlayRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.PlayRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_PlayRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlayRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_PlaybackRateChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Media::PlayTo::PlaybackRateChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.PlaybackRateChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_PlaybackRateChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PlaybackRateChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_SourceChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Media::PlayTo::SourceChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.SourceChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_SourceChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.SourceChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_StopRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StopRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_StopRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StopRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_TimeUpdateRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.TimeUpdateRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_TimeUpdateRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.TimeUpdateRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_add_VolumeChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::PlayTo::PlayToReceiver, winrt::Windows::Media::PlayTo::VolumeChangeRequestedEventArgs>>(arg);

            return py::convert(self->obj.VolumeChangeRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToReceiver_remove_VolumeChangeRequested(py::wrapper::Windows::Media::PlayTo::PlayToReceiver* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.VolumeChangeRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToReceiver(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToReceiver>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToReceiver[] = {
        { "notify_duration_change", reinterpret_cast<PyCFunction>(PlayToReceiver_NotifyDurationChange), METH_VARARGS, nullptr },
        { "notify_ended", reinterpret_cast<PyCFunction>(PlayToReceiver_NotifyEnded), METH_VARARGS, nullptr },
        { "notify_error", reinterpret_cast<PyCFunction>(PlayToReceiver_NotifyError), METH_VARARGS, nullptr },
        { "notify_loaded_metadata", reinterpret_cast<PyCFunction>(PlayToReceiver_NotifyLoadedMetadata), METH_VARARGS, nullptr },
        { "notify_paused", reinterpret_cast<PyCFunction>(PlayToReceiver_NotifyPaused), METH_VARARGS, nullptr },
        { "notify_playing", reinterpret_cast<PyCFunction>(PlayToReceiver_NotifyPlaying), METH_VARARGS, nullptr },
        { "notify_rate_change", reinterpret_cast<PyCFunction>(PlayToReceiver_NotifyRateChange), METH_VARARGS, nullptr },
        { "notify_seeked", reinterpret_cast<PyCFunction>(PlayToReceiver_NotifySeeked), METH_VARARGS, nullptr },
        { "notify_seeking", reinterpret_cast<PyCFunction>(PlayToReceiver_NotifySeeking), METH_VARARGS, nullptr },
        { "notify_stopped", reinterpret_cast<PyCFunction>(PlayToReceiver_NotifyStopped), METH_VARARGS, nullptr },
        { "notify_time_update", reinterpret_cast<PyCFunction>(PlayToReceiver_NotifyTimeUpdate), METH_VARARGS, nullptr },
        { "notify_volume_change", reinterpret_cast<PyCFunction>(PlayToReceiver_NotifyVolumeChange), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(PlayToReceiver_StartAsync), METH_VARARGS, nullptr },
        { "stop_async", reinterpret_cast<PyCFunction>(PlayToReceiver_StopAsync), METH_VARARGS, nullptr },
        { "add_current_time_change_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_add_CurrentTimeChangeRequested), METH_O, nullptr },
        { "remove_current_time_change_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_remove_CurrentTimeChangeRequested), METH_O, nullptr },
        { "add_mute_change_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_add_MuteChangeRequested), METH_O, nullptr },
        { "remove_mute_change_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_remove_MuteChangeRequested), METH_O, nullptr },
        { "add_pause_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_add_PauseRequested), METH_O, nullptr },
        { "remove_pause_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_remove_PauseRequested), METH_O, nullptr },
        { "add_play_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_add_PlayRequested), METH_O, nullptr },
        { "remove_play_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_remove_PlayRequested), METH_O, nullptr },
        { "add_playback_rate_change_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_add_PlaybackRateChangeRequested), METH_O, nullptr },
        { "remove_playback_rate_change_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_remove_PlaybackRateChangeRequested), METH_O, nullptr },
        { "add_source_change_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_add_SourceChangeRequested), METH_O, nullptr },
        { "remove_source_change_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_remove_SourceChangeRequested), METH_O, nullptr },
        { "add_stop_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_add_StopRequested), METH_O, nullptr },
        { "remove_stop_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_remove_StopRequested), METH_O, nullptr },
        { "add_time_update_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_add_TimeUpdateRequested), METH_O, nullptr },
        { "remove_time_update_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_remove_TimeUpdateRequested), METH_O, nullptr },
        { "add_volume_change_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_add_VolumeChangeRequested), METH_O, nullptr },
        { "remove_volume_change_requested", reinterpret_cast<PyCFunction>(PlayToReceiver_remove_VolumeChangeRequested), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayToReceiver), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayToReceiver[] = {
        { "supports_video", reinterpret_cast<getter>(PlayToReceiver_get_SupportsVideo), reinterpret_cast<setter>(PlayToReceiver_put_SupportsVideo), nullptr, nullptr },
        { "supports_image", reinterpret_cast<getter>(PlayToReceiver_get_SupportsImage), reinterpret_cast<setter>(PlayToReceiver_put_SupportsImage), nullptr, nullptr },
        { "supports_audio", reinterpret_cast<getter>(PlayToReceiver_get_SupportsAudio), reinterpret_cast<setter>(PlayToReceiver_put_SupportsAudio), nullptr, nullptr },
        { "friendly_name", reinterpret_cast<getter>(PlayToReceiver_get_FriendlyName), reinterpret_cast<setter>(PlayToReceiver_put_FriendlyName), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(PlayToReceiver_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayToReceiver[] = 
    {
        { Py_tp_new, _new_PlayToReceiver },
        { Py_tp_dealloc, _dealloc_PlayToReceiver },
        { Py_tp_methods, _methods_PlayToReceiver },
        { Py_tp_getset, _getset_PlayToReceiver },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToReceiver =
    {
        "_winsdk_Windows_Media_PlayTo.PlayToReceiver",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToReceiver),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToReceiver
    };

    // ----- PlayToSource class --------------------
    constexpr const char* const _type_name_PlayToSource = "PlayToSource";

    static PyObject* _new_PlayToSource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToSource);
        return nullptr;
    }

    static void _dealloc_PlayToSource(py::wrapper::Windows::Media::PlayTo::PlayToSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToSource_PlayNext(py::wrapper::Windows::Media::PlayTo::PlayToSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.PlayNext();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToSource_get_Next(py::wrapper::Windows::Media::PlayTo::PlayToSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Next());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayToSource_put_Next(py::wrapper::Windows::Media::PlayTo::PlayToSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::PlayTo::PlayToSource>(arg);

            self->obj.Next(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PlayToSource_get_Connection(py::wrapper::Windows::Media::PlayTo::PlayToSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Connection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToSource_get_PreferredSourceUri(py::wrapper::Windows::Media::PlayTo::PlayToSource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreferredSourceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PlayToSource_put_PreferredSourceUri(py::wrapper::Windows::Media::PlayTo::PlayToSource* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.PreferredSourceUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_PlayToSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToSource[] = {
        { "play_next", reinterpret_cast<PyCFunction>(PlayToSource_PlayNext), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayToSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayToSource[] = {
        { "next", reinterpret_cast<getter>(PlayToSource_get_Next), reinterpret_cast<setter>(PlayToSource_put_Next), nullptr, nullptr },
        { "connection", reinterpret_cast<getter>(PlayToSource_get_Connection), nullptr, nullptr, nullptr },
        { "preferred_source_uri", reinterpret_cast<getter>(PlayToSource_get_PreferredSourceUri), reinterpret_cast<setter>(PlayToSource_put_PreferredSourceUri), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayToSource[] = 
    {
        { Py_tp_new, _new_PlayToSource },
        { Py_tp_dealloc, _dealloc_PlayToSource },
        { Py_tp_methods, _methods_PlayToSource },
        { Py_tp_getset, _getset_PlayToSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToSource =
    {
        "_winsdk_Windows_Media_PlayTo.PlayToSource",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToSource
    };

    // ----- PlayToSourceDeferral class --------------------
    constexpr const char* const _type_name_PlayToSourceDeferral = "PlayToSourceDeferral";

    static PyObject* _new_PlayToSourceDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToSourceDeferral);
        return nullptr;
    }

    static void _dealloc_PlayToSourceDeferral(py::wrapper::Windows::Media::PlayTo::PlayToSourceDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToSourceDeferral_Complete(py::wrapper::Windows::Media::PlayTo::PlayToSourceDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PlayToSourceDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToSourceDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToSourceDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(PlayToSourceDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayToSourceDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayToSourceDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_PlayToSourceDeferral[] = 
    {
        { Py_tp_new, _new_PlayToSourceDeferral },
        { Py_tp_dealloc, _dealloc_PlayToSourceDeferral },
        { Py_tp_methods, _methods_PlayToSourceDeferral },
        { Py_tp_getset, _getset_PlayToSourceDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToSourceDeferral =
    {
        "_winsdk_Windows_Media_PlayTo.PlayToSourceDeferral",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToSourceDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToSourceDeferral
    };

    // ----- PlayToSourceRequest class --------------------
    constexpr const char* const _type_name_PlayToSourceRequest = "PlayToSourceRequest";

    static PyObject* _new_PlayToSourceRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToSourceRequest);
        return nullptr;
    }

    static void _dealloc_PlayToSourceRequest(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToSourceRequest_DisplayErrorString(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.DisplayErrorString(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToSourceRequest_GetDeferral(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToSourceRequest_SetSource(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::PlayTo::PlayToSource>(args, 0);

                self->obj.SetSource(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PlayToSourceRequest_get_Deadline(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Deadline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToSourceRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToSourceRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToSourceRequest[] = {
        { "display_error_string", reinterpret_cast<PyCFunction>(PlayToSourceRequest_DisplayErrorString), METH_VARARGS, nullptr },
        { "get_deferral", reinterpret_cast<PyCFunction>(PlayToSourceRequest_GetDeferral), METH_VARARGS, nullptr },
        { "set_source", reinterpret_cast<PyCFunction>(PlayToSourceRequest_SetSource), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayToSourceRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayToSourceRequest[] = {
        { "deadline", reinterpret_cast<getter>(PlayToSourceRequest_get_Deadline), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayToSourceRequest[] = 
    {
        { Py_tp_new, _new_PlayToSourceRequest },
        { Py_tp_dealloc, _dealloc_PlayToSourceRequest },
        { Py_tp_methods, _methods_PlayToSourceRequest },
        { Py_tp_getset, _getset_PlayToSourceRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToSourceRequest =
    {
        "_winsdk_Windows_Media_PlayTo.PlayToSourceRequest",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToSourceRequest
    };

    // ----- PlayToSourceRequestedEventArgs class --------------------
    constexpr const char* const _type_name_PlayToSourceRequestedEventArgs = "PlayToSourceRequestedEventArgs";

    static PyObject* _new_PlayToSourceRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToSourceRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_PlayToSourceRequestedEventArgs(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToSourceRequestedEventArgs_get_SourceRequest(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceRequest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToSourceRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToSourceRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToSourceRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayToSourceRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayToSourceRequestedEventArgs[] = {
        { "source_request", reinterpret_cast<getter>(PlayToSourceRequestedEventArgs_get_SourceRequest), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayToSourceRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_PlayToSourceRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_PlayToSourceRequestedEventArgs },
        { Py_tp_methods, _methods_PlayToSourceRequestedEventArgs },
        { Py_tp_getset, _getset_PlayToSourceRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToSourceRequestedEventArgs =
    {
        "_winsdk_Windows_Media_PlayTo.PlayToSourceRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToSourceRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToSourceRequestedEventArgs
    };

    // ----- PlayToSourceSelectedEventArgs class --------------------
    constexpr const char* const _type_name_PlayToSourceSelectedEventArgs = "PlayToSourceSelectedEventArgs";

    static PyObject* _new_PlayToSourceSelectedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlayToSourceSelectedEventArgs);
        return nullptr;
    }

    static void _dealloc_PlayToSourceSelectedEventArgs(py::wrapper::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlayToSourceSelectedEventArgs_get_FriendlyName(py::wrapper::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FriendlyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToSourceSelectedEventArgs_get_Icon(py::wrapper::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToSourceSelectedEventArgs_get_SupportsAudio(py::wrapper::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsAudio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToSourceSelectedEventArgs_get_SupportsImage(py::wrapper::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PlayToSourceSelectedEventArgs_get_SupportsVideo(py::wrapper::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsVideo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlayToSourceSelectedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlayToSourceSelectedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PlayToSourceSelectedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlayToSourceSelectedEventArgs[] = {
        { "friendly_name", reinterpret_cast<getter>(PlayToSourceSelectedEventArgs_get_FriendlyName), nullptr, nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(PlayToSourceSelectedEventArgs_get_Icon), nullptr, nullptr, nullptr },
        { "supports_audio", reinterpret_cast<getter>(PlayToSourceSelectedEventArgs_get_SupportsAudio), nullptr, nullptr, nullptr },
        { "supports_image", reinterpret_cast<getter>(PlayToSourceSelectedEventArgs_get_SupportsImage), nullptr, nullptr, nullptr },
        { "supports_video", reinterpret_cast<getter>(PlayToSourceSelectedEventArgs_get_SupportsVideo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlayToSourceSelectedEventArgs[] = 
    {
        { Py_tp_new, _new_PlayToSourceSelectedEventArgs },
        { Py_tp_dealloc, _dealloc_PlayToSourceSelectedEventArgs },
        { Py_tp_methods, _methods_PlayToSourceSelectedEventArgs },
        { Py_tp_getset, _getset_PlayToSourceSelectedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlayToSourceSelectedEventArgs =
    {
        "_winsdk_Windows_Media_PlayTo.PlayToSourceSelectedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlayToSourceSelectedEventArgs
    };

    // ----- PlaybackRateChangeRequestedEventArgs class --------------------
    constexpr const char* const _type_name_PlaybackRateChangeRequestedEventArgs = "PlaybackRateChangeRequestedEventArgs";

    static PyObject* _new_PlaybackRateChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PlaybackRateChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_PlaybackRateChangeRequestedEventArgs(py::wrapper::Windows::Media::PlayTo::PlaybackRateChangeRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PlaybackRateChangeRequestedEventArgs_get_Rate(py::wrapper::Windows::Media::PlayTo::PlaybackRateChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PlaybackRateChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::PlaybackRateChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PlaybackRateChangeRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PlaybackRateChangeRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PlaybackRateChangeRequestedEventArgs[] = {
        { "rate", reinterpret_cast<getter>(PlaybackRateChangeRequestedEventArgs_get_Rate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PlaybackRateChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_PlaybackRateChangeRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_PlaybackRateChangeRequestedEventArgs },
        { Py_tp_methods, _methods_PlaybackRateChangeRequestedEventArgs },
        { Py_tp_getset, _getset_PlaybackRateChangeRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PlaybackRateChangeRequestedEventArgs =
    {
        "_winsdk_Windows_Media_PlayTo.PlaybackRateChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::PlaybackRateChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PlaybackRateChangeRequestedEventArgs
    };

    // ----- SourceChangeRequestedEventArgs class --------------------
    constexpr const char* const _type_name_SourceChangeRequestedEventArgs = "SourceChangeRequestedEventArgs";

    static PyObject* _new_SourceChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SourceChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_SourceChangeRequestedEventArgs(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Album(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Album());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Author(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Author());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Date(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Date());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Description(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Genre(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Genre());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Properties(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Rating(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rating());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Stream(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Stream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Thumbnail(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SourceChangeRequestedEventArgs_get_Title(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SourceChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::SourceChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SourceChangeRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SourceChangeRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SourceChangeRequestedEventArgs[] = {
        { "album", reinterpret_cast<getter>(SourceChangeRequestedEventArgs_get_Album), nullptr, nullptr, nullptr },
        { "author", reinterpret_cast<getter>(SourceChangeRequestedEventArgs_get_Author), nullptr, nullptr, nullptr },
        { "date", reinterpret_cast<getter>(SourceChangeRequestedEventArgs_get_Date), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(SourceChangeRequestedEventArgs_get_Description), nullptr, nullptr, nullptr },
        { "genre", reinterpret_cast<getter>(SourceChangeRequestedEventArgs_get_Genre), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(SourceChangeRequestedEventArgs_get_Properties), nullptr, nullptr, nullptr },
        { "rating", reinterpret_cast<getter>(SourceChangeRequestedEventArgs_get_Rating), nullptr, nullptr, nullptr },
        { "stream", reinterpret_cast<getter>(SourceChangeRequestedEventArgs_get_Stream), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(SourceChangeRequestedEventArgs_get_Thumbnail), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(SourceChangeRequestedEventArgs_get_Title), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SourceChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_SourceChangeRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_SourceChangeRequestedEventArgs },
        { Py_tp_methods, _methods_SourceChangeRequestedEventArgs },
        { Py_tp_getset, _getset_SourceChangeRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SourceChangeRequestedEventArgs =
    {
        "_winsdk_Windows_Media_PlayTo.SourceChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::SourceChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SourceChangeRequestedEventArgs
    };

    // ----- VolumeChangeRequestedEventArgs class --------------------
    constexpr const char* const _type_name_VolumeChangeRequestedEventArgs = "VolumeChangeRequestedEventArgs";

    static PyObject* _new_VolumeChangeRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VolumeChangeRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_VolumeChangeRequestedEventArgs(py::wrapper::Windows::Media::PlayTo::VolumeChangeRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VolumeChangeRequestedEventArgs_get_Volume(py::wrapper::Windows::Media::PlayTo::VolumeChangeRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Volume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VolumeChangeRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::PlayTo::VolumeChangeRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VolumeChangeRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VolumeChangeRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VolumeChangeRequestedEventArgs[] = {
        { "volume", reinterpret_cast<getter>(VolumeChangeRequestedEventArgs_get_Volume), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VolumeChangeRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_VolumeChangeRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_VolumeChangeRequestedEventArgs },
        { Py_tp_methods, _methods_VolumeChangeRequestedEventArgs },
        { Py_tp_getset, _getset_VolumeChangeRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VolumeChangeRequestedEventArgs =
    {
        "_winsdk_Windows_Media_PlayTo.VolumeChangeRequestedEventArgs",
        sizeof(py::wrapper::Windows::Media::PlayTo::VolumeChangeRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VolumeChangeRequestedEventArgs
    };

    // ----- Windows.Media.PlayTo Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Media::PlayTo::CurrentTimeChangeRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_CurrentTimeChangeRequestedEventArgs, &_type_spec_CurrentTimeChangeRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::MuteChangeRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_MuteChangeRequestedEventArgs, &_type_spec_MuteChangeRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnection>::python_type = py::register_python_type(module, _type_name_PlayToConnection, &_type_spec_PlayToConnection, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnectionErrorEventArgs>::python_type = py::register_python_type(module, _type_name_PlayToConnectionErrorEventArgs, &_type_spec_PlayToConnectionErrorEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnectionStateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_PlayToConnectionStateChangedEventArgs, &_type_spec_PlayToConnectionStateChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToConnectionTransferredEventArgs>::python_type = py::register_python_type(module, _type_name_PlayToConnectionTransferredEventArgs, &_type_spec_PlayToConnectionTransferredEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToManager>::python_type = py::register_python_type(module, _type_name_PlayToManager, &_type_spec_PlayToManager, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToReceiver>::python_type = py::register_python_type(module, _type_name_PlayToReceiver, &_type_spec_PlayToReceiver, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSource>::python_type = py::register_python_type(module, _type_name_PlayToSource, &_type_spec_PlayToSource, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceDeferral>::python_type = py::register_python_type(module, _type_name_PlayToSourceDeferral, &_type_spec_PlayToSourceDeferral, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceRequest>::python_type = py::register_python_type(module, _type_name_PlayToSourceRequest, &_type_spec_PlayToSourceRequest, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_PlayToSourceRequestedEventArgs, &_type_spec_PlayToSourceRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlayToSourceSelectedEventArgs>::python_type = py::register_python_type(module, _type_name_PlayToSourceSelectedEventArgs, &_type_spec_PlayToSourceSelectedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::PlaybackRateChangeRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_PlaybackRateChangeRequestedEventArgs, &_type_spec_PlaybackRateChangeRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::SourceChangeRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_SourceChangeRequestedEventArgs, &_type_spec_SourceChangeRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::PlayTo::VolumeChangeRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_VolumeChangeRequestedEventArgs, &_type_spec_VolumeChangeRequestedEventArgs, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Media.PlayTo");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_PlayTo",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Media::PlayTo

PyMODINIT_FUNC
PyInit__winsdk_Windows_Media_PlayTo (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::PlayTo::module_def);
}
