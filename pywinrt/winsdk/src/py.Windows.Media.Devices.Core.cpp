// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Media.Devices.Core.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::CameraIntrinsics>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameControlCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCompensationControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFlashCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFlashControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFocusCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFocusControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::FrameIsoSpeedControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::Core::VariablePhotoSequenceController>::python_type;

namespace py::cpp::Windows::Media::Devices::Core
{
    // ----- CameraIntrinsics class --------------------
    constexpr const char* const _type_name_CameraIntrinsics = "CameraIntrinsics";

    static PyObject* _new_CameraIntrinsics(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Foundation::Numerics::float2>(args, 3);
                auto param4 = py::convert_to<uint32_t>(args, 4);
                auto param5 = py::convert_to<uint32_t>(args, 5);

                winrt::Windows::Media::Devices::Core::CameraIntrinsics instance{ param0, param1, param2, param3, param4, param5 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CameraIntrinsics(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CameraIntrinsics_DistortPoint(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.DistortPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_DistortPoints(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Point>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Foundation::Point> param1 ( param1_count, py::empty_instance<winrt::Windows::Foundation::Point>::get() );

                self->obj.DistortPoints(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_ProjectManyOntoFrame(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Numerics::float3>>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Point>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Foundation::Point> param1 ( param1_count, py::empty_instance<winrt::Windows::Foundation::Point>::get() );

                self->obj.ProjectManyOntoFrame(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_ProjectOntoFrame(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::float3>(args, 0);

                return py::convert(self->obj.ProjectOntoFrame(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UndistortPoint(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.UndistortPoint(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UndistortPoints(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Point>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Foundation::Point> param1 ( param1_count, py::empty_instance<winrt::Windows::Foundation::Point>::get() );

                self->obj.UndistortPoints(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UnprojectAtUnitDepth(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);

                return py::convert(self->obj.UnprojectAtUnitDepth(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_UnprojectPixelsAtUnitDepth(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Numerics::float2>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Foundation::Numerics::float2> param1 ( param1_count, py::empty_instance<winrt::Windows::Foundation::Numerics::float2>::get() );

                self->obj.UnprojectPixelsAtUnitDepth(param0, param1);

                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return out1.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_FocalLength(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FocalLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_ImageHeight(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ImageHeight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_ImageWidth(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ImageWidth());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_PrincipalPoint(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrincipalPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_RadialDistortion(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RadialDistortion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_TangentialDistortion(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TangentialDistortion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraIntrinsics_get_UndistortedProjectionTransform(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UndistortedProjectionTransform());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CameraIntrinsics(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::CameraIntrinsics>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraIntrinsics[] = {
        { "distort_point", reinterpret_cast<PyCFunction>(CameraIntrinsics_DistortPoint), METH_VARARGS, nullptr },
        { "distort_points", reinterpret_cast<PyCFunction>(CameraIntrinsics_DistortPoints), METH_VARARGS, nullptr },
        { "project_many_onto_frame", reinterpret_cast<PyCFunction>(CameraIntrinsics_ProjectManyOntoFrame), METH_VARARGS, nullptr },
        { "project_onto_frame", reinterpret_cast<PyCFunction>(CameraIntrinsics_ProjectOntoFrame), METH_VARARGS, nullptr },
        { "undistort_point", reinterpret_cast<PyCFunction>(CameraIntrinsics_UndistortPoint), METH_VARARGS, nullptr },
        { "undistort_points", reinterpret_cast<PyCFunction>(CameraIntrinsics_UndistortPoints), METH_VARARGS, nullptr },
        { "unproject_at_unit_depth", reinterpret_cast<PyCFunction>(CameraIntrinsics_UnprojectAtUnitDepth), METH_VARARGS, nullptr },
        { "unproject_pixels_at_unit_depth", reinterpret_cast<PyCFunction>(CameraIntrinsics_UnprojectPixelsAtUnitDepth), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraIntrinsics), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraIntrinsics[] = {
        { "focal_length", reinterpret_cast<getter>(CameraIntrinsics_get_FocalLength), nullptr, nullptr, nullptr },
        { "image_height", reinterpret_cast<getter>(CameraIntrinsics_get_ImageHeight), nullptr, nullptr, nullptr },
        { "image_width", reinterpret_cast<getter>(CameraIntrinsics_get_ImageWidth), nullptr, nullptr, nullptr },
        { "principal_point", reinterpret_cast<getter>(CameraIntrinsics_get_PrincipalPoint), nullptr, nullptr, nullptr },
        { "radial_distortion", reinterpret_cast<getter>(CameraIntrinsics_get_RadialDistortion), nullptr, nullptr, nullptr },
        { "tangential_distortion", reinterpret_cast<getter>(CameraIntrinsics_get_TangentialDistortion), nullptr, nullptr, nullptr },
        { "undistorted_projection_transform", reinterpret_cast<getter>(CameraIntrinsics_get_UndistortedProjectionTransform), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraIntrinsics[] = 
    {
        { Py_tp_new, _new_CameraIntrinsics },
        { Py_tp_dealloc, _dealloc_CameraIntrinsics },
        { Py_tp_methods, _methods_CameraIntrinsics },
        { Py_tp_getset, _getset_CameraIntrinsics },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CameraIntrinsics =
    {
        "_winsdk_Windows_Media_Devices_Core.CameraIntrinsics",
        sizeof(py::wrapper::Windows::Media::Devices::Core::CameraIntrinsics),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraIntrinsics
    };

    // ----- DepthCorrelatedCoordinateMapper class --------------------
    constexpr const char* const _type_name_DepthCorrelatedCoordinateMapper = "DepthCorrelatedCoordinateMapper";

    static PyObject* _new_DepthCorrelatedCoordinateMapper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DepthCorrelatedCoordinateMapper);
        return nullptr;
    }

    static void _dealloc_DepthCorrelatedCoordinateMapper(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DepthCorrelatedCoordinateMapper_Close(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_MapPoint(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Devices::Core::CameraIntrinsics>(args, 2);

                return py::convert(self->obj.MapPoint(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_MapPoints(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::Devices::Core::CameraIntrinsics>(args, 2);
                auto param3_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Point>::size_type>(args, 3);
                winrt::com_array<winrt::Windows::Foundation::Point> param3 ( param3_count, py::empty_instance<winrt::Windows::Foundation::Point>::get() );

                self->obj.MapPoints(param0, param1, param2, param3);

                py::pyobj_handle out3{ py::convert(param3) };
                if (!out3)
                {
                    return nullptr;
                }
                return out3.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_UnprojectPoint(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Point>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);

                return py::convert(self->obj.UnprojectPoint(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DepthCorrelatedCoordinateMapper_UnprojectPoints(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::Foundation::Point>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Perception::Spatial::SpatialCoordinateSystem>(args, 1);
                auto param2_count = py::convert_to<winrt::com_array<winrt::Windows::Foundation::Numerics::float3>::size_type>(args, 2);
                winrt::com_array<winrt::Windows::Foundation::Numerics::float3> param2 ( param2_count, py::empty_instance<winrt::Windows::Foundation::Numerics::float3>::get() );

                self->obj.UnprojectPoints(param0, param1, param2);

                py::pyobj_handle out2{ py::convert(param2) };
                if (!out2)
                {
                    return nullptr;
                }
                return out2.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_DepthCorrelatedCoordinateMapper(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DepthCorrelatedCoordinateMapper(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_DepthCorrelatedCoordinateMapper(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DepthCorrelatedCoordinateMapper[] = {
        { "close", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_Close), METH_VARARGS, nullptr },
        { "map_point", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_MapPoint), METH_VARARGS, nullptr },
        { "map_points", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_MapPoints), METH_VARARGS, nullptr },
        { "unproject_point", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_UnprojectPoint), METH_VARARGS, nullptr },
        { "unproject_points", reinterpret_cast<PyCFunction>(DepthCorrelatedCoordinateMapper_UnprojectPoints), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DepthCorrelatedCoordinateMapper), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DepthCorrelatedCoordinateMapper), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_DepthCorrelatedCoordinateMapper), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_DepthCorrelatedCoordinateMapper[] = {
        { }
    };

    static PyType_Slot _type_slots_DepthCorrelatedCoordinateMapper[] = 
    {
        { Py_tp_new, _new_DepthCorrelatedCoordinateMapper },
        { Py_tp_dealloc, _dealloc_DepthCorrelatedCoordinateMapper },
        { Py_tp_methods, _methods_DepthCorrelatedCoordinateMapper },
        { Py_tp_getset, _getset_DepthCorrelatedCoordinateMapper },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DepthCorrelatedCoordinateMapper =
    {
        "_winsdk_Windows_Media_Devices_Core.DepthCorrelatedCoordinateMapper",
        sizeof(py::wrapper::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DepthCorrelatedCoordinateMapper
    };

    // ----- FrameControlCapabilities class --------------------
    constexpr const char* const _type_name_FrameControlCapabilities = "FrameControlCapabilities";

    static PyObject* _new_FrameControlCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameControlCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameControlCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameControlCapabilities_get_Exposure(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_ExposureCompensation(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExposureCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_Focus(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Focus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_IsoSpeed(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsoSpeed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_PhotoConfirmationSupported(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotoConfirmationSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameControlCapabilities_get_Flash(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Flash());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameControlCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameControlCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameControlCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameControlCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameControlCapabilities[] = {
        { "exposure", reinterpret_cast<getter>(FrameControlCapabilities_get_Exposure), nullptr, nullptr, nullptr },
        { "exposure_compensation", reinterpret_cast<getter>(FrameControlCapabilities_get_ExposureCompensation), nullptr, nullptr, nullptr },
        { "focus", reinterpret_cast<getter>(FrameControlCapabilities_get_Focus), nullptr, nullptr, nullptr },
        { "iso_speed", reinterpret_cast<getter>(FrameControlCapabilities_get_IsoSpeed), nullptr, nullptr, nullptr },
        { "photo_confirmation_supported", reinterpret_cast<getter>(FrameControlCapabilities_get_PhotoConfirmationSupported), nullptr, nullptr, nullptr },
        { "flash", reinterpret_cast<getter>(FrameControlCapabilities_get_Flash), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameControlCapabilities[] = 
    {
        { Py_tp_new, _new_FrameControlCapabilities },
        { Py_tp_dealloc, _dealloc_FrameControlCapabilities },
        { Py_tp_methods, _methods_FrameControlCapabilities },
        { Py_tp_getset, _getset_FrameControlCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameControlCapabilities =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameControlCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameControlCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameControlCapabilities
    };

    // ----- FrameController class --------------------
    constexpr const char* const _type_name_FrameController = "FrameController";

    static PyObject* _new_FrameController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::Core::FrameController instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FrameController(py::wrapper::Windows::Media::Devices::Core::FrameController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameController_get_PhotoConfirmationEnabled(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotoConfirmationEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameController_put_PhotoConfirmationEnabled(py::wrapper::Windows::Media::Devices::Core::FrameController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.PhotoConfirmationEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameController_get_ExposureCompensationControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExposureCompensationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_ExposureControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExposureControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_FocusControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FocusControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_IsoSpeedControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsoSpeedControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameController_get_FlashControl(py::wrapper::Windows::Media::Devices::Core::FrameController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FlashControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameController[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameController[] = {
        { "photo_confirmation_enabled", reinterpret_cast<getter>(FrameController_get_PhotoConfirmationEnabled), reinterpret_cast<setter>(FrameController_put_PhotoConfirmationEnabled), nullptr, nullptr },
        { "exposure_compensation_control", reinterpret_cast<getter>(FrameController_get_ExposureCompensationControl), nullptr, nullptr, nullptr },
        { "exposure_control", reinterpret_cast<getter>(FrameController_get_ExposureControl), nullptr, nullptr, nullptr },
        { "focus_control", reinterpret_cast<getter>(FrameController_get_FocusControl), nullptr, nullptr, nullptr },
        { "iso_speed_control", reinterpret_cast<getter>(FrameController_get_IsoSpeedControl), nullptr, nullptr, nullptr },
        { "flash_control", reinterpret_cast<getter>(FrameController_get_FlashControl), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameController[] = 
    {
        { Py_tp_new, _new_FrameController },
        { Py_tp_dealloc, _dealloc_FrameController },
        { Py_tp_methods, _methods_FrameController },
        { Py_tp_getset, _getset_FrameController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameController =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameController",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameController
    };

    // ----- FrameExposureCapabilities class --------------------
    constexpr const char* const _type_name_FrameExposureCapabilities = "FrameExposureCapabilities";

    static PyObject* _new_FrameExposureCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameExposureCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameExposureCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameExposureCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameExposureCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameExposureCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameExposureCapabilities[] = {
        { "max", reinterpret_cast<getter>(FrameExposureCapabilities_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(FrameExposureCapabilities_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(FrameExposureCapabilities_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameExposureCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameExposureCapabilities[] = 
    {
        { Py_tp_new, _new_FrameExposureCapabilities },
        { Py_tp_dealloc, _dealloc_FrameExposureCapabilities },
        { Py_tp_methods, _methods_FrameExposureCapabilities },
        { Py_tp_getset, _getset_FrameExposureCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameExposureCapabilities =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameExposureCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureCapabilities
    };

    // ----- FrameExposureCompensationCapabilities class --------------------
    constexpr const char* const _type_name_FrameExposureCompensationCapabilities = "FrameExposureCompensationCapabilities";

    static PyObject* _new_FrameExposureCompensationCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameExposureCompensationCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameExposureCompensationCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameExposureCompensationCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameExposureCompensationCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureCompensationCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameExposureCompensationCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameExposureCompensationCapabilities[] = {
        { "max", reinterpret_cast<getter>(FrameExposureCompensationCapabilities_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(FrameExposureCompensationCapabilities_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(FrameExposureCompensationCapabilities_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameExposureCompensationCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameExposureCompensationCapabilities[] = 
    {
        { Py_tp_new, _new_FrameExposureCompensationCapabilities },
        { Py_tp_dealloc, _dealloc_FrameExposureCompensationCapabilities },
        { Py_tp_methods, _methods_FrameExposureCompensationCapabilities },
        { Py_tp_getset, _getset_FrameExposureCompensationCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameExposureCompensationCapabilities =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameExposureCompensationCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureCompensationCapabilities
    };

    // ----- FrameExposureCompensationControl class --------------------
    constexpr const char* const _type_name_FrameExposureCompensationControl = "FrameExposureCompensationControl";

    static PyObject* _new_FrameExposureCompensationControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameExposureCompensationControl);
        return nullptr;
    }

    static void _dealloc_FrameExposureCompensationControl(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameExposureCompensationControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameExposureCompensationControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<float>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FrameExposureCompensationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureCompensationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureCompensationControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameExposureCompensationControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameExposureCompensationControl[] = {
        { "value", reinterpret_cast<getter>(FrameExposureCompensationControl_get_Value), reinterpret_cast<setter>(FrameExposureCompensationControl_put_Value), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameExposureCompensationControl[] = 
    {
        { Py_tp_new, _new_FrameExposureCompensationControl },
        { Py_tp_dealloc, _dealloc_FrameExposureCompensationControl },
        { Py_tp_methods, _methods_FrameExposureCompensationControl },
        { Py_tp_getset, _getset_FrameExposureCompensationControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameExposureCompensationControl =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameExposureCompensationControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureCompensationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureCompensationControl
    };

    // ----- FrameExposureControl class --------------------
    constexpr const char* const _type_name_FrameExposureControl = "FrameExposureControl";

    static PyObject* _new_FrameExposureControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameExposureControl);
        return nullptr;
    }

    static void _dealloc_FrameExposureControl(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameExposureControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameExposureControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::TimeSpan>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameExposureControl_get_Auto(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameExposureControl_put_Auto(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Auto(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FrameExposureControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameExposureControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameExposureControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameExposureControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameExposureControl[] = {
        { "value", reinterpret_cast<getter>(FrameExposureControl_get_Value), reinterpret_cast<setter>(FrameExposureControl_put_Value), nullptr, nullptr },
        { "auto", reinterpret_cast<getter>(FrameExposureControl_get_Auto), reinterpret_cast<setter>(FrameExposureControl_put_Auto), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameExposureControl[] = 
    {
        { Py_tp_new, _new_FrameExposureControl },
        { Py_tp_dealloc, _dealloc_FrameExposureControl },
        { Py_tp_methods, _methods_FrameExposureControl },
        { Py_tp_getset, _getset_FrameExposureControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameExposureControl =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameExposureControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameExposureControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameExposureControl
    };

    // ----- FrameFlashCapabilities class --------------------
    constexpr const char* const _type_name_FrameFlashCapabilities = "FrameFlashCapabilities";

    static PyObject* _new_FrameFlashCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameFlashCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameFlashCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameFlashCapabilities_get_PowerSupported(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFlashCapabilities_get_RedEyeReductionSupported(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RedEyeReductionSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFlashCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameFlashCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFlashCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFlashCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameFlashCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameFlashCapabilities[] = {
        { "power_supported", reinterpret_cast<getter>(FrameFlashCapabilities_get_PowerSupported), nullptr, nullptr, nullptr },
        { "red_eye_reduction_supported", reinterpret_cast<getter>(FrameFlashCapabilities_get_RedEyeReductionSupported), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameFlashCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameFlashCapabilities[] = 
    {
        { Py_tp_new, _new_FrameFlashCapabilities },
        { Py_tp_dealloc, _dealloc_FrameFlashCapabilities },
        { Py_tp_methods, _methods_FrameFlashCapabilities },
        { Py_tp_getset, _getset_FrameFlashCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameFlashCapabilities =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameFlashCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFlashCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFlashCapabilities
    };

    // ----- FrameFlashControl class --------------------
    constexpr const char* const _type_name_FrameFlashControl = "FrameFlashControl";

    static PyObject* _new_FrameFlashControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameFlashControl);
        return nullptr;
    }

    static void _dealloc_FrameFlashControl(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameFlashControl_get_RedEyeReduction(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RedEyeReduction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_RedEyeReduction(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RedEyeReduction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameFlashControl_get_PowerPercent(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_PowerPercent(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PowerPercent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameFlashControl_get_Mode(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_Mode(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::Core::FrameFlashMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameFlashControl_get_Auto(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFlashControl_put_Auto(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Auto(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FrameFlashControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFlashControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFlashControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameFlashControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameFlashControl[] = {
        { "red_eye_reduction", reinterpret_cast<getter>(FrameFlashControl_get_RedEyeReduction), reinterpret_cast<setter>(FrameFlashControl_put_RedEyeReduction), nullptr, nullptr },
        { "power_percent", reinterpret_cast<getter>(FrameFlashControl_get_PowerPercent), reinterpret_cast<setter>(FrameFlashControl_put_PowerPercent), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(FrameFlashControl_get_Mode), reinterpret_cast<setter>(FrameFlashControl_put_Mode), nullptr, nullptr },
        { "auto", reinterpret_cast<getter>(FrameFlashControl_get_Auto), reinterpret_cast<setter>(FrameFlashControl_put_Auto), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameFlashControl[] = 
    {
        { Py_tp_new, _new_FrameFlashControl },
        { Py_tp_dealloc, _dealloc_FrameFlashControl },
        { Py_tp_methods, _methods_FrameFlashControl },
        { Py_tp_getset, _getset_FrameFlashControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameFlashControl =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameFlashControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFlashControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFlashControl
    };

    // ----- FrameFocusCapabilities class --------------------
    constexpr const char* const _type_name_FrameFocusCapabilities = "FrameFocusCapabilities";

    static PyObject* _new_FrameFocusCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameFocusCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameFocusCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameFocusCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFocusCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFocusCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameFocusCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameFocusCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFocusCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFocusCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameFocusCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameFocusCapabilities[] = {
        { "max", reinterpret_cast<getter>(FrameFocusCapabilities_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(FrameFocusCapabilities_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(FrameFocusCapabilities_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameFocusCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameFocusCapabilities[] = 
    {
        { Py_tp_new, _new_FrameFocusCapabilities },
        { Py_tp_dealloc, _dealloc_FrameFocusCapabilities },
        { Py_tp_methods, _methods_FrameFocusCapabilities },
        { Py_tp_getset, _getset_FrameFocusCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameFocusCapabilities =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameFocusCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFocusCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFocusCapabilities
    };

    // ----- FrameFocusControl class --------------------
    constexpr const char* const _type_name_FrameFocusControl = "FrameFocusControl";

    static PyObject* _new_FrameFocusControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameFocusControl);
        return nullptr;
    }

    static void _dealloc_FrameFocusControl(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameFocusControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameFocusControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FrameFocusControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameFocusControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameFocusControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameFocusControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameFocusControl[] = {
        { "value", reinterpret_cast<getter>(FrameFocusControl_get_Value), reinterpret_cast<setter>(FrameFocusControl_put_Value), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameFocusControl[] = 
    {
        { Py_tp_new, _new_FrameFocusControl },
        { Py_tp_dealloc, _dealloc_FrameFocusControl },
        { Py_tp_methods, _methods_FrameFocusControl },
        { Py_tp_getset, _getset_FrameFocusControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameFocusControl =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameFocusControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameFocusControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameFocusControl
    };

    // ----- FrameIsoSpeedCapabilities class --------------------
    constexpr const char* const _type_name_FrameIsoSpeedCapabilities = "FrameIsoSpeedCapabilities";

    static PyObject* _new_FrameIsoSpeedCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameIsoSpeedCapabilities);
        return nullptr;
    }

    static void _dealloc_FrameIsoSpeedCapabilities(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Max(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Min(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Step(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FrameIsoSpeedCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FrameIsoSpeedCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameIsoSpeedCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameIsoSpeedCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameIsoSpeedCapabilities[] = {
        { "max", reinterpret_cast<getter>(FrameIsoSpeedCapabilities_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(FrameIsoSpeedCapabilities_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(FrameIsoSpeedCapabilities_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FrameIsoSpeedCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameIsoSpeedCapabilities[] = 
    {
        { Py_tp_new, _new_FrameIsoSpeedCapabilities },
        { Py_tp_dealloc, _dealloc_FrameIsoSpeedCapabilities },
        { Py_tp_methods, _methods_FrameIsoSpeedCapabilities },
        { Py_tp_getset, _getset_FrameIsoSpeedCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameIsoSpeedCapabilities =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameIsoSpeedCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameIsoSpeedCapabilities
    };

    // ----- FrameIsoSpeedControl class --------------------
    constexpr const char* const _type_name_FrameIsoSpeedControl = "FrameIsoSpeedControl";

    static PyObject* _new_FrameIsoSpeedControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FrameIsoSpeedControl);
        return nullptr;
    }

    static void _dealloc_FrameIsoSpeedControl(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FrameIsoSpeedControl_get_Value(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameIsoSpeedControl_put_Value(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FrameIsoSpeedControl_get_Auto(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FrameIsoSpeedControl_put_Auto(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Auto(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FrameIsoSpeedControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::FrameIsoSpeedControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FrameIsoSpeedControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FrameIsoSpeedControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FrameIsoSpeedControl[] = {
        { "value", reinterpret_cast<getter>(FrameIsoSpeedControl_get_Value), reinterpret_cast<setter>(FrameIsoSpeedControl_put_Value), nullptr, nullptr },
        { "auto", reinterpret_cast<getter>(FrameIsoSpeedControl_get_Auto), reinterpret_cast<setter>(FrameIsoSpeedControl_put_Auto), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FrameIsoSpeedControl[] = 
    {
        { Py_tp_new, _new_FrameIsoSpeedControl },
        { Py_tp_dealloc, _dealloc_FrameIsoSpeedControl },
        { Py_tp_methods, _methods_FrameIsoSpeedControl },
        { Py_tp_getset, _getset_FrameIsoSpeedControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FrameIsoSpeedControl =
    {
        "_winsdk_Windows_Media_Devices_Core.FrameIsoSpeedControl",
        sizeof(py::wrapper::Windows::Media::Devices::Core::FrameIsoSpeedControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FrameIsoSpeedControl
    };

    // ----- VariablePhotoSequenceController class --------------------
    constexpr const char* const _type_name_VariablePhotoSequenceController = "VariablePhotoSequenceController";

    static PyObject* _new_VariablePhotoSequenceController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VariablePhotoSequenceController);
        return nullptr;
    }

    static void _dealloc_VariablePhotoSequenceController(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VariablePhotoSequenceController_GetCurrentFrameRate(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentFrameRate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_GetHighestConcurrentFrameRate(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 0);

                return py::convert(self->obj.GetHighestConcurrentFrameRate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_PhotosPerSecondLimit(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotosPerSecondLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VariablePhotoSequenceController_put_PhotosPerSecondLimit(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PhotosPerSecondLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_DesiredFrameControllers(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredFrameControllers());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_FrameCapabilities(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_MaxPhotosPerSecond(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPhotosPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VariablePhotoSequenceController_get_Supported(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VariablePhotoSequenceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::Core::VariablePhotoSequenceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VariablePhotoSequenceController[] = {
        { "get_current_frame_rate", reinterpret_cast<PyCFunction>(VariablePhotoSequenceController_GetCurrentFrameRate), METH_VARARGS, nullptr },
        { "get_highest_concurrent_frame_rate", reinterpret_cast<PyCFunction>(VariablePhotoSequenceController_GetHighestConcurrentFrameRate), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VariablePhotoSequenceController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VariablePhotoSequenceController[] = {
        { "photos_per_second_limit", reinterpret_cast<getter>(VariablePhotoSequenceController_get_PhotosPerSecondLimit), reinterpret_cast<setter>(VariablePhotoSequenceController_put_PhotosPerSecondLimit), nullptr, nullptr },
        { "desired_frame_controllers", reinterpret_cast<getter>(VariablePhotoSequenceController_get_DesiredFrameControllers), nullptr, nullptr, nullptr },
        { "frame_capabilities", reinterpret_cast<getter>(VariablePhotoSequenceController_get_FrameCapabilities), nullptr, nullptr, nullptr },
        { "max_photos_per_second", reinterpret_cast<getter>(VariablePhotoSequenceController_get_MaxPhotosPerSecond), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(VariablePhotoSequenceController_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VariablePhotoSequenceController[] = 
    {
        { Py_tp_new, _new_VariablePhotoSequenceController },
        { Py_tp_dealloc, _dealloc_VariablePhotoSequenceController },
        { Py_tp_methods, _methods_VariablePhotoSequenceController },
        { Py_tp_getset, _getset_VariablePhotoSequenceController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VariablePhotoSequenceController =
    {
        "_winsdk_Windows_Media_Devices_Core.VariablePhotoSequenceController",
        sizeof(py::wrapper::Windows::Media::Devices::Core::VariablePhotoSequenceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VariablePhotoSequenceController
    };

    // ----- Windows.Media.Devices.Core Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Media::Devices::Core::CameraIntrinsics>::python_type = py::register_python_type(module, _type_name_CameraIntrinsics, &_type_spec_CameraIntrinsics, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::DepthCorrelatedCoordinateMapper>::python_type = py::register_python_type(module, _type_name_DepthCorrelatedCoordinateMapper, &_type_spec_DepthCorrelatedCoordinateMapper, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameControlCapabilities>::python_type = py::register_python_type(module, _type_name_FrameControlCapabilities, &_type_spec_FrameControlCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameController>::python_type = py::register_python_type(module, _type_name_FrameController, &_type_spec_FrameController, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCapabilities>::python_type = py::register_python_type(module, _type_name_FrameExposureCapabilities, &_type_spec_FrameExposureCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCompensationCapabilities>::python_type = py::register_python_type(module, _type_name_FrameExposureCompensationCapabilities, &_type_spec_FrameExposureCompensationCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureCompensationControl>::python_type = py::register_python_type(module, _type_name_FrameExposureCompensationControl, &_type_spec_FrameExposureCompensationControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameExposureControl>::python_type = py::register_python_type(module, _type_name_FrameExposureControl, &_type_spec_FrameExposureControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFlashCapabilities>::python_type = py::register_python_type(module, _type_name_FrameFlashCapabilities, &_type_spec_FrameFlashCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFlashControl>::python_type = py::register_python_type(module, _type_name_FrameFlashControl, &_type_spec_FrameFlashControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFocusCapabilities>::python_type = py::register_python_type(module, _type_name_FrameFocusCapabilities, &_type_spec_FrameFocusCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameFocusControl>::python_type = py::register_python_type(module, _type_name_FrameFocusControl, &_type_spec_FrameFocusControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameIsoSpeedCapabilities>::python_type = py::register_python_type(module, _type_name_FrameIsoSpeedCapabilities, &_type_spec_FrameIsoSpeedCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::FrameIsoSpeedControl>::python_type = py::register_python_type(module, _type_name_FrameIsoSpeedControl, &_type_spec_FrameIsoSpeedControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::Core::VariablePhotoSequenceController>::python_type = py::register_python_type(module, _type_name_VariablePhotoSequenceController, &_type_spec_VariablePhotoSequenceController, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Media.Devices.Core");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_Devices_Core",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Media::Devices::Core

PyMODINIT_FUNC
PyInit__winsdk_Windows_Media_Devices_Core (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::Devices::Core::module_def);
}
