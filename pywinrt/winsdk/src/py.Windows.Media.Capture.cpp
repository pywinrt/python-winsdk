// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.2

#include "pybase.h"
#include "py.Windows.Media.Capture.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AdvancedCapturedPhoto>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AdvancedPhotoCapture>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::AppCapture>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUI>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CapturedFrame>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CapturedFrameControlValues>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::CapturedPhoto>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::LowLagMediaRecording>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::LowLagPhotoCapture>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCapture>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureFailedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCapturePauseResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureStopResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::PhotoCapturedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::VideoStreamConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Capture::WhiteBalanceGain>::python_type;

PyObject* py::converter<winrt::Windows::Media::Capture::WhiteBalanceGain>::convert(winrt::Windows::Media::Capture::WhiteBalanceGain instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Media::Capture::WhiteBalanceGain>());
}
winrt::Windows::Media::Capture::WhiteBalanceGain py::converter<winrt::Windows::Media::Capture::WhiteBalanceGain>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Media::Capture::WhiteBalanceGain>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Media::Capture::WhiteBalanceGain>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Media::Capture::WhiteBalanceGain return_value{};

    PyObject* py_R = PyDict_GetItemString(obj, "r");
    if (!py_R) { throw winrt::hresult_invalid_argument(); }
    return_value.R = converter<double>::convert_to(py_R);

    PyObject* py_G = PyDict_GetItemString(obj, "g");
    if (!py_G) { throw winrt::hresult_invalid_argument(); }
    return_value.G = converter<double>::convert_to(py_G);

    PyObject* py_B = PyDict_GetItemString(obj, "b");
    if (!py_B) { throw winrt::hresult_invalid_argument(); }
    return_value.B = converter<double>::convert_to(py_B);

    return return_value;
}

namespace py::cpp::Windows::Media::Capture
{
    // ----- AdvancedCapturedPhoto class --------------------
    constexpr const char* const _type_name_AdvancedCapturedPhoto = "AdvancedCapturedPhoto";

    static PyObject* _new_AdvancedCapturedPhoto(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdvancedCapturedPhoto);
        return nullptr;
    }

    static void _dealloc_AdvancedCapturedPhoto(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdvancedCapturedPhoto_get_Context(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedCapturedPhoto_get_Frame(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedCapturedPhoto_get_Mode(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedCapturedPhoto_get_FrameBoundsRelativeToReferencePhoto(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameBoundsRelativeToReferencePhoto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdvancedCapturedPhoto(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AdvancedCapturedPhoto>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdvancedCapturedPhoto[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AdvancedCapturedPhoto), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdvancedCapturedPhoto[] = {
        { "context", reinterpret_cast<getter>(AdvancedCapturedPhoto_get_Context), nullptr, nullptr, nullptr },
        { "frame", reinterpret_cast<getter>(AdvancedCapturedPhoto_get_Frame), nullptr, nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(AdvancedCapturedPhoto_get_Mode), nullptr, nullptr, nullptr },
        { "frame_bounds_relative_to_reference_photo", reinterpret_cast<getter>(AdvancedCapturedPhoto_get_FrameBoundsRelativeToReferencePhoto), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdvancedCapturedPhoto[] = 
    {
        { Py_tp_new, _new_AdvancedCapturedPhoto },
        { Py_tp_dealloc, _dealloc_AdvancedCapturedPhoto },
        { Py_tp_methods, _methods_AdvancedCapturedPhoto },
        { Py_tp_getset, _getset_AdvancedCapturedPhoto },
        { },
    };

    static PyType_Spec _type_spec_AdvancedCapturedPhoto =
    {
        "_winsdk_Windows_Media_Capture.AdvancedCapturedPhoto",
        sizeof(py::wrapper::Windows::Media::Capture::AdvancedCapturedPhoto),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdvancedCapturedPhoto
    };

    // ----- AdvancedPhotoCapture class --------------------
    constexpr const char* const _type_name_AdvancedPhotoCapture = "AdvancedPhotoCapture";

    static PyObject* _new_AdvancedPhotoCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdvancedPhotoCapture);
        return nullptr;
    }

    static void _dealloc_AdvancedPhotoCapture(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdvancedPhotoCapture_CaptureAsync(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CaptureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 0);

                return py::convert(self->obj.CaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_FinishAsync(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_add_AllPhotosCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AdvancedPhotoCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AllPhotosCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_remove_AllPhotosCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AllPhotosCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_add_OptionalReferencePhotoCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AdvancedPhotoCapture, winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>>(arg);

            return py::convert(self->obj.OptionalReferencePhotoCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoCapture_remove_OptionalReferencePhotoCaptured(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OptionalReferencePhotoCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdvancedPhotoCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AdvancedPhotoCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdvancedPhotoCapture[] = {
        { "capture_async", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_CaptureAsync), METH_VARARGS, nullptr },
        { "finish_async", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_FinishAsync), METH_VARARGS, nullptr },
        { "add_all_photos_captured", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_add_AllPhotosCaptured), METH_O, nullptr },
        { "remove_all_photos_captured", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_remove_AllPhotosCaptured), METH_O, nullptr },
        { "add_optional_reference_photo_captured", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_add_OptionalReferencePhotoCaptured), METH_O, nullptr },
        { "remove_optional_reference_photo_captured", reinterpret_cast<PyCFunction>(AdvancedPhotoCapture_remove_OptionalReferencePhotoCaptured), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdvancedPhotoCapture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdvancedPhotoCapture[] = {
        { }
    };

    static PyType_Slot _type_slots_AdvancedPhotoCapture[] = 
    {
        { Py_tp_new, _new_AdvancedPhotoCapture },
        { Py_tp_dealloc, _dealloc_AdvancedPhotoCapture },
        { Py_tp_methods, _methods_AdvancedPhotoCapture },
        { Py_tp_getset, _getset_AdvancedPhotoCapture },
        { },
    };

    static PyType_Spec _type_spec_AdvancedPhotoCapture =
    {
        "_winsdk_Windows_Media_Capture.AdvancedPhotoCapture",
        sizeof(py::wrapper::Windows::Media::Capture::AdvancedPhotoCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdvancedPhotoCapture
    };

    // ----- AppCapture class --------------------
    constexpr const char* const _type_name_AppCapture = "AppCapture";

    static PyObject* _new_AppCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppCapture);
        return nullptr;
    }

    static void _dealloc_AppCapture(py::wrapper::Windows::Media::Capture::AppCapture* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppCapture_GetForCurrentView(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Capture::AppCapture::GetForCurrentView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCapture_SetAllowedAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::AppCapture::SetAllowedAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppCapture_get_IsCapturingAudio(py::wrapper::Windows::Media::Capture::AppCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCapturingAudio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCapture_get_IsCapturingVideo(py::wrapper::Windows::Media::Capture::AppCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCapturingVideo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCapture_add_CapturingChanged(py::wrapper::Windows::Media::Capture::AppCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::AppCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CapturingChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppCapture_remove_CapturingChanged(py::wrapper::Windows::Media::Capture::AppCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CapturingChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::AppCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppCapture[] = {
        { "get_for_current_view", reinterpret_cast<PyCFunction>(AppCapture_GetForCurrentView), METH_VARARGS | METH_STATIC, nullptr },
        { "set_allowed_async", reinterpret_cast<PyCFunction>(AppCapture_SetAllowedAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_capturing_changed", reinterpret_cast<PyCFunction>(AppCapture_add_CapturingChanged), METH_O, nullptr },
        { "remove_capturing_changed", reinterpret_cast<PyCFunction>(AppCapture_remove_CapturingChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppCapture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppCapture[] = {
        { "is_capturing_audio", reinterpret_cast<getter>(AppCapture_get_IsCapturingAudio), nullptr, nullptr, nullptr },
        { "is_capturing_video", reinterpret_cast<getter>(AppCapture_get_IsCapturingVideo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppCapture[] = 
    {
        { Py_tp_new, _new_AppCapture },
        { Py_tp_dealloc, _dealloc_AppCapture },
        { Py_tp_methods, _methods_AppCapture },
        { Py_tp_getset, _getset_AppCapture },
        { },
    };

    static PyType_Spec _type_spec_AppCapture =
    {
        "_winsdk_Windows_Media_Capture.AppCapture",
        sizeof(py::wrapper::Windows::Media::Capture::AppCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppCapture
    };

    // ----- CameraCaptureUI class --------------------
    constexpr const char* const _type_name_CameraCaptureUI = "CameraCaptureUI";

    static PyObject* _new_CameraCaptureUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::CameraCaptureUI instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CameraCaptureUI(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CameraCaptureUI_CaptureFileAsync(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIMode>(args, 0);

                return py::convert(self->obj.CaptureFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraCaptureUI_get_PhotoSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotoSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraCaptureUI_get_VideoSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CameraCaptureUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CameraCaptureUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraCaptureUI[] = {
        { "capture_file_async", reinterpret_cast<PyCFunction>(CameraCaptureUI_CaptureFileAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraCaptureUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraCaptureUI[] = {
        { "photo_settings", reinterpret_cast<getter>(CameraCaptureUI_get_PhotoSettings), nullptr, nullptr, nullptr },
        { "video_settings", reinterpret_cast<getter>(CameraCaptureUI_get_VideoSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraCaptureUI[] = 
    {
        { Py_tp_new, _new_CameraCaptureUI },
        { Py_tp_dealloc, _dealloc_CameraCaptureUI },
        { Py_tp_methods, _methods_CameraCaptureUI },
        { Py_tp_getset, _getset_CameraCaptureUI },
        { },
    };

    static PyType_Spec _type_spec_CameraCaptureUI =
    {
        "_winsdk_Windows_Media_Capture.CameraCaptureUI",
        sizeof(py::wrapper::Windows::Media::Capture::CameraCaptureUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraCaptureUI
    };

    // ----- CameraCaptureUIPhotoCaptureSettings class --------------------
    constexpr const char* const _type_name_CameraCaptureUIPhotoCaptureSettings = "CameraCaptureUIPhotoCaptureSettings";

    static PyObject* _new_CameraCaptureUIPhotoCaptureSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CameraCaptureUIPhotoCaptureSettings);
        return nullptr;
    }

    static void _dealloc_CameraCaptureUIPhotoCaptureSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIMaxPhotoResolution>(arg);

            self->obj.MaxResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIPhotoFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_CroppedSizeInPixels(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CroppedSizeInPixels());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_CroppedSizeInPixels(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.CroppedSizeInPixels(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_CroppedAspectRatio(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CroppedAspectRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_CroppedAspectRatio(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.CroppedAspectRatio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIPhotoCaptureSettings_get_AllowCropping(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowCropping());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIPhotoCaptureSettings_put_AllowCropping(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowCropping(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_CameraCaptureUIPhotoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraCaptureUIPhotoCaptureSettings[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraCaptureUIPhotoCaptureSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraCaptureUIPhotoCaptureSettings[] = {
        { "max_resolution", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_MaxResolution), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_MaxResolution), nullptr, nullptr },
        { "format", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_Format), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_Format), nullptr, nullptr },
        { "cropped_size_in_pixels", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_CroppedSizeInPixels), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_CroppedSizeInPixels), nullptr, nullptr },
        { "cropped_aspect_ratio", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_CroppedAspectRatio), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_CroppedAspectRatio), nullptr, nullptr },
        { "allow_cropping", reinterpret_cast<getter>(CameraCaptureUIPhotoCaptureSettings_get_AllowCropping), reinterpret_cast<setter>(CameraCaptureUIPhotoCaptureSettings_put_AllowCropping), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraCaptureUIPhotoCaptureSettings[] = 
    {
        { Py_tp_new, _new_CameraCaptureUIPhotoCaptureSettings },
        { Py_tp_dealloc, _dealloc_CameraCaptureUIPhotoCaptureSettings },
        { Py_tp_methods, _methods_CameraCaptureUIPhotoCaptureSettings },
        { Py_tp_getset, _getset_CameraCaptureUIPhotoCaptureSettings },
        { },
    };

    static PyType_Spec _type_spec_CameraCaptureUIPhotoCaptureSettings =
    {
        "_winsdk_Windows_Media_Capture.CameraCaptureUIPhotoCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraCaptureUIPhotoCaptureSettings
    };

    // ----- CameraCaptureUIVideoCaptureSettings class --------------------
    constexpr const char* const _type_name_CameraCaptureUIVideoCaptureSettings = "CameraCaptureUIVideoCaptureSettings";

    static PyObject* _new_CameraCaptureUIVideoCaptureSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CameraCaptureUIVideoCaptureSettings);
        return nullptr;
    }

    static void _dealloc_CameraCaptureUIVideoCaptureSettings(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_MaxResolution(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIMaxVideoResolution>(arg);

            self->obj.MaxResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_MaxDurationInSeconds(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxDurationInSeconds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_MaxDurationInSeconds(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.MaxDurationInSeconds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_Format(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::CameraCaptureUIVideoFormat>(arg);

            self->obj.Format(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CameraCaptureUIVideoCaptureSettings_get_AllowTrimming(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowTrimming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CameraCaptureUIVideoCaptureSettings_put_AllowTrimming(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowTrimming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_CameraCaptureUIVideoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraCaptureUIVideoCaptureSettings[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraCaptureUIVideoCaptureSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraCaptureUIVideoCaptureSettings[] = {
        { "max_resolution", reinterpret_cast<getter>(CameraCaptureUIVideoCaptureSettings_get_MaxResolution), reinterpret_cast<setter>(CameraCaptureUIVideoCaptureSettings_put_MaxResolution), nullptr, nullptr },
        { "max_duration_in_seconds", reinterpret_cast<getter>(CameraCaptureUIVideoCaptureSettings_get_MaxDurationInSeconds), reinterpret_cast<setter>(CameraCaptureUIVideoCaptureSettings_put_MaxDurationInSeconds), nullptr, nullptr },
        { "format", reinterpret_cast<getter>(CameraCaptureUIVideoCaptureSettings_get_Format), reinterpret_cast<setter>(CameraCaptureUIVideoCaptureSettings_put_Format), nullptr, nullptr },
        { "allow_trimming", reinterpret_cast<getter>(CameraCaptureUIVideoCaptureSettings_get_AllowTrimming), reinterpret_cast<setter>(CameraCaptureUIVideoCaptureSettings_put_AllowTrimming), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraCaptureUIVideoCaptureSettings[] = 
    {
        { Py_tp_new, _new_CameraCaptureUIVideoCaptureSettings },
        { Py_tp_dealloc, _dealloc_CameraCaptureUIVideoCaptureSettings },
        { Py_tp_methods, _methods_CameraCaptureUIVideoCaptureSettings },
        { Py_tp_getset, _getset_CameraCaptureUIVideoCaptureSettings },
        { },
    };

    static PyType_Spec _type_spec_CameraCaptureUIVideoCaptureSettings =
    {
        "_winsdk_Windows_Media_Capture.CameraCaptureUIVideoCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraCaptureUIVideoCaptureSettings
    };

    // ----- CapturedFrame class --------------------
    constexpr const char* const _type_name_CapturedFrame = "CapturedFrame";

    static PyObject* _new_CapturedFrame(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CapturedFrame);
        return nullptr;
    }

    static void _dealloc_CapturedFrame(py::wrapper::Windows::Media::Capture::CapturedFrame* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CapturedFrame_CloneStream(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CloneStream());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_Close(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_FlushAsync(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FlushAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_GetInputStreamAt(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetInputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_GetOutputStreamAt(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                return py::convert(self->obj.GetOutputStreamAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_ReadAsync(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Streams::InputStreamOptions>(args, 2);

                return py::convert(self->obj.ReadAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_Seek(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint64_t>(args, 0);

                self->obj.Seek(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_WriteAsync(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.WriteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Height(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Width(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_BitmapProperties(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitmapProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_ControlValues(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ControlValues());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_SoftwareBitmap(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SoftwareBitmap());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_ContentType(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Size(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CapturedFrame_put_Size(py::wrapper::Windows::Media::Capture::CapturedFrame* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.Size(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CapturedFrame_get_CanRead(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanRead());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_CanWrite(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanWrite());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrame_get_Position(py::wrapper::Windows::Media::Capture::CapturedFrame* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CapturedFrame(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CapturedFrame>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_CapturedFrame(py::wrapper::Windows::Media::Capture::CapturedFrame* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_CapturedFrame(py::wrapper::Windows::Media::Capture::CapturedFrame* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CapturedFrame[] = {
        { "clone_stream", reinterpret_cast<PyCFunction>(CapturedFrame_CloneStream), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(CapturedFrame_Close), METH_VARARGS, nullptr },
        { "flush_async", reinterpret_cast<PyCFunction>(CapturedFrame_FlushAsync), METH_VARARGS, nullptr },
        { "get_input_stream_at", reinterpret_cast<PyCFunction>(CapturedFrame_GetInputStreamAt), METH_VARARGS, nullptr },
        { "get_output_stream_at", reinterpret_cast<PyCFunction>(CapturedFrame_GetOutputStreamAt), METH_VARARGS, nullptr },
        { "read_async", reinterpret_cast<PyCFunction>(CapturedFrame_ReadAsync), METH_VARARGS, nullptr },
        { "seek", reinterpret_cast<PyCFunction>(CapturedFrame_Seek), METH_VARARGS, nullptr },
        { "write_async", reinterpret_cast<PyCFunction>(CapturedFrame_WriteAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CapturedFrame), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_CapturedFrame), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_CapturedFrame), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_CapturedFrame[] = {
        { "height", reinterpret_cast<getter>(CapturedFrame_get_Height), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(CapturedFrame_get_Width), nullptr, nullptr, nullptr },
        { "bitmap_properties", reinterpret_cast<getter>(CapturedFrame_get_BitmapProperties), nullptr, nullptr, nullptr },
        { "control_values", reinterpret_cast<getter>(CapturedFrame_get_ControlValues), nullptr, nullptr, nullptr },
        { "software_bitmap", reinterpret_cast<getter>(CapturedFrame_get_SoftwareBitmap), nullptr, nullptr, nullptr },
        { "content_type", reinterpret_cast<getter>(CapturedFrame_get_ContentType), nullptr, nullptr, nullptr },
        { "size", reinterpret_cast<getter>(CapturedFrame_get_Size), reinterpret_cast<setter>(CapturedFrame_put_Size), nullptr, nullptr },
        { "can_read", reinterpret_cast<getter>(CapturedFrame_get_CanRead), nullptr, nullptr, nullptr },
        { "can_write", reinterpret_cast<getter>(CapturedFrame_get_CanWrite), nullptr, nullptr, nullptr },
        { "position", reinterpret_cast<getter>(CapturedFrame_get_Position), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CapturedFrame[] = 
    {
        { Py_tp_new, _new_CapturedFrame },
        { Py_tp_dealloc, _dealloc_CapturedFrame },
        { Py_tp_methods, _methods_CapturedFrame },
        { Py_tp_getset, _getset_CapturedFrame },
        { },
    };

    static PyType_Spec _type_spec_CapturedFrame =
    {
        "_winsdk_Windows_Media_Capture.CapturedFrame",
        sizeof(py::wrapper::Windows::Media::Capture::CapturedFrame),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CapturedFrame
    };

    // ----- CapturedFrameControlValues class --------------------
    constexpr const char* const _type_name_CapturedFrameControlValues = "CapturedFrameControlValues";

    static PyObject* _new_CapturedFrameControlValues(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CapturedFrameControlValues);
        return nullptr;
    }

    static void _dealloc_CapturedFrameControlValues(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CapturedFrameControlValues_get_Exposure(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_ExposureCompensation(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExposureCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_FlashPowerPercent(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FlashPowerPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_Flashed(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Flashed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_Focus(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Focus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_IsoSpeed(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsoSpeed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_SceneMode(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SceneMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_WhiteBalance(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WhiteBalance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_ZoomFactor(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZoomFactor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_FocusState(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_IsoAnalogGain(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsoAnalogGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_IsoDigitalGain(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsoDigitalGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_SensorFrameRate(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SensorFrameRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedFrameControlValues_get_WhiteBalanceGain(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WhiteBalanceGain());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CapturedFrameControlValues(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CapturedFrameControlValues>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CapturedFrameControlValues[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CapturedFrameControlValues), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CapturedFrameControlValues[] = {
        { "exposure", reinterpret_cast<getter>(CapturedFrameControlValues_get_Exposure), nullptr, nullptr, nullptr },
        { "exposure_compensation", reinterpret_cast<getter>(CapturedFrameControlValues_get_ExposureCompensation), nullptr, nullptr, nullptr },
        { "flash_power_percent", reinterpret_cast<getter>(CapturedFrameControlValues_get_FlashPowerPercent), nullptr, nullptr, nullptr },
        { "flashed", reinterpret_cast<getter>(CapturedFrameControlValues_get_Flashed), nullptr, nullptr, nullptr },
        { "focus", reinterpret_cast<getter>(CapturedFrameControlValues_get_Focus), nullptr, nullptr, nullptr },
        { "iso_speed", reinterpret_cast<getter>(CapturedFrameControlValues_get_IsoSpeed), nullptr, nullptr, nullptr },
        { "scene_mode", reinterpret_cast<getter>(CapturedFrameControlValues_get_SceneMode), nullptr, nullptr, nullptr },
        { "white_balance", reinterpret_cast<getter>(CapturedFrameControlValues_get_WhiteBalance), nullptr, nullptr, nullptr },
        { "zoom_factor", reinterpret_cast<getter>(CapturedFrameControlValues_get_ZoomFactor), nullptr, nullptr, nullptr },
        { "focus_state", reinterpret_cast<getter>(CapturedFrameControlValues_get_FocusState), nullptr, nullptr, nullptr },
        { "iso_analog_gain", reinterpret_cast<getter>(CapturedFrameControlValues_get_IsoAnalogGain), nullptr, nullptr, nullptr },
        { "iso_digital_gain", reinterpret_cast<getter>(CapturedFrameControlValues_get_IsoDigitalGain), nullptr, nullptr, nullptr },
        { "sensor_frame_rate", reinterpret_cast<getter>(CapturedFrameControlValues_get_SensorFrameRate), nullptr, nullptr, nullptr },
        { "white_balance_gain", reinterpret_cast<getter>(CapturedFrameControlValues_get_WhiteBalanceGain), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CapturedFrameControlValues[] = 
    {
        { Py_tp_new, _new_CapturedFrameControlValues },
        { Py_tp_dealloc, _dealloc_CapturedFrameControlValues },
        { Py_tp_methods, _methods_CapturedFrameControlValues },
        { Py_tp_getset, _getset_CapturedFrameControlValues },
        { },
    };

    static PyType_Spec _type_spec_CapturedFrameControlValues =
    {
        "_winsdk_Windows_Media_Capture.CapturedFrameControlValues",
        sizeof(py::wrapper::Windows::Media::Capture::CapturedFrameControlValues),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CapturedFrameControlValues
    };

    // ----- CapturedPhoto class --------------------
    constexpr const char* const _type_name_CapturedPhoto = "CapturedPhoto";

    static PyObject* _new_CapturedPhoto(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CapturedPhoto);
        return nullptr;
    }

    static void _dealloc_CapturedPhoto(py::wrapper::Windows::Media::Capture::CapturedPhoto* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CapturedPhoto_get_Frame(py::wrapper::Windows::Media::Capture::CapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CapturedPhoto_get_Thumbnail(py::wrapper::Windows::Media::Capture::CapturedPhoto* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CapturedPhoto(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::CapturedPhoto>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CapturedPhoto[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CapturedPhoto), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CapturedPhoto[] = {
        { "frame", reinterpret_cast<getter>(CapturedPhoto_get_Frame), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(CapturedPhoto_get_Thumbnail), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CapturedPhoto[] = 
    {
        { Py_tp_new, _new_CapturedPhoto },
        { Py_tp_dealloc, _dealloc_CapturedPhoto },
        { Py_tp_methods, _methods_CapturedPhoto },
        { Py_tp_getset, _getset_CapturedPhoto },
        { },
    };

    static PyType_Spec _type_spec_CapturedPhoto =
    {
        "_winsdk_Windows_Media_Capture.CapturedPhoto",
        sizeof(py::wrapper::Windows::Media::Capture::CapturedPhoto),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CapturedPhoto
    };

    // ----- LowLagMediaRecording class --------------------
    constexpr const char* const _type_name_LowLagMediaRecording = "LowLagMediaRecording";

    static PyObject* _new_LowLagMediaRecording(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LowLagMediaRecording);
        return nullptr;
    }

    static void _dealloc_LowLagMediaRecording(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LowLagMediaRecording_FinishAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_PauseAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_PauseWithResultAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_ResumeAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ResumeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_StartAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_StopAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagMediaRecording_StopWithResultAsync(py::wrapper::Windows::Media::Capture::LowLagMediaRecording* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopWithResultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_LowLagMediaRecording(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::LowLagMediaRecording>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagMediaRecording[] = {
        { "finish_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_FinishAsync), METH_VARARGS, nullptr },
        { "pause_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_PauseAsync), METH_VARARGS, nullptr },
        { "pause_with_result_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_PauseWithResultAsync), METH_VARARGS, nullptr },
        { "resume_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_ResumeAsync), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_StartAsync), METH_VARARGS, nullptr },
        { "stop_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_StopAsync), METH_VARARGS, nullptr },
        { "stop_with_result_async", reinterpret_cast<PyCFunction>(LowLagMediaRecording_StopWithResultAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLagMediaRecording), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLagMediaRecording[] = {
        { }
    };

    static PyType_Slot _type_slots_LowLagMediaRecording[] = 
    {
        { Py_tp_new, _new_LowLagMediaRecording },
        { Py_tp_dealloc, _dealloc_LowLagMediaRecording },
        { Py_tp_methods, _methods_LowLagMediaRecording },
        { Py_tp_getset, _getset_LowLagMediaRecording },
        { },
    };

    static PyType_Spec _type_spec_LowLagMediaRecording =
    {
        "_winsdk_Windows_Media_Capture.LowLagMediaRecording",
        sizeof(py::wrapper::Windows::Media::Capture::LowLagMediaRecording),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagMediaRecording
    };

    // ----- LowLagPhotoCapture class --------------------
    constexpr const char* const _type_name_LowLagPhotoCapture = "LowLagPhotoCapture";

    static PyObject* _new_LowLagPhotoCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LowLagPhotoCapture);
        return nullptr;
    }

    static void _dealloc_LowLagPhotoCapture(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LowLagPhotoCapture_CaptureAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CaptureAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoCapture_FinishAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_LowLagPhotoCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::LowLagPhotoCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagPhotoCapture[] = {
        { "capture_async", reinterpret_cast<PyCFunction>(LowLagPhotoCapture_CaptureAsync), METH_VARARGS, nullptr },
        { "finish_async", reinterpret_cast<PyCFunction>(LowLagPhotoCapture_FinishAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLagPhotoCapture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLagPhotoCapture[] = {
        { }
    };

    static PyType_Slot _type_slots_LowLagPhotoCapture[] = 
    {
        { Py_tp_new, _new_LowLagPhotoCapture },
        { Py_tp_dealloc, _dealloc_LowLagPhotoCapture },
        { Py_tp_methods, _methods_LowLagPhotoCapture },
        { Py_tp_getset, _getset_LowLagPhotoCapture },
        { },
    };

    static PyType_Spec _type_spec_LowLagPhotoCapture =
    {
        "_winsdk_Windows_Media_Capture.LowLagPhotoCapture",
        sizeof(py::wrapper::Windows::Media::Capture::LowLagPhotoCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagPhotoCapture
    };

    // ----- LowLagPhotoSequenceCapture class --------------------
    constexpr const char* const _type_name_LowLagPhotoSequenceCapture = "LowLagPhotoSequenceCapture";

    static PyObject* _new_LowLagPhotoSequenceCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LowLagPhotoSequenceCapture);
        return nullptr;
    }

    static void _dealloc_LowLagPhotoSequenceCapture(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LowLagPhotoSequenceCapture_FinishAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FinishAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_StartAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_StopAsync(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_add_PhotoCaptured(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture, winrt::Windows::Media::Capture::PhotoCapturedEventArgs>>(arg);

            return py::convert(self->obj.PhotoCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceCapture_remove_PhotoCaptured(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PhotoCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LowLagPhotoSequenceCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagPhotoSequenceCapture[] = {
        { "finish_async", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_FinishAsync), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_StartAsync), METH_VARARGS, nullptr },
        { "stop_async", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_StopAsync), METH_VARARGS, nullptr },
        { "add_photo_captured", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_add_PhotoCaptured), METH_O, nullptr },
        { "remove_photo_captured", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceCapture_remove_PhotoCaptured), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLagPhotoSequenceCapture), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLagPhotoSequenceCapture[] = {
        { }
    };

    static PyType_Slot _type_slots_LowLagPhotoSequenceCapture[] = 
    {
        { Py_tp_new, _new_LowLagPhotoSequenceCapture },
        { Py_tp_dealloc, _dealloc_LowLagPhotoSequenceCapture },
        { Py_tp_methods, _methods_LowLagPhotoSequenceCapture },
        { Py_tp_getset, _getset_LowLagPhotoSequenceCapture },
        { },
    };

    static PyType_Spec _type_spec_LowLagPhotoSequenceCapture =
    {
        "_winsdk_Windows_Media_Capture.LowLagPhotoSequenceCapture",
        sizeof(py::wrapper::Windows::Media::Capture::LowLagPhotoSequenceCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagPhotoSequenceCapture
    };

    // ----- MediaCapture class --------------------
    constexpr const char* const _type_name_MediaCapture = "MediaCapture";

    static PyObject* _new_MediaCapture(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::MediaCapture instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaCapture(py::wrapper::Windows::Media::Capture::MediaCapture* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCapture_AddAudioEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IAudioEffectDefinition>(args, 0);

                return py::convert(self->obj.AddAudioEffectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_AddEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.AddEffectAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_AddVideoEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::IVideoEffectDefinition>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 1);

                return py::convert(self->obj.AddVideoEffectAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CapturePhotoToStorageFileAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.CapturePhotoToStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CapturePhotoToStreamAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.CapturePhotoToStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_ClearEffectsAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.ClearEffectsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_Close(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CreateFrameReaderAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);

                return py::convert(self->obj.CreateFrameReaderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CreateFrameReaderAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSource>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::Imaging::BitmapSize>(args, 2);

                return py::convert(self->obj.CreateFrameReaderAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CreateMultiSourceFrameReaderAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Capture::Frames::MediaFrameSource>>(args, 0);

                return py::convert(self->obj.CreateMultiSourceFrameReaderAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_CreateRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::StreamingCaptureMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::WindowManagement::DisplayRegion>(args, 1);

                return py::convert(self->obj.CreateRelativePanelWatcher(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_FindAllVideoProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::FindAllVideoProfiles(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_FindConcurrentProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::FindConcurrentProfiles(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_FindKnownVideoProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::KnownVideoProfile>(args, 1);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::FindKnownVideoProfiles(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetEncoderProperty(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);

                return py::convert(self->obj.GetEncoderProperty(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetPreviewFrameAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPreviewFrameAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::VideoFrame>(args, 0);

                return py::convert(self->obj.GetPreviewFrameAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetPreviewMirroring(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPreviewMirroring());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetPreviewRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPreviewRotation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_GetRecordRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetRecordRotation());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_InitializeAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.InitializeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>(args, 0);

                return py::convert(self->obj.InitializeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_IsVideoProfileSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Media::Capture::MediaCapture::IsVideoProfileSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PauseRecordAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseRecordAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PauseRecordWithResultAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCapturePauseBehavior>(args, 0);

                return py::convert(self->obj.PauseRecordWithResultAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareAdvancedPhotoCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareAdvancedPhotoCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagPhotoCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareLowLagPhotoCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagPhotoSequenceCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareLowLagPhotoSequenceCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagRecordToCustomSinkAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 1);

                return py::convert(self->obj.PrepareLowLagRecordToCustomSinkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.PrepareLowLagRecordToCustomSinkAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagRecordToStorageFileAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.PrepareLowLagRecordToStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareLowLagRecordToStreamAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.PrepareLowLagRecordToStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_PrepareVariablePhotoSequenceCaptureAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>(args, 0);

                return py::convert(self->obj.PrepareVariablePhotoSequenceCaptureAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_RemoveEffectAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 0);

                return py::convert(self->obj.RemoveEffectAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_ResumeRecordAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ResumeRecordAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetEncoderProperty(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::guid>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 2);

                self->obj.SetEncoderProperty(param0, param1, param2);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetEncodingPropertiesAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaPropertySet>(args, 2);

                return py::convert(self->obj.SetEncodingPropertiesAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetPreviewMirroring(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                self->obj.SetPreviewMirroring(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetPreviewRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::VideoRotation>(args, 0);

                self->obj.SetPreviewRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_SetRecordRotation(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::VideoRotation>(args, 0);

                self->obj.SetRecordRotation(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartPreviewAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartPreviewToCustomSinkAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 1);

                return py::convert(self->obj.StartPreviewToCustomSinkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.StartPreviewToCustomSinkAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartRecordToCustomSinkAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::IMediaExtension>(args, 1);

                return py::convert(self->obj.StartRecordToCustomSinkAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 2);

                return py::convert(self->obj.StartRecordToCustomSinkAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartRecordToStorageFileAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 1);

                return py::convert(self->obj.StartRecordToStorageFileAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StartRecordToStreamAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 1);

                return py::convert(self->obj.StartRecordToStreamAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StopPreviewAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopPreviewAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StopRecordAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopRecordAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_StopRecordWithResultAsync(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopRecordWithResultAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_AudioDeviceController(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioDeviceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_MediaCaptureSettings(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaCaptureSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_VideoDeviceController(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_CameraStreamState(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraStreamState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_ThermalStatus(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ThermalStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_get_FrameSources(py::wrapper::Windows::Media::Capture::MediaCapture* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameSources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_Failed(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureFailedEventHandler>(arg);

            return py::convert(self->obj.Failed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_Failed(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Failed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_RecordLimitationExceeded(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::RecordLimitationExceededEventHandler>(arg);

            return py::convert(self->obj.RecordLimitationExceeded(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_RecordLimitationExceeded(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RecordLimitationExceeded(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_FocusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>>(arg);

            return py::convert(self->obj.FocusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_FocusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FocusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_PhotoConfirmationCaptured(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>>(arg);

            return py::convert(self->obj.PhotoConfirmationCaptured(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_PhotoConfirmationCaptured(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PhotoConfirmationCaptured(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_CameraStreamStateChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.CameraStreamStateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_CameraStreamStateChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CameraStreamStateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_ThermalStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.ThermalStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_ThermalStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ThermalStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_add_CaptureDeviceExclusiveControlStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCapture, winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>>(arg);

            return py::convert(self->obj.CaptureDeviceExclusiveControlStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapture_remove_CaptureDeviceExclusiveControlStatusChanged(py::wrapper::Windows::Media::Capture::MediaCapture* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.CaptureDeviceExclusiveControlStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCapture(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCapture>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCapture(py::wrapper::Windows::Media::Capture::MediaCapture* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MediaCapture(py::wrapper::Windows::Media::Capture::MediaCapture* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCapture[] = {
        { "add_audio_effect_async", reinterpret_cast<PyCFunction>(MediaCapture_AddAudioEffectAsync), METH_VARARGS, nullptr },
        { "add_effect_async", reinterpret_cast<PyCFunction>(MediaCapture_AddEffectAsync), METH_VARARGS, nullptr },
        { "add_video_effect_async", reinterpret_cast<PyCFunction>(MediaCapture_AddVideoEffectAsync), METH_VARARGS, nullptr },
        { "capture_photo_to_storage_file_async", reinterpret_cast<PyCFunction>(MediaCapture_CapturePhotoToStorageFileAsync), METH_VARARGS, nullptr },
        { "capture_photo_to_stream_async", reinterpret_cast<PyCFunction>(MediaCapture_CapturePhotoToStreamAsync), METH_VARARGS, nullptr },
        { "clear_effects_async", reinterpret_cast<PyCFunction>(MediaCapture_ClearEffectsAsync), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(MediaCapture_Close), METH_VARARGS, nullptr },
        { "create_frame_reader_async", reinterpret_cast<PyCFunction>(MediaCapture_CreateFrameReaderAsync), METH_VARARGS, nullptr },
        { "create_multi_source_frame_reader_async", reinterpret_cast<PyCFunction>(MediaCapture_CreateMultiSourceFrameReaderAsync), METH_VARARGS, nullptr },
        { "create_relative_panel_watcher", reinterpret_cast<PyCFunction>(MediaCapture_CreateRelativePanelWatcher), METH_VARARGS, nullptr },
        { "find_all_video_profiles", reinterpret_cast<PyCFunction>(MediaCapture_FindAllVideoProfiles), METH_VARARGS | METH_STATIC, nullptr },
        { "find_concurrent_profiles", reinterpret_cast<PyCFunction>(MediaCapture_FindConcurrentProfiles), METH_VARARGS | METH_STATIC, nullptr },
        { "find_known_video_profiles", reinterpret_cast<PyCFunction>(MediaCapture_FindKnownVideoProfiles), METH_VARARGS | METH_STATIC, nullptr },
        { "get_encoder_property", reinterpret_cast<PyCFunction>(MediaCapture_GetEncoderProperty), METH_VARARGS, nullptr },
        { "get_preview_frame_async", reinterpret_cast<PyCFunction>(MediaCapture_GetPreviewFrameAsync), METH_VARARGS, nullptr },
        { "get_preview_mirroring", reinterpret_cast<PyCFunction>(MediaCapture_GetPreviewMirroring), METH_VARARGS, nullptr },
        { "get_preview_rotation", reinterpret_cast<PyCFunction>(MediaCapture_GetPreviewRotation), METH_VARARGS, nullptr },
        { "get_record_rotation", reinterpret_cast<PyCFunction>(MediaCapture_GetRecordRotation), METH_VARARGS, nullptr },
        { "initialize_async", reinterpret_cast<PyCFunction>(MediaCapture_InitializeAsync), METH_VARARGS, nullptr },
        { "is_video_profile_supported", reinterpret_cast<PyCFunction>(MediaCapture_IsVideoProfileSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "pause_record_async", reinterpret_cast<PyCFunction>(MediaCapture_PauseRecordAsync), METH_VARARGS, nullptr },
        { "pause_record_with_result_async", reinterpret_cast<PyCFunction>(MediaCapture_PauseRecordWithResultAsync), METH_VARARGS, nullptr },
        { "prepare_advanced_photo_capture_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareAdvancedPhotoCaptureAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_photo_capture_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagPhotoCaptureAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_photo_sequence_capture_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagPhotoSequenceCaptureAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_record_to_custom_sink_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagRecordToCustomSinkAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_record_to_storage_file_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagRecordToStorageFileAsync), METH_VARARGS, nullptr },
        { "prepare_low_lag_record_to_stream_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareLowLagRecordToStreamAsync), METH_VARARGS, nullptr },
        { "prepare_variable_photo_sequence_capture_async", reinterpret_cast<PyCFunction>(MediaCapture_PrepareVariablePhotoSequenceCaptureAsync), METH_VARARGS, nullptr },
        { "remove_effect_async", reinterpret_cast<PyCFunction>(MediaCapture_RemoveEffectAsync), METH_VARARGS, nullptr },
        { "resume_record_async", reinterpret_cast<PyCFunction>(MediaCapture_ResumeRecordAsync), METH_VARARGS, nullptr },
        { "set_encoder_property", reinterpret_cast<PyCFunction>(MediaCapture_SetEncoderProperty), METH_VARARGS, nullptr },
        { "set_encoding_properties_async", reinterpret_cast<PyCFunction>(MediaCapture_SetEncodingPropertiesAsync), METH_VARARGS, nullptr },
        { "set_preview_mirroring", reinterpret_cast<PyCFunction>(MediaCapture_SetPreviewMirroring), METH_VARARGS, nullptr },
        { "set_preview_rotation", reinterpret_cast<PyCFunction>(MediaCapture_SetPreviewRotation), METH_VARARGS, nullptr },
        { "set_record_rotation", reinterpret_cast<PyCFunction>(MediaCapture_SetRecordRotation), METH_VARARGS, nullptr },
        { "start_preview_async", reinterpret_cast<PyCFunction>(MediaCapture_StartPreviewAsync), METH_VARARGS, nullptr },
        { "start_preview_to_custom_sink_async", reinterpret_cast<PyCFunction>(MediaCapture_StartPreviewToCustomSinkAsync), METH_VARARGS, nullptr },
        { "start_record_to_custom_sink_async", reinterpret_cast<PyCFunction>(MediaCapture_StartRecordToCustomSinkAsync), METH_VARARGS, nullptr },
        { "start_record_to_storage_file_async", reinterpret_cast<PyCFunction>(MediaCapture_StartRecordToStorageFileAsync), METH_VARARGS, nullptr },
        { "start_record_to_stream_async", reinterpret_cast<PyCFunction>(MediaCapture_StartRecordToStreamAsync), METH_VARARGS, nullptr },
        { "stop_preview_async", reinterpret_cast<PyCFunction>(MediaCapture_StopPreviewAsync), METH_VARARGS, nullptr },
        { "stop_record_async", reinterpret_cast<PyCFunction>(MediaCapture_StopRecordAsync), METH_VARARGS, nullptr },
        { "stop_record_with_result_async", reinterpret_cast<PyCFunction>(MediaCapture_StopRecordWithResultAsync), METH_VARARGS, nullptr },
        { "add_failed", reinterpret_cast<PyCFunction>(MediaCapture_add_Failed), METH_O, nullptr },
        { "remove_failed", reinterpret_cast<PyCFunction>(MediaCapture_remove_Failed), METH_O, nullptr },
        { "add_record_limitation_exceeded", reinterpret_cast<PyCFunction>(MediaCapture_add_RecordLimitationExceeded), METH_O, nullptr },
        { "remove_record_limitation_exceeded", reinterpret_cast<PyCFunction>(MediaCapture_remove_RecordLimitationExceeded), METH_O, nullptr },
        { "add_focus_changed", reinterpret_cast<PyCFunction>(MediaCapture_add_FocusChanged), METH_O, nullptr },
        { "remove_focus_changed", reinterpret_cast<PyCFunction>(MediaCapture_remove_FocusChanged), METH_O, nullptr },
        { "add_photo_confirmation_captured", reinterpret_cast<PyCFunction>(MediaCapture_add_PhotoConfirmationCaptured), METH_O, nullptr },
        { "remove_photo_confirmation_captured", reinterpret_cast<PyCFunction>(MediaCapture_remove_PhotoConfirmationCaptured), METH_O, nullptr },
        { "add_camera_stream_state_changed", reinterpret_cast<PyCFunction>(MediaCapture_add_CameraStreamStateChanged), METH_O, nullptr },
        { "remove_camera_stream_state_changed", reinterpret_cast<PyCFunction>(MediaCapture_remove_CameraStreamStateChanged), METH_O, nullptr },
        { "add_thermal_status_changed", reinterpret_cast<PyCFunction>(MediaCapture_add_ThermalStatusChanged), METH_O, nullptr },
        { "remove_thermal_status_changed", reinterpret_cast<PyCFunction>(MediaCapture_remove_ThermalStatusChanged), METH_O, nullptr },
        { "add_capture_device_exclusive_control_status_changed", reinterpret_cast<PyCFunction>(MediaCapture_add_CaptureDeviceExclusiveControlStatusChanged), METH_O, nullptr },
        { "remove_capture_device_exclusive_control_status_changed", reinterpret_cast<PyCFunction>(MediaCapture_remove_CaptureDeviceExclusiveControlStatusChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCapture), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaCapture), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaCapture), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCapture[] = {
        { "audio_device_controller", reinterpret_cast<getter>(MediaCapture_get_AudioDeviceController), nullptr, nullptr, nullptr },
        { "media_capture_settings", reinterpret_cast<getter>(MediaCapture_get_MediaCaptureSettings), nullptr, nullptr, nullptr },
        { "video_device_controller", reinterpret_cast<getter>(MediaCapture_get_VideoDeviceController), nullptr, nullptr, nullptr },
        { "camera_stream_state", reinterpret_cast<getter>(MediaCapture_get_CameraStreamState), nullptr, nullptr, nullptr },
        { "thermal_status", reinterpret_cast<getter>(MediaCapture_get_ThermalStatus), nullptr, nullptr, nullptr },
        { "frame_sources", reinterpret_cast<getter>(MediaCapture_get_FrameSources), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCapture[] = 
    {
        { Py_tp_new, _new_MediaCapture },
        { Py_tp_dealloc, _dealloc_MediaCapture },
        { Py_tp_methods, _methods_MediaCapture },
        { Py_tp_getset, _getset_MediaCapture },
        { },
    };

    static PyType_Spec _type_spec_MediaCapture =
    {
        "_winsdk_Windows_Media_Capture.MediaCapture",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCapture),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCapture
    };

    // ----- MediaCaptureDeviceExclusiveControlStatusChangedEventArgs class --------------------
    constexpr const char* const _type_name_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs = "MediaCaptureDeviceExclusiveControlStatusChangedEventArgs";

    static PyObject* _new_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_DeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_Status(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs[] = {
        { "device_id", reinterpret_cast<getter>(MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_DeviceId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(MediaCaptureDeviceExclusiveControlStatusChangedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs },
        { Py_tp_methods, _methods_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs },
        { Py_tp_getset, _getset_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureDeviceExclusiveControlStatusChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs
    };

    // ----- MediaCaptureFailedEventArgs class --------------------
    constexpr const char* const _type_name_MediaCaptureFailedEventArgs = "MediaCaptureFailedEventArgs";

    static PyObject* _new_MediaCaptureFailedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureFailedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaCaptureFailedEventArgs(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureFailedEventArgs_get_Code(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Code());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureFailedEventArgs_get_Message(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureFailedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureFailedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureFailedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureFailedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureFailedEventArgs[] = {
        { "code", reinterpret_cast<getter>(MediaCaptureFailedEventArgs_get_Code), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(MediaCaptureFailedEventArgs_get_Message), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureFailedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaCaptureFailedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaCaptureFailedEventArgs },
        { Py_tp_methods, _methods_MediaCaptureFailedEventArgs },
        { Py_tp_getset, _getset_MediaCaptureFailedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MediaCaptureFailedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureFailedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureFailedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureFailedEventArgs
    };

    // ----- MediaCaptureFocusChangedEventArgs class --------------------
    constexpr const char* const _type_name_MediaCaptureFocusChangedEventArgs = "MediaCaptureFocusChangedEventArgs";

    static PyObject* _new_MediaCaptureFocusChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureFocusChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_MediaCaptureFocusChangedEventArgs(py::wrapper::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureFocusChangedEventArgs_get_FocusState(py::wrapper::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureFocusChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureFocusChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureFocusChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureFocusChangedEventArgs[] = {
        { "focus_state", reinterpret_cast<getter>(MediaCaptureFocusChangedEventArgs_get_FocusState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureFocusChangedEventArgs[] = 
    {
        { Py_tp_new, _new_MediaCaptureFocusChangedEventArgs },
        { Py_tp_dealloc, _dealloc_MediaCaptureFocusChangedEventArgs },
        { Py_tp_methods, _methods_MediaCaptureFocusChangedEventArgs },
        { Py_tp_getset, _getset_MediaCaptureFocusChangedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_MediaCaptureFocusChangedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureFocusChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureFocusChangedEventArgs
    };

    // ----- MediaCaptureInitializationSettings class --------------------
    constexpr const char* const _type_name_MediaCaptureInitializationSettings = "MediaCaptureInitializationSettings";

    static PyObject* _new_MediaCaptureInitializationSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::MediaCaptureInitializationSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaCaptureInitializationSettings(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureInitializationSettings_get_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.VideoDeviceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_StreamingCaptureMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StreamingCaptureMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_StreamingCaptureMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::StreamingCaptureMode>(arg);

            self->obj.StreamingCaptureMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_PhotoCaptureSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotoCaptureSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_PhotoCaptureSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::PhotoCaptureSource>(arg);

            self->obj.PhotoCaptureSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AudioDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AudioDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AudioDeviceId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_MediaCategory(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_MediaCategory(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(arg);

            self->obj.MediaCategory(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AudioProcessing(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AudioProcessing(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::AudioProcessing>(arg);

            self->obj.AudioProcessing(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_VideoSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_VideoSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(arg);

            self->obj.VideoSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AudioSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AudioSource(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Core::IMediaSource>(arg);

            self->obj.AudioSource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_VideoProfile(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_VideoProfile(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>(arg);

            self->obj.VideoProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_RecordMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecordMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_RecordMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>(arg);

            self->obj.RecordMediaDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_PreviewMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviewMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_PreviewMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>(arg);

            self->obj.PreviewMediaDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_PhotoMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotoMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_PhotoMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>(arg);

            self->obj.PhotoMediaDescription(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_SourceGroup(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_SourceGroup(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::Frames::MediaFrameSourceGroup>(arg);

            self->obj.SourceGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_SharingMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SharingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_SharingMode(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureSharingMode>(arg);

            self->obj.SharingMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_MemoryPreference(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MemoryPreference());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_MemoryPreference(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaCaptureMemoryPreference>(arg);

            self->obj.MemoryPreference(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_AlwaysPlaySystemShutterSound(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlwaysPlaySystemShutterSound());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_AlwaysPlaySystemShutterSound(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AlwaysPlaySystemShutterSound(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_DeviceUriPasswordCredential(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceUriPasswordCredential());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_DeviceUriPasswordCredential(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Security::Credentials::PasswordCredential>(arg);

            self->obj.DeviceUriPasswordCredential(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaCaptureInitializationSettings_get_DeviceUri(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaCaptureInitializationSettings_put_DeviceUri(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.DeviceUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MediaCaptureInitializationSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureInitializationSettings[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureInitializationSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureInitializationSettings[] = {
        { "video_device_id", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_VideoDeviceId), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_VideoDeviceId), nullptr, nullptr },
        { "streaming_capture_mode", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_StreamingCaptureMode), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_StreamingCaptureMode), nullptr, nullptr },
        { "photo_capture_source", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_PhotoCaptureSource), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_PhotoCaptureSource), nullptr, nullptr },
        { "audio_device_id", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_AudioDeviceId), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_AudioDeviceId), nullptr, nullptr },
        { "media_category", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_MediaCategory), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_MediaCategory), nullptr, nullptr },
        { "audio_processing", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_AudioProcessing), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_AudioProcessing), nullptr, nullptr },
        { "video_source", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_VideoSource), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_VideoSource), nullptr, nullptr },
        { "audio_source", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_AudioSource), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_AudioSource), nullptr, nullptr },
        { "video_profile", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_VideoProfile), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_VideoProfile), nullptr, nullptr },
        { "record_media_description", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_RecordMediaDescription), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_RecordMediaDescription), nullptr, nullptr },
        { "preview_media_description", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_PreviewMediaDescription), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_PreviewMediaDescription), nullptr, nullptr },
        { "photo_media_description", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_PhotoMediaDescription), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_PhotoMediaDescription), nullptr, nullptr },
        { "source_group", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_SourceGroup), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_SourceGroup), nullptr, nullptr },
        { "sharing_mode", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_SharingMode), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_SharingMode), nullptr, nullptr },
        { "memory_preference", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_MemoryPreference), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_MemoryPreference), nullptr, nullptr },
        { "always_play_system_shutter_sound", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_AlwaysPlaySystemShutterSound), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_AlwaysPlaySystemShutterSound), nullptr, nullptr },
        { "device_uri_password_credential", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_DeviceUriPasswordCredential), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_DeviceUriPasswordCredential), nullptr, nullptr },
        { "device_uri", reinterpret_cast<getter>(MediaCaptureInitializationSettings_get_DeviceUri), reinterpret_cast<setter>(MediaCaptureInitializationSettings_put_DeviceUri), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureInitializationSettings[] = 
    {
        { Py_tp_new, _new_MediaCaptureInitializationSettings },
        { Py_tp_dealloc, _dealloc_MediaCaptureInitializationSettings },
        { Py_tp_methods, _methods_MediaCaptureInitializationSettings },
        { Py_tp_getset, _getset_MediaCaptureInitializationSettings },
        { },
    };

    static PyType_Spec _type_spec_MediaCaptureInitializationSettings =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureInitializationSettings",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureInitializationSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureInitializationSettings
    };

    // ----- MediaCapturePauseResult class --------------------
    constexpr const char* const _type_name_MediaCapturePauseResult = "MediaCapturePauseResult";

    static PyObject* _new_MediaCapturePauseResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCapturePauseResult);
        return nullptr;
    }

    static void _dealloc_MediaCapturePauseResult(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCapturePauseResult_Close(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCapturePauseResult_get_LastFrame(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCapturePauseResult_get_RecordDuration(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecordDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCapturePauseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCapturePauseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCapturePauseResult(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MediaCapturePauseResult(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCapturePauseResult[] = {
        { "close", reinterpret_cast<PyCFunction>(MediaCapturePauseResult_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCapturePauseResult), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaCapturePauseResult), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaCapturePauseResult), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCapturePauseResult[] = {
        { "last_frame", reinterpret_cast<getter>(MediaCapturePauseResult_get_LastFrame), nullptr, nullptr, nullptr },
        { "record_duration", reinterpret_cast<getter>(MediaCapturePauseResult_get_RecordDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCapturePauseResult[] = 
    {
        { Py_tp_new, _new_MediaCapturePauseResult },
        { Py_tp_dealloc, _dealloc_MediaCapturePauseResult },
        { Py_tp_methods, _methods_MediaCapturePauseResult },
        { Py_tp_getset, _getset_MediaCapturePauseResult },
        { },
    };

    static PyType_Spec _type_spec_MediaCapturePauseResult =
    {
        "_winsdk_Windows_Media_Capture.MediaCapturePauseResult",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCapturePauseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCapturePauseResult
    };

    // ----- MediaCaptureRelativePanelWatcher class --------------------
    constexpr const char* const _type_name_MediaCaptureRelativePanelWatcher = "MediaCaptureRelativePanelWatcher";

    static PyObject* _new_MediaCaptureRelativePanelWatcher(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureRelativePanelWatcher);
        return nullptr;
    }

    static void _dealloc_MediaCaptureRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureRelativePanelWatcher_Close(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_Start(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_Stop(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_get_RelativePanel(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelativePanel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_add_Changed(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureRelativePanelWatcher_remove_Changed(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureRelativePanelWatcher(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCaptureRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MediaCaptureRelativePanelWatcher(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureRelativePanelWatcher[] = {
        { "close", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_Close), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_Stop), METH_VARARGS, nullptr },
        { "add_changed", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(MediaCaptureRelativePanelWatcher_remove_Changed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureRelativePanelWatcher), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaCaptureRelativePanelWatcher), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaCaptureRelativePanelWatcher), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureRelativePanelWatcher[] = {
        { "relative_panel", reinterpret_cast<getter>(MediaCaptureRelativePanelWatcher_get_RelativePanel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureRelativePanelWatcher[] = 
    {
        { Py_tp_new, _new_MediaCaptureRelativePanelWatcher },
        { Py_tp_dealloc, _dealloc_MediaCaptureRelativePanelWatcher },
        { Py_tp_methods, _methods_MediaCaptureRelativePanelWatcher },
        { Py_tp_getset, _getset_MediaCaptureRelativePanelWatcher },
        { },
    };

    static PyType_Spec _type_spec_MediaCaptureRelativePanelWatcher =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureRelativePanelWatcher",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureRelativePanelWatcher),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureRelativePanelWatcher
    };

    // ----- MediaCaptureSettings class --------------------
    constexpr const char* const _type_name_MediaCaptureSettings = "MediaCaptureSettings";

    static PyObject* _new_MediaCaptureSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureSettings);
        return nullptr;
    }

    static void _dealloc_MediaCaptureSettings(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureSettings_get_AudioDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_PhotoCaptureSource(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotoCaptureSource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_StreamingCaptureMode(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StreamingCaptureMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_VideoDeviceCharacteristic(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceCharacteristic());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_AudioProcessing(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioProcessing());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_CameraSoundRequiredForRegion(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraSoundRequiredForRegion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_ConcurrentRecordAndPhotoSequenceSupported(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConcurrentRecordAndPhotoSequenceSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_ConcurrentRecordAndPhotoSupported(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConcurrentRecordAndPhotoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_Horizontal35mmEquivalentFocalLength(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Horizontal35mmEquivalentFocalLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_MediaCategory(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MediaCategory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_PitchOffsetDegrees(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PitchOffsetDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_Vertical35mmEquivalentFocalLength(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Vertical35mmEquivalentFocalLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureSettings_get_Direct3D11Device(py::wrapper::Windows::Media::Capture::MediaCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Direct3D11Device());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureSettings[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureSettings[] = {
        { "audio_device_id", reinterpret_cast<getter>(MediaCaptureSettings_get_AudioDeviceId), nullptr, nullptr, nullptr },
        { "photo_capture_source", reinterpret_cast<getter>(MediaCaptureSettings_get_PhotoCaptureSource), nullptr, nullptr, nullptr },
        { "streaming_capture_mode", reinterpret_cast<getter>(MediaCaptureSettings_get_StreamingCaptureMode), nullptr, nullptr, nullptr },
        { "video_device_characteristic", reinterpret_cast<getter>(MediaCaptureSettings_get_VideoDeviceCharacteristic), nullptr, nullptr, nullptr },
        { "video_device_id", reinterpret_cast<getter>(MediaCaptureSettings_get_VideoDeviceId), nullptr, nullptr, nullptr },
        { "audio_processing", reinterpret_cast<getter>(MediaCaptureSettings_get_AudioProcessing), nullptr, nullptr, nullptr },
        { "camera_sound_required_for_region", reinterpret_cast<getter>(MediaCaptureSettings_get_CameraSoundRequiredForRegion), nullptr, nullptr, nullptr },
        { "concurrent_record_and_photo_sequence_supported", reinterpret_cast<getter>(MediaCaptureSettings_get_ConcurrentRecordAndPhotoSequenceSupported), nullptr, nullptr, nullptr },
        { "concurrent_record_and_photo_supported", reinterpret_cast<getter>(MediaCaptureSettings_get_ConcurrentRecordAndPhotoSupported), nullptr, nullptr, nullptr },
        { "horizontal35mm_equivalent_focal_length", reinterpret_cast<getter>(MediaCaptureSettings_get_Horizontal35mmEquivalentFocalLength), nullptr, nullptr, nullptr },
        { "media_category", reinterpret_cast<getter>(MediaCaptureSettings_get_MediaCategory), nullptr, nullptr, nullptr },
        { "pitch_offset_degrees", reinterpret_cast<getter>(MediaCaptureSettings_get_PitchOffsetDegrees), nullptr, nullptr, nullptr },
        { "vertical35mm_equivalent_focal_length", reinterpret_cast<getter>(MediaCaptureSettings_get_Vertical35mmEquivalentFocalLength), nullptr, nullptr, nullptr },
        { "direct3_d11_device", reinterpret_cast<getter>(MediaCaptureSettings_get_Direct3D11Device), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureSettings[] = 
    {
        { Py_tp_new, _new_MediaCaptureSettings },
        { Py_tp_dealloc, _dealloc_MediaCaptureSettings },
        { Py_tp_methods, _methods_MediaCaptureSettings },
        { Py_tp_getset, _getset_MediaCaptureSettings },
        { },
    };

    static PyType_Spec _type_spec_MediaCaptureSettings =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureSettings
    };

    // ----- MediaCaptureStopResult class --------------------
    constexpr const char* const _type_name_MediaCaptureStopResult = "MediaCaptureStopResult";

    static PyObject* _new_MediaCaptureStopResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureStopResult);
        return nullptr;
    }

    static void _dealloc_MediaCaptureStopResult(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureStopResult_Close(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureStopResult_get_LastFrame(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureStopResult_get_RecordDuration(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecordDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureStopResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureStopResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MediaCaptureStopResult(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MediaCaptureStopResult(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureStopResult[] = {
        { "close", reinterpret_cast<PyCFunction>(MediaCaptureStopResult_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureStopResult), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MediaCaptureStopResult), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MediaCaptureStopResult), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureStopResult[] = {
        { "last_frame", reinterpret_cast<getter>(MediaCaptureStopResult_get_LastFrame), nullptr, nullptr, nullptr },
        { "record_duration", reinterpret_cast<getter>(MediaCaptureStopResult_get_RecordDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureStopResult[] = 
    {
        { Py_tp_new, _new_MediaCaptureStopResult },
        { Py_tp_dealloc, _dealloc_MediaCaptureStopResult },
        { Py_tp_methods, _methods_MediaCaptureStopResult },
        { Py_tp_getset, _getset_MediaCaptureStopResult },
        { },
    };

    static PyType_Spec _type_spec_MediaCaptureStopResult =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureStopResult",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureStopResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureStopResult
    };

    // ----- MediaCaptureVideoProfile class --------------------
    constexpr const char* const _type_name_MediaCaptureVideoProfile = "MediaCaptureVideoProfile";

    static PyObject* _new_MediaCaptureVideoProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureVideoProfile);
        return nullptr;
    }

    static void _dealloc_MediaCaptureVideoProfile(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureVideoProfile_GetConcurrency(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConcurrency());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_Id(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_SupportedPhotoMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedPhotoMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_SupportedPreviewMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedPreviewMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_SupportedRecordMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedRecordMediaDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_VideoDeviceId(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_FrameSourceInfos(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameSourceInfos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfile_get_Properties(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureVideoProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureVideoProfile[] = {
        { "get_concurrency", reinterpret_cast<PyCFunction>(MediaCaptureVideoProfile_GetConcurrency), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureVideoProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureVideoProfile[] = {
        { "id", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_Id), nullptr, nullptr, nullptr },
        { "supported_photo_media_description", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_SupportedPhotoMediaDescription), nullptr, nullptr, nullptr },
        { "supported_preview_media_description", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_SupportedPreviewMediaDescription), nullptr, nullptr, nullptr },
        { "supported_record_media_description", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_SupportedRecordMediaDescription), nullptr, nullptr, nullptr },
        { "video_device_id", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_VideoDeviceId), nullptr, nullptr, nullptr },
        { "frame_source_infos", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_FrameSourceInfos), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(MediaCaptureVideoProfile_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureVideoProfile[] = 
    {
        { Py_tp_new, _new_MediaCaptureVideoProfile },
        { Py_tp_dealloc, _dealloc_MediaCaptureVideoProfile },
        { Py_tp_methods, _methods_MediaCaptureVideoProfile },
        { Py_tp_getset, _getset_MediaCaptureVideoProfile },
        { },
    };

    static PyType_Spec _type_spec_MediaCaptureVideoProfile =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureVideoProfile",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureVideoProfile
    };

    // ----- MediaCaptureVideoProfileMediaDescription class --------------------
    constexpr const char* const _type_name_MediaCaptureVideoProfileMediaDescription = "MediaCaptureVideoProfileMediaDescription";

    static PyObject* _new_MediaCaptureVideoProfileMediaDescription(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaCaptureVideoProfileMediaDescription);
        return nullptr;
    }

    static void _dealloc_MediaCaptureVideoProfileMediaDescription(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_FrameRate(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Height(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_IsHdrVideoSupported(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsHdrVideoSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_IsVariablePhotoSequenceSupported(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVariablePhotoSequenceSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Width(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Properties(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaCaptureVideoProfileMediaDescription_get_Subtype(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaCaptureVideoProfileMediaDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaCaptureVideoProfileMediaDescription[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaCaptureVideoProfileMediaDescription), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaCaptureVideoProfileMediaDescription[] = {
        { "frame_rate", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_FrameRate), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_Height), nullptr, nullptr, nullptr },
        { "is_hdr_video_supported", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_IsHdrVideoSupported), nullptr, nullptr, nullptr },
        { "is_variable_photo_sequence_supported", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_IsVariablePhotoSequenceSupported), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_Width), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_Properties), nullptr, nullptr, nullptr },
        { "subtype", reinterpret_cast<getter>(MediaCaptureVideoProfileMediaDescription_get_Subtype), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaCaptureVideoProfileMediaDescription[] = 
    {
        { Py_tp_new, _new_MediaCaptureVideoProfileMediaDescription },
        { Py_tp_dealloc, _dealloc_MediaCaptureVideoProfileMediaDescription },
        { Py_tp_methods, _methods_MediaCaptureVideoProfileMediaDescription },
        { Py_tp_getset, _getset_MediaCaptureVideoProfileMediaDescription },
        { },
    };

    static PyType_Spec _type_spec_MediaCaptureVideoProfileMediaDescription =
    {
        "_winsdk_Windows_Media_Capture.MediaCaptureVideoProfileMediaDescription",
        sizeof(py::wrapper::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaCaptureVideoProfileMediaDescription
    };

    // ----- OptionalReferencePhotoCapturedEventArgs class --------------------
    constexpr const char* const _type_name_OptionalReferencePhotoCapturedEventArgs = "OptionalReferencePhotoCapturedEventArgs";

    static PyObject* _new_OptionalReferencePhotoCapturedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_OptionalReferencePhotoCapturedEventArgs);
        return nullptr;
    }

    static void _dealloc_OptionalReferencePhotoCapturedEventArgs(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* OptionalReferencePhotoCapturedEventArgs_get_Context(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OptionalReferencePhotoCapturedEventArgs_get_Frame(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_OptionalReferencePhotoCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OptionalReferencePhotoCapturedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_OptionalReferencePhotoCapturedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OptionalReferencePhotoCapturedEventArgs[] = {
        { "context", reinterpret_cast<getter>(OptionalReferencePhotoCapturedEventArgs_get_Context), nullptr, nullptr, nullptr },
        { "frame", reinterpret_cast<getter>(OptionalReferencePhotoCapturedEventArgs_get_Frame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OptionalReferencePhotoCapturedEventArgs[] = 
    {
        { Py_tp_new, _new_OptionalReferencePhotoCapturedEventArgs },
        { Py_tp_dealloc, _dealloc_OptionalReferencePhotoCapturedEventArgs },
        { Py_tp_methods, _methods_OptionalReferencePhotoCapturedEventArgs },
        { Py_tp_getset, _getset_OptionalReferencePhotoCapturedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_OptionalReferencePhotoCapturedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.OptionalReferencePhotoCapturedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OptionalReferencePhotoCapturedEventArgs
    };

    // ----- PhotoCapturedEventArgs class --------------------
    constexpr const char* const _type_name_PhotoCapturedEventArgs = "PhotoCapturedEventArgs";

    static PyObject* _new_PhotoCapturedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhotoCapturedEventArgs);
        return nullptr;
    }

    static void _dealloc_PhotoCapturedEventArgs(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhotoCapturedEventArgs_get_CaptureTimeOffset(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CaptureTimeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoCapturedEventArgs_get_Frame(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoCapturedEventArgs_get_Thumbnail(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Thumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhotoCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::PhotoCapturedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoCapturedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoCapturedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoCapturedEventArgs[] = {
        { "capture_time_offset", reinterpret_cast<getter>(PhotoCapturedEventArgs_get_CaptureTimeOffset), nullptr, nullptr, nullptr },
        { "frame", reinterpret_cast<getter>(PhotoCapturedEventArgs_get_Frame), nullptr, nullptr, nullptr },
        { "thumbnail", reinterpret_cast<getter>(PhotoCapturedEventArgs_get_Thumbnail), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoCapturedEventArgs[] = 
    {
        { Py_tp_new, _new_PhotoCapturedEventArgs },
        { Py_tp_dealloc, _dealloc_PhotoCapturedEventArgs },
        { Py_tp_methods, _methods_PhotoCapturedEventArgs },
        { Py_tp_getset, _getset_PhotoCapturedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_PhotoCapturedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.PhotoCapturedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::PhotoCapturedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoCapturedEventArgs
    };

    // ----- PhotoConfirmationCapturedEventArgs class --------------------
    constexpr const char* const _type_name_PhotoConfirmationCapturedEventArgs = "PhotoConfirmationCapturedEventArgs";

    static PyObject* _new_PhotoConfirmationCapturedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhotoConfirmationCapturedEventArgs);
        return nullptr;
    }

    static void _dealloc_PhotoConfirmationCapturedEventArgs(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhotoConfirmationCapturedEventArgs_get_CaptureTimeOffset(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CaptureTimeOffset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhotoConfirmationCapturedEventArgs_get_Frame(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Frame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhotoConfirmationCapturedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoConfirmationCapturedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoConfirmationCapturedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoConfirmationCapturedEventArgs[] = {
        { "capture_time_offset", reinterpret_cast<getter>(PhotoConfirmationCapturedEventArgs_get_CaptureTimeOffset), nullptr, nullptr, nullptr },
        { "frame", reinterpret_cast<getter>(PhotoConfirmationCapturedEventArgs_get_Frame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoConfirmationCapturedEventArgs[] = 
    {
        { Py_tp_new, _new_PhotoConfirmationCapturedEventArgs },
        { Py_tp_dealloc, _dealloc_PhotoConfirmationCapturedEventArgs },
        { Py_tp_methods, _methods_PhotoConfirmationCapturedEventArgs },
        { Py_tp_getset, _getset_PhotoConfirmationCapturedEventArgs },
        { },
    };

    static PyType_Spec _type_spec_PhotoConfirmationCapturedEventArgs =
    {
        "_winsdk_Windows_Media_Capture.PhotoConfirmationCapturedEventArgs",
        sizeof(py::wrapper::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoConfirmationCapturedEventArgs
    };

    // ----- VideoStreamConfiguration class --------------------
    constexpr const char* const _type_name_VideoStreamConfiguration = "VideoStreamConfiguration";

    static PyObject* _new_VideoStreamConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoStreamConfiguration);
        return nullptr;
    }

    static void _dealloc_VideoStreamConfiguration(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoStreamConfiguration_get_InputProperties(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoStreamConfiguration_get_OutputProperties(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoStreamConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Capture::VideoStreamConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoStreamConfiguration[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoStreamConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoStreamConfiguration[] = {
        { "input_properties", reinterpret_cast<getter>(VideoStreamConfiguration_get_InputProperties), nullptr, nullptr, nullptr },
        { "output_properties", reinterpret_cast<getter>(VideoStreamConfiguration_get_OutputProperties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoStreamConfiguration[] = 
    {
        { Py_tp_new, _new_VideoStreamConfiguration },
        { Py_tp_dealloc, _dealloc_VideoStreamConfiguration },
        { Py_tp_methods, _methods_VideoStreamConfiguration },
        { Py_tp_getset, _getset_VideoStreamConfiguration },
        { },
    };

    static PyType_Spec _type_spec_VideoStreamConfiguration =
    {
        "_winsdk_Windows_Media_Capture.VideoStreamConfiguration",
        sizeof(py::wrapper::Windows::Media::Capture::VideoStreamConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoStreamConfiguration
    };

    // ----- WhiteBalanceGain struct --------------------
    constexpr const char* const _type_name_WhiteBalanceGain = "WhiteBalanceGain";

    PyObject* _new_WhiteBalanceGain(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Media::Capture::WhiteBalanceGain return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Media::Capture::WhiteBalanceGain>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        double _R{};
        double _G{};
        double _B{};

        static const char* kwlist[] = {"r", "g", "b", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ddd", const_cast<char**>(kwlist), &_R, &_G, &_B))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Media::Capture::WhiteBalanceGain return_value{ _R, _G, _B };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_WhiteBalanceGain(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self)
    {
    }

    static PyObject* WhiteBalanceGain_get_R(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.R);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WhiteBalanceGain_set_R(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.R = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WhiteBalanceGain_get_G(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.G);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WhiteBalanceGain_set_G(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.G = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WhiteBalanceGain_get_B(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.B);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WhiteBalanceGain_set_B(py::wrapper::Windows::Media::Capture::WhiteBalanceGain* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.B = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_WhiteBalanceGain[] = {
        { "r", reinterpret_cast<getter>(WhiteBalanceGain_get_R), reinterpret_cast<setter>(WhiteBalanceGain_set_R), nullptr, nullptr },
        { "g", reinterpret_cast<getter>(WhiteBalanceGain_get_G), reinterpret_cast<setter>(WhiteBalanceGain_set_G), nullptr, nullptr },
        { "b", reinterpret_cast<getter>(WhiteBalanceGain_get_B), reinterpret_cast<setter>(WhiteBalanceGain_set_B), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WhiteBalanceGain[] = 
    {
        { Py_tp_new, _new_WhiteBalanceGain },
        { Py_tp_dealloc, _dealloc_WhiteBalanceGain },
        { Py_tp_getset, _getset_WhiteBalanceGain },
        { },
    };

    static PyType_Spec _type_spec_WhiteBalanceGain =
    {
        "_winsdk_Windows_Media_Capture.WhiteBalanceGain",
        sizeof(py::wrapper::Windows::Media::Capture::WhiteBalanceGain),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WhiteBalanceGain
    };

    // ----- Windows.Media.Capture Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Media::Capture::AdvancedCapturedPhoto>::python_type = py::register_python_type(module, _type_name_AdvancedCapturedPhoto, &_type_spec_AdvancedCapturedPhoto, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::AdvancedPhotoCapture>::python_type = py::register_python_type(module, _type_name_AdvancedPhotoCapture, &_type_spec_AdvancedPhotoCapture, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::AppCapture>::python_type = py::register_python_type(module, _type_name_AppCapture, &_type_spec_AppCapture, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUI>::python_type = py::register_python_type(module, _type_name_CameraCaptureUI, &_type_spec_CameraCaptureUI, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUIPhotoCaptureSettings>::python_type = py::register_python_type(module, _type_name_CameraCaptureUIPhotoCaptureSettings, &_type_spec_CameraCaptureUIPhotoCaptureSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::CameraCaptureUIVideoCaptureSettings>::python_type = py::register_python_type(module, _type_name_CameraCaptureUIVideoCaptureSettings, &_type_spec_CameraCaptureUIVideoCaptureSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::CapturedFrame>::python_type = py::register_python_type(module, _type_name_CapturedFrame, &_type_spec_CapturedFrame, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::CapturedFrameControlValues>::python_type = py::register_python_type(module, _type_name_CapturedFrameControlValues, &_type_spec_CapturedFrameControlValues, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::CapturedPhoto>::python_type = py::register_python_type(module, _type_name_CapturedPhoto, &_type_spec_CapturedPhoto, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::LowLagMediaRecording>::python_type = py::register_python_type(module, _type_name_LowLagMediaRecording, &_type_spec_LowLagMediaRecording, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::LowLagPhotoCapture>::python_type = py::register_python_type(module, _type_name_LowLagPhotoCapture, &_type_spec_LowLagPhotoCapture, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::LowLagPhotoSequenceCapture>::python_type = py::register_python_type(module, _type_name_LowLagPhotoSequenceCapture, &_type_spec_LowLagPhotoSequenceCapture, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCapture>::python_type = py::register_python_type(module, _type_name_MediaCapture, &_type_spec_MediaCapture, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureDeviceExclusiveControlStatusChangedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs, &_type_spec_MediaCaptureDeviceExclusiveControlStatusChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureFailedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaCaptureFailedEventArgs, &_type_spec_MediaCaptureFailedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureFocusChangedEventArgs>::python_type = py::register_python_type(module, _type_name_MediaCaptureFocusChangedEventArgs, &_type_spec_MediaCaptureFocusChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureInitializationSettings>::python_type = py::register_python_type(module, _type_name_MediaCaptureInitializationSettings, &_type_spec_MediaCaptureInitializationSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCapturePauseResult>::python_type = py::register_python_type(module, _type_name_MediaCapturePauseResult, &_type_spec_MediaCapturePauseResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureRelativePanelWatcher>::python_type = py::register_python_type(module, _type_name_MediaCaptureRelativePanelWatcher, &_type_spec_MediaCaptureRelativePanelWatcher, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureSettings>::python_type = py::register_python_type(module, _type_name_MediaCaptureSettings, &_type_spec_MediaCaptureSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureStopResult>::python_type = py::register_python_type(module, _type_name_MediaCaptureStopResult, &_type_spec_MediaCaptureStopResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureVideoProfile>::python_type = py::register_python_type(module, _type_name_MediaCaptureVideoProfile, &_type_spec_MediaCaptureVideoProfile, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::MediaCaptureVideoProfileMediaDescription>::python_type = py::register_python_type(module, _type_name_MediaCaptureVideoProfileMediaDescription, &_type_spec_MediaCaptureVideoProfileMediaDescription, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::OptionalReferencePhotoCapturedEventArgs>::python_type = py::register_python_type(module, _type_name_OptionalReferencePhotoCapturedEventArgs, &_type_spec_OptionalReferencePhotoCapturedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::PhotoCapturedEventArgs>::python_type = py::register_python_type(module, _type_name_PhotoCapturedEventArgs, &_type_spec_PhotoCapturedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::PhotoConfirmationCapturedEventArgs>::python_type = py::register_python_type(module, _type_name_PhotoConfirmationCapturedEventArgs, &_type_spec_PhotoConfirmationCapturedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::VideoStreamConfiguration>::python_type = py::register_python_type(module, _type_name_VideoStreamConfiguration, &_type_spec_VideoStreamConfiguration, bases.get());
            py::winrt_type<winrt::Windows::Media::Capture::WhiteBalanceGain>::python_type = py::register_python_type(module, _type_name_WhiteBalanceGain, &_type_spec_WhiteBalanceGain, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Media.Capture");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_Capture",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Media::Capture

PyMODINIT_FUNC
PyInit__winsdk_Windows_Media_Capture (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::Capture::module_def);
}
