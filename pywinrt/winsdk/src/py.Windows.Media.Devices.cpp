// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Media.Devices.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::AdvancedPhotoCaptureSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::AdvancedPhotoControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceModule>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceModulesManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::CameraOcclusionInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::CameraOcclusionState>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::DigitalWindowBounds>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::DigitalWindowCapability>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::DigitalWindowControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::ExposureCompensationControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::ExposureControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::ExposurePriorityVideoControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::FlashControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::FocusControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::FocusSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::HdrVideoControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::InfraredTorchControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::IsoSpeedControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::LowLagPhotoControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::LowLagPhotoSequenceControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::MediaDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::MediaDeviceControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::MediaDeviceControlCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::ModuleCommandResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::OpticalImageStabilizationControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::PanelBasedOptimizationControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::PhotoConfirmationControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::RegionOfInterest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::RegionsOfInterestControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::SceneModeControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::TorchControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::VideoDeviceController>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::VideoTemporalDenoisingControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::WhiteBalanceControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::ZoomControl>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::ZoomSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Devices::IMediaDeviceController>::python_type;

namespace py::cpp::Windows::Media::Devices
{
    // ----- AdvancedPhotoCaptureSettings class --------------------
    constexpr const char* const _type_name_AdvancedPhotoCaptureSettings = "AdvancedPhotoCaptureSettings";

    static PyObject* _new_AdvancedPhotoCaptureSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::AdvancedPhotoCaptureSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AdvancedPhotoCaptureSettings(py::wrapper::Windows::Media::Devices::AdvancedPhotoCaptureSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdvancedPhotoCaptureSettings_get_Mode(py::wrapper::Windows::Media::Devices::AdvancedPhotoCaptureSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AdvancedPhotoCaptureSettings_put_Mode(py::wrapper::Windows::Media::Devices::AdvancedPhotoCaptureSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::AdvancedPhotoMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AdvancedPhotoCaptureSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AdvancedPhotoCaptureSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdvancedPhotoCaptureSettings[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AdvancedPhotoCaptureSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdvancedPhotoCaptureSettings[] = {
        { "mode", reinterpret_cast<getter>(AdvancedPhotoCaptureSettings_get_Mode), reinterpret_cast<setter>(AdvancedPhotoCaptureSettings_put_Mode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdvancedPhotoCaptureSettings[] = 
    {
        { Py_tp_new, _new_AdvancedPhotoCaptureSettings },
        { Py_tp_dealloc, _dealloc_AdvancedPhotoCaptureSettings },
        { Py_tp_methods, _methods_AdvancedPhotoCaptureSettings },
        { Py_tp_getset, _getset_AdvancedPhotoCaptureSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdvancedPhotoCaptureSettings =
    {
        "_winsdk_Windows_Media_Devices.AdvancedPhotoCaptureSettings",
        sizeof(py::wrapper::Windows::Media::Devices::AdvancedPhotoCaptureSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdvancedPhotoCaptureSettings
    };

    // ----- AdvancedPhotoControl class --------------------
    constexpr const char* const _type_name_AdvancedPhotoControl = "AdvancedPhotoControl";

    static PyObject* _new_AdvancedPhotoControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AdvancedPhotoControl);
        return nullptr;
    }

    static void _dealloc_AdvancedPhotoControl(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AdvancedPhotoControl_Configure(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::AdvancedPhotoCaptureSettings>(args, 0);

                self->obj.Configure(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoControl_get_Mode(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoControl_get_Supported(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AdvancedPhotoControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AdvancedPhotoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AdvancedPhotoControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AdvancedPhotoControl[] = {
        { "configure", reinterpret_cast<PyCFunction>(AdvancedPhotoControl_Configure), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AdvancedPhotoControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AdvancedPhotoControl[] = {
        { "mode", reinterpret_cast<getter>(AdvancedPhotoControl_get_Mode), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(AdvancedPhotoControl_get_Supported), nullptr, nullptr, nullptr },
        { "supported_modes", reinterpret_cast<getter>(AdvancedPhotoControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AdvancedPhotoControl[] = 
    {
        { Py_tp_new, _new_AdvancedPhotoControl },
        { Py_tp_dealloc, _dealloc_AdvancedPhotoControl },
        { Py_tp_methods, _methods_AdvancedPhotoControl },
        { Py_tp_getset, _getset_AdvancedPhotoControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AdvancedPhotoControl =
    {
        "_winsdk_Windows_Media_Devices.AdvancedPhotoControl",
        sizeof(py::wrapper::Windows::Media::Devices::AdvancedPhotoControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AdvancedPhotoControl
    };

    // ----- AudioDeviceController class --------------------
    constexpr const char* const _type_name_AudioDeviceController = "AudioDeviceController";

    static PyObject* _new_AudioDeviceController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioDeviceController);
        return nullptr;
    }

    static void _dealloc_AudioDeviceController(py::wrapper::Windows::Media::Devices::AudioDeviceController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioDeviceController_GetAvailableMediaStreamProperties(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetAvailableMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceController_GetMediaStreamProperties(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceController_SetMediaStreamPropertiesAsync(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 1);

                return py::convert(self->obj.SetMediaStreamPropertiesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceController_get_VolumePercent(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VolumePercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceController_put_VolumePercent(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.VolumePercent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioDeviceController_get_Muted(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Muted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioDeviceController_put_Muted(py::wrapper::Windows::Media::Devices::AudioDeviceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Muted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_AudioDeviceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AudioDeviceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceController[] = {
        { "get_available_media_stream_properties", reinterpret_cast<PyCFunction>(AudioDeviceController_GetAvailableMediaStreamProperties), METH_VARARGS, nullptr },
        { "get_media_stream_properties", reinterpret_cast<PyCFunction>(AudioDeviceController_GetMediaStreamProperties), METH_VARARGS, nullptr },
        { "set_media_stream_properties_async", reinterpret_cast<PyCFunction>(AudioDeviceController_SetMediaStreamPropertiesAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioDeviceController[] = {
        { "volume_percent", reinterpret_cast<getter>(AudioDeviceController_get_VolumePercent), reinterpret_cast<setter>(AudioDeviceController_put_VolumePercent), nullptr, nullptr },
        { "muted", reinterpret_cast<getter>(AudioDeviceController_get_Muted), reinterpret_cast<setter>(AudioDeviceController_put_Muted), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioDeviceController[] = 
    {
        { Py_tp_new, _new_AudioDeviceController },
        { Py_tp_dealloc, _dealloc_AudioDeviceController },
        { Py_tp_methods, _methods_AudioDeviceController },
        { Py_tp_getset, _getset_AudioDeviceController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioDeviceController =
    {
        "_winsdk_Windows_Media_Devices.AudioDeviceController",
        sizeof(py::wrapper::Windows::Media::Devices::AudioDeviceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceController
    };

    // ----- AudioDeviceModule class --------------------
    constexpr const char* const _type_name_AudioDeviceModule = "AudioDeviceModule";

    static PyObject* _new_AudioDeviceModule(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioDeviceModule);
        return nullptr;
    }

    static void _dealloc_AudioDeviceModule(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioDeviceModule_SendCommandAsync(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                return py::convert(self->obj.SendCommandAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_ClassId(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_DisplayName(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_InstanceId(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstanceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_MajorVersion(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MajorVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModule_get_MinorVersion(py::wrapper::Windows::Media::Devices::AudioDeviceModule* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinorVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioDeviceModule(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AudioDeviceModule>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceModule[] = {
        { "send_command_async", reinterpret_cast<PyCFunction>(AudioDeviceModule_SendCommandAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceModule), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioDeviceModule[] = {
        { "class_id", reinterpret_cast<getter>(AudioDeviceModule_get_ClassId), nullptr, nullptr, nullptr },
        { "display_name", reinterpret_cast<getter>(AudioDeviceModule_get_DisplayName), nullptr, nullptr, nullptr },
        { "instance_id", reinterpret_cast<getter>(AudioDeviceModule_get_InstanceId), nullptr, nullptr, nullptr },
        { "major_version", reinterpret_cast<getter>(AudioDeviceModule_get_MajorVersion), nullptr, nullptr, nullptr },
        { "minor_version", reinterpret_cast<getter>(AudioDeviceModule_get_MinorVersion), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioDeviceModule[] = 
    {
        { Py_tp_new, _new_AudioDeviceModule },
        { Py_tp_dealloc, _dealloc_AudioDeviceModule },
        { Py_tp_methods, _methods_AudioDeviceModule },
        { Py_tp_getset, _getset_AudioDeviceModule },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioDeviceModule =
    {
        "_winsdk_Windows_Media_Devices.AudioDeviceModule",
        sizeof(py::wrapper::Windows::Media::Devices::AudioDeviceModule),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceModule
    };

    // ----- AudioDeviceModuleNotificationEventArgs class --------------------
    constexpr const char* const _type_name_AudioDeviceModuleNotificationEventArgs = "AudioDeviceModuleNotificationEventArgs";

    static PyObject* _new_AudioDeviceModuleNotificationEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioDeviceModuleNotificationEventArgs);
        return nullptr;
    }

    static void _dealloc_AudioDeviceModuleNotificationEventArgs(py::wrapper::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioDeviceModuleNotificationEventArgs_get_Module(py::wrapper::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Module());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModuleNotificationEventArgs_get_NotificationData(py::wrapper::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NotificationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioDeviceModuleNotificationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceModuleNotificationEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceModuleNotificationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioDeviceModuleNotificationEventArgs[] = {
        { "module", reinterpret_cast<getter>(AudioDeviceModuleNotificationEventArgs_get_Module), nullptr, nullptr, nullptr },
        { "notification_data", reinterpret_cast<getter>(AudioDeviceModuleNotificationEventArgs_get_NotificationData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioDeviceModuleNotificationEventArgs[] = 
    {
        { Py_tp_new, _new_AudioDeviceModuleNotificationEventArgs },
        { Py_tp_dealloc, _dealloc_AudioDeviceModuleNotificationEventArgs },
        { Py_tp_methods, _methods_AudioDeviceModuleNotificationEventArgs },
        { Py_tp_getset, _getset_AudioDeviceModuleNotificationEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioDeviceModuleNotificationEventArgs =
    {
        "_winsdk_Windows_Media_Devices.AudioDeviceModuleNotificationEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceModuleNotificationEventArgs
    };

    // ----- AudioDeviceModulesManager class --------------------
    constexpr const char* const _type_name_AudioDeviceModulesManager = "AudioDeviceModulesManager";

    static PyObject* _new_AudioDeviceModulesManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Media::Devices::AudioDeviceModulesManager instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioDeviceModulesManager(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioDeviceModulesManager_FindAll(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindAll());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModulesManager_FindAllById(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindAllById(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModulesManager_add_ModuleNotificationReceived(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Devices::AudioDeviceModulesManager, winrt::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs>>(arg);

            return py::convert(self->obj.ModuleNotificationReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioDeviceModulesManager_remove_ModuleNotificationReceived(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ModuleNotificationReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioDeviceModulesManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::AudioDeviceModulesManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioDeviceModulesManager[] = {
        { "find_all", reinterpret_cast<PyCFunction>(AudioDeviceModulesManager_FindAll), METH_VARARGS, nullptr },
        { "find_all_by_id", reinterpret_cast<PyCFunction>(AudioDeviceModulesManager_FindAllById), METH_VARARGS, nullptr },
        { "add_module_notification_received", reinterpret_cast<PyCFunction>(AudioDeviceModulesManager_add_ModuleNotificationReceived), METH_O, nullptr },
        { "remove_module_notification_received", reinterpret_cast<PyCFunction>(AudioDeviceModulesManager_remove_ModuleNotificationReceived), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioDeviceModulesManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioDeviceModulesManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AudioDeviceModulesManager[] = 
    {
        { Py_tp_new, _new_AudioDeviceModulesManager },
        { Py_tp_dealloc, _dealloc_AudioDeviceModulesManager },
        { Py_tp_methods, _methods_AudioDeviceModulesManager },
        { Py_tp_getset, _getset_AudioDeviceModulesManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioDeviceModulesManager =
    {
        "_winsdk_Windows_Media_Devices.AudioDeviceModulesManager",
        sizeof(py::wrapper::Windows::Media::Devices::AudioDeviceModulesManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioDeviceModulesManager
    };

    // ----- CameraOcclusionInfo class --------------------
    constexpr const char* const _type_name_CameraOcclusionInfo = "CameraOcclusionInfo";

    static PyObject* _new_CameraOcclusionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CameraOcclusionInfo);
        return nullptr;
    }

    static void _dealloc_CameraOcclusionInfo(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CameraOcclusionInfo_GetState(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetState());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraOcclusionInfo_IsOcclusionKindSupported(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::CameraOcclusionKind>(args, 0);

                return py::convert(self->obj.IsOcclusionKindSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraOcclusionInfo_add_StateChanged(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Devices::CameraOcclusionInfo, winrt::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraOcclusionInfo_remove_StateChanged(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CameraOcclusionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::CameraOcclusionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraOcclusionInfo[] = {
        { "get_state", reinterpret_cast<PyCFunction>(CameraOcclusionInfo_GetState), METH_VARARGS, nullptr },
        { "is_occlusion_kind_supported", reinterpret_cast<PyCFunction>(CameraOcclusionInfo_IsOcclusionKindSupported), METH_VARARGS, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(CameraOcclusionInfo_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(CameraOcclusionInfo_remove_StateChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraOcclusionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraOcclusionInfo[] = {
        { }
    };

    static PyType_Slot _type_slots_CameraOcclusionInfo[] = 
    {
        { Py_tp_new, _new_CameraOcclusionInfo },
        { Py_tp_dealloc, _dealloc_CameraOcclusionInfo },
        { Py_tp_methods, _methods_CameraOcclusionInfo },
        { Py_tp_getset, _getset_CameraOcclusionInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CameraOcclusionInfo =
    {
        "_winsdk_Windows_Media_Devices.CameraOcclusionInfo",
        sizeof(py::wrapper::Windows::Media::Devices::CameraOcclusionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraOcclusionInfo
    };

    // ----- CameraOcclusionState class --------------------
    constexpr const char* const _type_name_CameraOcclusionState = "CameraOcclusionState";

    static PyObject* _new_CameraOcclusionState(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CameraOcclusionState);
        return nullptr;
    }

    static void _dealloc_CameraOcclusionState(py::wrapper::Windows::Media::Devices::CameraOcclusionState* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CameraOcclusionState_IsOcclusionKind(py::wrapper::Windows::Media::Devices::CameraOcclusionState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::CameraOcclusionKind>(args, 0);

                return py::convert(self->obj.IsOcclusionKind(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CameraOcclusionState_get_IsOccluded(py::wrapper::Windows::Media::Devices::CameraOcclusionState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOccluded());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CameraOcclusionState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::CameraOcclusionState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraOcclusionState[] = {
        { "is_occlusion_kind", reinterpret_cast<PyCFunction>(CameraOcclusionState_IsOcclusionKind), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraOcclusionState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraOcclusionState[] = {
        { "is_occluded", reinterpret_cast<getter>(CameraOcclusionState_get_IsOccluded), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraOcclusionState[] = 
    {
        { Py_tp_new, _new_CameraOcclusionState },
        { Py_tp_dealloc, _dealloc_CameraOcclusionState },
        { Py_tp_methods, _methods_CameraOcclusionState },
        { Py_tp_getset, _getset_CameraOcclusionState },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CameraOcclusionState =
    {
        "_winsdk_Windows_Media_Devices.CameraOcclusionState",
        sizeof(py::wrapper::Windows::Media::Devices::CameraOcclusionState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraOcclusionState
    };

    // ----- CameraOcclusionStateChangedEventArgs class --------------------
    constexpr const char* const _type_name_CameraOcclusionStateChangedEventArgs = "CameraOcclusionStateChangedEventArgs";

    static PyObject* _new_CameraOcclusionStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CameraOcclusionStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_CameraOcclusionStateChangedEventArgs(py::wrapper::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CameraOcclusionStateChangedEventArgs_get_State(py::wrapper::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CameraOcclusionStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraOcclusionStateChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraOcclusionStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraOcclusionStateChangedEventArgs[] = {
        { "state", reinterpret_cast<getter>(CameraOcclusionStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraOcclusionStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_CameraOcclusionStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_CameraOcclusionStateChangedEventArgs },
        { Py_tp_methods, _methods_CameraOcclusionStateChangedEventArgs },
        { Py_tp_getset, _getset_CameraOcclusionStateChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CameraOcclusionStateChangedEventArgs =
    {
        "_winsdk_Windows_Media_Devices.CameraOcclusionStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraOcclusionStateChangedEventArgs
    };

    // ----- DefaultAudioCaptureDeviceChangedEventArgs class --------------------
    constexpr const char* const _type_name_DefaultAudioCaptureDeviceChangedEventArgs = "DefaultAudioCaptureDeviceChangedEventArgs";

    static PyObject* _new_DefaultAudioCaptureDeviceChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DefaultAudioCaptureDeviceChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_DefaultAudioCaptureDeviceChangedEventArgs(py::wrapper::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DefaultAudioCaptureDeviceChangedEventArgs_get_Id(py::wrapper::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DefaultAudioCaptureDeviceChangedEventArgs_get_Role(py::wrapper::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Role());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DefaultAudioCaptureDeviceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DefaultAudioCaptureDeviceChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DefaultAudioCaptureDeviceChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DefaultAudioCaptureDeviceChangedEventArgs[] = {
        { "id", reinterpret_cast<getter>(DefaultAudioCaptureDeviceChangedEventArgs_get_Id), nullptr, nullptr, nullptr },
        { "role", reinterpret_cast<getter>(DefaultAudioCaptureDeviceChangedEventArgs_get_Role), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DefaultAudioCaptureDeviceChangedEventArgs[] = 
    {
        { Py_tp_new, _new_DefaultAudioCaptureDeviceChangedEventArgs },
        { Py_tp_dealloc, _dealloc_DefaultAudioCaptureDeviceChangedEventArgs },
        { Py_tp_methods, _methods_DefaultAudioCaptureDeviceChangedEventArgs },
        { Py_tp_getset, _getset_DefaultAudioCaptureDeviceChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DefaultAudioCaptureDeviceChangedEventArgs =
    {
        "_winsdk_Windows_Media_Devices.DefaultAudioCaptureDeviceChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DefaultAudioCaptureDeviceChangedEventArgs
    };

    // ----- DefaultAudioRenderDeviceChangedEventArgs class --------------------
    constexpr const char* const _type_name_DefaultAudioRenderDeviceChangedEventArgs = "DefaultAudioRenderDeviceChangedEventArgs";

    static PyObject* _new_DefaultAudioRenderDeviceChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DefaultAudioRenderDeviceChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_DefaultAudioRenderDeviceChangedEventArgs(py::wrapper::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DefaultAudioRenderDeviceChangedEventArgs_get_Id(py::wrapper::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DefaultAudioRenderDeviceChangedEventArgs_get_Role(py::wrapper::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Role());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DefaultAudioRenderDeviceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DefaultAudioRenderDeviceChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DefaultAudioRenderDeviceChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DefaultAudioRenderDeviceChangedEventArgs[] = {
        { "id", reinterpret_cast<getter>(DefaultAudioRenderDeviceChangedEventArgs_get_Id), nullptr, nullptr, nullptr },
        { "role", reinterpret_cast<getter>(DefaultAudioRenderDeviceChangedEventArgs_get_Role), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DefaultAudioRenderDeviceChangedEventArgs[] = 
    {
        { Py_tp_new, _new_DefaultAudioRenderDeviceChangedEventArgs },
        { Py_tp_dealloc, _dealloc_DefaultAudioRenderDeviceChangedEventArgs },
        { Py_tp_methods, _methods_DefaultAudioRenderDeviceChangedEventArgs },
        { Py_tp_getset, _getset_DefaultAudioRenderDeviceChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DefaultAudioRenderDeviceChangedEventArgs =
    {
        "_winsdk_Windows_Media_Devices.DefaultAudioRenderDeviceChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DefaultAudioRenderDeviceChangedEventArgs
    };

    // ----- DigitalWindowBounds class --------------------
    constexpr const char* const _type_name_DigitalWindowBounds = "DigitalWindowBounds";

    static PyObject* _new_DigitalWindowBounds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::DigitalWindowBounds instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DigitalWindowBounds(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DigitalWindowBounds_get_Scale(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Scale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DigitalWindowBounds_put_Scale(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Scale(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DigitalWindowBounds_get_NormalizedOriginTop(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NormalizedOriginTop());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DigitalWindowBounds_put_NormalizedOriginTop(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.NormalizedOriginTop(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DigitalWindowBounds_get_NormalizedOriginLeft(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NormalizedOriginLeft());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DigitalWindowBounds_put_NormalizedOriginLeft(py::wrapper::Windows::Media::Devices::DigitalWindowBounds* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.NormalizedOriginLeft(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DigitalWindowBounds(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DigitalWindowBounds>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DigitalWindowBounds[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DigitalWindowBounds), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DigitalWindowBounds[] = {
        { "scale", reinterpret_cast<getter>(DigitalWindowBounds_get_Scale), reinterpret_cast<setter>(DigitalWindowBounds_put_Scale), nullptr, nullptr },
        { "normalized_origin_top", reinterpret_cast<getter>(DigitalWindowBounds_get_NormalizedOriginTop), reinterpret_cast<setter>(DigitalWindowBounds_put_NormalizedOriginTop), nullptr, nullptr },
        { "normalized_origin_left", reinterpret_cast<getter>(DigitalWindowBounds_get_NormalizedOriginLeft), reinterpret_cast<setter>(DigitalWindowBounds_put_NormalizedOriginLeft), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DigitalWindowBounds[] = 
    {
        { Py_tp_new, _new_DigitalWindowBounds },
        { Py_tp_dealloc, _dealloc_DigitalWindowBounds },
        { Py_tp_methods, _methods_DigitalWindowBounds },
        { Py_tp_getset, _getset_DigitalWindowBounds },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DigitalWindowBounds =
    {
        "_winsdk_Windows_Media_Devices.DigitalWindowBounds",
        sizeof(py::wrapper::Windows::Media::Devices::DigitalWindowBounds),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DigitalWindowBounds
    };

    // ----- DigitalWindowCapability class --------------------
    constexpr const char* const _type_name_DigitalWindowCapability = "DigitalWindowCapability";

    static PyObject* _new_DigitalWindowCapability(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DigitalWindowCapability);
        return nullptr;
    }

    static void _dealloc_DigitalWindowCapability(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DigitalWindowCapability_get_Height(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_MaxScaleValue(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxScaleValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_MinScaleValue(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinScaleValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_MinScaleValueWithoutUpsampling(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinScaleValueWithoutUpsampling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_NormalizedFieldOfViewLimit(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NormalizedFieldOfViewLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowCapability_get_Width(py::wrapper::Windows::Media::Devices::DigitalWindowCapability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DigitalWindowCapability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DigitalWindowCapability>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DigitalWindowCapability[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DigitalWindowCapability), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DigitalWindowCapability[] = {
        { "height", reinterpret_cast<getter>(DigitalWindowCapability_get_Height), nullptr, nullptr, nullptr },
        { "max_scale_value", reinterpret_cast<getter>(DigitalWindowCapability_get_MaxScaleValue), nullptr, nullptr, nullptr },
        { "min_scale_value", reinterpret_cast<getter>(DigitalWindowCapability_get_MinScaleValue), nullptr, nullptr, nullptr },
        { "min_scale_value_without_upsampling", reinterpret_cast<getter>(DigitalWindowCapability_get_MinScaleValueWithoutUpsampling), nullptr, nullptr, nullptr },
        { "normalized_field_of_view_limit", reinterpret_cast<getter>(DigitalWindowCapability_get_NormalizedFieldOfViewLimit), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(DigitalWindowCapability_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DigitalWindowCapability[] = 
    {
        { Py_tp_new, _new_DigitalWindowCapability },
        { Py_tp_dealloc, _dealloc_DigitalWindowCapability },
        { Py_tp_methods, _methods_DigitalWindowCapability },
        { Py_tp_getset, _getset_DigitalWindowCapability },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DigitalWindowCapability =
    {
        "_winsdk_Windows_Media_Devices.DigitalWindowCapability",
        sizeof(py::wrapper::Windows::Media::Devices::DigitalWindowCapability),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DigitalWindowCapability
    };

    // ----- DigitalWindowControl class --------------------
    constexpr const char* const _type_name_DigitalWindowControl = "DigitalWindowControl";

    static PyObject* _new_DigitalWindowControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DigitalWindowControl);
        return nullptr;
    }

    static void _dealloc_DigitalWindowControl(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DigitalWindowControl_Configure(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::DigitalWindowMode>(args, 0);

                self->obj.Configure(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::DigitalWindowMode>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Devices::DigitalWindowBounds>(args, 1);

                self->obj.Configure(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_GetBounds(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetBounds());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_GetCapabilityForSize(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);

                return py::convert(self->obj.GetCapabilityForSize(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_get_CurrentMode(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_get_IsSupported(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_get_SupportedCapabilities(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedCapabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DigitalWindowControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::DigitalWindowControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DigitalWindowControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::DigitalWindowControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DigitalWindowControl[] = {
        { "configure", reinterpret_cast<PyCFunction>(DigitalWindowControl_Configure), METH_VARARGS, nullptr },
        { "get_bounds", reinterpret_cast<PyCFunction>(DigitalWindowControl_GetBounds), METH_VARARGS, nullptr },
        { "get_capability_for_size", reinterpret_cast<PyCFunction>(DigitalWindowControl_GetCapabilityForSize), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DigitalWindowControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DigitalWindowControl[] = {
        { "current_mode", reinterpret_cast<getter>(DigitalWindowControl_get_CurrentMode), nullptr, nullptr, nullptr },
        { "is_supported", reinterpret_cast<getter>(DigitalWindowControl_get_IsSupported), nullptr, nullptr, nullptr },
        { "supported_capabilities", reinterpret_cast<getter>(DigitalWindowControl_get_SupportedCapabilities), nullptr, nullptr, nullptr },
        { "supported_modes", reinterpret_cast<getter>(DigitalWindowControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DigitalWindowControl[] = 
    {
        { Py_tp_new, _new_DigitalWindowControl },
        { Py_tp_dealloc, _dealloc_DigitalWindowControl },
        { Py_tp_methods, _methods_DigitalWindowControl },
        { Py_tp_getset, _getset_DigitalWindowControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DigitalWindowControl =
    {
        "_winsdk_Windows_Media_Devices.DigitalWindowControl",
        sizeof(py::wrapper::Windows::Media::Devices::DigitalWindowControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DigitalWindowControl
    };

    // ----- ExposureCompensationControl class --------------------
    constexpr const char* const _type_name_ExposureCompensationControl = "ExposureCompensationControl";

    static PyObject* _new_ExposureCompensationControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ExposureCompensationControl);
        return nullptr;
    }

    static void _dealloc_ExposureCompensationControl(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ExposureCompensationControl_SetValueAsync(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<float>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Max(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Min(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Step(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Supported(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureCompensationControl_get_Value(py::wrapper::Windows::Media::Devices::ExposureCompensationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ExposureCompensationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ExposureCompensationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExposureCompensationControl[] = {
        { "set_value_async", reinterpret_cast<PyCFunction>(ExposureCompensationControl_SetValueAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExposureCompensationControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ExposureCompensationControl[] = {
        { "max", reinterpret_cast<getter>(ExposureCompensationControl_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(ExposureCompensationControl_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(ExposureCompensationControl_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(ExposureCompensationControl_get_Supported), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ExposureCompensationControl_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ExposureCompensationControl[] = 
    {
        { Py_tp_new, _new_ExposureCompensationControl },
        { Py_tp_dealloc, _dealloc_ExposureCompensationControl },
        { Py_tp_methods, _methods_ExposureCompensationControl },
        { Py_tp_getset, _getset_ExposureCompensationControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ExposureCompensationControl =
    {
        "_winsdk_Windows_Media_Devices.ExposureCompensationControl",
        sizeof(py::wrapper::Windows::Media::Devices::ExposureCompensationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExposureCompensationControl
    };

    // ----- ExposureControl class --------------------
    constexpr const char* const _type_name_ExposureControl = "ExposureControl";

    static PyObject* _new_ExposureControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ExposureControl);
        return nullptr;
    }

    static void _dealloc_ExposureControl(py::wrapper::Windows::Media::Devices::ExposureControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ExposureControl_SetAutoAsync(py::wrapper::Windows::Media::Devices::ExposureControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.SetAutoAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ExposureControl_SetValueAsync(py::wrapper::Windows::Media::Devices::ExposureControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Auto(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Max(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Min(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Step(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Supported(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ExposureControl_get_Value(py::wrapper::Windows::Media::Devices::ExposureControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ExposureControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ExposureControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExposureControl[] = {
        { "set_auto_async", reinterpret_cast<PyCFunction>(ExposureControl_SetAutoAsync), METH_VARARGS, nullptr },
        { "set_value_async", reinterpret_cast<PyCFunction>(ExposureControl_SetValueAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ExposureControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ExposureControl[] = {
        { "auto", reinterpret_cast<getter>(ExposureControl_get_Auto), nullptr, nullptr, nullptr },
        { "max", reinterpret_cast<getter>(ExposureControl_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(ExposureControl_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(ExposureControl_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(ExposureControl_get_Supported), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(ExposureControl_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ExposureControl[] = 
    {
        { Py_tp_new, _new_ExposureControl },
        { Py_tp_dealloc, _dealloc_ExposureControl },
        { Py_tp_methods, _methods_ExposureControl },
        { Py_tp_getset, _getset_ExposureControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ExposureControl =
    {
        "_winsdk_Windows_Media_Devices.ExposureControl",
        sizeof(py::wrapper::Windows::Media::Devices::ExposureControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExposureControl
    };

    // ----- ExposurePriorityVideoControl class --------------------
    constexpr const char* const _type_name_ExposurePriorityVideoControl = "ExposurePriorityVideoControl";

    static PyObject* _new_ExposurePriorityVideoControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ExposurePriorityVideoControl);
        return nullptr;
    }

    static void _dealloc_ExposurePriorityVideoControl(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ExposurePriorityVideoControl_get_Enabled(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ExposurePriorityVideoControl_put_Enabled(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ExposurePriorityVideoControl_get_Supported(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ExposurePriorityVideoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ExposurePriorityVideoControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ExposurePriorityVideoControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ExposurePriorityVideoControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ExposurePriorityVideoControl[] = {
        { "enabled", reinterpret_cast<getter>(ExposurePriorityVideoControl_get_Enabled), reinterpret_cast<setter>(ExposurePriorityVideoControl_put_Enabled), nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(ExposurePriorityVideoControl_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ExposurePriorityVideoControl[] = 
    {
        { Py_tp_new, _new_ExposurePriorityVideoControl },
        { Py_tp_dealloc, _dealloc_ExposurePriorityVideoControl },
        { Py_tp_methods, _methods_ExposurePriorityVideoControl },
        { Py_tp_getset, _getset_ExposurePriorityVideoControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ExposurePriorityVideoControl =
    {
        "_winsdk_Windows_Media_Devices.ExposurePriorityVideoControl",
        sizeof(py::wrapper::Windows::Media::Devices::ExposurePriorityVideoControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ExposurePriorityVideoControl
    };

    // ----- FlashControl class --------------------
    constexpr const char* const _type_name_FlashControl = "FlashControl";

    static PyObject* _new_FlashControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FlashControl);
        return nullptr;
    }

    static void _dealloc_FlashControl(py::wrapper::Windows::Media::Devices::FlashControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FlashControl_get_RedEyeReduction(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RedEyeReduction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_RedEyeReduction(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RedEyeReduction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_PowerPercent(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_PowerPercent(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PowerPercent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_Enabled(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_Enabled(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_Auto(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_Auto(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Auto(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_PowerSupported(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlashControl_get_RedEyeReductionSupported(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RedEyeReductionSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlashControl_get_Supported(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FlashControl_get_AssistantLightEnabled(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AssistantLightEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FlashControl_put_AssistantLightEnabled(py::wrapper::Windows::Media::Devices::FlashControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AssistantLightEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FlashControl_get_AssistantLightSupported(py::wrapper::Windows::Media::Devices::FlashControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AssistantLightSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FlashControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::FlashControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FlashControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FlashControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FlashControl[] = {
        { "red_eye_reduction", reinterpret_cast<getter>(FlashControl_get_RedEyeReduction), reinterpret_cast<setter>(FlashControl_put_RedEyeReduction), nullptr, nullptr },
        { "power_percent", reinterpret_cast<getter>(FlashControl_get_PowerPercent), reinterpret_cast<setter>(FlashControl_put_PowerPercent), nullptr, nullptr },
        { "enabled", reinterpret_cast<getter>(FlashControl_get_Enabled), reinterpret_cast<setter>(FlashControl_put_Enabled), nullptr, nullptr },
        { "auto", reinterpret_cast<getter>(FlashControl_get_Auto), reinterpret_cast<setter>(FlashControl_put_Auto), nullptr, nullptr },
        { "power_supported", reinterpret_cast<getter>(FlashControl_get_PowerSupported), nullptr, nullptr, nullptr },
        { "red_eye_reduction_supported", reinterpret_cast<getter>(FlashControl_get_RedEyeReductionSupported), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FlashControl_get_Supported), nullptr, nullptr, nullptr },
        { "assistant_light_enabled", reinterpret_cast<getter>(FlashControl_get_AssistantLightEnabled), reinterpret_cast<setter>(FlashControl_put_AssistantLightEnabled), nullptr, nullptr },
        { "assistant_light_supported", reinterpret_cast<getter>(FlashControl_get_AssistantLightSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FlashControl[] = 
    {
        { Py_tp_new, _new_FlashControl },
        { Py_tp_dealloc, _dealloc_FlashControl },
        { Py_tp_methods, _methods_FlashControl },
        { Py_tp_getset, _getset_FlashControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FlashControl =
    {
        "_winsdk_Windows_Media_Devices.FlashControl",
        sizeof(py::wrapper::Windows::Media::Devices::FlashControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FlashControl
    };

    // ----- FocusControl class --------------------
    constexpr const char* const _type_name_FocusControl = "FocusControl";

    static PyObject* _new_FocusControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FocusControl);
        return nullptr;
    }

    static void _dealloc_FocusControl(py::wrapper::Windows::Media::Devices::FocusControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FocusControl_Configure(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::FocusSettings>(args, 0);

                self->obj.Configure(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_FocusAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FocusAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_LockAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.LockAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_SetPresetAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::FocusPreset>(args, 0);

                return py::convert(self->obj.SetPresetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::FocusPreset>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.SetPresetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_SetValueAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_UnlockAsync(py::wrapper::Windows::Media::Devices::FocusControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.UnlockAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Max(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Min(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Preset(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Preset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Step(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Supported(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_SupportedPresets(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedPresets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Value(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_FocusChangedSupported(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FocusChangedSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_FocusState(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FocusState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_Mode(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_SupportedFocusDistances(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedFocusDistances());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_SupportedFocusModes(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedFocusModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_SupportedFocusRanges(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedFocusRanges());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FocusControl_get_WaitForFocusSupported(py::wrapper::Windows::Media::Devices::FocusControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WaitForFocusSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FocusControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::FocusControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusControl[] = {
        { "configure", reinterpret_cast<PyCFunction>(FocusControl_Configure), METH_VARARGS, nullptr },
        { "focus_async", reinterpret_cast<PyCFunction>(FocusControl_FocusAsync), METH_VARARGS, nullptr },
        { "lock_async", reinterpret_cast<PyCFunction>(FocusControl_LockAsync), METH_VARARGS, nullptr },
        { "set_preset_async", reinterpret_cast<PyCFunction>(FocusControl_SetPresetAsync), METH_VARARGS, nullptr },
        { "set_value_async", reinterpret_cast<PyCFunction>(FocusControl_SetValueAsync), METH_VARARGS, nullptr },
        { "unlock_async", reinterpret_cast<PyCFunction>(FocusControl_UnlockAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FocusControl[] = {
        { "max", reinterpret_cast<getter>(FocusControl_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(FocusControl_get_Min), nullptr, nullptr, nullptr },
        { "preset", reinterpret_cast<getter>(FocusControl_get_Preset), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(FocusControl_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(FocusControl_get_Supported), nullptr, nullptr, nullptr },
        { "supported_presets", reinterpret_cast<getter>(FocusControl_get_SupportedPresets), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(FocusControl_get_Value), nullptr, nullptr, nullptr },
        { "focus_changed_supported", reinterpret_cast<getter>(FocusControl_get_FocusChangedSupported), nullptr, nullptr, nullptr },
        { "focus_state", reinterpret_cast<getter>(FocusControl_get_FocusState), nullptr, nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(FocusControl_get_Mode), nullptr, nullptr, nullptr },
        { "supported_focus_distances", reinterpret_cast<getter>(FocusControl_get_SupportedFocusDistances), nullptr, nullptr, nullptr },
        { "supported_focus_modes", reinterpret_cast<getter>(FocusControl_get_SupportedFocusModes), nullptr, nullptr, nullptr },
        { "supported_focus_ranges", reinterpret_cast<getter>(FocusControl_get_SupportedFocusRanges), nullptr, nullptr, nullptr },
        { "wait_for_focus_supported", reinterpret_cast<getter>(FocusControl_get_WaitForFocusSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FocusControl[] = 
    {
        { Py_tp_new, _new_FocusControl },
        { Py_tp_dealloc, _dealloc_FocusControl },
        { Py_tp_methods, _methods_FocusControl },
        { Py_tp_getset, _getset_FocusControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FocusControl =
    {
        "_winsdk_Windows_Media_Devices.FocusControl",
        sizeof(py::wrapper::Windows::Media::Devices::FocusControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusControl
    };

    // ----- FocusSettings class --------------------
    constexpr const char* const _type_name_FocusSettings = "FocusSettings";

    static PyObject* _new_FocusSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::FocusSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_FocusSettings(py::wrapper::Windows::Media::Devices::FocusSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FocusSettings_get_WaitForFocus(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WaitForFocus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_WaitForFocus(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.WaitForFocus(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_Value(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_Value(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_Mode(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_Mode(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::FocusMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_Distance(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Distance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_Distance(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Media::Devices::ManualFocusDistance>>(arg);

            self->obj.Distance(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_DisableDriverFallback(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisableDriverFallback());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_DisableDriverFallback(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DisableDriverFallback(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FocusSettings_get_AutoFocusRange(py::wrapper::Windows::Media::Devices::FocusSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoFocusRange());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FocusSettings_put_AutoFocusRange(py::wrapper::Windows::Media::Devices::FocusSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::AutoFocusRange>(arg);

            self->obj.AutoFocusRange(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FocusSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::FocusSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FocusSettings[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FocusSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FocusSettings[] = {
        { "wait_for_focus", reinterpret_cast<getter>(FocusSettings_get_WaitForFocus), reinterpret_cast<setter>(FocusSettings_put_WaitForFocus), nullptr, nullptr },
        { "value", reinterpret_cast<getter>(FocusSettings_get_Value), reinterpret_cast<setter>(FocusSettings_put_Value), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(FocusSettings_get_Mode), reinterpret_cast<setter>(FocusSettings_put_Mode), nullptr, nullptr },
        { "distance", reinterpret_cast<getter>(FocusSettings_get_Distance), reinterpret_cast<setter>(FocusSettings_put_Distance), nullptr, nullptr },
        { "disable_driver_fallback", reinterpret_cast<getter>(FocusSettings_get_DisableDriverFallback), reinterpret_cast<setter>(FocusSettings_put_DisableDriverFallback), nullptr, nullptr },
        { "auto_focus_range", reinterpret_cast<getter>(FocusSettings_get_AutoFocusRange), reinterpret_cast<setter>(FocusSettings_put_AutoFocusRange), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FocusSettings[] = 
    {
        { Py_tp_new, _new_FocusSettings },
        { Py_tp_dealloc, _dealloc_FocusSettings },
        { Py_tp_methods, _methods_FocusSettings },
        { Py_tp_getset, _getset_FocusSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FocusSettings =
    {
        "_winsdk_Windows_Media_Devices.FocusSettings",
        sizeof(py::wrapper::Windows::Media::Devices::FocusSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FocusSettings
    };

    // ----- HdrVideoControl class --------------------
    constexpr const char* const _type_name_HdrVideoControl = "HdrVideoControl";

    static PyObject* _new_HdrVideoControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_HdrVideoControl);
        return nullptr;
    }

    static void _dealloc_HdrVideoControl(py::wrapper::Windows::Media::Devices::HdrVideoControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* HdrVideoControl_get_Mode(py::wrapper::Windows::Media::Devices::HdrVideoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int HdrVideoControl_put_Mode(py::wrapper::Windows::Media::Devices::HdrVideoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::HdrVideoMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* HdrVideoControl_get_Supported(py::wrapper::Windows::Media::Devices::HdrVideoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* HdrVideoControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::HdrVideoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_HdrVideoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::HdrVideoControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_HdrVideoControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_HdrVideoControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_HdrVideoControl[] = {
        { "mode", reinterpret_cast<getter>(HdrVideoControl_get_Mode), reinterpret_cast<setter>(HdrVideoControl_put_Mode), nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(HdrVideoControl_get_Supported), nullptr, nullptr, nullptr },
        { "supported_modes", reinterpret_cast<getter>(HdrVideoControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_HdrVideoControl[] = 
    {
        { Py_tp_new, _new_HdrVideoControl },
        { Py_tp_dealloc, _dealloc_HdrVideoControl },
        { Py_tp_methods, _methods_HdrVideoControl },
        { Py_tp_getset, _getset_HdrVideoControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_HdrVideoControl =
    {
        "_winsdk_Windows_Media_Devices.HdrVideoControl",
        sizeof(py::wrapper::Windows::Media::Devices::HdrVideoControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_HdrVideoControl
    };

    // ----- InfraredTorchControl class --------------------
    constexpr const char* const _type_name_InfraredTorchControl = "InfraredTorchControl";

    static PyObject* _new_InfraredTorchControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InfraredTorchControl);
        return nullptr;
    }

    static void _dealloc_InfraredTorchControl(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InfraredTorchControl_get_Power(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Power());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfraredTorchControl_put_Power(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Power(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfraredTorchControl_get_CurrentMode(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InfraredTorchControl_put_CurrentMode(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::InfraredTorchMode>(arg);

            self->obj.CurrentMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InfraredTorchControl_get_IsSupported(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfraredTorchControl_get_MaxPower(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPower());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfraredTorchControl_get_MinPower(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MinPower());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfraredTorchControl_get_PowerStep(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerStep());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* InfraredTorchControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::InfraredTorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_InfraredTorchControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::InfraredTorchControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InfraredTorchControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InfraredTorchControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InfraredTorchControl[] = {
        { "power", reinterpret_cast<getter>(InfraredTorchControl_get_Power), reinterpret_cast<setter>(InfraredTorchControl_put_Power), nullptr, nullptr },
        { "current_mode", reinterpret_cast<getter>(InfraredTorchControl_get_CurrentMode), reinterpret_cast<setter>(InfraredTorchControl_put_CurrentMode), nullptr, nullptr },
        { "is_supported", reinterpret_cast<getter>(InfraredTorchControl_get_IsSupported), nullptr, nullptr, nullptr },
        { "max_power", reinterpret_cast<getter>(InfraredTorchControl_get_MaxPower), nullptr, nullptr, nullptr },
        { "min_power", reinterpret_cast<getter>(InfraredTorchControl_get_MinPower), nullptr, nullptr, nullptr },
        { "power_step", reinterpret_cast<getter>(InfraredTorchControl_get_PowerStep), nullptr, nullptr, nullptr },
        { "supported_modes", reinterpret_cast<getter>(InfraredTorchControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InfraredTorchControl[] = 
    {
        { Py_tp_new, _new_InfraredTorchControl },
        { Py_tp_dealloc, _dealloc_InfraredTorchControl },
        { Py_tp_methods, _methods_InfraredTorchControl },
        { Py_tp_getset, _getset_InfraredTorchControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InfraredTorchControl =
    {
        "_winsdk_Windows_Media_Devices.InfraredTorchControl",
        sizeof(py::wrapper::Windows::Media::Devices::InfraredTorchControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InfraredTorchControl
    };

    // ----- IsoSpeedControl class --------------------
    constexpr const char* const _type_name_IsoSpeedControl = "IsoSpeedControl";

    static PyObject* _new_IsoSpeedControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_IsoSpeedControl);
        return nullptr;
    }

    static void _dealloc_IsoSpeedControl(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IsoSpeedControl_SetAutoAsync(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SetAutoAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_SetPresetAsync(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::IsoSpeedPreset>(args, 0);

                return py::convert(self->obj.SetPresetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_SetValueAsync(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Preset(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Preset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Supported(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_SupportedPresets(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedPresets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Auto(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Auto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Max(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Min(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Step(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IsoSpeedControl_get_Value(py::wrapper::Windows::Media::Devices::IsoSpeedControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IsoSpeedControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::IsoSpeedControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IsoSpeedControl[] = {
        { "set_auto_async", reinterpret_cast<PyCFunction>(IsoSpeedControl_SetAutoAsync), METH_VARARGS, nullptr },
        { "set_preset_async", reinterpret_cast<PyCFunction>(IsoSpeedControl_SetPresetAsync), METH_VARARGS, nullptr },
        { "set_value_async", reinterpret_cast<PyCFunction>(IsoSpeedControl_SetValueAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IsoSpeedControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IsoSpeedControl[] = {
        { "preset", reinterpret_cast<getter>(IsoSpeedControl_get_Preset), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(IsoSpeedControl_get_Supported), nullptr, nullptr, nullptr },
        { "supported_presets", reinterpret_cast<getter>(IsoSpeedControl_get_SupportedPresets), nullptr, nullptr, nullptr },
        { "auto", reinterpret_cast<getter>(IsoSpeedControl_get_Auto), nullptr, nullptr, nullptr },
        { "max", reinterpret_cast<getter>(IsoSpeedControl_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(IsoSpeedControl_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(IsoSpeedControl_get_Step), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(IsoSpeedControl_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IsoSpeedControl[] = 
    {
        { Py_tp_new, _new_IsoSpeedControl },
        { Py_tp_dealloc, _dealloc_IsoSpeedControl },
        { Py_tp_methods, _methods_IsoSpeedControl },
        { Py_tp_getset, _getset_IsoSpeedControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IsoSpeedControl =
    {
        "_winsdk_Windows_Media_Devices.IsoSpeedControl",
        sizeof(py::wrapper::Windows::Media::Devices::IsoSpeedControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IsoSpeedControl
    };

    // ----- LowLagPhotoControl class --------------------
    constexpr const char* const _type_name_LowLagPhotoControl = "LowLagPhotoControl";

    static PyObject* _new_LowLagPhotoControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LowLagPhotoControl);
        return nullptr;
    }

    static void _dealloc_LowLagPhotoControl(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LowLagPhotoControl_GetCurrentFrameRate(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentFrameRate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoControl_GetHighestConcurrentFrameRate(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 0);

                return py::convert(self->obj.GetHighestConcurrentFrameRate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoControl_get_ThumbnailFormat(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ThumbnailFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoControl_put_ThumbnailFormat(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaThumbnailFormat>(arg);

            self->obj.ThumbnailFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoControl_get_ThumbnailEnabled(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ThumbnailEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoControl_put_ThumbnailEnabled(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ThumbnailEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoControl_get_DesiredThumbnailSize(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredThumbnailSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoControl_put_DesiredThumbnailSize(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DesiredThumbnailSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoControl_get_HardwareAcceleratedThumbnailSupported(py::wrapper::Windows::Media::Devices::LowLagPhotoControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareAcceleratedThumbnailSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LowLagPhotoControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::LowLagPhotoControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagPhotoControl[] = {
        { "get_current_frame_rate", reinterpret_cast<PyCFunction>(LowLagPhotoControl_GetCurrentFrameRate), METH_VARARGS, nullptr },
        { "get_highest_concurrent_frame_rate", reinterpret_cast<PyCFunction>(LowLagPhotoControl_GetHighestConcurrentFrameRate), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLagPhotoControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLagPhotoControl[] = {
        { "thumbnail_format", reinterpret_cast<getter>(LowLagPhotoControl_get_ThumbnailFormat), reinterpret_cast<setter>(LowLagPhotoControl_put_ThumbnailFormat), nullptr, nullptr },
        { "thumbnail_enabled", reinterpret_cast<getter>(LowLagPhotoControl_get_ThumbnailEnabled), reinterpret_cast<setter>(LowLagPhotoControl_put_ThumbnailEnabled), nullptr, nullptr },
        { "desired_thumbnail_size", reinterpret_cast<getter>(LowLagPhotoControl_get_DesiredThumbnailSize), reinterpret_cast<setter>(LowLagPhotoControl_put_DesiredThumbnailSize), nullptr, nullptr },
        { "hardware_accelerated_thumbnail_supported", reinterpret_cast<getter>(LowLagPhotoControl_get_HardwareAcceleratedThumbnailSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LowLagPhotoControl[] = 
    {
        { Py_tp_new, _new_LowLagPhotoControl },
        { Py_tp_dealloc, _dealloc_LowLagPhotoControl },
        { Py_tp_methods, _methods_LowLagPhotoControl },
        { Py_tp_getset, _getset_LowLagPhotoControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LowLagPhotoControl =
    {
        "_winsdk_Windows_Media_Devices.LowLagPhotoControl",
        sizeof(py::wrapper::Windows::Media::Devices::LowLagPhotoControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagPhotoControl
    };

    // ----- LowLagPhotoSequenceControl class --------------------
    constexpr const char* const _type_name_LowLagPhotoSequenceControl = "LowLagPhotoSequenceControl";

    static PyObject* _new_LowLagPhotoSequenceControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LowLagPhotoSequenceControl);
        return nullptr;
    }

    static void _dealloc_LowLagPhotoSequenceControl(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LowLagPhotoSequenceControl_GetCurrentFrameRate(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentFrameRate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_GetHighestConcurrentFrameRate(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 0);

                return py::convert(self->obj.GetHighestConcurrentFrameRate(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_ThumbnailFormat(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ThumbnailFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_ThumbnailFormat(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaThumbnailFormat>(arg);

            self->obj.ThumbnailFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_ThumbnailEnabled(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ThumbnailEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_ThumbnailEnabled(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ThumbnailEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_PhotosPerSecondLimit(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotosPerSecondLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_PhotosPerSecondLimit(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PhotosPerSecondLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_PastPhotoLimit(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PastPhotoLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_PastPhotoLimit(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.PastPhotoLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_DesiredThumbnailSize(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredThumbnailSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LowLagPhotoSequenceControl_put_DesiredThumbnailSize(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.DesiredThumbnailSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_HardwareAcceleratedThumbnailSupported(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardwareAcceleratedThumbnailSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_MaxPastPhotos(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPastPhotos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_MaxPhotosPerSecond(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPhotosPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LowLagPhotoSequenceControl_get_Supported(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LowLagPhotoSequenceControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::LowLagPhotoSequenceControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LowLagPhotoSequenceControl[] = {
        { "get_current_frame_rate", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceControl_GetCurrentFrameRate), METH_VARARGS, nullptr },
        { "get_highest_concurrent_frame_rate", reinterpret_cast<PyCFunction>(LowLagPhotoSequenceControl_GetHighestConcurrentFrameRate), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LowLagPhotoSequenceControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LowLagPhotoSequenceControl[] = {
        { "thumbnail_format", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_ThumbnailFormat), reinterpret_cast<setter>(LowLagPhotoSequenceControl_put_ThumbnailFormat), nullptr, nullptr },
        { "thumbnail_enabled", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_ThumbnailEnabled), reinterpret_cast<setter>(LowLagPhotoSequenceControl_put_ThumbnailEnabled), nullptr, nullptr },
        { "photos_per_second_limit", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_PhotosPerSecondLimit), reinterpret_cast<setter>(LowLagPhotoSequenceControl_put_PhotosPerSecondLimit), nullptr, nullptr },
        { "past_photo_limit", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_PastPhotoLimit), reinterpret_cast<setter>(LowLagPhotoSequenceControl_put_PastPhotoLimit), nullptr, nullptr },
        { "desired_thumbnail_size", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_DesiredThumbnailSize), reinterpret_cast<setter>(LowLagPhotoSequenceControl_put_DesiredThumbnailSize), nullptr, nullptr },
        { "hardware_accelerated_thumbnail_supported", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_HardwareAcceleratedThumbnailSupported), nullptr, nullptr, nullptr },
        { "max_past_photos", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_MaxPastPhotos), nullptr, nullptr, nullptr },
        { "max_photos_per_second", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_MaxPhotosPerSecond), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(LowLagPhotoSequenceControl_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LowLagPhotoSequenceControl[] = 
    {
        { Py_tp_new, _new_LowLagPhotoSequenceControl },
        { Py_tp_dealloc, _dealloc_LowLagPhotoSequenceControl },
        { Py_tp_methods, _methods_LowLagPhotoSequenceControl },
        { Py_tp_getset, _getset_LowLagPhotoSequenceControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LowLagPhotoSequenceControl =
    {
        "_winsdk_Windows_Media_Devices.LowLagPhotoSequenceControl",
        sizeof(py::wrapper::Windows::Media::Devices::LowLagPhotoSequenceControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LowLagPhotoSequenceControl
    };

    // ----- MediaDevice class --------------------
    constexpr const char* const _type_name_MediaDevice = "MediaDevice";

    static PyObject* _new_MediaDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaDevice);
        return nullptr;
    }

    static PyObject* MediaDevice_GetAudioCaptureSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetAudioCaptureSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_GetAudioRenderSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetAudioRenderSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_GetDefaultAudioCaptureId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 0);

                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetDefaultAudioCaptureId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_GetDefaultAudioRenderId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::AudioDeviceRole>(args, 0);

                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetDefaultAudioRenderId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_GetVideoCaptureSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::Devices::MediaDevice::GetVideoCaptureSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDevice_add_DefaultAudioCaptureDeviceChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs>>(arg);

            return py::convert(winrt::Windows::Media::Devices::MediaDevice::DefaultAudioCaptureDeviceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDevice_remove_DefaultAudioCaptureDeviceChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::Devices::MediaDevice::DefaultAudioCaptureDeviceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDevice_add_DefaultAudioRenderDeviceChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Foundation::IInspectable, winrt::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs>>(arg);

            return py::convert(winrt::Windows::Media::Devices::MediaDevice::DefaultAudioRenderDeviceChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDevice_remove_DefaultAudioRenderDeviceChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Media::Devices::MediaDevice::DefaultAudioRenderDeviceChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaDevice[] = {
        { "get_audio_capture_selector", reinterpret_cast<PyCFunction>(MediaDevice_GetAudioCaptureSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_audio_render_selector", reinterpret_cast<PyCFunction>(MediaDevice_GetAudioRenderSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_audio_capture_id", reinterpret_cast<PyCFunction>(MediaDevice_GetDefaultAudioCaptureId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_default_audio_render_id", reinterpret_cast<PyCFunction>(MediaDevice_GetDefaultAudioRenderId), METH_VARARGS | METH_STATIC, nullptr },
        { "get_video_capture_selector", reinterpret_cast<PyCFunction>(MediaDevice_GetVideoCaptureSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "add_default_audio_capture_device_changed", reinterpret_cast<PyCFunction>(MediaDevice_add_DefaultAudioCaptureDeviceChanged), METH_O | METH_STATIC, nullptr },
        { "remove_default_audio_capture_device_changed", reinterpret_cast<PyCFunction>(MediaDevice_remove_DefaultAudioCaptureDeviceChanged), METH_O | METH_STATIC, nullptr },
        { "add_default_audio_render_device_changed", reinterpret_cast<PyCFunction>(MediaDevice_add_DefaultAudioRenderDeviceChanged), METH_O | METH_STATIC, nullptr },
        { "remove_default_audio_render_device_changed", reinterpret_cast<PyCFunction>(MediaDevice_remove_DefaultAudioRenderDeviceChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaDevice[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaDevice[] = 
    {
        { Py_tp_new, _new_MediaDevice },
        { Py_tp_methods, _methods_MediaDevice },
        { Py_tp_getset, _getset_MediaDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaDevice =
    {
        "_winsdk_Windows_Media_Devices.MediaDevice",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaDevice
    };

    // ----- MediaDeviceControl class --------------------
    constexpr const char* const _type_name_MediaDeviceControl = "MediaDeviceControl";

    static PyObject* _new_MediaDeviceControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaDeviceControl);
        return nullptr;
    }

    static void _dealloc_MediaDeviceControl(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaDeviceControl_TryGetAuto(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                bool param0 {  };

                auto return_value = self->obj.TryGetAuto(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControl_TryGetValue(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                double param0 {  };

                auto return_value = self->obj.TryGetValue(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControl_TrySetAuto(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<bool>(args, 0);

                return py::convert(self->obj.TrySetAuto(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControl_TrySetValue(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<double>(args, 0);

                return py::convert(self->obj.TrySetValue(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControl_get_Capabilities(py::wrapper::Windows::Media::Devices::MediaDeviceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Capabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaDeviceControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::MediaDeviceControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaDeviceControl[] = {
        { "try_get_auto", reinterpret_cast<PyCFunction>(MediaDeviceControl_TryGetAuto), METH_VARARGS, nullptr },
        { "try_get_value", reinterpret_cast<PyCFunction>(MediaDeviceControl_TryGetValue), METH_VARARGS, nullptr },
        { "try_set_auto", reinterpret_cast<PyCFunction>(MediaDeviceControl_TrySetAuto), METH_VARARGS, nullptr },
        { "try_set_value", reinterpret_cast<PyCFunction>(MediaDeviceControl_TrySetValue), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaDeviceControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaDeviceControl[] = {
        { "capabilities", reinterpret_cast<getter>(MediaDeviceControl_get_Capabilities), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaDeviceControl[] = 
    {
        { Py_tp_new, _new_MediaDeviceControl },
        { Py_tp_dealloc, _dealloc_MediaDeviceControl },
        { Py_tp_methods, _methods_MediaDeviceControl },
        { Py_tp_getset, _getset_MediaDeviceControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaDeviceControl =
    {
        "_winsdk_Windows_Media_Devices.MediaDeviceControl",
        sizeof(py::wrapper::Windows::Media::Devices::MediaDeviceControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaDeviceControl
    };

    // ----- MediaDeviceControlCapabilities class --------------------
    constexpr const char* const _type_name_MediaDeviceControlCapabilities = "MediaDeviceControlCapabilities";

    static PyObject* _new_MediaDeviceControlCapabilities(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_MediaDeviceControlCapabilities);
        return nullptr;
    }

    static void _dealloc_MediaDeviceControlCapabilities(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* MediaDeviceControlCapabilities_get_AutoModeSupported(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoModeSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Default(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Default());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Max(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Min(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Step(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaDeviceControlCapabilities_get_Supported(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaDeviceControlCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::MediaDeviceControlCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaDeviceControlCapabilities[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaDeviceControlCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaDeviceControlCapabilities[] = {
        { "auto_mode_supported", reinterpret_cast<getter>(MediaDeviceControlCapabilities_get_AutoModeSupported), nullptr, nullptr, nullptr },
        { "default", reinterpret_cast<getter>(MediaDeviceControlCapabilities_get_Default), nullptr, nullptr, nullptr },
        { "max", reinterpret_cast<getter>(MediaDeviceControlCapabilities_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(MediaDeviceControlCapabilities_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(MediaDeviceControlCapabilities_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(MediaDeviceControlCapabilities_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaDeviceControlCapabilities[] = 
    {
        { Py_tp_new, _new_MediaDeviceControlCapabilities },
        { Py_tp_dealloc, _dealloc_MediaDeviceControlCapabilities },
        { Py_tp_methods, _methods_MediaDeviceControlCapabilities },
        { Py_tp_getset, _getset_MediaDeviceControlCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_MediaDeviceControlCapabilities =
    {
        "_winsdk_Windows_Media_Devices.MediaDeviceControlCapabilities",
        sizeof(py::wrapper::Windows::Media::Devices::MediaDeviceControlCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaDeviceControlCapabilities
    };

    // ----- ModuleCommandResult class --------------------
    constexpr const char* const _type_name_ModuleCommandResult = "ModuleCommandResult";

    static PyObject* _new_ModuleCommandResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ModuleCommandResult);
        return nullptr;
    }

    static void _dealloc_ModuleCommandResult(py::wrapper::Windows::Media::Devices::ModuleCommandResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ModuleCommandResult_get_Result(py::wrapper::Windows::Media::Devices::ModuleCommandResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ModuleCommandResult_get_Status(py::wrapper::Windows::Media::Devices::ModuleCommandResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ModuleCommandResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ModuleCommandResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ModuleCommandResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ModuleCommandResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ModuleCommandResult[] = {
        { "result", reinterpret_cast<getter>(ModuleCommandResult_get_Result), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(ModuleCommandResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ModuleCommandResult[] = 
    {
        { Py_tp_new, _new_ModuleCommandResult },
        { Py_tp_dealloc, _dealloc_ModuleCommandResult },
        { Py_tp_methods, _methods_ModuleCommandResult },
        { Py_tp_getset, _getset_ModuleCommandResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ModuleCommandResult =
    {
        "_winsdk_Windows_Media_Devices.ModuleCommandResult",
        sizeof(py::wrapper::Windows::Media::Devices::ModuleCommandResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ModuleCommandResult
    };

    // ----- OpticalImageStabilizationControl class --------------------
    constexpr const char* const _type_name_OpticalImageStabilizationControl = "OpticalImageStabilizationControl";

    static PyObject* _new_OpticalImageStabilizationControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_OpticalImageStabilizationControl);
        return nullptr;
    }

    static void _dealloc_OpticalImageStabilizationControl(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* OpticalImageStabilizationControl_get_Mode(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int OpticalImageStabilizationControl_put_Mode(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::OpticalImageStabilizationMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* OpticalImageStabilizationControl_get_Supported(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* OpticalImageStabilizationControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_OpticalImageStabilizationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::OpticalImageStabilizationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_OpticalImageStabilizationControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_OpticalImageStabilizationControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_OpticalImageStabilizationControl[] = {
        { "mode", reinterpret_cast<getter>(OpticalImageStabilizationControl_get_Mode), reinterpret_cast<setter>(OpticalImageStabilizationControl_put_Mode), nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(OpticalImageStabilizationControl_get_Supported), nullptr, nullptr, nullptr },
        { "supported_modes", reinterpret_cast<getter>(OpticalImageStabilizationControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_OpticalImageStabilizationControl[] = 
    {
        { Py_tp_new, _new_OpticalImageStabilizationControl },
        { Py_tp_dealloc, _dealloc_OpticalImageStabilizationControl },
        { Py_tp_methods, _methods_OpticalImageStabilizationControl },
        { Py_tp_getset, _getset_OpticalImageStabilizationControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_OpticalImageStabilizationControl =
    {
        "_winsdk_Windows_Media_Devices.OpticalImageStabilizationControl",
        sizeof(py::wrapper::Windows::Media::Devices::OpticalImageStabilizationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_OpticalImageStabilizationControl
    };

    // ----- PanelBasedOptimizationControl class --------------------
    constexpr const char* const _type_name_PanelBasedOptimizationControl = "PanelBasedOptimizationControl";

    static PyObject* _new_PanelBasedOptimizationControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PanelBasedOptimizationControl);
        return nullptr;
    }

    static void _dealloc_PanelBasedOptimizationControl(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PanelBasedOptimizationControl_get_Panel(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Panel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PanelBasedOptimizationControl_put_Panel(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::Panel>(arg);

            self->obj.Panel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PanelBasedOptimizationControl_get_IsSupported(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PanelBasedOptimizationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::PanelBasedOptimizationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PanelBasedOptimizationControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PanelBasedOptimizationControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PanelBasedOptimizationControl[] = {
        { "panel", reinterpret_cast<getter>(PanelBasedOptimizationControl_get_Panel), reinterpret_cast<setter>(PanelBasedOptimizationControl_put_Panel), nullptr, nullptr },
        { "is_supported", reinterpret_cast<getter>(PanelBasedOptimizationControl_get_IsSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PanelBasedOptimizationControl[] = 
    {
        { Py_tp_new, _new_PanelBasedOptimizationControl },
        { Py_tp_dealloc, _dealloc_PanelBasedOptimizationControl },
        { Py_tp_methods, _methods_PanelBasedOptimizationControl },
        { Py_tp_getset, _getset_PanelBasedOptimizationControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PanelBasedOptimizationControl =
    {
        "_winsdk_Windows_Media_Devices.PanelBasedOptimizationControl",
        sizeof(py::wrapper::Windows::Media::Devices::PanelBasedOptimizationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PanelBasedOptimizationControl
    };

    // ----- PhotoConfirmationControl class --------------------
    constexpr const char* const _type_name_PhotoConfirmationControl = "PhotoConfirmationControl";

    static PyObject* _new_PhotoConfirmationControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PhotoConfirmationControl);
        return nullptr;
    }

    static void _dealloc_PhotoConfirmationControl(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PhotoConfirmationControl_get_PixelFormat(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoConfirmationControl_put_PixelFormat(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaPixelFormat>(arg);

            self->obj.PixelFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoConfirmationControl_get_Enabled(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int PhotoConfirmationControl_put_Enabled(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* PhotoConfirmationControl_get_Supported(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhotoConfirmationControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::PhotoConfirmationControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhotoConfirmationControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PhotoConfirmationControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhotoConfirmationControl[] = {
        { "pixel_format", reinterpret_cast<getter>(PhotoConfirmationControl_get_PixelFormat), reinterpret_cast<setter>(PhotoConfirmationControl_put_PixelFormat), nullptr, nullptr },
        { "enabled", reinterpret_cast<getter>(PhotoConfirmationControl_get_Enabled), reinterpret_cast<setter>(PhotoConfirmationControl_put_Enabled), nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(PhotoConfirmationControl_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhotoConfirmationControl[] = 
    {
        { Py_tp_new, _new_PhotoConfirmationControl },
        { Py_tp_dealloc, _dealloc_PhotoConfirmationControl },
        { Py_tp_methods, _methods_PhotoConfirmationControl },
        { Py_tp_getset, _getset_PhotoConfirmationControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PhotoConfirmationControl =
    {
        "_winsdk_Windows_Media_Devices.PhotoConfirmationControl",
        sizeof(py::wrapper::Windows::Media::Devices::PhotoConfirmationControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhotoConfirmationControl
    };

    // ----- RegionOfInterest class --------------------
    constexpr const char* const _type_name_RegionOfInterest = "RegionOfInterest";

    static PyObject* _new_RegionOfInterest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::RegionOfInterest instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RegionOfInterest(py::wrapper::Windows::Media::Devices::RegionOfInterest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RegionOfInterest_get_Bounds(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bounds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_Bounds(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.Bounds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_AutoWhiteBalanceEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoWhiteBalanceEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_AutoWhiteBalanceEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoWhiteBalanceEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_AutoFocusEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoFocusEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_AutoFocusEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoFocusEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_AutoExposureEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoExposureEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_AutoExposureEnabled(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoExposureEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_Weight(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Weight());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_Weight(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Weight(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_Type(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_Type(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::RegionOfInterestType>(arg);

            self->obj.Type(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegionOfInterest_get_BoundsNormalized(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BoundsNormalized());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegionOfInterest_put_BoundsNormalized(py::wrapper::Windows::Media::Devices::RegionOfInterest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.BoundsNormalized(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_RegionOfInterest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::RegionOfInterest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RegionOfInterest[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_RegionOfInterest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RegionOfInterest[] = {
        { "bounds", reinterpret_cast<getter>(RegionOfInterest_get_Bounds), reinterpret_cast<setter>(RegionOfInterest_put_Bounds), nullptr, nullptr },
        { "auto_white_balance_enabled", reinterpret_cast<getter>(RegionOfInterest_get_AutoWhiteBalanceEnabled), reinterpret_cast<setter>(RegionOfInterest_put_AutoWhiteBalanceEnabled), nullptr, nullptr },
        { "auto_focus_enabled", reinterpret_cast<getter>(RegionOfInterest_get_AutoFocusEnabled), reinterpret_cast<setter>(RegionOfInterest_put_AutoFocusEnabled), nullptr, nullptr },
        { "auto_exposure_enabled", reinterpret_cast<getter>(RegionOfInterest_get_AutoExposureEnabled), reinterpret_cast<setter>(RegionOfInterest_put_AutoExposureEnabled), nullptr, nullptr },
        { "weight", reinterpret_cast<getter>(RegionOfInterest_get_Weight), reinterpret_cast<setter>(RegionOfInterest_put_Weight), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(RegionOfInterest_get_Type), reinterpret_cast<setter>(RegionOfInterest_put_Type), nullptr, nullptr },
        { "bounds_normalized", reinterpret_cast<getter>(RegionOfInterest_get_BoundsNormalized), reinterpret_cast<setter>(RegionOfInterest_put_BoundsNormalized), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RegionOfInterest[] = 
    {
        { Py_tp_new, _new_RegionOfInterest },
        { Py_tp_dealloc, _dealloc_RegionOfInterest },
        { Py_tp_methods, _methods_RegionOfInterest },
        { Py_tp_getset, _getset_RegionOfInterest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RegionOfInterest =
    {
        "_winsdk_Windows_Media_Devices.RegionOfInterest",
        sizeof(py::wrapper::Windows::Media::Devices::RegionOfInterest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RegionOfInterest
    };

    // ----- RegionsOfInterestControl class --------------------
    constexpr const char* const _type_name_RegionsOfInterestControl = "RegionsOfInterestControl";

    static PyObject* _new_RegionsOfInterestControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_RegionsOfInterestControl);
        return nullptr;
    }

    static void _dealloc_RegionsOfInterestControl(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RegionsOfInterestControl_ClearRegionsAsync(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearRegionsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_SetRegionsAsync(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Devices::RegionOfInterest>>(args, 0);

                return py::convert(self->obj.SetRegionsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Devices::RegionOfInterest>>(args, 0);
                auto param1 = py::convert_to<bool>(args, 1);

                return py::convert(self->obj.SetRegionsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_get_AutoExposureSupported(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoExposureSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_get_AutoFocusSupported(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoFocusSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_get_AutoWhiteBalanceSupported(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoWhiteBalanceSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegionsOfInterestControl_get_MaxRegions(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxRegions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RegionsOfInterestControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::RegionsOfInterestControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RegionsOfInterestControl[] = {
        { "clear_regions_async", reinterpret_cast<PyCFunction>(RegionsOfInterestControl_ClearRegionsAsync), METH_VARARGS, nullptr },
        { "set_regions_async", reinterpret_cast<PyCFunction>(RegionsOfInterestControl_SetRegionsAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_RegionsOfInterestControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RegionsOfInterestControl[] = {
        { "auto_exposure_supported", reinterpret_cast<getter>(RegionsOfInterestControl_get_AutoExposureSupported), nullptr, nullptr, nullptr },
        { "auto_focus_supported", reinterpret_cast<getter>(RegionsOfInterestControl_get_AutoFocusSupported), nullptr, nullptr, nullptr },
        { "auto_white_balance_supported", reinterpret_cast<getter>(RegionsOfInterestControl_get_AutoWhiteBalanceSupported), nullptr, nullptr, nullptr },
        { "max_regions", reinterpret_cast<getter>(RegionsOfInterestControl_get_MaxRegions), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RegionsOfInterestControl[] = 
    {
        { Py_tp_new, _new_RegionsOfInterestControl },
        { Py_tp_dealloc, _dealloc_RegionsOfInterestControl },
        { Py_tp_methods, _methods_RegionsOfInterestControl },
        { Py_tp_getset, _getset_RegionsOfInterestControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RegionsOfInterestControl =
    {
        "_winsdk_Windows_Media_Devices.RegionsOfInterestControl",
        sizeof(py::wrapper::Windows::Media::Devices::RegionsOfInterestControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RegionsOfInterestControl
    };

    // ----- SceneModeControl class --------------------
    constexpr const char* const _type_name_SceneModeControl = "SceneModeControl";

    static PyObject* _new_SceneModeControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SceneModeControl);
        return nullptr;
    }

    static void _dealloc_SceneModeControl(py::wrapper::Windows::Media::Devices::SceneModeControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SceneModeControl_SetValueAsync(py::wrapper::Windows::Media::Devices::SceneModeControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::CaptureSceneMode>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SceneModeControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::SceneModeControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SceneModeControl_get_Value(py::wrapper::Windows::Media::Devices::SceneModeControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SceneModeControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::SceneModeControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SceneModeControl[] = {
        { "set_value_async", reinterpret_cast<PyCFunction>(SceneModeControl_SetValueAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SceneModeControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SceneModeControl[] = {
        { "supported_modes", reinterpret_cast<getter>(SceneModeControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(SceneModeControl_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SceneModeControl[] = 
    {
        { Py_tp_new, _new_SceneModeControl },
        { Py_tp_dealloc, _dealloc_SceneModeControl },
        { Py_tp_methods, _methods_SceneModeControl },
        { Py_tp_getset, _getset_SceneModeControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SceneModeControl =
    {
        "_winsdk_Windows_Media_Devices.SceneModeControl",
        sizeof(py::wrapper::Windows::Media::Devices::SceneModeControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SceneModeControl
    };

    // ----- TorchControl class --------------------
    constexpr const char* const _type_name_TorchControl = "TorchControl";

    static PyObject* _new_TorchControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_TorchControl);
        return nullptr;
    }

    static void _dealloc_TorchControl(py::wrapper::Windows::Media::Devices::TorchControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* TorchControl_get_PowerPercent(py::wrapper::Windows::Media::Devices::TorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerPercent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TorchControl_put_PowerPercent(py::wrapper::Windows::Media::Devices::TorchControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.PowerPercent(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TorchControl_get_Enabled(py::wrapper::Windows::Media::Devices::TorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Enabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TorchControl_put_Enabled(py::wrapper::Windows::Media::Devices::TorchControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Enabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TorchControl_get_PowerSupported(py::wrapper::Windows::Media::Devices::TorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PowerSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TorchControl_get_Supported(py::wrapper::Windows::Media::Devices::TorchControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TorchControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::TorchControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TorchControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TorchControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TorchControl[] = {
        { "power_percent", reinterpret_cast<getter>(TorchControl_get_PowerPercent), reinterpret_cast<setter>(TorchControl_put_PowerPercent), nullptr, nullptr },
        { "enabled", reinterpret_cast<getter>(TorchControl_get_Enabled), reinterpret_cast<setter>(TorchControl_put_Enabled), nullptr, nullptr },
        { "power_supported", reinterpret_cast<getter>(TorchControl_get_PowerSupported), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(TorchControl_get_Supported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TorchControl[] = 
    {
        { Py_tp_new, _new_TorchControl },
        { Py_tp_dealloc, _dealloc_TorchControl },
        { Py_tp_methods, _methods_TorchControl },
        { Py_tp_getset, _getset_TorchControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_TorchControl =
    {
        "_winsdk_Windows_Media_Devices.TorchControl",
        sizeof(py::wrapper::Windows::Media::Devices::TorchControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TorchControl
    };

    // ----- VideoDeviceController class --------------------
    constexpr const char* const _type_name_VideoDeviceController = "VideoDeviceController";

    static PyObject* _new_VideoDeviceController(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoDeviceController);
        return nullptr;
    }

    static void _dealloc_VideoDeviceController(py::wrapper::Windows::Media::Devices::VideoDeviceController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoDeviceController_GetAvailableMediaStreamProperties(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetAvailableMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_GetDeviceProperty(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetDeviceProperty(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_GetDevicePropertyByExtendedId(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(args, 1);

                return py::convert(self->obj.GetDevicePropertyByExtendedId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_GetDevicePropertyById(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IReference<uint32_t>>(args, 1);

                return py::convert(self->obj.GetDevicePropertyById(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_GetMediaStreamProperties(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_SetDeviceProperty(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                self->obj.SetDeviceProperty(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_SetDevicePropertyByExtendedId(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<uint8_t>>(args, 1);

                return py::convert(self->obj.SetDevicePropertyByExtendedId(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_SetDevicePropertyById(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.SetDevicePropertyById(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_SetMediaStreamPropertiesAsync(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 1);

                return py::convert(self->obj.SetMediaStreamPropertiesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_TryGetPowerlineFrequency(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Capture::PowerlineFrequency param0 {  };

                auto return_value = self->obj.TryGetPowerlineFrequency(param0);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out0.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_TrySetPowerlineFrequency(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::PowerlineFrequency>(args, 0);

                return py::convert(self->obj.TrySetPowerlineFrequency(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_CameraOcclusionInfo(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CameraOcclusionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_PrimaryUse(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrimaryUse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoDeviceController_put_PrimaryUse(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::CaptureUse>(arg);

            self->obj.PrimaryUse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoDeviceController_get_FocusControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FocusControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_IsoSpeedControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsoSpeedControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_LowLagPhoto(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LowLagPhoto());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_WhiteBalanceControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WhiteBalanceControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_TorchControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TorchControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_SceneModeControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SceneModeControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_RegionsOfInterestControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RegionsOfInterestControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_FlashControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FlashControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_LowLagPhotoSequence(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LowLagPhotoSequence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_ExposureCompensationControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExposureCompensationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_ExposureControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExposureControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_ZoomControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZoomControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_PhotoConfirmationControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhotoConfirmationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_VariablePhotoSequenceController(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VariablePhotoSequenceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_DesiredOptimization(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DesiredOptimization());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoDeviceController_put_DesiredOptimization(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::MediaCaptureOptimization>(arg);

            self->obj.DesiredOptimization(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoDeviceController_get_AdvancedPhotoControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdvancedPhotoControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_ExposurePriorityVideoControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExposurePriorityVideoControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_HdrVideoControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HdrVideoControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_OpticalImageStabilizationControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OpticalImageStabilizationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Id(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_VideoTemporalDenoisingControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoTemporalDenoisingControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_InfraredTorchControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InfraredTorchControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_PanelBasedOptimizationControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PanelBasedOptimizationControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_DigitalWindowControl(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DigitalWindowControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Hue(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Hue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Zoom(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Zoom());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Contrast(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contrast());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_WhiteBalance(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WhiteBalance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_BacklightCompensation(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BacklightCompensation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Brightness(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Brightness());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Exposure(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Exposure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Tilt(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tilt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Roll(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Roll());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Pan(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pan());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceController_get_Focus(py::wrapper::Windows::Media::Devices::VideoDeviceController* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Focus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoDeviceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::VideoDeviceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoDeviceController[] = {
        { "get_available_media_stream_properties", reinterpret_cast<PyCFunction>(VideoDeviceController_GetAvailableMediaStreamProperties), METH_VARARGS, nullptr },
        { "get_device_property", reinterpret_cast<PyCFunction>(VideoDeviceController_GetDeviceProperty), METH_VARARGS, nullptr },
        { "get_device_property_by_extended_id", reinterpret_cast<PyCFunction>(VideoDeviceController_GetDevicePropertyByExtendedId), METH_VARARGS, nullptr },
        { "get_device_property_by_id", reinterpret_cast<PyCFunction>(VideoDeviceController_GetDevicePropertyById), METH_VARARGS, nullptr },
        { "get_media_stream_properties", reinterpret_cast<PyCFunction>(VideoDeviceController_GetMediaStreamProperties), METH_VARARGS, nullptr },
        { "set_device_property", reinterpret_cast<PyCFunction>(VideoDeviceController_SetDeviceProperty), METH_VARARGS, nullptr },
        { "set_device_property_by_extended_id", reinterpret_cast<PyCFunction>(VideoDeviceController_SetDevicePropertyByExtendedId), METH_VARARGS, nullptr },
        { "set_device_property_by_id", reinterpret_cast<PyCFunction>(VideoDeviceController_SetDevicePropertyById), METH_VARARGS, nullptr },
        { "set_media_stream_properties_async", reinterpret_cast<PyCFunction>(VideoDeviceController_SetMediaStreamPropertiesAsync), METH_VARARGS, nullptr },
        { "try_get_powerline_frequency", reinterpret_cast<PyCFunction>(VideoDeviceController_TryGetPowerlineFrequency), METH_VARARGS, nullptr },
        { "try_set_powerline_frequency", reinterpret_cast<PyCFunction>(VideoDeviceController_TrySetPowerlineFrequency), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoDeviceController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoDeviceController[] = {
        { "camera_occlusion_info", reinterpret_cast<getter>(VideoDeviceController_get_CameraOcclusionInfo), nullptr, nullptr, nullptr },
        { "primary_use", reinterpret_cast<getter>(VideoDeviceController_get_PrimaryUse), reinterpret_cast<setter>(VideoDeviceController_put_PrimaryUse), nullptr, nullptr },
        { "focus_control", reinterpret_cast<getter>(VideoDeviceController_get_FocusControl), nullptr, nullptr, nullptr },
        { "iso_speed_control", reinterpret_cast<getter>(VideoDeviceController_get_IsoSpeedControl), nullptr, nullptr, nullptr },
        { "low_lag_photo", reinterpret_cast<getter>(VideoDeviceController_get_LowLagPhoto), nullptr, nullptr, nullptr },
        { "white_balance_control", reinterpret_cast<getter>(VideoDeviceController_get_WhiteBalanceControl), nullptr, nullptr, nullptr },
        { "torch_control", reinterpret_cast<getter>(VideoDeviceController_get_TorchControl), nullptr, nullptr, nullptr },
        { "scene_mode_control", reinterpret_cast<getter>(VideoDeviceController_get_SceneModeControl), nullptr, nullptr, nullptr },
        { "regions_of_interest_control", reinterpret_cast<getter>(VideoDeviceController_get_RegionsOfInterestControl), nullptr, nullptr, nullptr },
        { "flash_control", reinterpret_cast<getter>(VideoDeviceController_get_FlashControl), nullptr, nullptr, nullptr },
        { "low_lag_photo_sequence", reinterpret_cast<getter>(VideoDeviceController_get_LowLagPhotoSequence), nullptr, nullptr, nullptr },
        { "exposure_compensation_control", reinterpret_cast<getter>(VideoDeviceController_get_ExposureCompensationControl), nullptr, nullptr, nullptr },
        { "exposure_control", reinterpret_cast<getter>(VideoDeviceController_get_ExposureControl), nullptr, nullptr, nullptr },
        { "zoom_control", reinterpret_cast<getter>(VideoDeviceController_get_ZoomControl), nullptr, nullptr, nullptr },
        { "photo_confirmation_control", reinterpret_cast<getter>(VideoDeviceController_get_PhotoConfirmationControl), nullptr, nullptr, nullptr },
        { "variable_photo_sequence_controller", reinterpret_cast<getter>(VideoDeviceController_get_VariablePhotoSequenceController), nullptr, nullptr, nullptr },
        { "desired_optimization", reinterpret_cast<getter>(VideoDeviceController_get_DesiredOptimization), reinterpret_cast<setter>(VideoDeviceController_put_DesiredOptimization), nullptr, nullptr },
        { "advanced_photo_control", reinterpret_cast<getter>(VideoDeviceController_get_AdvancedPhotoControl), nullptr, nullptr, nullptr },
        { "exposure_priority_video_control", reinterpret_cast<getter>(VideoDeviceController_get_ExposurePriorityVideoControl), nullptr, nullptr, nullptr },
        { "hdr_video_control", reinterpret_cast<getter>(VideoDeviceController_get_HdrVideoControl), nullptr, nullptr, nullptr },
        { "optical_image_stabilization_control", reinterpret_cast<getter>(VideoDeviceController_get_OpticalImageStabilizationControl), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(VideoDeviceController_get_Id), nullptr, nullptr, nullptr },
        { "video_temporal_denoising_control", reinterpret_cast<getter>(VideoDeviceController_get_VideoTemporalDenoisingControl), nullptr, nullptr, nullptr },
        { "infrared_torch_control", reinterpret_cast<getter>(VideoDeviceController_get_InfraredTorchControl), nullptr, nullptr, nullptr },
        { "panel_based_optimization_control", reinterpret_cast<getter>(VideoDeviceController_get_PanelBasedOptimizationControl), nullptr, nullptr, nullptr },
        { "digital_window_control", reinterpret_cast<getter>(VideoDeviceController_get_DigitalWindowControl), nullptr, nullptr, nullptr },
        { "hue", reinterpret_cast<getter>(VideoDeviceController_get_Hue), nullptr, nullptr, nullptr },
        { "zoom", reinterpret_cast<getter>(VideoDeviceController_get_Zoom), nullptr, nullptr, nullptr },
        { "contrast", reinterpret_cast<getter>(VideoDeviceController_get_Contrast), nullptr, nullptr, nullptr },
        { "white_balance", reinterpret_cast<getter>(VideoDeviceController_get_WhiteBalance), nullptr, nullptr, nullptr },
        { "backlight_compensation", reinterpret_cast<getter>(VideoDeviceController_get_BacklightCompensation), nullptr, nullptr, nullptr },
        { "brightness", reinterpret_cast<getter>(VideoDeviceController_get_Brightness), nullptr, nullptr, nullptr },
        { "exposure", reinterpret_cast<getter>(VideoDeviceController_get_Exposure), nullptr, nullptr, nullptr },
        { "tilt", reinterpret_cast<getter>(VideoDeviceController_get_Tilt), nullptr, nullptr, nullptr },
        { "roll", reinterpret_cast<getter>(VideoDeviceController_get_Roll), nullptr, nullptr, nullptr },
        { "pan", reinterpret_cast<getter>(VideoDeviceController_get_Pan), nullptr, nullptr, nullptr },
        { "focus", reinterpret_cast<getter>(VideoDeviceController_get_Focus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoDeviceController[] = 
    {
        { Py_tp_new, _new_VideoDeviceController },
        { Py_tp_dealloc, _dealloc_VideoDeviceController },
        { Py_tp_methods, _methods_VideoDeviceController },
        { Py_tp_getset, _getset_VideoDeviceController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoDeviceController =
    {
        "_winsdk_Windows_Media_Devices.VideoDeviceController",
        sizeof(py::wrapper::Windows::Media::Devices::VideoDeviceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoDeviceController
    };

    // ----- VideoDeviceControllerGetDevicePropertyResult class --------------------
    constexpr const char* const _type_name_VideoDeviceControllerGetDevicePropertyResult = "VideoDeviceControllerGetDevicePropertyResult";

    static PyObject* _new_VideoDeviceControllerGetDevicePropertyResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoDeviceControllerGetDevicePropertyResult);
        return nullptr;
    }

    static void _dealloc_VideoDeviceControllerGetDevicePropertyResult(py::wrapper::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoDeviceControllerGetDevicePropertyResult_get_Status(py::wrapper::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoDeviceControllerGetDevicePropertyResult_get_Value(py::wrapper::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoDeviceControllerGetDevicePropertyResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoDeviceControllerGetDevicePropertyResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoDeviceControllerGetDevicePropertyResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoDeviceControllerGetDevicePropertyResult[] = {
        { "status", reinterpret_cast<getter>(VideoDeviceControllerGetDevicePropertyResult_get_Status), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(VideoDeviceControllerGetDevicePropertyResult_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoDeviceControllerGetDevicePropertyResult[] = 
    {
        { Py_tp_new, _new_VideoDeviceControllerGetDevicePropertyResult },
        { Py_tp_dealloc, _dealloc_VideoDeviceControllerGetDevicePropertyResult },
        { Py_tp_methods, _methods_VideoDeviceControllerGetDevicePropertyResult },
        { Py_tp_getset, _getset_VideoDeviceControllerGetDevicePropertyResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoDeviceControllerGetDevicePropertyResult =
    {
        "_winsdk_Windows_Media_Devices.VideoDeviceControllerGetDevicePropertyResult",
        sizeof(py::wrapper::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoDeviceControllerGetDevicePropertyResult
    };

    // ----- VideoTemporalDenoisingControl class --------------------
    constexpr const char* const _type_name_VideoTemporalDenoisingControl = "VideoTemporalDenoisingControl";

    static PyObject* _new_VideoTemporalDenoisingControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoTemporalDenoisingControl);
        return nullptr;
    }

    static void _dealloc_VideoTemporalDenoisingControl(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoTemporalDenoisingControl_get_Mode(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTemporalDenoisingControl_put_Mode(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::VideoTemporalDenoisingMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTemporalDenoisingControl_get_Supported(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTemporalDenoisingControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoTemporalDenoisingControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::VideoTemporalDenoisingControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTemporalDenoisingControl[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTemporalDenoisingControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTemporalDenoisingControl[] = {
        { "mode", reinterpret_cast<getter>(VideoTemporalDenoisingControl_get_Mode), reinterpret_cast<setter>(VideoTemporalDenoisingControl_put_Mode), nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(VideoTemporalDenoisingControl_get_Supported), nullptr, nullptr, nullptr },
        { "supported_modes", reinterpret_cast<getter>(VideoTemporalDenoisingControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTemporalDenoisingControl[] = 
    {
        { Py_tp_new, _new_VideoTemporalDenoisingControl },
        { Py_tp_dealloc, _dealloc_VideoTemporalDenoisingControl },
        { Py_tp_methods, _methods_VideoTemporalDenoisingControl },
        { Py_tp_getset, _getset_VideoTemporalDenoisingControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoTemporalDenoisingControl =
    {
        "_winsdk_Windows_Media_Devices.VideoTemporalDenoisingControl",
        sizeof(py::wrapper::Windows::Media::Devices::VideoTemporalDenoisingControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTemporalDenoisingControl
    };

    // ----- WhiteBalanceControl class --------------------
    constexpr const char* const _type_name_WhiteBalanceControl = "WhiteBalanceControl";

    static PyObject* _new_WhiteBalanceControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_WhiteBalanceControl);
        return nullptr;
    }

    static void _dealloc_WhiteBalanceControl(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WhiteBalanceControl_SetPresetAsync(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::ColorTemperaturePreset>(args, 0);

                return py::convert(self->obj.SetPresetAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_SetValueAsync(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.SetValueAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Max(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Min(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Preset(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Preset());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Step(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Supported(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WhiteBalanceControl_get_Value(py::wrapper::Windows::Media::Devices::WhiteBalanceControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WhiteBalanceControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::WhiteBalanceControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WhiteBalanceControl[] = {
        { "set_preset_async", reinterpret_cast<PyCFunction>(WhiteBalanceControl_SetPresetAsync), METH_VARARGS, nullptr },
        { "set_value_async", reinterpret_cast<PyCFunction>(WhiteBalanceControl_SetValueAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WhiteBalanceControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WhiteBalanceControl[] = {
        { "max", reinterpret_cast<getter>(WhiteBalanceControl_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(WhiteBalanceControl_get_Min), nullptr, nullptr, nullptr },
        { "preset", reinterpret_cast<getter>(WhiteBalanceControl_get_Preset), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(WhiteBalanceControl_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(WhiteBalanceControl_get_Supported), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(WhiteBalanceControl_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WhiteBalanceControl[] = 
    {
        { Py_tp_new, _new_WhiteBalanceControl },
        { Py_tp_dealloc, _dealloc_WhiteBalanceControl },
        { Py_tp_methods, _methods_WhiteBalanceControl },
        { Py_tp_getset, _getset_WhiteBalanceControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WhiteBalanceControl =
    {
        "_winsdk_Windows_Media_Devices.WhiteBalanceControl",
        sizeof(py::wrapper::Windows::Media::Devices::WhiteBalanceControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WhiteBalanceControl
    };

    // ----- ZoomControl class --------------------
    constexpr const char* const _type_name_ZoomControl = "ZoomControl";

    static PyObject* _new_ZoomControl(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ZoomControl);
        return nullptr;
    }

    static void _dealloc_ZoomControl(py::wrapper::Windows::Media::Devices::ZoomControl* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ZoomControl_Configure(py::wrapper::Windows::Media::Devices::ZoomControl* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Devices::ZoomSettings>(args, 0);

                self->obj.Configure(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Value(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ZoomControl_put_Value(py::wrapper::Windows::Media::Devices::ZoomControl* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ZoomControl_get_Max(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Max());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Min(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Min());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Step(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Step());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Supported(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Supported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_Mode(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ZoomControl_get_SupportedModes(py::wrapper::Windows::Media::Devices::ZoomControl* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedModes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ZoomControl(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ZoomControl>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ZoomControl[] = {
        { "configure", reinterpret_cast<PyCFunction>(ZoomControl_Configure), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ZoomControl), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ZoomControl[] = {
        { "value", reinterpret_cast<getter>(ZoomControl_get_Value), reinterpret_cast<setter>(ZoomControl_put_Value), nullptr, nullptr },
        { "max", reinterpret_cast<getter>(ZoomControl_get_Max), nullptr, nullptr, nullptr },
        { "min", reinterpret_cast<getter>(ZoomControl_get_Min), nullptr, nullptr, nullptr },
        { "step", reinterpret_cast<getter>(ZoomControl_get_Step), nullptr, nullptr, nullptr },
        { "supported", reinterpret_cast<getter>(ZoomControl_get_Supported), nullptr, nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(ZoomControl_get_Mode), nullptr, nullptr, nullptr },
        { "supported_modes", reinterpret_cast<getter>(ZoomControl_get_SupportedModes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ZoomControl[] = 
    {
        { Py_tp_new, _new_ZoomControl },
        { Py_tp_dealloc, _dealloc_ZoomControl },
        { Py_tp_methods, _methods_ZoomControl },
        { Py_tp_getset, _getset_ZoomControl },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ZoomControl =
    {
        "_winsdk_Windows_Media_Devices.ZoomControl",
        sizeof(py::wrapper::Windows::Media::Devices::ZoomControl),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ZoomControl
    };

    // ----- ZoomSettings class --------------------
    constexpr const char* const _type_name_ZoomSettings = "ZoomSettings";

    static PyObject* _new_ZoomSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Devices::ZoomSettings instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ZoomSettings(py::wrapper::Windows::Media::Devices::ZoomSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ZoomSettings_get_Value(py::wrapper::Windows::Media::Devices::ZoomSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ZoomSettings_put_Value(py::wrapper::Windows::Media::Devices::ZoomSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<float>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ZoomSettings_get_Mode(py::wrapper::Windows::Media::Devices::ZoomSettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ZoomSettings_put_Mode(py::wrapper::Windows::Media::Devices::ZoomSettings* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Devices::ZoomTransitionMode>(arg);

            self->obj.Mode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ZoomSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::ZoomSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ZoomSettings[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ZoomSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ZoomSettings[] = {
        { "value", reinterpret_cast<getter>(ZoomSettings_get_Value), reinterpret_cast<setter>(ZoomSettings_put_Value), nullptr, nullptr },
        { "mode", reinterpret_cast<getter>(ZoomSettings_get_Mode), reinterpret_cast<setter>(ZoomSettings_put_Mode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ZoomSettings[] = 
    {
        { Py_tp_new, _new_ZoomSettings },
        { Py_tp_dealloc, _dealloc_ZoomSettings },
        { Py_tp_methods, _methods_ZoomSettings },
        { Py_tp_getset, _getset_ZoomSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ZoomSettings =
    {
        "_winsdk_Windows_Media_Devices.ZoomSettings",
        sizeof(py::wrapper::Windows::Media::Devices::ZoomSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ZoomSettings
    };

    // ----- IDefaultAudioDeviceChangedEventArgs interface --------------------
    constexpr const char* const _type_name_IDefaultAudioDeviceChangedEventArgs = "IDefaultAudioDeviceChangedEventArgs";

    static PyObject* _new_IDefaultAudioDeviceChangedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IDefaultAudioDeviceChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_IDefaultAudioDeviceChangedEventArgs(py::wrapper::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IDefaultAudioDeviceChangedEventArgs_get_Id(py::wrapper::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDefaultAudioDeviceChangedEventArgs_get_Role(py::wrapper::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Role());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IDefaultAudioDeviceChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDefaultAudioDeviceChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IDefaultAudioDeviceChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDefaultAudioDeviceChangedEventArgs[] = {
        { "id", reinterpret_cast<getter>(IDefaultAudioDeviceChangedEventArgs_get_Id), nullptr, nullptr, nullptr },
        { "role", reinterpret_cast<getter>(IDefaultAudioDeviceChangedEventArgs_get_Role), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IDefaultAudioDeviceChangedEventArgs[] = 
    {
        { Py_tp_new, _new_IDefaultAudioDeviceChangedEventArgs },
        { Py_tp_dealloc, _dealloc_IDefaultAudioDeviceChangedEventArgs },
        { Py_tp_methods, _methods_IDefaultAudioDeviceChangedEventArgs },
        { Py_tp_getset, _getset_IDefaultAudioDeviceChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IDefaultAudioDeviceChangedEventArgs =
    {
        "_winsdk_Windows_Media_Devices.IDefaultAudioDeviceChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDefaultAudioDeviceChangedEventArgs
    };

    // ----- IMediaDeviceController interface --------------------
    constexpr const char* const _type_name_IMediaDeviceController = "IMediaDeviceController";

    static PyObject* _new_IMediaDeviceController(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IMediaDeviceController);
        return nullptr;
    }

    static void _dealloc_IMediaDeviceController(py::wrapper::Windows::Media::Devices::IMediaDeviceController* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IMediaDeviceController_GetAvailableMediaStreamProperties(py::wrapper::Windows::Media::Devices::IMediaDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetAvailableMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMediaDeviceController_GetMediaStreamProperties(py::wrapper::Windows::Media::Devices::IMediaDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);

                return py::convert(self->obj.GetMediaStreamProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMediaDeviceController_SetMediaStreamPropertiesAsync(py::wrapper::Windows::Media::Devices::IMediaDeviceController* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Capture::MediaStreamType>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>(args, 1);

                return py::convert(self->obj.SetMediaStreamPropertiesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IMediaDeviceController(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Devices::IMediaDeviceController>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaDeviceController[] = {
        { "get_available_media_stream_properties", reinterpret_cast<PyCFunction>(IMediaDeviceController_GetAvailableMediaStreamProperties), METH_VARARGS, nullptr },
        { "get_media_stream_properties", reinterpret_cast<PyCFunction>(IMediaDeviceController_GetMediaStreamProperties), METH_VARARGS, nullptr },
        { "set_media_stream_properties_async", reinterpret_cast<PyCFunction>(IMediaDeviceController_SetMediaStreamPropertiesAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaDeviceController), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaDeviceController[] = {
        { }
    };

    static PyType_Slot _type_slots_IMediaDeviceController[] = 
    {
        { Py_tp_new, _new_IMediaDeviceController },
        { Py_tp_dealloc, _dealloc_IMediaDeviceController },
        { Py_tp_methods, _methods_IMediaDeviceController },
        { Py_tp_getset, _getset_IMediaDeviceController },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IMediaDeviceController =
    {
        "_winsdk_Windows_Media_Devices.IMediaDeviceController",
        sizeof(py::wrapper::Windows::Media::Devices::IMediaDeviceController),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaDeviceController
    };

    // ----- Windows.Media.Devices Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Media::Devices::AdvancedPhotoCaptureSettings>::python_type = py::register_python_type(module, _type_name_AdvancedPhotoCaptureSettings, &_type_spec_AdvancedPhotoCaptureSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::AdvancedPhotoControl>::python_type = py::register_python_type(module, _type_name_AdvancedPhotoControl, &_type_spec_AdvancedPhotoControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceController>::python_type = py::register_python_type(module, _type_name_AudioDeviceController, &_type_spec_AudioDeviceController, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceModule>::python_type = py::register_python_type(module, _type_name_AudioDeviceModule, &_type_spec_AudioDeviceModule, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceModuleNotificationEventArgs>::python_type = py::register_python_type(module, _type_name_AudioDeviceModuleNotificationEventArgs, &_type_spec_AudioDeviceModuleNotificationEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::AudioDeviceModulesManager>::python_type = py::register_python_type(module, _type_name_AudioDeviceModulesManager, &_type_spec_AudioDeviceModulesManager, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::CameraOcclusionInfo>::python_type = py::register_python_type(module, _type_name_CameraOcclusionInfo, &_type_spec_CameraOcclusionInfo, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::CameraOcclusionState>::python_type = py::register_python_type(module, _type_name_CameraOcclusionState, &_type_spec_CameraOcclusionState, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::CameraOcclusionStateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_CameraOcclusionStateChangedEventArgs, &_type_spec_CameraOcclusionStateChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::DefaultAudioCaptureDeviceChangedEventArgs>::python_type = py::register_python_type(module, _type_name_DefaultAudioCaptureDeviceChangedEventArgs, &_type_spec_DefaultAudioCaptureDeviceChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::DefaultAudioRenderDeviceChangedEventArgs>::python_type = py::register_python_type(module, _type_name_DefaultAudioRenderDeviceChangedEventArgs, &_type_spec_DefaultAudioRenderDeviceChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::DigitalWindowBounds>::python_type = py::register_python_type(module, _type_name_DigitalWindowBounds, &_type_spec_DigitalWindowBounds, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::DigitalWindowCapability>::python_type = py::register_python_type(module, _type_name_DigitalWindowCapability, &_type_spec_DigitalWindowCapability, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::DigitalWindowControl>::python_type = py::register_python_type(module, _type_name_DigitalWindowControl, &_type_spec_DigitalWindowControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::ExposureCompensationControl>::python_type = py::register_python_type(module, _type_name_ExposureCompensationControl, &_type_spec_ExposureCompensationControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::ExposureControl>::python_type = py::register_python_type(module, _type_name_ExposureControl, &_type_spec_ExposureControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::ExposurePriorityVideoControl>::python_type = py::register_python_type(module, _type_name_ExposurePriorityVideoControl, &_type_spec_ExposurePriorityVideoControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::FlashControl>::python_type = py::register_python_type(module, _type_name_FlashControl, &_type_spec_FlashControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::FocusControl>::python_type = py::register_python_type(module, _type_name_FocusControl, &_type_spec_FocusControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::FocusSettings>::python_type = py::register_python_type(module, _type_name_FocusSettings, &_type_spec_FocusSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::HdrVideoControl>::python_type = py::register_python_type(module, _type_name_HdrVideoControl, &_type_spec_HdrVideoControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::InfraredTorchControl>::python_type = py::register_python_type(module, _type_name_InfraredTorchControl, &_type_spec_InfraredTorchControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::IsoSpeedControl>::python_type = py::register_python_type(module, _type_name_IsoSpeedControl, &_type_spec_IsoSpeedControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::LowLagPhotoControl>::python_type = py::register_python_type(module, _type_name_LowLagPhotoControl, &_type_spec_LowLagPhotoControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::LowLagPhotoSequenceControl>::python_type = py::register_python_type(module, _type_name_LowLagPhotoSequenceControl, &_type_spec_LowLagPhotoSequenceControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::MediaDevice>::python_type = py::register_python_type(module, _type_name_MediaDevice, &_type_spec_MediaDevice, nullptr);
            py::winrt_type<winrt::Windows::Media::Devices::MediaDeviceControl>::python_type = py::register_python_type(module, _type_name_MediaDeviceControl, &_type_spec_MediaDeviceControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::MediaDeviceControlCapabilities>::python_type = py::register_python_type(module, _type_name_MediaDeviceControlCapabilities, &_type_spec_MediaDeviceControlCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::ModuleCommandResult>::python_type = py::register_python_type(module, _type_name_ModuleCommandResult, &_type_spec_ModuleCommandResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::OpticalImageStabilizationControl>::python_type = py::register_python_type(module, _type_name_OpticalImageStabilizationControl, &_type_spec_OpticalImageStabilizationControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::PanelBasedOptimizationControl>::python_type = py::register_python_type(module, _type_name_PanelBasedOptimizationControl, &_type_spec_PanelBasedOptimizationControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::PhotoConfirmationControl>::python_type = py::register_python_type(module, _type_name_PhotoConfirmationControl, &_type_spec_PhotoConfirmationControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::RegionOfInterest>::python_type = py::register_python_type(module, _type_name_RegionOfInterest, &_type_spec_RegionOfInterest, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::RegionsOfInterestControl>::python_type = py::register_python_type(module, _type_name_RegionsOfInterestControl, &_type_spec_RegionsOfInterestControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::SceneModeControl>::python_type = py::register_python_type(module, _type_name_SceneModeControl, &_type_spec_SceneModeControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::TorchControl>::python_type = py::register_python_type(module, _type_name_TorchControl, &_type_spec_TorchControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::VideoDeviceController>::python_type = py::register_python_type(module, _type_name_VideoDeviceController, &_type_spec_VideoDeviceController, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::VideoDeviceControllerGetDevicePropertyResult>::python_type = py::register_python_type(module, _type_name_VideoDeviceControllerGetDevicePropertyResult, &_type_spec_VideoDeviceControllerGetDevicePropertyResult, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::VideoTemporalDenoisingControl>::python_type = py::register_python_type(module, _type_name_VideoTemporalDenoisingControl, &_type_spec_VideoTemporalDenoisingControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::WhiteBalanceControl>::python_type = py::register_python_type(module, _type_name_WhiteBalanceControl, &_type_spec_WhiteBalanceControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::ZoomControl>::python_type = py::register_python_type(module, _type_name_ZoomControl, &_type_spec_ZoomControl, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::ZoomSettings>::python_type = py::register_python_type(module, _type_name_ZoomSettings, &_type_spec_ZoomSettings, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::IDefaultAudioDeviceChangedEventArgs>::python_type = py::register_python_type(module, _type_name_IDefaultAudioDeviceChangedEventArgs, &_type_spec_IDefaultAudioDeviceChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::Devices::IMediaDeviceController>::python_type = py::register_python_type(module, _type_name_IMediaDeviceController, &_type_spec_IMediaDeviceController, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Media.Devices");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_Devices",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Media::Devices

PyMODINIT_FUNC
PyInit__winsdk_Windows_Media_Devices (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::Devices::module_def);
}
