// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Media.SpeechRecognition.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>::python_type;

namespace py::cpp::Windows::Media::SpeechRecognition
{
    // ----- SpeechContinuousRecognitionCompletedEventArgs class --------------------
    constexpr const char* const _type_name_SpeechContinuousRecognitionCompletedEventArgs = "SpeechContinuousRecognitionCompletedEventArgs";

    static PyObject* _new_SpeechContinuousRecognitionCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechContinuousRecognitionCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionCompletedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechContinuousRecognitionCompletedEventArgs_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechContinuousRecognitionCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionCompletedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechContinuousRecognitionCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechContinuousRecognitionCompletedEventArgs[] = {
        { "status", reinterpret_cast<getter>(SpeechContinuousRecognitionCompletedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechContinuousRecognitionCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechContinuousRecognitionCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechContinuousRecognitionCompletedEventArgs },
        { Py_tp_methods, _methods_SpeechContinuousRecognitionCompletedEventArgs },
        { Py_tp_getset, _getset_SpeechContinuousRecognitionCompletedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechContinuousRecognitionCompletedEventArgs =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechContinuousRecognitionCompletedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionCompletedEventArgs
    };

    // ----- SpeechContinuousRecognitionResultGeneratedEventArgs class --------------------
    constexpr const char* const _type_name_SpeechContinuousRecognitionResultGeneratedEventArgs = "SpeechContinuousRecognitionResultGeneratedEventArgs";

    static PyObject* _new_SpeechContinuousRecognitionResultGeneratedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechContinuousRecognitionResultGeneratedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionResultGeneratedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechContinuousRecognitionResultGeneratedEventArgs_get_Result(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechContinuousRecognitionResultGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionResultGeneratedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechContinuousRecognitionResultGeneratedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechContinuousRecognitionResultGeneratedEventArgs[] = {
        { "result", reinterpret_cast<getter>(SpeechContinuousRecognitionResultGeneratedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechContinuousRecognitionResultGeneratedEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechContinuousRecognitionResultGeneratedEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechContinuousRecognitionResultGeneratedEventArgs },
        { Py_tp_methods, _methods_SpeechContinuousRecognitionResultGeneratedEventArgs },
        { Py_tp_getset, _getset_SpeechContinuousRecognitionResultGeneratedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechContinuousRecognitionResultGeneratedEventArgs =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechContinuousRecognitionResultGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionResultGeneratedEventArgs
    };

    // ----- SpeechContinuousRecognitionSession class --------------------
    constexpr const char* const _type_name_SpeechContinuousRecognitionSession = "SpeechContinuousRecognitionSession";

    static PyObject* _new_SpeechContinuousRecognitionSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechContinuousRecognitionSession);
        return nullptr;
    }

    static void _dealloc_SpeechContinuousRecognitionSession(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechContinuousRecognitionSession_CancelAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CancelAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_PauseAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PauseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_Resume(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Resume();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_StartAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StartAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionMode>(args, 0);

                return py::convert(self->obj.StartAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_StopAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_get_AutoStopSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoStopSilenceTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechContinuousRecognitionSession_put_AutoStopSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AutoStopSilenceTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_add_Completed(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession, winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_remove_Completed(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_add_ResultGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession, winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>>(arg);

            return py::convert(self->obj.ResultGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechContinuousRecognitionSession_remove_ResultGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.ResultGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechContinuousRecognitionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechContinuousRecognitionSession[] = {
        { "cancel_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_CancelAsync), METH_VARARGS, nullptr },
        { "pause_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_PauseAsync), METH_VARARGS, nullptr },
        { "resume", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_Resume), METH_VARARGS, nullptr },
        { "start_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_StartAsync), METH_VARARGS, nullptr },
        { "stop_async", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_StopAsync), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_remove_Completed), METH_O, nullptr },
        { "add_result_generated", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_add_ResultGenerated), METH_O, nullptr },
        { "remove_result_generated", reinterpret_cast<PyCFunction>(SpeechContinuousRecognitionSession_remove_ResultGenerated), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechContinuousRecognitionSession), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechContinuousRecognitionSession[] = {
        { "auto_stop_silence_timeout", reinterpret_cast<getter>(SpeechContinuousRecognitionSession_get_AutoStopSilenceTimeout), reinterpret_cast<setter>(SpeechContinuousRecognitionSession_put_AutoStopSilenceTimeout), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechContinuousRecognitionSession[] = 
    {
        { Py_tp_new, _new_SpeechContinuousRecognitionSession },
        { Py_tp_dealloc, _dealloc_SpeechContinuousRecognitionSession },
        { Py_tp_methods, _methods_SpeechContinuousRecognitionSession },
        { Py_tp_getset, _getset_SpeechContinuousRecognitionSession },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechContinuousRecognitionSession =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechContinuousRecognitionSession",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechContinuousRecognitionSession
    };

    // ----- SpeechRecognitionCompilationResult class --------------------
    constexpr const char* const _type_name_SpeechRecognitionCompilationResult = "SpeechRecognitionCompilationResult";

    static PyObject* _new_SpeechRecognitionCompilationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognitionCompilationResult);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionCompilationResult(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionCompilationResult_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionCompilationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionCompilationResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionCompilationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionCompilationResult[] = {
        { "status", reinterpret_cast<getter>(SpeechRecognitionCompilationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionCompilationResult[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionCompilationResult },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionCompilationResult },
        { Py_tp_methods, _methods_SpeechRecognitionCompilationResult },
        { Py_tp_getset, _getset_SpeechRecognitionCompilationResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionCompilationResult =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionCompilationResult",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionCompilationResult
    };

    // ----- SpeechRecognitionGrammarFileConstraint class --------------------
    constexpr const char* const _type_name_SpeechRecognitionGrammarFileConstraint = "SpeechRecognitionGrammarFileConstraint";

    static PyObject* _new_SpeechRecognitionGrammarFileConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::StorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionGrammarFileConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionGrammarFileConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionGrammarFileConstraint_get_GrammarFile(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.GrammarFile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionGrammarFileConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionGrammarFileConstraint[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionGrammarFileConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionGrammarFileConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionGrammarFileConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionGrammarFileConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionGrammarFileConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_Type), nullptr, nullptr, nullptr },
        { "grammar_file", reinterpret_cast<getter>(SpeechRecognitionGrammarFileConstraint_get_GrammarFile), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionGrammarFileConstraint[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionGrammarFileConstraint },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionGrammarFileConstraint },
        { Py_tp_methods, _methods_SpeechRecognitionGrammarFileConstraint },
        { Py_tp_getset, _getset_SpeechRecognitionGrammarFileConstraint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionGrammarFileConstraint =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionGrammarFileConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionGrammarFileConstraint
    };

    // ----- SpeechRecognitionHypothesis class --------------------
    constexpr const char* const _type_name_SpeechRecognitionHypothesis = "SpeechRecognitionHypothesis";

    static PyObject* _new_SpeechRecognitionHypothesis(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognitionHypothesis);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionHypothesis(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionHypothesis_get_Text(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionHypothesis(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionHypothesis[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionHypothesis), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionHypothesis[] = {
        { "text", reinterpret_cast<getter>(SpeechRecognitionHypothesis_get_Text), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionHypothesis[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionHypothesis },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionHypothesis },
        { Py_tp_methods, _methods_SpeechRecognitionHypothesis },
        { Py_tp_getset, _getset_SpeechRecognitionHypothesis },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionHypothesis =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionHypothesis",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionHypothesis
    };

    // ----- SpeechRecognitionHypothesisGeneratedEventArgs class --------------------
    constexpr const char* const _type_name_SpeechRecognitionHypothesisGeneratedEventArgs = "SpeechRecognitionHypothesisGeneratedEventArgs";

    static PyObject* _new_SpeechRecognitionHypothesisGeneratedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognitionHypothesisGeneratedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionHypothesisGeneratedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionHypothesisGeneratedEventArgs_get_Hypothesis(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Hypothesis());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionHypothesisGeneratedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionHypothesisGeneratedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionHypothesisGeneratedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionHypothesisGeneratedEventArgs[] = {
        { "hypothesis", reinterpret_cast<getter>(SpeechRecognitionHypothesisGeneratedEventArgs_get_Hypothesis), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionHypothesisGeneratedEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionHypothesisGeneratedEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionHypothesisGeneratedEventArgs },
        { Py_tp_methods, _methods_SpeechRecognitionHypothesisGeneratedEventArgs },
        { Py_tp_getset, _getset_SpeechRecognitionHypothesisGeneratedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionHypothesisGeneratedEventArgs =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionHypothesisGeneratedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionHypothesisGeneratedEventArgs
    };

    // ----- SpeechRecognitionListConstraint class --------------------
    constexpr const char* const _type_name_SpeechRecognitionListConstraint = "SpeechRecognitionListConstraint";

    static PyObject* _new_SpeechRecognitionListConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionListConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionListConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionListConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionListConstraint_get_Commands(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Commands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionListConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionListConstraint[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionListConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionListConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionListConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionListConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionListConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Type), nullptr, nullptr, nullptr },
        { "commands", reinterpret_cast<getter>(SpeechRecognitionListConstraint_get_Commands), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionListConstraint[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionListConstraint },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionListConstraint },
        { Py_tp_methods, _methods_SpeechRecognitionListConstraint },
        { Py_tp_getset, _getset_SpeechRecognitionListConstraint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionListConstraint =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionListConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionListConstraint
    };

    // ----- SpeechRecognitionQualityDegradingEventArgs class --------------------
    constexpr const char* const _type_name_SpeechRecognitionQualityDegradingEventArgs = "SpeechRecognitionQualityDegradingEventArgs";

    static PyObject* _new_SpeechRecognitionQualityDegradingEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognitionQualityDegradingEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionQualityDegradingEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionQualityDegradingEventArgs_get_Problem(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Problem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionQualityDegradingEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionQualityDegradingEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionQualityDegradingEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionQualityDegradingEventArgs[] = {
        { "problem", reinterpret_cast<getter>(SpeechRecognitionQualityDegradingEventArgs_get_Problem), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionQualityDegradingEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionQualityDegradingEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionQualityDegradingEventArgs },
        { Py_tp_methods, _methods_SpeechRecognitionQualityDegradingEventArgs },
        { Py_tp_getset, _getset_SpeechRecognitionQualityDegradingEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionQualityDegradingEventArgs =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionQualityDegradingEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionQualityDegradingEventArgs
    };

    // ----- SpeechRecognitionResult class --------------------
    constexpr const char* const _type_name_SpeechRecognitionResult = "SpeechRecognitionResult";

    static PyObject* _new_SpeechRecognitionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognitionResult);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionResult(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionResult_GetAlternates(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAlternates(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Confidence(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Confidence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Constraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Constraint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_RawConfidence(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawConfidence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_RulePath(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RulePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_SemanticInterpretation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SemanticInterpretation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Status(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_Text(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Text());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_PhraseDuration(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhraseDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionResult_get_PhraseStartTime(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhraseStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionResult[] = {
        { "get_alternates", reinterpret_cast<PyCFunction>(SpeechRecognitionResult_GetAlternates), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionResult[] = {
        { "confidence", reinterpret_cast<getter>(SpeechRecognitionResult_get_Confidence), nullptr, nullptr, nullptr },
        { "constraint", reinterpret_cast<getter>(SpeechRecognitionResult_get_Constraint), nullptr, nullptr, nullptr },
        { "raw_confidence", reinterpret_cast<getter>(SpeechRecognitionResult_get_RawConfidence), nullptr, nullptr, nullptr },
        { "rule_path", reinterpret_cast<getter>(SpeechRecognitionResult_get_RulePath), nullptr, nullptr, nullptr },
        { "semantic_interpretation", reinterpret_cast<getter>(SpeechRecognitionResult_get_SemanticInterpretation), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(SpeechRecognitionResult_get_Status), nullptr, nullptr, nullptr },
        { "text", reinterpret_cast<getter>(SpeechRecognitionResult_get_Text), nullptr, nullptr, nullptr },
        { "phrase_duration", reinterpret_cast<getter>(SpeechRecognitionResult_get_PhraseDuration), nullptr, nullptr, nullptr },
        { "phrase_start_time", reinterpret_cast<getter>(SpeechRecognitionResult_get_PhraseStartTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionResult[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionResult },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionResult },
        { Py_tp_methods, _methods_SpeechRecognitionResult },
        { Py_tp_getset, _getset_SpeechRecognitionResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionResult =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionResult",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionResult
    };

    // ----- SpeechRecognitionSemanticInterpretation class --------------------
    constexpr const char* const _type_name_SpeechRecognitionSemanticInterpretation = "SpeechRecognitionSemanticInterpretation";

    static PyObject* _new_SpeechRecognitionSemanticInterpretation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognitionSemanticInterpretation);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionSemanticInterpretation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionSemanticInterpretation_get_Properties(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionSemanticInterpretation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionSemanticInterpretation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionSemanticInterpretation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionSemanticInterpretation[] = {
        { "properties", reinterpret_cast<getter>(SpeechRecognitionSemanticInterpretation_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionSemanticInterpretation[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionSemanticInterpretation },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionSemanticInterpretation },
        { Py_tp_methods, _methods_SpeechRecognitionSemanticInterpretation },
        { Py_tp_getset, _getset_SpeechRecognitionSemanticInterpretation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionSemanticInterpretation =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionSemanticInterpretation",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionSemanticInterpretation
    };

    // ----- SpeechRecognitionTopicConstraint class --------------------
    constexpr const char* const _type_name_SpeechRecognitionTopicConstraint = "SpeechRecognitionTopicConstraint";

    static PyObject* _new_SpeechRecognitionTopicConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionScenario>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionScenario>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognitionTopicConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionTopicConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_Scenario(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Scenario());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognitionTopicConstraint_get_TopicHint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TopicHint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionTopicConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionTopicConstraint[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionTopicConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionTopicConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionTopicConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionTopicConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionTopicConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Type), nullptr, nullptr, nullptr },
        { "scenario", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_Scenario), nullptr, nullptr, nullptr },
        { "topic_hint", reinterpret_cast<getter>(SpeechRecognitionTopicConstraint_get_TopicHint), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionTopicConstraint[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionTopicConstraint },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionTopicConstraint },
        { Py_tp_methods, _methods_SpeechRecognitionTopicConstraint },
        { Py_tp_getset, _getset_SpeechRecognitionTopicConstraint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionTopicConstraint =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionTopicConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionTopicConstraint
    };

    // ----- SpeechRecognitionVoiceCommandDefinitionConstraint class --------------------
    constexpr const char* const _type_name_SpeechRecognitionVoiceCommandDefinitionConstraint = "SpeechRecognitionVoiceCommandDefinitionConstraint";

    static PyObject* _new_SpeechRecognitionVoiceCommandDefinitionConstraint(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognitionVoiceCommandDefinitionConstraint);
        return nullptr;
    }

    static void _dealloc_SpeechRecognitionVoiceCommandDefinitionConstraint(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognitionVoiceCommandDefinitionConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognitionVoiceCommandDefinitionConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognitionVoiceCommandDefinitionConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognitionVoiceCommandDefinitionConstraint[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognitionVoiceCommandDefinitionConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognitionVoiceCommandDefinitionConstraint[] = {
        { "tag", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_Tag), reinterpret_cast<setter>(SpeechRecognitionVoiceCommandDefinitionConstraint_put_Tag), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_Probability), reinterpret_cast<setter>(SpeechRecognitionVoiceCommandDefinitionConstraint_put_Probability), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_IsEnabled), reinterpret_cast<setter>(SpeechRecognitionVoiceCommandDefinitionConstraint_put_IsEnabled), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(SpeechRecognitionVoiceCommandDefinitionConstraint_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognitionVoiceCommandDefinitionConstraint[] = 
    {
        { Py_tp_new, _new_SpeechRecognitionVoiceCommandDefinitionConstraint },
        { Py_tp_dealloc, _dealloc_SpeechRecognitionVoiceCommandDefinitionConstraint },
        { Py_tp_methods, _methods_SpeechRecognitionVoiceCommandDefinitionConstraint },
        { Py_tp_getset, _getset_SpeechRecognitionVoiceCommandDefinitionConstraint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognitionVoiceCommandDefinitionConstraint =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognitionVoiceCommandDefinitionConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognitionVoiceCommandDefinitionConstraint
    };

    // ----- SpeechRecognizer class --------------------
    constexpr const char* const _type_name_SpeechRecognizer = "SpeechRecognizer";

    static PyObject* _new_SpeechRecognizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Globalization::Language>(args, 0);

                winrt::Windows::Media::SpeechRecognition::SpeechRecognizer instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::SpeechRecognition::SpeechRecognizer instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognizer_Close(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_CompileConstraintsAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CompileConstraintsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_RecognizeAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RecognizeAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_RecognizeWithUIAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RecognizeWithUIAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_StopRecognitionAsync(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.StopRecognitionAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_TrySetSystemSpeechLanguageAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Globalization::Language>(args, 0);

                return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::TrySetSystemSpeechLanguageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_Constraints(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Constraints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_CurrentLanguage(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_Timeouts(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timeouts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_UIOptions(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UIOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_ContinuousRecognitionSession(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContinuousRecognitionSession());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_State(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SupportedGrammarLanguages(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SupportedGrammarLanguages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SupportedTopicLanguages(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SupportedTopicLanguages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_get_SystemSpeechLanguage(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::SpeechRecognition::SpeechRecognizer::SystemSpeechLanguage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_RecognitionQualityDegrading(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>>(arg);

            return py::convert(self->obj.RecognitionQualityDegrading(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_RecognitionQualityDegrading(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.RecognitionQualityDegrading(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_StateChanged(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>>(arg);

            return py::convert(self->obj.StateChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_StateChanged(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StateChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_add_HypothesisGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer, winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>>(arg);

            return py::convert(self->obj.HypothesisGenerated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SpeechRecognizer_remove_HypothesisGenerated(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.HypothesisGenerated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_SpeechRecognizer(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizer[] = {
        { "close", reinterpret_cast<PyCFunction>(SpeechRecognizer_Close), METH_VARARGS, nullptr },
        { "compile_constraints_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_CompileConstraintsAsync), METH_VARARGS, nullptr },
        { "recognize_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_RecognizeAsync), METH_VARARGS, nullptr },
        { "recognize_with_u_i_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_RecognizeWithUIAsync), METH_VARARGS, nullptr },
        { "stop_recognition_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_StopRecognitionAsync), METH_VARARGS, nullptr },
        { "try_set_system_speech_language_async", reinterpret_cast<PyCFunction>(SpeechRecognizer_TrySetSystemSpeechLanguageAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_supported_grammar_languages", reinterpret_cast<PyCFunction>(SpeechRecognizer_get_SupportedGrammarLanguages), METH_NOARGS | METH_STATIC, nullptr },
        { "get_supported_topic_languages", reinterpret_cast<PyCFunction>(SpeechRecognizer_get_SupportedTopicLanguages), METH_NOARGS | METH_STATIC, nullptr },
        { "get_system_speech_language", reinterpret_cast<PyCFunction>(SpeechRecognizer_get_SystemSpeechLanguage), METH_NOARGS | METH_STATIC, nullptr },
        { "add_recognition_quality_degrading", reinterpret_cast<PyCFunction>(SpeechRecognizer_add_RecognitionQualityDegrading), METH_O, nullptr },
        { "remove_recognition_quality_degrading", reinterpret_cast<PyCFunction>(SpeechRecognizer_remove_RecognitionQualityDegrading), METH_O, nullptr },
        { "add_state_changed", reinterpret_cast<PyCFunction>(SpeechRecognizer_add_StateChanged), METH_O, nullptr },
        { "remove_state_changed", reinterpret_cast<PyCFunction>(SpeechRecognizer_remove_StateChanged), METH_O, nullptr },
        { "add_hypothesis_generated", reinterpret_cast<PyCFunction>(SpeechRecognizer_add_HypothesisGenerated), METH_O, nullptr },
        { "remove_hypothesis_generated", reinterpret_cast<PyCFunction>(SpeechRecognizer_remove_HypothesisGenerated), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_SpeechRecognizer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_SpeechRecognizer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognizer[] = {
        { "constraints", reinterpret_cast<getter>(SpeechRecognizer_get_Constraints), nullptr, nullptr, nullptr },
        { "current_language", reinterpret_cast<getter>(SpeechRecognizer_get_CurrentLanguage), nullptr, nullptr, nullptr },
        { "timeouts", reinterpret_cast<getter>(SpeechRecognizer_get_Timeouts), nullptr, nullptr, nullptr },
        { "u_i_options", reinterpret_cast<getter>(SpeechRecognizer_get_UIOptions), nullptr, nullptr, nullptr },
        { "continuous_recognition_session", reinterpret_cast<getter>(SpeechRecognizer_get_ContinuousRecognitionSession), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(SpeechRecognizer_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognizer[] = 
    {
        { Py_tp_new, _new_SpeechRecognizer },
        { Py_tp_dealloc, _dealloc_SpeechRecognizer },
        { Py_tp_methods, _methods_SpeechRecognizer },
        { Py_tp_getset, _getset_SpeechRecognizer },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognizer =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognizer",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizer
    };

    // ----- SpeechRecognizerStateChangedEventArgs class --------------------
    constexpr const char* const _type_name_SpeechRecognizerStateChangedEventArgs = "SpeechRecognizerStateChangedEventArgs";

    static PyObject* _new_SpeechRecognizerStateChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognizerStateChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerStateChangedEventArgs(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognizerStateChangedEventArgs_get_State(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SpeechRecognizerStateChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerStateChangedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizerStateChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognizerStateChangedEventArgs[] = {
        { "state", reinterpret_cast<getter>(SpeechRecognizerStateChangedEventArgs_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognizerStateChangedEventArgs[] = 
    {
        { Py_tp_new, _new_SpeechRecognizerStateChangedEventArgs },
        { Py_tp_dealloc, _dealloc_SpeechRecognizerStateChangedEventArgs },
        { Py_tp_methods, _methods_SpeechRecognizerStateChangedEventArgs },
        { Py_tp_getset, _getset_SpeechRecognizerStateChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognizerStateChangedEventArgs =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognizerStateChangedEventArgs",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerStateChangedEventArgs
    };

    // ----- SpeechRecognizerTimeouts class --------------------
    constexpr const char* const _type_name_SpeechRecognizerTimeouts = "SpeechRecognizerTimeouts";

    static PyObject* _new_SpeechRecognizerTimeouts(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognizerTimeouts);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerTimeouts(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognizerTimeouts_get_InitialSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InitialSilenceTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_InitialSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.InitialSilenceTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerTimeouts_get_EndSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndSilenceTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_EndSilenceTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.EndSilenceTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerTimeouts_get_BabbleTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BabbleTimeout());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerTimeouts_put_BabbleTimeout(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.BabbleTimeout(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_SpeechRecognizerTimeouts(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerTimeouts[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizerTimeouts), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognizerTimeouts[] = {
        { "initial_silence_timeout", reinterpret_cast<getter>(SpeechRecognizerTimeouts_get_InitialSilenceTimeout), reinterpret_cast<setter>(SpeechRecognizerTimeouts_put_InitialSilenceTimeout), nullptr, nullptr },
        { "end_silence_timeout", reinterpret_cast<getter>(SpeechRecognizerTimeouts_get_EndSilenceTimeout), reinterpret_cast<setter>(SpeechRecognizerTimeouts_put_EndSilenceTimeout), nullptr, nullptr },
        { "babble_timeout", reinterpret_cast<getter>(SpeechRecognizerTimeouts_get_BabbleTimeout), reinterpret_cast<setter>(SpeechRecognizerTimeouts_put_BabbleTimeout), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognizerTimeouts[] = 
    {
        { Py_tp_new, _new_SpeechRecognizerTimeouts },
        { Py_tp_dealloc, _dealloc_SpeechRecognizerTimeouts },
        { Py_tp_methods, _methods_SpeechRecognizerTimeouts },
        { Py_tp_getset, _getset_SpeechRecognizerTimeouts },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognizerTimeouts =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognizerTimeouts",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerTimeouts
    };

    // ----- SpeechRecognizerUIOptions class --------------------
    constexpr const char* const _type_name_SpeechRecognizerUIOptions = "SpeechRecognizerUIOptions";

    static PyObject* _new_SpeechRecognizerUIOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SpeechRecognizerUIOptions);
        return nullptr;
    }

    static void _dealloc_SpeechRecognizerUIOptions(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SpeechRecognizerUIOptions_get_ShowConfirmation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShowConfirmation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_ShowConfirmation(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowConfirmation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_IsReadBackEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadBackEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_IsReadBackEnabled(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsReadBackEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_ExampleText(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExampleText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_ExampleText(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ExampleText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* SpeechRecognizerUIOptions_get_AudiblePrompt(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudiblePrompt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int SpeechRecognizerUIOptions_put_AudiblePrompt(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AudiblePrompt(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_SpeechRecognizerUIOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SpeechRecognizerUIOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SpeechRecognizerUIOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SpeechRecognizerUIOptions[] = {
        { "show_confirmation", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_ShowConfirmation), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_ShowConfirmation), nullptr, nullptr },
        { "is_read_back_enabled", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_IsReadBackEnabled), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_IsReadBackEnabled), nullptr, nullptr },
        { "example_text", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_ExampleText), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_ExampleText), nullptr, nullptr },
        { "audible_prompt", reinterpret_cast<getter>(SpeechRecognizerUIOptions_get_AudiblePrompt), reinterpret_cast<setter>(SpeechRecognizerUIOptions_put_AudiblePrompt), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SpeechRecognizerUIOptions[] = 
    {
        { Py_tp_new, _new_SpeechRecognizerUIOptions },
        { Py_tp_dealloc, _dealloc_SpeechRecognizerUIOptions },
        { Py_tp_methods, _methods_SpeechRecognizerUIOptions },
        { Py_tp_getset, _getset_SpeechRecognizerUIOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SpeechRecognizerUIOptions =
    {
        "_winsdk_Windows_Media_SpeechRecognition.SpeechRecognizerUIOptions",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SpeechRecognizerUIOptions
    };

    // ----- ISpeechRecognitionConstraint interface --------------------
    constexpr const char* const _type_name_ISpeechRecognitionConstraint = "ISpeechRecognitionConstraint";

    static PyObject* _new_ISpeechRecognitionConstraint(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ISpeechRecognitionConstraint);
        return nullptr;
    }

    static void _dealloc_ISpeechRecognitionConstraint(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ISpeechRecognitionConstraint_get_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_IsEnabled(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Probability(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Probability());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_Probability(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionConstraintProbability>(arg);

            self->obj.Probability(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Tag(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Tag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ISpeechRecognitionConstraint_put_Tag(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Tag(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ISpeechRecognitionConstraint_get_Type(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ISpeechRecognitionConstraint(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISpeechRecognitionConstraint[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ISpeechRecognitionConstraint), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISpeechRecognitionConstraint[] = {
        { "is_enabled", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_IsEnabled), reinterpret_cast<setter>(ISpeechRecognitionConstraint_put_IsEnabled), nullptr, nullptr },
        { "probability", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_Probability), reinterpret_cast<setter>(ISpeechRecognitionConstraint_put_Probability), nullptr, nullptr },
        { "tag", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_Tag), reinterpret_cast<setter>(ISpeechRecognitionConstraint_put_Tag), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ISpeechRecognitionConstraint_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISpeechRecognitionConstraint[] = 
    {
        { Py_tp_new, _new_ISpeechRecognitionConstraint },
        { Py_tp_dealloc, _dealloc_ISpeechRecognitionConstraint },
        { Py_tp_methods, _methods_ISpeechRecognitionConstraint },
        { Py_tp_getset, _getset_ISpeechRecognitionConstraint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ISpeechRecognitionConstraint =
    {
        "_winsdk_Windows_Media_SpeechRecognition.ISpeechRecognitionConstraint",
        sizeof(py::wrapper::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISpeechRecognitionConstraint
    };

    // ----- Windows.Media.SpeechRecognition Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_SpeechContinuousRecognitionCompletedEventArgs, &_type_spec_SpeechContinuousRecognitionCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionResultGeneratedEventArgs>::python_type = py::register_python_type(module, _type_name_SpeechContinuousRecognitionResultGeneratedEventArgs, &_type_spec_SpeechContinuousRecognitionResultGeneratedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechContinuousRecognitionSession>::python_type = py::register_python_type(module, _type_name_SpeechContinuousRecognitionSession, &_type_spec_SpeechContinuousRecognitionSession, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionCompilationResult>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionCompilationResult, &_type_spec_SpeechRecognitionCompilationResult, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionGrammarFileConstraint>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionGrammarFileConstraint, &_type_spec_SpeechRecognitionGrammarFileConstraint, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesis>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionHypothesis, &_type_spec_SpeechRecognitionHypothesis, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionHypothesisGeneratedEventArgs>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionHypothesisGeneratedEventArgs, &_type_spec_SpeechRecognitionHypothesisGeneratedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionListConstraint>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionListConstraint, &_type_spec_SpeechRecognitionListConstraint, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionQualityDegradingEventArgs>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionQualityDegradingEventArgs, &_type_spec_SpeechRecognitionQualityDegradingEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionResult>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionResult, &_type_spec_SpeechRecognitionResult, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionSemanticInterpretation>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionSemanticInterpretation, &_type_spec_SpeechRecognitionSemanticInterpretation, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionTopicConstraint>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionTopicConstraint, &_type_spec_SpeechRecognitionTopicConstraint, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognitionVoiceCommandDefinitionConstraint>::python_type = py::register_python_type(module, _type_name_SpeechRecognitionVoiceCommandDefinitionConstraint, &_type_spec_SpeechRecognitionVoiceCommandDefinitionConstraint, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizer>::python_type = py::register_python_type(module, _type_name_SpeechRecognizer, &_type_spec_SpeechRecognizer, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerStateChangedEventArgs>::python_type = py::register_python_type(module, _type_name_SpeechRecognizerStateChangedEventArgs, &_type_spec_SpeechRecognizerStateChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerTimeouts>::python_type = py::register_python_type(module, _type_name_SpeechRecognizerTimeouts, &_type_spec_SpeechRecognizerTimeouts, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::SpeechRecognizerUIOptions>::python_type = py::register_python_type(module, _type_name_SpeechRecognizerUIOptions, &_type_spec_SpeechRecognizerUIOptions, bases.get());
            py::winrt_type<winrt::Windows::Media::SpeechRecognition::ISpeechRecognitionConstraint>::python_type = py::register_python_type(module, _type_name_ISpeechRecognitionConstraint, &_type_spec_ISpeechRecognitionConstraint, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Media.SpeechRecognition");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_SpeechRecognition",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Media::SpeechRecognition

PyMODINIT_FUNC
PyInit__winsdk_Windows_Media_SpeechRecognition (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::SpeechRecognition::module_def);
}
