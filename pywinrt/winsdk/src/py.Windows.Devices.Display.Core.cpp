// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Devices.Display.Core.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayAdapter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayFence>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerResultWithState>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayModeInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPath>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayScanout>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplaySource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayState>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayStateOperationResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplaySurface>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTarget>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTask>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTaskPool>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTaskResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayView>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayWireFormat>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>::python_type;

PyObject* py::converter<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>::convert(winrt::Windows::Devices::Display::Core::DisplayPresentationRate instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>());
}
winrt::Windows::Devices::Display::Core::DisplayPresentationRate py::converter<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Devices::Display::Core::DisplayPresentationRate return_value{};

    PyObject* py_VerticalSyncRate = PyDict_GetItemString(obj, "vertical_sync_rate");
    if (!py_VerticalSyncRate) { throw winrt::hresult_invalid_argument(); }
    return_value.VerticalSyncRate = converter<winrt::Windows::Foundation::Numerics::Rational>::convert_to(py_VerticalSyncRate);

    PyObject* py_VerticalSyncsPerPresentation = PyDict_GetItemString(obj, "vertical_syncs_per_presentation");
    if (!py_VerticalSyncsPerPresentation) { throw winrt::hresult_invalid_argument(); }
    return_value.VerticalSyncsPerPresentation = converter<int32_t>::convert_to(py_VerticalSyncsPerPresentation);

    return return_value;
}

namespace py::cpp::Windows::Devices::Display::Core
{
    // ----- DisplayAdapter class --------------------
    constexpr const char* const _type_name_DisplayAdapter = "DisplayAdapter";

    static PyObject* _new_DisplayAdapter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayAdapter);
        return nullptr;
    }

    static void _dealloc_DisplayAdapter(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayAdapter_FromId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DisplayAdapterId>(args, 0);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayAdapter::FromId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_DeviceInterfacePath(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInterfacePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_Id(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciDeviceId(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PciDeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciRevision(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PciRevision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciSubSystemId(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PciSubSystemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_PciVendorId(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PciVendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayAdapter_get_SourceCount(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayAdapter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayAdapter[] = {
        { "from_id", reinterpret_cast<PyCFunction>(DisplayAdapter_FromId), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayAdapter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayAdapter[] = {
        { "device_interface_path", reinterpret_cast<getter>(DisplayAdapter_get_DeviceInterfacePath), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(DisplayAdapter_get_Id), nullptr, nullptr, nullptr },
        { "pci_device_id", reinterpret_cast<getter>(DisplayAdapter_get_PciDeviceId), nullptr, nullptr, nullptr },
        { "pci_revision", reinterpret_cast<getter>(DisplayAdapter_get_PciRevision), nullptr, nullptr, nullptr },
        { "pci_sub_system_id", reinterpret_cast<getter>(DisplayAdapter_get_PciSubSystemId), nullptr, nullptr, nullptr },
        { "pci_vendor_id", reinterpret_cast<getter>(DisplayAdapter_get_PciVendorId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayAdapter_get_Properties), nullptr, nullptr, nullptr },
        { "source_count", reinterpret_cast<getter>(DisplayAdapter_get_SourceCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayAdapter[] = 
    {
        { Py_tp_new, _new_DisplayAdapter },
        { Py_tp_dealloc, _dealloc_DisplayAdapter },
        { Py_tp_methods, _methods_DisplayAdapter },
        { Py_tp_getset, _getset_DisplayAdapter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayAdapter =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayAdapter",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayAdapter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayAdapter
    };

    // ----- DisplayDevice class --------------------
    constexpr const char* const _type_name_DisplayDevice = "DisplayDevice";

    static PyObject* _new_DisplayDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayDevice);
        return nullptr;
    }

    static void _dealloc_DisplayDevice(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayDevice_CreatePeriodicFence(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(args, 1);

                return py::convert(self->obj.CreatePeriodicFence(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreatePrimary(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>(args, 1);

                return py::convert(self->obj.CreatePrimary(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateScanoutSource(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.CreateScanoutSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateSimpleScanout(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySurface>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);

                return py::convert(self->obj.CreateSimpleScanout(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateSimpleScanoutWithDirtyRectsAndOptions(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySource>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySurface>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<uint32_t>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Graphics::RectInt32>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayScanoutOptions>(args, 5);

                return py::convert(self->obj.CreateSimpleScanoutWithDirtyRectsAndOptions(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_CreateTaskPool(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateTaskPool());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_IsCapabilitySupported(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayDeviceCapability>(args, 0);

                return py::convert(self->obj.IsCapabilitySupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayDevice_WaitForVBlank(py::wrapper::Windows::Devices::Display::Core::DisplayDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplaySource>(args, 0);

                self->obj.WaitForVBlank(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_DisplayDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayDevice[] = {
        { "create_periodic_fence", reinterpret_cast<PyCFunction>(DisplayDevice_CreatePeriodicFence), METH_VARARGS, nullptr },
        { "create_primary", reinterpret_cast<PyCFunction>(DisplayDevice_CreatePrimary), METH_VARARGS, nullptr },
        { "create_scanout_source", reinterpret_cast<PyCFunction>(DisplayDevice_CreateScanoutSource), METH_VARARGS, nullptr },
        { "create_simple_scanout", reinterpret_cast<PyCFunction>(DisplayDevice_CreateSimpleScanout), METH_VARARGS, nullptr },
        { "create_simple_scanout_with_dirty_rects_and_options", reinterpret_cast<PyCFunction>(DisplayDevice_CreateSimpleScanoutWithDirtyRectsAndOptions), METH_VARARGS, nullptr },
        { "create_task_pool", reinterpret_cast<PyCFunction>(DisplayDevice_CreateTaskPool), METH_VARARGS, nullptr },
        { "is_capability_supported", reinterpret_cast<PyCFunction>(DisplayDevice_IsCapabilitySupported), METH_VARARGS, nullptr },
        { "wait_for_v_blank", reinterpret_cast<PyCFunction>(DisplayDevice_WaitForVBlank), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayDevice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayDevice[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayDevice[] = 
    {
        { Py_tp_new, _new_DisplayDevice },
        { Py_tp_dealloc, _dealloc_DisplayDevice },
        { Py_tp_methods, _methods_DisplayDevice },
        { Py_tp_getset, _getset_DisplayDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayDevice =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayDevice",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayDevice
    };

    // ----- DisplayFence class --------------------
    constexpr const char* const _type_name_DisplayFence = "DisplayFence";

    static PyObject* _new_DisplayFence(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayFence);
        return nullptr;
    }

    static void _dealloc_DisplayFence(py::wrapper::Windows::Devices::Display::Core::DisplayFence* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_DisplayFence(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayFence>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayFence[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayFence), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayFence[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayFence[] = 
    {
        { Py_tp_new, _new_DisplayFence },
        { Py_tp_dealloc, _dealloc_DisplayFence },
        { Py_tp_methods, _methods_DisplayFence },
        { Py_tp_getset, _getset_DisplayFence },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayFence =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayFence",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayFence),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayFence
    };

    // ----- DisplayManager class --------------------
    constexpr const char* const _type_name_DisplayManager = "DisplayManager";

    static PyObject* _new_DisplayManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayManager);
        return nullptr;
    }

    static void _dealloc_DisplayManager(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayManager_Close(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_Create(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayManagerOptions>(args, 0);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayManager::Create(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_CreateDisplayDevice(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayAdapter>(args, 0);

                return py::convert(self->obj.CreateDisplayDevice(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_GetCurrentAdapters(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentAdapters());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_GetCurrentTargets(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentTargets());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_ReleaseTarget(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                self->obj.ReleaseTarget(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_Start(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_Stop(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTarget(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.TryAcquireTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTargetsAndCreateEmptyState(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Display::Core::DisplayTarget>>(args, 0);

                return py::convert(self->obj.TryAcquireTargetsAndCreateEmptyState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTargetsAndCreateSubstate(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayState>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Display::Core::DisplayTarget>>(args, 1);

                return py::convert(self->obj.TryAcquireTargetsAndCreateSubstate(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryAcquireTargetsAndReadCurrentState(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Display::Core::DisplayTarget>>(args, 0);

                return py::convert(self->obj.TryAcquireTargetsAndReadCurrentState(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_TryReadCurrentStateForAllTargets(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryReadCurrentStateForAllTargets());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_Changed(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_Changed(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_Disabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>>(arg);

            return py::convert(self->obj.Disabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_Disabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Disabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_Enabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>>(arg);

            return py::convert(self->obj.Enabled(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_Enabled(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Enabled(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_add_PathsFailedOrInvalidated(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplayManager, winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>>(arg);

            return py::convert(self->obj.PathsFailedOrInvalidated(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManager_remove_PathsFailedOrInvalidated(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.PathsFailedOrInvalidated(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_DisplayManager(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_DisplayManager(py::wrapper::Windows::Devices::Display::Core::DisplayManager* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManager[] = {
        { "close", reinterpret_cast<PyCFunction>(DisplayManager_Close), METH_VARARGS, nullptr },
        { "create", reinterpret_cast<PyCFunction>(DisplayManager_Create), METH_VARARGS | METH_STATIC, nullptr },
        { "create_display_device", reinterpret_cast<PyCFunction>(DisplayManager_CreateDisplayDevice), METH_VARARGS, nullptr },
        { "get_current_adapters", reinterpret_cast<PyCFunction>(DisplayManager_GetCurrentAdapters), METH_VARARGS, nullptr },
        { "get_current_targets", reinterpret_cast<PyCFunction>(DisplayManager_GetCurrentTargets), METH_VARARGS, nullptr },
        { "release_target", reinterpret_cast<PyCFunction>(DisplayManager_ReleaseTarget), METH_VARARGS, nullptr },
        { "start", reinterpret_cast<PyCFunction>(DisplayManager_Start), METH_VARARGS, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(DisplayManager_Stop), METH_VARARGS, nullptr },
        { "try_acquire_target", reinterpret_cast<PyCFunction>(DisplayManager_TryAcquireTarget), METH_VARARGS, nullptr },
        { "try_acquire_targets_and_create_empty_state", reinterpret_cast<PyCFunction>(DisplayManager_TryAcquireTargetsAndCreateEmptyState), METH_VARARGS, nullptr },
        { "try_acquire_targets_and_create_substate", reinterpret_cast<PyCFunction>(DisplayManager_TryAcquireTargetsAndCreateSubstate), METH_VARARGS, nullptr },
        { "try_acquire_targets_and_read_current_state", reinterpret_cast<PyCFunction>(DisplayManager_TryAcquireTargetsAndReadCurrentState), METH_VARARGS, nullptr },
        { "try_read_current_state_for_all_targets", reinterpret_cast<PyCFunction>(DisplayManager_TryReadCurrentStateForAllTargets), METH_VARARGS, nullptr },
        { "add_changed", reinterpret_cast<PyCFunction>(DisplayManager_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(DisplayManager_remove_Changed), METH_O, nullptr },
        { "add_disabled", reinterpret_cast<PyCFunction>(DisplayManager_add_Disabled), METH_O, nullptr },
        { "remove_disabled", reinterpret_cast<PyCFunction>(DisplayManager_remove_Disabled), METH_O, nullptr },
        { "add_enabled", reinterpret_cast<PyCFunction>(DisplayManager_add_Enabled), METH_O, nullptr },
        { "remove_enabled", reinterpret_cast<PyCFunction>(DisplayManager_remove_Enabled), METH_O, nullptr },
        { "add_paths_failed_or_invalidated", reinterpret_cast<PyCFunction>(DisplayManager_add_PathsFailedOrInvalidated), METH_O, nullptr },
        { "remove_paths_failed_or_invalidated", reinterpret_cast<PyCFunction>(DisplayManager_remove_PathsFailedOrInvalidated), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManager), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_DisplayManager), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_DisplayManager), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManager[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayManager[] = 
    {
        { Py_tp_new, _new_DisplayManager },
        { Py_tp_dealloc, _dealloc_DisplayManager },
        { Py_tp_methods, _methods_DisplayManager },
        { Py_tp_getset, _getset_DisplayManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayManager =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayManager",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManager
    };

    // ----- DisplayManagerChangedEventArgs class --------------------
    constexpr const char* const _type_name_DisplayManagerChangedEventArgs = "DisplayManagerChangedEventArgs";

    static PyObject* _new_DisplayManagerChangedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayManagerChangedEventArgs);
        return nullptr;
    }

    static void _dealloc_DisplayManagerChangedEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayManagerChangedEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerChangedEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerChangedEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DisplayManagerChangedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerChangedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DisplayManagerChangedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerChangedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerChangedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DisplayManagerChangedEventArgs_get_Handled), reinterpret_cast<setter>(DisplayManagerChangedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerChangedEventArgs[] = 
    {
        { Py_tp_new, _new_DisplayManagerChangedEventArgs },
        { Py_tp_dealloc, _dealloc_DisplayManagerChangedEventArgs },
        { Py_tp_methods, _methods_DisplayManagerChangedEventArgs },
        { Py_tp_getset, _getset_DisplayManagerChangedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayManagerChangedEventArgs =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayManagerChangedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerChangedEventArgs
    };

    // ----- DisplayManagerDisabledEventArgs class --------------------
    constexpr const char* const _type_name_DisplayManagerDisabledEventArgs = "DisplayManagerDisabledEventArgs";

    static PyObject* _new_DisplayManagerDisabledEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayManagerDisabledEventArgs);
        return nullptr;
    }

    static void _dealloc_DisplayManagerDisabledEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayManagerDisabledEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerDisabledEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerDisabledEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DisplayManagerDisabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerDisabledEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DisplayManagerDisabledEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerDisabledEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerDisabledEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DisplayManagerDisabledEventArgs_get_Handled), reinterpret_cast<setter>(DisplayManagerDisabledEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerDisabledEventArgs[] = 
    {
        { Py_tp_new, _new_DisplayManagerDisabledEventArgs },
        { Py_tp_dealloc, _dealloc_DisplayManagerDisabledEventArgs },
        { Py_tp_methods, _methods_DisplayManagerDisabledEventArgs },
        { Py_tp_getset, _getset_DisplayManagerDisabledEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayManagerDisabledEventArgs =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayManagerDisabledEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerDisabledEventArgs
    };

    // ----- DisplayManagerEnabledEventArgs class --------------------
    constexpr const char* const _type_name_DisplayManagerEnabledEventArgs = "DisplayManagerEnabledEventArgs";

    static PyObject* _new_DisplayManagerEnabledEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayManagerEnabledEventArgs);
        return nullptr;
    }

    static void _dealloc_DisplayManagerEnabledEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayManagerEnabledEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerEnabledEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerEnabledEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DisplayManagerEnabledEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerEnabledEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DisplayManagerEnabledEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerEnabledEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerEnabledEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DisplayManagerEnabledEventArgs_get_Handled), reinterpret_cast<setter>(DisplayManagerEnabledEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerEnabledEventArgs[] = 
    {
        { Py_tp_new, _new_DisplayManagerEnabledEventArgs },
        { Py_tp_dealloc, _dealloc_DisplayManagerEnabledEventArgs },
        { Py_tp_methods, _methods_DisplayManagerEnabledEventArgs },
        { Py_tp_getset, _getset_DisplayManagerEnabledEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayManagerEnabledEventArgs =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayManagerEnabledEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerEnabledEventArgs
    };

    // ----- DisplayManagerPathsFailedOrInvalidatedEventArgs class --------------------
    constexpr const char* const _type_name_DisplayManagerPathsFailedOrInvalidatedEventArgs = "DisplayManagerPathsFailedOrInvalidatedEventArgs";

    static PyObject* _new_DisplayManagerPathsFailedOrInvalidatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayManagerPathsFailedOrInvalidatedEventArgs);
        return nullptr;
    }

    static void _dealloc_DisplayManagerPathsFailedOrInvalidatedEventArgs(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayManagerPathsFailedOrInvalidatedEventArgs_GetDeferral(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayManagerPathsFailedOrInvalidatedEventArgs_get_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Handled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayManagerPathsFailedOrInvalidatedEventArgs_put_Handled(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.Handled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DisplayManagerPathsFailedOrInvalidatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerPathsFailedOrInvalidatedEventArgs[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(DisplayManagerPathsFailedOrInvalidatedEventArgs_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerPathsFailedOrInvalidatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerPathsFailedOrInvalidatedEventArgs[] = {
        { "handled", reinterpret_cast<getter>(DisplayManagerPathsFailedOrInvalidatedEventArgs_get_Handled), reinterpret_cast<setter>(DisplayManagerPathsFailedOrInvalidatedEventArgs_put_Handled), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerPathsFailedOrInvalidatedEventArgs[] = 
    {
        { Py_tp_new, _new_DisplayManagerPathsFailedOrInvalidatedEventArgs },
        { Py_tp_dealloc, _dealloc_DisplayManagerPathsFailedOrInvalidatedEventArgs },
        { Py_tp_methods, _methods_DisplayManagerPathsFailedOrInvalidatedEventArgs },
        { Py_tp_getset, _getset_DisplayManagerPathsFailedOrInvalidatedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayManagerPathsFailedOrInvalidatedEventArgs =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayManagerPathsFailedOrInvalidatedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerPathsFailedOrInvalidatedEventArgs
    };

    // ----- DisplayManagerResultWithState class --------------------
    constexpr const char* const _type_name_DisplayManagerResultWithState = "DisplayManagerResultWithState";

    static PyObject* _new_DisplayManagerResultWithState(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayManagerResultWithState);
        return nullptr;
    }

    static void _dealloc_DisplayManagerResultWithState(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayManagerResultWithState_get_ErrorCode(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManagerResultWithState_get_ExtendedErrorCode(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayManagerResultWithState_get_State(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayManagerResultWithState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayManagerResultWithState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayManagerResultWithState[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayManagerResultWithState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayManagerResultWithState[] = {
        { "error_code", reinterpret_cast<getter>(DisplayManagerResultWithState_get_ErrorCode), nullptr, nullptr, nullptr },
        { "extended_error_code", reinterpret_cast<getter>(DisplayManagerResultWithState_get_ExtendedErrorCode), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(DisplayManagerResultWithState_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayManagerResultWithState[] = 
    {
        { Py_tp_new, _new_DisplayManagerResultWithState },
        { Py_tp_dealloc, _dealloc_DisplayManagerResultWithState },
        { Py_tp_methods, _methods_DisplayManagerResultWithState },
        { Py_tp_getset, _getset_DisplayManagerResultWithState },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayManagerResultWithState =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayManagerResultWithState",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayManagerResultWithState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayManagerResultWithState
    };

    // ----- DisplayModeInfo class --------------------
    constexpr const char* const _type_name_DisplayModeInfo = "DisplayModeInfo";

    static PyObject* _new_DisplayModeInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayModeInfo);
        return nullptr;
    }

    static void _dealloc_DisplayModeInfo(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayModeInfo_GetWireFormatSupportedBitsPerChannel(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatPixelEncoding>(args, 0);

                return py::convert(self->obj.GetWireFormatSupportedBitsPerChannel(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_IsWireFormatSupported(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormat>(args, 0);

                return py::convert(self->obj.IsWireFormatSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_IsInterlaced(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInterlaced());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStereo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_PresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_SourcePixelFormat(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourcePixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_SourceResolution(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_TargetResolution(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TargetResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayModeInfo_get_PhysicalPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalPresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayModeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayModeInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayModeInfo[] = {
        { "get_wire_format_supported_bits_per_channel", reinterpret_cast<PyCFunction>(DisplayModeInfo_GetWireFormatSupportedBitsPerChannel), METH_VARARGS, nullptr },
        { "is_wire_format_supported", reinterpret_cast<PyCFunction>(DisplayModeInfo_IsWireFormatSupported), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayModeInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayModeInfo[] = {
        { "is_interlaced", reinterpret_cast<getter>(DisplayModeInfo_get_IsInterlaced), nullptr, nullptr, nullptr },
        { "is_stereo", reinterpret_cast<getter>(DisplayModeInfo_get_IsStereo), nullptr, nullptr, nullptr },
        { "presentation_rate", reinterpret_cast<getter>(DisplayModeInfo_get_PresentationRate), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayModeInfo_get_Properties), nullptr, nullptr, nullptr },
        { "source_pixel_format", reinterpret_cast<getter>(DisplayModeInfo_get_SourcePixelFormat), nullptr, nullptr, nullptr },
        { "source_resolution", reinterpret_cast<getter>(DisplayModeInfo_get_SourceResolution), nullptr, nullptr, nullptr },
        { "target_resolution", reinterpret_cast<getter>(DisplayModeInfo_get_TargetResolution), nullptr, nullptr, nullptr },
        { "physical_presentation_rate", reinterpret_cast<getter>(DisplayModeInfo_get_PhysicalPresentationRate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayModeInfo[] = 
    {
        { Py_tp_new, _new_DisplayModeInfo },
        { Py_tp_dealloc, _dealloc_DisplayModeInfo },
        { Py_tp_methods, _methods_DisplayModeInfo },
        { Py_tp_getset, _getset_DisplayModeInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayModeInfo =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayModeInfo",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayModeInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayModeInfo
    };

    // ----- DisplayPath class --------------------
    constexpr const char* const _type_name_DisplayPath = "DisplayPath";

    static PyObject* _new_DisplayPath(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayPath);
        return nullptr;
    }

    static void _dealloc_DisplayPath(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayPath_ApplyPropertiesFromMode(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayModeInfo>(args, 0);

                self->obj.ApplyPropertiesFromMode(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayPath_FindModes(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayModeQueryOptions>(args, 0);

                return py::convert(self->obj.FindModes(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_WireFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WireFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_WireFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormat>(arg);

            self->obj.WireFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_TargetResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TargetResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_TargetResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::SizeInt32>>(arg);

            self->obj.TargetResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_SourceResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_SourceResolution(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::SizeInt32>>(arg);

            self->obj.SourceResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_SourcePixelFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourcePixelFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_SourcePixelFormat(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(arg);

            self->obj.SourcePixelFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_Scaling(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Scaling());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_Scaling(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayPathScaling>(arg);

            self->obj.Scaling(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_Rotation(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_Rotation(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayRotation>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_PresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_PresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>>(arg);

            self->obj.PresentationRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStereo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsStereo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_IsInterlaced(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInterlaced());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_IsInterlaced(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsInterlaced(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPath_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_Status(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_Target(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Target());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_View(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.View());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPath_get_PhysicalPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PhysicalPresentationRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPath_put_PhysicalPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPath* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>>(arg);

            self->obj.PhysicalPresentationRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_DisplayPath(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayPath>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayPath[] = {
        { "apply_properties_from_mode", reinterpret_cast<PyCFunction>(DisplayPath_ApplyPropertiesFromMode), METH_VARARGS, nullptr },
        { "find_modes", reinterpret_cast<PyCFunction>(DisplayPath_FindModes), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayPath), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayPath[] = {
        { "wire_format", reinterpret_cast<getter>(DisplayPath_get_WireFormat), reinterpret_cast<setter>(DisplayPath_put_WireFormat), nullptr, nullptr },
        { "target_resolution", reinterpret_cast<getter>(DisplayPath_get_TargetResolution), reinterpret_cast<setter>(DisplayPath_put_TargetResolution), nullptr, nullptr },
        { "source_resolution", reinterpret_cast<getter>(DisplayPath_get_SourceResolution), reinterpret_cast<setter>(DisplayPath_put_SourceResolution), nullptr, nullptr },
        { "source_pixel_format", reinterpret_cast<getter>(DisplayPath_get_SourcePixelFormat), reinterpret_cast<setter>(DisplayPath_put_SourcePixelFormat), nullptr, nullptr },
        { "scaling", reinterpret_cast<getter>(DisplayPath_get_Scaling), reinterpret_cast<setter>(DisplayPath_put_Scaling), nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(DisplayPath_get_Rotation), reinterpret_cast<setter>(DisplayPath_put_Rotation), nullptr, nullptr },
        { "presentation_rate", reinterpret_cast<getter>(DisplayPath_get_PresentationRate), reinterpret_cast<setter>(DisplayPath_put_PresentationRate), nullptr, nullptr },
        { "is_stereo", reinterpret_cast<getter>(DisplayPath_get_IsStereo), reinterpret_cast<setter>(DisplayPath_put_IsStereo), nullptr, nullptr },
        { "is_interlaced", reinterpret_cast<getter>(DisplayPath_get_IsInterlaced), reinterpret_cast<setter>(DisplayPath_put_IsInterlaced), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayPath_get_Properties), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DisplayPath_get_Status), nullptr, nullptr, nullptr },
        { "target", reinterpret_cast<getter>(DisplayPath_get_Target), nullptr, nullptr, nullptr },
        { "view", reinterpret_cast<getter>(DisplayPath_get_View), nullptr, nullptr, nullptr },
        { "physical_presentation_rate", reinterpret_cast<getter>(DisplayPath_get_PhysicalPresentationRate), reinterpret_cast<setter>(DisplayPath_put_PhysicalPresentationRate), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayPath[] = 
    {
        { Py_tp_new, _new_DisplayPath },
        { Py_tp_dealloc, _dealloc_DisplayPath },
        { Py_tp_methods, _methods_DisplayPath },
        { Py_tp_getset, _getset_DisplayPath },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayPath =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayPath",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayPath),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayPath
    };

    // ----- DisplayPrimaryDescription class --------------------
    constexpr const char* const _type_name_DisplayPrimaryDescription = "DisplayPrimaryDescription";

    static PyObject* _new_DisplayPrimaryDescription(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXColorSpace>(args, 3);
                auto param4 = py::convert_to<bool>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::Direct3DMultisampleDescription>(args, 5);

                winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription instance{ param0, param1, param2, param3, param4, param5 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DisplayPrimaryDescription(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayPrimaryDescription_CreateWithProperties(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::guid, winrt::Windows::Foundation::IInspectable>>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXPixelFormat>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Graphics::DirectX::DirectXColorSpace>(args, 4);
                auto param5 = py::convert_to<bool>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::Direct3DMultisampleDescription>(args, 6);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription::CreateWithProperties(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_ColorSpace(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorSpace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Format(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Format());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Height(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_IsStereo(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStereo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_MultisampleDescription(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MultisampleDescription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayPrimaryDescription_get_Width(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayPrimaryDescription(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayPrimaryDescription[] = {
        { "create_with_properties", reinterpret_cast<PyCFunction>(DisplayPrimaryDescription_CreateWithProperties), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayPrimaryDescription), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayPrimaryDescription[] = {
        { "color_space", reinterpret_cast<getter>(DisplayPrimaryDescription_get_ColorSpace), nullptr, nullptr, nullptr },
        { "format", reinterpret_cast<getter>(DisplayPrimaryDescription_get_Format), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(DisplayPrimaryDescription_get_Height), nullptr, nullptr, nullptr },
        { "is_stereo", reinterpret_cast<getter>(DisplayPrimaryDescription_get_IsStereo), nullptr, nullptr, nullptr },
        { "multisample_description", reinterpret_cast<getter>(DisplayPrimaryDescription_get_MultisampleDescription), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayPrimaryDescription_get_Properties), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(DisplayPrimaryDescription_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayPrimaryDescription[] = 
    {
        { Py_tp_new, _new_DisplayPrimaryDescription },
        { Py_tp_dealloc, _dealloc_DisplayPrimaryDescription },
        { Py_tp_methods, _methods_DisplayPrimaryDescription },
        { Py_tp_getset, _getset_DisplayPrimaryDescription },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayPrimaryDescription =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayPrimaryDescription",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayPrimaryDescription),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayPrimaryDescription
    };

    // ----- DisplayScanout class --------------------
    constexpr const char* const _type_name_DisplayScanout = "DisplayScanout";

    static PyObject* _new_DisplayScanout(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayScanout);
        return nullptr;
    }

    static void _dealloc_DisplayScanout(py::wrapper::Windows::Devices::Display::Core::DisplayScanout* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_DisplayScanout(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayScanout>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayScanout[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayScanout), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayScanout[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayScanout[] = 
    {
        { Py_tp_new, _new_DisplayScanout },
        { Py_tp_dealloc, _dealloc_DisplayScanout },
        { Py_tp_methods, _methods_DisplayScanout },
        { Py_tp_getset, _getset_DisplayScanout },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayScanout =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayScanout",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayScanout),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayScanout
    };

    // ----- DisplaySource class --------------------
    constexpr const char* const _type_name_DisplaySource = "DisplaySource";

    static PyObject* _new_DisplaySource(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplaySource);
        return nullptr;
    }

    static void _dealloc_DisplaySource(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplaySource_GetMetadata(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.GetMetadata(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplaySource_get_AdapterId(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_get_SourceId(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_get_Status(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_add_StatusChanged(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Display::Core::DisplaySource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplaySource_remove_StatusChanged(py::wrapper::Windows::Devices::Display::Core::DisplaySource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplaySource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplaySource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplaySource[] = {
        { "get_metadata", reinterpret_cast<PyCFunction>(DisplaySource_GetMetadata), METH_VARARGS, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(DisplaySource_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(DisplaySource_remove_StatusChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplaySource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplaySource[] = {
        { "adapter_id", reinterpret_cast<getter>(DisplaySource_get_AdapterId), nullptr, nullptr, nullptr },
        { "source_id", reinterpret_cast<getter>(DisplaySource_get_SourceId), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DisplaySource_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplaySource[] = 
    {
        { Py_tp_new, _new_DisplaySource },
        { Py_tp_dealloc, _dealloc_DisplaySource },
        { Py_tp_methods, _methods_DisplaySource },
        { Py_tp_getset, _getset_DisplaySource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplaySource =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplaySource",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplaySource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplaySource
    };

    // ----- DisplayState class --------------------
    constexpr const char* const _type_name_DisplayState = "DisplayState";

    static PyObject* _new_DisplayState(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayState);
        return nullptr;
    }

    static void _dealloc_DisplayState(py::wrapper::Windows::Devices::Display::Core::DisplayState* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayState_CanConnectTargetToView(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayView>(args, 1);

                return py::convert(self->obj.CanConnectTargetToView(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_Clone(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Clone());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_ConnectTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.ConnectTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayView>(args, 1);

                return py::convert(self->obj.ConnectTarget(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_DisconnectTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                self->obj.DisconnectTarget(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_GetPathForTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.GetPathForTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_GetViewForTarget(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.GetViewForTarget(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_TryApply(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayStateApplyOptions>(args, 0);

                return py::convert(self->obj.TryApply(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_TryFunctionalize(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayStateFunctionalizeOptions>(args, 0);

                return py::convert(self->obj.TryFunctionalize(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_IsReadOnly(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_IsStale(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_Targets(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Targets());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayState_get_Views(py::wrapper::Windows::Devices::Display::Core::DisplayState* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Views());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayState(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayState>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayState[] = {
        { "can_connect_target_to_view", reinterpret_cast<PyCFunction>(DisplayState_CanConnectTargetToView), METH_VARARGS, nullptr },
        { "clone", reinterpret_cast<PyCFunction>(DisplayState_Clone), METH_VARARGS, nullptr },
        { "connect_target", reinterpret_cast<PyCFunction>(DisplayState_ConnectTarget), METH_VARARGS, nullptr },
        { "disconnect_target", reinterpret_cast<PyCFunction>(DisplayState_DisconnectTarget), METH_VARARGS, nullptr },
        { "get_path_for_target", reinterpret_cast<PyCFunction>(DisplayState_GetPathForTarget), METH_VARARGS, nullptr },
        { "get_view_for_target", reinterpret_cast<PyCFunction>(DisplayState_GetViewForTarget), METH_VARARGS, nullptr },
        { "try_apply", reinterpret_cast<PyCFunction>(DisplayState_TryApply), METH_VARARGS, nullptr },
        { "try_functionalize", reinterpret_cast<PyCFunction>(DisplayState_TryFunctionalize), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayState), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayState[] = {
        { "is_read_only", reinterpret_cast<getter>(DisplayState_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "is_stale", reinterpret_cast<getter>(DisplayState_get_IsStale), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayState_get_Properties), nullptr, nullptr, nullptr },
        { "targets", reinterpret_cast<getter>(DisplayState_get_Targets), nullptr, nullptr, nullptr },
        { "views", reinterpret_cast<getter>(DisplayState_get_Views), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayState[] = 
    {
        { Py_tp_new, _new_DisplayState },
        { Py_tp_dealloc, _dealloc_DisplayState },
        { Py_tp_methods, _methods_DisplayState },
        { Py_tp_getset, _getset_DisplayState },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayState =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayState",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayState),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayState
    };

    // ----- DisplayStateOperationResult class --------------------
    constexpr const char* const _type_name_DisplayStateOperationResult = "DisplayStateOperationResult";

    static PyObject* _new_DisplayStateOperationResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayStateOperationResult);
        return nullptr;
    }

    static void _dealloc_DisplayStateOperationResult(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayStateOperationResult_get_ExtendedErrorCode(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayStateOperationResult_get_Status(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayStateOperationResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayStateOperationResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayStateOperationResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayStateOperationResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayStateOperationResult[] = {
        { "extended_error_code", reinterpret_cast<getter>(DisplayStateOperationResult_get_ExtendedErrorCode), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(DisplayStateOperationResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayStateOperationResult[] = 
    {
        { Py_tp_new, _new_DisplayStateOperationResult },
        { Py_tp_dealloc, _dealloc_DisplayStateOperationResult },
        { Py_tp_methods, _methods_DisplayStateOperationResult },
        { Py_tp_getset, _getset_DisplayStateOperationResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayStateOperationResult =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayStateOperationResult",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayStateOperationResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayStateOperationResult
    };

    // ----- DisplaySurface class --------------------
    constexpr const char* const _type_name_DisplaySurface = "DisplaySurface";

    static PyObject* _new_DisplaySurface(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplaySurface);
        return nullptr;
    }

    static void _dealloc_DisplaySurface(py::wrapper::Windows::Devices::Display::Core::DisplaySurface* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* _from_DisplaySurface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplaySurface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplaySurface[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplaySurface), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplaySurface[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplaySurface[] = 
    {
        { Py_tp_new, _new_DisplaySurface },
        { Py_tp_dealloc, _dealloc_DisplaySurface },
        { Py_tp_methods, _methods_DisplaySurface },
        { Py_tp_getset, _getset_DisplaySurface },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplaySurface =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplaySurface",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplaySurface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplaySurface
    };

    // ----- DisplayTarget class --------------------
    constexpr const char* const _type_name_DisplayTarget = "DisplayTarget";

    static PyObject* _new_DisplayTarget(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayTarget);
        return nullptr;
    }

    static void _dealloc_DisplayTarget(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayTarget_IsEqual(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.IsEqual(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_IsSame(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTarget>(args, 0);

                return py::convert(self->obj.IsSame(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_TryGetMonitor(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryGetMonitor());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_Adapter(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Adapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_AdapterRelativeId(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AdapterRelativeId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_DeviceInterfacePath(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInterfacePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsConnected(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsStale(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsStale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsVirtualModeEnabled(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVirtualModeEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_IsVirtualTopologyEnabled(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsVirtualTopologyEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_MonitorPersistence(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MonitorPersistence());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_StableMonitorId(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StableMonitorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTarget_get_UsageKind(py::wrapper::Windows::Devices::Display::Core::DisplayTarget* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsageKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayTarget(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTarget>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTarget[] = {
        { "is_equal", reinterpret_cast<PyCFunction>(DisplayTarget_IsEqual), METH_VARARGS, nullptr },
        { "is_same", reinterpret_cast<PyCFunction>(DisplayTarget_IsSame), METH_VARARGS, nullptr },
        { "try_get_monitor", reinterpret_cast<PyCFunction>(DisplayTarget_TryGetMonitor), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayTarget), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayTarget[] = {
        { "adapter", reinterpret_cast<getter>(DisplayTarget_get_Adapter), nullptr, nullptr, nullptr },
        { "adapter_relative_id", reinterpret_cast<getter>(DisplayTarget_get_AdapterRelativeId), nullptr, nullptr, nullptr },
        { "device_interface_path", reinterpret_cast<getter>(DisplayTarget_get_DeviceInterfacePath), nullptr, nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(DisplayTarget_get_IsConnected), nullptr, nullptr, nullptr },
        { "is_stale", reinterpret_cast<getter>(DisplayTarget_get_IsStale), nullptr, nullptr, nullptr },
        { "is_virtual_mode_enabled", reinterpret_cast<getter>(DisplayTarget_get_IsVirtualModeEnabled), nullptr, nullptr, nullptr },
        { "is_virtual_topology_enabled", reinterpret_cast<getter>(DisplayTarget_get_IsVirtualTopologyEnabled), nullptr, nullptr, nullptr },
        { "monitor_persistence", reinterpret_cast<getter>(DisplayTarget_get_MonitorPersistence), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayTarget_get_Properties), nullptr, nullptr, nullptr },
        { "stable_monitor_id", reinterpret_cast<getter>(DisplayTarget_get_StableMonitorId), nullptr, nullptr, nullptr },
        { "usage_kind", reinterpret_cast<getter>(DisplayTarget_get_UsageKind), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayTarget[] = 
    {
        { Py_tp_new, _new_DisplayTarget },
        { Py_tp_dealloc, _dealloc_DisplayTarget },
        { Py_tp_methods, _methods_DisplayTarget },
        { Py_tp_getset, _getset_DisplayTarget },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayTarget =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayTarget",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTarget),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTarget
    };

    // ----- DisplayTask class --------------------
    constexpr const char* const _type_name_DisplayTask = "DisplayTask";

    static PyObject* _new_DisplayTask(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayTask);
        return nullptr;
    }

    static void _dealloc_DisplayTask(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayTask_SetScanout(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayScanout>(args, 0);

                self->obj.SetScanout(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTask_SetSignal(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTaskSignalKind>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayFence>(args, 1);

                self->obj.SetSignal(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTask_SetWait(py::wrapper::Windows::Devices::Display::Core::DisplayTask* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayFence>(args, 0);
                auto param1 = py::convert_to<uint64_t>(args, 1);

                self->obj.SetWait(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_DisplayTask(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTask>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTask[] = {
        { "set_scanout", reinterpret_cast<PyCFunction>(DisplayTask_SetScanout), METH_VARARGS, nullptr },
        { "set_signal", reinterpret_cast<PyCFunction>(DisplayTask_SetSignal), METH_VARARGS, nullptr },
        { "set_wait", reinterpret_cast<PyCFunction>(DisplayTask_SetWait), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayTask), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayTask[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayTask[] = 
    {
        { Py_tp_new, _new_DisplayTask },
        { Py_tp_dealloc, _dealloc_DisplayTask },
        { Py_tp_methods, _methods_DisplayTask },
        { Py_tp_getset, _getset_DisplayTask },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayTask =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayTask",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTask),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTask
    };

    // ----- DisplayTaskPool class --------------------
    constexpr const char* const _type_name_DisplayTaskPool = "DisplayTaskPool";

    static PyObject* _new_DisplayTaskPool(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayTaskPool);
        return nullptr;
    }

    static void _dealloc_DisplayTaskPool(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayTaskPool_CreateTask(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CreateTask());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTaskPool_ExecuteTask(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTask>(args, 0);

                self->obj.ExecuteTask(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayTaskPool_TryExecuteTask(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayTask>(args, 0);

                return py::convert(self->obj.TryExecuteTask(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_DisplayTaskPool(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTaskPool>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTaskPool[] = {
        { "create_task", reinterpret_cast<PyCFunction>(DisplayTaskPool_CreateTask), METH_VARARGS, nullptr },
        { "execute_task", reinterpret_cast<PyCFunction>(DisplayTaskPool_ExecuteTask), METH_VARARGS, nullptr },
        { "try_execute_task", reinterpret_cast<PyCFunction>(DisplayTaskPool_TryExecuteTask), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayTaskPool), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayTaskPool[] = {
        { }
    };

    static PyType_Slot _type_slots_DisplayTaskPool[] = 
    {
        { Py_tp_new, _new_DisplayTaskPool },
        { Py_tp_dealloc, _dealloc_DisplayTaskPool },
        { Py_tp_methods, _methods_DisplayTaskPool },
        { Py_tp_getset, _getset_DisplayTaskPool },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayTaskPool =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayTaskPool",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTaskPool),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTaskPool
    };

    // ----- DisplayTaskResult class --------------------
    constexpr const char* const _type_name_DisplayTaskResult = "DisplayTaskResult";

    static PyObject* _new_DisplayTaskResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayTaskResult);
        return nullptr;
    }

    static void _dealloc_DisplayTaskResult(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayTaskResult_get_PresentId(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PresentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTaskResult_get_PresentStatus(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PresentStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayTaskResult_get_SourceStatus(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SourceStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayTaskResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayTaskResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayTaskResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayTaskResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayTaskResult[] = {
        { "present_id", reinterpret_cast<getter>(DisplayTaskResult_get_PresentId), nullptr, nullptr, nullptr },
        { "present_status", reinterpret_cast<getter>(DisplayTaskResult_get_PresentStatus), nullptr, nullptr, nullptr },
        { "source_status", reinterpret_cast<getter>(DisplayTaskResult_get_SourceStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayTaskResult[] = 
    {
        { Py_tp_new, _new_DisplayTaskResult },
        { Py_tp_dealloc, _dealloc_DisplayTaskResult },
        { Py_tp_methods, _methods_DisplayTaskResult },
        { Py_tp_getset, _getset_DisplayTaskResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayTaskResult =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayTaskResult",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayTaskResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayTaskResult
    };

    // ----- DisplayView class --------------------
    constexpr const char* const _type_name_DisplayView = "DisplayView";

    static PyObject* _new_DisplayView(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DisplayView);
        return nullptr;
    }

    static void _dealloc_DisplayView(py::wrapper::Windows::Devices::Display::Core::DisplayView* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayView_SetPrimaryPath(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayPath>(args, 0);

                self->obj.SetPrimaryPath(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayView_get_ContentResolution(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentResolution());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayView_put_ContentResolution(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Graphics::SizeInt32>>(arg);

            self->obj.ContentResolution(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayView_get_Paths(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Paths());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayView_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayView* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayView(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayView>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayView[] = {
        { "set_primary_path", reinterpret_cast<PyCFunction>(DisplayView_SetPrimaryPath), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayView), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayView[] = {
        { "content_resolution", reinterpret_cast<getter>(DisplayView_get_ContentResolution), reinterpret_cast<setter>(DisplayView_put_ContentResolution), nullptr, nullptr },
        { "paths", reinterpret_cast<getter>(DisplayView_get_Paths), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayView_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayView[] = 
    {
        { Py_tp_new, _new_DisplayView },
        { Py_tp_dealloc, _dealloc_DisplayView },
        { Py_tp_methods, _methods_DisplayView },
        { Py_tp_getset, _getset_DisplayView },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayView =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayView",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayView),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayView
    };

    // ----- DisplayWireFormat class --------------------
    constexpr const char* const _type_name_DisplayWireFormat = "DisplayWireFormat";

    static PyObject* _new_DisplayWireFormat(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatPixelEncoding>(args, 0);
                auto param1 = py::convert_to<int32_t>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatColorSpace>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatEotf>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatHdrMetadata>(args, 4);

                winrt::Windows::Devices::Display::Core::DisplayWireFormat instance{ param0, param1, param2, param3, param4 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_DisplayWireFormat(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DisplayWireFormat_CreateWithProperties(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Collections::IKeyValuePair<winrt::guid, winrt::Windows::Foundation::IInspectable>>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatPixelEncoding>(args, 1);
                auto param2 = py::convert_to<int32_t>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatColorSpace>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatEotf>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayWireFormatHdrMetadata>(args, 5);

                return py::convert(winrt::Windows::Devices::Display::Core::DisplayWireFormat::CreateWithProperties(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_BitsPerChannel(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitsPerChannel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_ColorSpace(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ColorSpace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_Eotf(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Eotf());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_HdrMetadata(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HdrMetadata());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_PixelEncoding(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelEncoding());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DisplayWireFormat_get_Properties(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DisplayWireFormat(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Display::Core::DisplayWireFormat>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DisplayWireFormat[] = {
        { "create_with_properties", reinterpret_cast<PyCFunction>(DisplayWireFormat_CreateWithProperties), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DisplayWireFormat), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DisplayWireFormat[] = {
        { "bits_per_channel", reinterpret_cast<getter>(DisplayWireFormat_get_BitsPerChannel), nullptr, nullptr, nullptr },
        { "color_space", reinterpret_cast<getter>(DisplayWireFormat_get_ColorSpace), nullptr, nullptr, nullptr },
        { "eotf", reinterpret_cast<getter>(DisplayWireFormat_get_Eotf), nullptr, nullptr, nullptr },
        { "hdr_metadata", reinterpret_cast<getter>(DisplayWireFormat_get_HdrMetadata), nullptr, nullptr, nullptr },
        { "pixel_encoding", reinterpret_cast<getter>(DisplayWireFormat_get_PixelEncoding), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(DisplayWireFormat_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayWireFormat[] = 
    {
        { Py_tp_new, _new_DisplayWireFormat },
        { Py_tp_dealloc, _dealloc_DisplayWireFormat },
        { Py_tp_methods, _methods_DisplayWireFormat },
        { Py_tp_getset, _getset_DisplayWireFormat },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayWireFormat =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayWireFormat",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayWireFormat),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayWireFormat
    };

    // ----- DisplayPresentationRate struct --------------------
    constexpr const char* const _type_name_DisplayPresentationRate = "DisplayPresentationRate";

    PyObject* _new_DisplayPresentationRate(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Devices::Display::Core::DisplayPresentationRate return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        PyObject* _VerticalSyncRate{};
        int32_t _VerticalSyncsPerPresentation{};

        static const char* kwlist[] = {"vertical_sync_rate", "vertical_syncs_per_presentation", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "Oi", const_cast<char**>(kwlist), &_VerticalSyncRate, &_VerticalSyncsPerPresentation))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Devices::Display::Core::DisplayPresentationRate return_value{ py::converter<winrt::Windows::Foundation::Numerics::Rational>::convert_to(_VerticalSyncRate), _VerticalSyncsPerPresentation };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_DisplayPresentationRate(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self)
    {
    }

    static PyObject* DisplayPresentationRate_get_VerticalSyncRate(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VerticalSyncRate);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPresentationRate_set_VerticalSyncRate(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.VerticalSyncRate = py::converter<winrt::Windows::Foundation::Numerics::Rational>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DisplayPresentationRate_get_VerticalSyncsPerPresentation(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VerticalSyncsPerPresentation);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DisplayPresentationRate_set_VerticalSyncsPerPresentation(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.VerticalSyncsPerPresentation = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_DisplayPresentationRate[] = {
        { "vertical_sync_rate", reinterpret_cast<getter>(DisplayPresentationRate_get_VerticalSyncRate), reinterpret_cast<setter>(DisplayPresentationRate_set_VerticalSyncRate), nullptr, nullptr },
        { "vertical_syncs_per_presentation", reinterpret_cast<getter>(DisplayPresentationRate_get_VerticalSyncsPerPresentation), reinterpret_cast<setter>(DisplayPresentationRate_set_VerticalSyncsPerPresentation), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DisplayPresentationRate[] = 
    {
        { Py_tp_new, _new_DisplayPresentationRate },
        { Py_tp_dealloc, _dealloc_DisplayPresentationRate },
        { Py_tp_getset, _getset_DisplayPresentationRate },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DisplayPresentationRate =
    {
        "_winsdk_Windows_Devices_Display_Core.DisplayPresentationRate",
        sizeof(py::wrapper::Windows::Devices::Display::Core::DisplayPresentationRate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DisplayPresentationRate
    };

    // ----- Windows.Devices.Display.Core Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayAdapter>::python_type = py::register_python_type(module, _type_name_DisplayAdapter, &_type_spec_DisplayAdapter, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayDevice>::python_type = py::register_python_type(module, _type_name_DisplayDevice, &_type_spec_DisplayDevice, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayFence>::python_type = py::register_python_type(module, _type_name_DisplayFence, &_type_spec_DisplayFence, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManager>::python_type = py::register_python_type(module, _type_name_DisplayManager, &_type_spec_DisplayManager, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerChangedEventArgs>::python_type = py::register_python_type(module, _type_name_DisplayManagerChangedEventArgs, &_type_spec_DisplayManagerChangedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerDisabledEventArgs>::python_type = py::register_python_type(module, _type_name_DisplayManagerDisabledEventArgs, &_type_spec_DisplayManagerDisabledEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerEnabledEventArgs>::python_type = py::register_python_type(module, _type_name_DisplayManagerEnabledEventArgs, &_type_spec_DisplayManagerEnabledEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerPathsFailedOrInvalidatedEventArgs>::python_type = py::register_python_type(module, _type_name_DisplayManagerPathsFailedOrInvalidatedEventArgs, &_type_spec_DisplayManagerPathsFailedOrInvalidatedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayManagerResultWithState>::python_type = py::register_python_type(module, _type_name_DisplayManagerResultWithState, &_type_spec_DisplayManagerResultWithState, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayModeInfo>::python_type = py::register_python_type(module, _type_name_DisplayModeInfo, &_type_spec_DisplayModeInfo, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPath>::python_type = py::register_python_type(module, _type_name_DisplayPath, &_type_spec_DisplayPath, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPrimaryDescription>::python_type = py::register_python_type(module, _type_name_DisplayPrimaryDescription, &_type_spec_DisplayPrimaryDescription, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayScanout>::python_type = py::register_python_type(module, _type_name_DisplayScanout, &_type_spec_DisplayScanout, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplaySource>::python_type = py::register_python_type(module, _type_name_DisplaySource, &_type_spec_DisplaySource, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayState>::python_type = py::register_python_type(module, _type_name_DisplayState, &_type_spec_DisplayState, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayStateOperationResult>::python_type = py::register_python_type(module, _type_name_DisplayStateOperationResult, &_type_spec_DisplayStateOperationResult, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplaySurface>::python_type = py::register_python_type(module, _type_name_DisplaySurface, &_type_spec_DisplaySurface, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTarget>::python_type = py::register_python_type(module, _type_name_DisplayTarget, &_type_spec_DisplayTarget, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTask>::python_type = py::register_python_type(module, _type_name_DisplayTask, &_type_spec_DisplayTask, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTaskPool>::python_type = py::register_python_type(module, _type_name_DisplayTaskPool, &_type_spec_DisplayTaskPool, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayTaskResult>::python_type = py::register_python_type(module, _type_name_DisplayTaskResult, &_type_spec_DisplayTaskResult, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayView>::python_type = py::register_python_type(module, _type_name_DisplayView, &_type_spec_DisplayView, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayWireFormat>::python_type = py::register_python_type(module, _type_name_DisplayWireFormat, &_type_spec_DisplayWireFormat, bases.get());
            py::winrt_type<winrt::Windows::Devices::Display::Core::DisplayPresentationRate>::python_type = py::register_python_type(module, _type_name_DisplayPresentationRate, &_type_spec_DisplayPresentationRate, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Devices.Display.Core");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Display_Core",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Devices::Display::Core

PyMODINIT_FUNC
PyInit__winsdk_Windows_Devices_Display_Core (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::Display::Core::module_def);
}
