// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Services.Store.h"

PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreAcquireLicenseResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreAppLicense>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreAvailability>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreCollectionData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreConsumableResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreContext>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreImage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreLicense>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageInstallOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageLicense>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdate>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdateResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePrice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProduct>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProductOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProductPagedQueryResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProductQueryResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreProductResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePurchaseProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePurchaseResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreQueueItem>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreQueueItemStatus>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreRateAndReviewResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreRequestHelper>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreSendRequestResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreSku>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreSubscriptionInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StoreVideo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdateStatus>::python_type;

PyObject* py::converter<winrt::Windows::Services::Store::StorePackageUpdateStatus>::convert(winrt::Windows::Services::Store::StorePackageUpdateStatus instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Services::Store::StorePackageUpdateStatus>());
}
winrt::Windows::Services::Store::StorePackageUpdateStatus py::converter<winrt::Windows::Services::Store::StorePackageUpdateStatus>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Services::Store::StorePackageUpdateStatus>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Services::Store::StorePackageUpdateStatus>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Services::Store::StorePackageUpdateStatus return_value{};

    PyObject* py_PackageFamilyName = PyDict_GetItemString(obj, "package_family_name");
    if (!py_PackageFamilyName) { throw winrt::hresult_invalid_argument(); }
    return_value.PackageFamilyName = converter<winrt::hstring>::convert_to(py_PackageFamilyName);

    PyObject* py_PackageDownloadSizeInBytes = PyDict_GetItemString(obj, "package_download_size_in_bytes");
    if (!py_PackageDownloadSizeInBytes) { throw winrt::hresult_invalid_argument(); }
    return_value.PackageDownloadSizeInBytes = converter<uint64_t>::convert_to(py_PackageDownloadSizeInBytes);

    PyObject* py_PackageBytesDownloaded = PyDict_GetItemString(obj, "package_bytes_downloaded");
    if (!py_PackageBytesDownloaded) { throw winrt::hresult_invalid_argument(); }
    return_value.PackageBytesDownloaded = converter<uint64_t>::convert_to(py_PackageBytesDownloaded);

    PyObject* py_PackageDownloadProgress = PyDict_GetItemString(obj, "package_download_progress");
    if (!py_PackageDownloadProgress) { throw winrt::hresult_invalid_argument(); }
    return_value.PackageDownloadProgress = converter<double>::convert_to(py_PackageDownloadProgress);

    PyObject* py_TotalDownloadProgress = PyDict_GetItemString(obj, "total_download_progress");
    if (!py_TotalDownloadProgress) { throw winrt::hresult_invalid_argument(); }
    return_value.TotalDownloadProgress = converter<double>::convert_to(py_TotalDownloadProgress);

    PyObject* py_PackageUpdateState = PyDict_GetItemString(obj, "package_update_state");
    if (!py_PackageUpdateState) { throw winrt::hresult_invalid_argument(); }
    return_value.PackageUpdateState = converter<winrt::Windows::Services::Store::StorePackageUpdateState>::convert_to(py_PackageUpdateState);

    return return_value;
}

namespace py::cpp::Windows::Services::Store
{
    // ----- StoreAcquireLicenseResult class --------------------
    constexpr const char* const _type_name_StoreAcquireLicenseResult = "StoreAcquireLicenseResult";

    static PyObject* _new_StoreAcquireLicenseResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreAcquireLicenseResult);
        return nullptr;
    }

    static void _dealloc_StoreAcquireLicenseResult(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreAcquireLicenseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAcquireLicenseResult_get_StorePackageLicense(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StorePackageLicense());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAcquireLicenseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAcquireLicenseResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreAcquireLicenseResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreAcquireLicenseResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreAcquireLicenseResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "store_package_license", reinterpret_cast<getter>(StoreAcquireLicenseResult_get_StorePackageLicense), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreAcquireLicenseResult[] = 
    {
        { Py_tp_new, _new_StoreAcquireLicenseResult },
        { Py_tp_dealloc, _dealloc_StoreAcquireLicenseResult },
        { Py_tp_methods, _methods_StoreAcquireLicenseResult },
        { Py_tp_getset, _getset_StoreAcquireLicenseResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreAcquireLicenseResult =
    {
        "_winsdk_Windows_Services_Store.StoreAcquireLicenseResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreAcquireLicenseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAcquireLicenseResult
    };

    // ----- StoreAppLicense class --------------------
    constexpr const char* const _type_name_StoreAppLicense = "StoreAppLicense";

    static PyObject* _new_StoreAppLicense(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreAppLicense);
        return nullptr;
    }

    static void _dealloc_StoreAppLicense(py::wrapper::Windows::Services::Store::StoreAppLicense* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreAppLicense_get_AddOnLicenses(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AddOnLicenses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_ExpirationDate(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsActive(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsTrial(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTrial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsTrialOwnedByThisUser(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTrialOwnedByThisUser());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_SkuStoreId(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SkuStoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_TrialTimeRemaining(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrialTimeRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_TrialUniqueId(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrialUniqueId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAppLicense_get_IsDiscLicense(py::wrapper::Windows::Services::Store::StoreAppLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDiscLicense());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreAppLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAppLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAppLicense[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreAppLicense), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreAppLicense[] = {
        { "add_on_licenses", reinterpret_cast<getter>(StoreAppLicense_get_AddOnLicenses), nullptr, nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(StoreAppLicense_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreAppLicense_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(StoreAppLicense_get_IsActive), nullptr, nullptr, nullptr },
        { "is_trial", reinterpret_cast<getter>(StoreAppLicense_get_IsTrial), nullptr, nullptr, nullptr },
        { "is_trial_owned_by_this_user", reinterpret_cast<getter>(StoreAppLicense_get_IsTrialOwnedByThisUser), nullptr, nullptr, nullptr },
        { "sku_store_id", reinterpret_cast<getter>(StoreAppLicense_get_SkuStoreId), nullptr, nullptr, nullptr },
        { "trial_time_remaining", reinterpret_cast<getter>(StoreAppLicense_get_TrialTimeRemaining), nullptr, nullptr, nullptr },
        { "trial_unique_id", reinterpret_cast<getter>(StoreAppLicense_get_TrialUniqueId), nullptr, nullptr, nullptr },
        { "is_disc_license", reinterpret_cast<getter>(StoreAppLicense_get_IsDiscLicense), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreAppLicense[] = 
    {
        { Py_tp_new, _new_StoreAppLicense },
        { Py_tp_dealloc, _dealloc_StoreAppLicense },
        { Py_tp_methods, _methods_StoreAppLicense },
        { Py_tp_getset, _getset_StoreAppLicense },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreAppLicense =
    {
        "_winsdk_Windows_Services_Store.StoreAppLicense",
        sizeof(py::wrapper::Windows::Services::Store::StoreAppLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAppLicense
    };

    // ----- StoreAvailability class --------------------
    constexpr const char* const _type_name_StoreAvailability = "StoreAvailability";

    static PyObject* _new_StoreAvailability(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreAvailability);
        return nullptr;
    }

    static void _dealloc_StoreAvailability(py::wrapper::Windows::Services::Store::StoreAvailability* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreAvailability_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreAvailability* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestPurchaseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_EndDate(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_Price(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Price());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreAvailability_get_StoreId(py::wrapper::Windows::Services::Store::StoreAvailability* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreAvailability(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreAvailability>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreAvailability[] = {
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreAvailability_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreAvailability), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreAvailability[] = {
        { "end_date", reinterpret_cast<getter>(StoreAvailability_get_EndDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreAvailability_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(StoreAvailability_get_Price), nullptr, nullptr, nullptr },
        { "store_id", reinterpret_cast<getter>(StoreAvailability_get_StoreId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreAvailability[] = 
    {
        { Py_tp_new, _new_StoreAvailability },
        { Py_tp_dealloc, _dealloc_StoreAvailability },
        { Py_tp_methods, _methods_StoreAvailability },
        { Py_tp_getset, _getset_StoreAvailability },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreAvailability =
    {
        "_winsdk_Windows_Services_Store.StoreAvailability",
        sizeof(py::wrapper::Windows::Services::Store::StoreAvailability),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreAvailability
    };

    // ----- StoreCanAcquireLicenseResult class --------------------
    constexpr const char* const _type_name_StoreCanAcquireLicenseResult = "StoreCanAcquireLicenseResult";

    static PyObject* _new_StoreCanAcquireLicenseResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreCanAcquireLicenseResult);
        return nullptr;
    }

    static void _dealloc_StoreCanAcquireLicenseResult(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreCanAcquireLicenseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCanAcquireLicenseResult_get_LicensableSku(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LicensableSku());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCanAcquireLicenseResult_get_Status(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreCanAcquireLicenseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreCanAcquireLicenseResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreCanAcquireLicenseResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreCanAcquireLicenseResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreCanAcquireLicenseResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "licensable_sku", reinterpret_cast<getter>(StoreCanAcquireLicenseResult_get_LicensableSku), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreCanAcquireLicenseResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreCanAcquireLicenseResult[] = 
    {
        { Py_tp_new, _new_StoreCanAcquireLicenseResult },
        { Py_tp_dealloc, _dealloc_StoreCanAcquireLicenseResult },
        { Py_tp_methods, _methods_StoreCanAcquireLicenseResult },
        { Py_tp_getset, _getset_StoreCanAcquireLicenseResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreCanAcquireLicenseResult =
    {
        "_winsdk_Windows_Services_Store.StoreCanAcquireLicenseResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreCanAcquireLicenseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreCanAcquireLicenseResult
    };

    // ----- StoreCollectionData class --------------------
    constexpr const char* const _type_name_StoreCollectionData = "StoreCollectionData";

    static PyObject* _new_StoreCollectionData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreCollectionData);
        return nullptr;
    }

    static void _dealloc_StoreCollectionData(py::wrapper::Windows::Services::Store::StoreCollectionData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreCollectionData_get_AcquiredDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AcquiredDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_CampaignId(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CampaignId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_DeveloperOfferId(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeveloperOfferId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_EndDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_IsTrial(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTrial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_StartDate(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreCollectionData_get_TrialTimeRemaining(py::wrapper::Windows::Services::Store::StoreCollectionData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrialTimeRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreCollectionData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreCollectionData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreCollectionData[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreCollectionData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreCollectionData[] = {
        { "acquired_date", reinterpret_cast<getter>(StoreCollectionData_get_AcquiredDate), nullptr, nullptr, nullptr },
        { "campaign_id", reinterpret_cast<getter>(StoreCollectionData_get_CampaignId), nullptr, nullptr, nullptr },
        { "developer_offer_id", reinterpret_cast<getter>(StoreCollectionData_get_DeveloperOfferId), nullptr, nullptr, nullptr },
        { "end_date", reinterpret_cast<getter>(StoreCollectionData_get_EndDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreCollectionData_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "is_trial", reinterpret_cast<getter>(StoreCollectionData_get_IsTrial), nullptr, nullptr, nullptr },
        { "start_date", reinterpret_cast<getter>(StoreCollectionData_get_StartDate), nullptr, nullptr, nullptr },
        { "trial_time_remaining", reinterpret_cast<getter>(StoreCollectionData_get_TrialTimeRemaining), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreCollectionData[] = 
    {
        { Py_tp_new, _new_StoreCollectionData },
        { Py_tp_dealloc, _dealloc_StoreCollectionData },
        { Py_tp_methods, _methods_StoreCollectionData },
        { Py_tp_getset, _getset_StoreCollectionData },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreCollectionData =
    {
        "_winsdk_Windows_Services_Store.StoreCollectionData",
        sizeof(py::wrapper::Windows::Services::Store::StoreCollectionData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreCollectionData
    };

    // ----- StoreConsumableResult class --------------------
    constexpr const char* const _type_name_StoreConsumableResult = "StoreConsumableResult";

    static PyObject* _new_StoreConsumableResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreConsumableResult);
        return nullptr;
    }

    static void _dealloc_StoreConsumableResult(py::wrapper::Windows::Services::Store::StoreConsumableResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreConsumableResult_get_BalanceRemaining(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BalanceRemaining());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_Status(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreConsumableResult_get_TrackingId(py::wrapper::Windows::Services::Store::StoreConsumableResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrackingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreConsumableResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreConsumableResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreConsumableResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreConsumableResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreConsumableResult[] = {
        { "balance_remaining", reinterpret_cast<getter>(StoreConsumableResult_get_BalanceRemaining), nullptr, nullptr, nullptr },
        { "extended_error", reinterpret_cast<getter>(StoreConsumableResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreConsumableResult_get_Status), nullptr, nullptr, nullptr },
        { "tracking_id", reinterpret_cast<getter>(StoreConsumableResult_get_TrackingId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreConsumableResult[] = 
    {
        { Py_tp_new, _new_StoreConsumableResult },
        { Py_tp_dealloc, _dealloc_StoreConsumableResult },
        { Py_tp_methods, _methods_StoreConsumableResult },
        { Py_tp_getset, _getset_StoreConsumableResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreConsumableResult =
    {
        "_winsdk_Windows_Services_Store.StoreConsumableResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreConsumableResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreConsumableResult
    };

    // ----- StoreContext class --------------------
    constexpr const char* const _type_name_StoreContext = "StoreContext";

    static PyObject* _new_StoreContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreContext);
        return nullptr;
    }

    static void _dealloc_StoreContext(py::wrapper::Windows::Services::Store::StoreContext* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreContext_AcquireStoreLicenseForOptionalPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.AcquireStoreLicenseForOptionalPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_CanAcquireStoreLicenseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.CanAcquireStoreLicenseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_CanAcquireStoreLicenseForOptionalPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.CanAcquireStoreLicenseForOptionalPackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_DownloadAndInstallStorePackagesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.DownloadAndInstallStorePackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_FindStoreProductForPackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 1);

                return py::convert(self->obj.FindStoreProductForPackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAppAndOptionalStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAppAndOptionalStorePackageUpdatesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAppLicenseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAppLicenseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreProductsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetAssociatedStoreProductsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreProductsWithPagingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetAssociatedStoreProductsWithPagingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetAssociatedStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAssociatedStoreQueueItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetConsumableBalanceRemainingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetConsumableBalanceRemainingAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetCustomerCollectionsIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetCustomerCollectionsIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetCustomerPurchaseIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.GetCustomerPurchaseIdAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Services::Store::StoreContext::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::Services::Store::StoreContext::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreProductForCurrentAppAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStoreProductForCurrentAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreProductsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);

                return py::convert(self->obj.GetStoreProductsAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Services::Store::StoreProductOptions>(args, 2);

                return py::convert(self->obj.GetStoreProductsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetStoreQueueItemsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetUserCollectionAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.GetUserCollectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_GetUserCollectionWithPagingAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(self->obj.GetUserCollectionWithPagingAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_ReportConsumableFulfillmentAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                return py::convert(self->obj.ReportConsumableFulfillmentAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadAndInstallStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.RequestDownloadAndInstallStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadAndInstallStorePackagesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);

                return py::convert(self->obj.RequestDownloadAndInstallStorePackagesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Services::Store::StorePackageInstallOptions>(args, 1);

                return py::convert(self->obj.RequestDownloadAndInstallStorePackagesAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestDownloadStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.RequestDownloadStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 1);

                return py::convert(self->obj.RequestPurchaseAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestRateAndReviewAppAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestRateAndReviewAppAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestUninstallStorePackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.RequestUninstallStorePackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_RequestUninstallStorePackageByStoreIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RequestUninstallStorePackageByStoreIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_SetInstallOrderForAssociatedStoreQueueItemsAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StoreQueueItem>>(args, 0);

                return py::convert(self->obj.SetInstallOrderForAssociatedStoreQueueItemsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_TrySilentDownloadAndInstallStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.TrySilentDownloadAndInstallStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_TrySilentDownloadStorePackageUpdatesAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Services::Store::StorePackageUpdate>>(args, 0);

                return py::convert(self->obj.TrySilentDownloadStorePackageUpdatesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_UninstallStorePackageAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);

                return py::convert(self->obj.UninstallStorePackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_UninstallStorePackageByStoreIdAsync(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.UninstallStorePackageByStoreIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreContext_get_User(py::wrapper::Windows::Services::Store::StoreContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_get_CanSilentlyDownloadStorePackageUpdates(py::wrapper::Windows::Services::Store::StoreContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanSilentlyDownloadStorePackageUpdates());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_add_OfflineLicensesChanged(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreContext, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.OfflineLicensesChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreContext_remove_OfflineLicensesChanged(py::wrapper::Windows::Services::Store::StoreContext* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.OfflineLicensesChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreContext[] = {
        { "acquire_store_license_for_optional_package_async", reinterpret_cast<PyCFunction>(StoreContext_AcquireStoreLicenseForOptionalPackageAsync), METH_VARARGS, nullptr },
        { "can_acquire_store_license_async", reinterpret_cast<PyCFunction>(StoreContext_CanAcquireStoreLicenseAsync), METH_VARARGS, nullptr },
        { "can_acquire_store_license_for_optional_package_async", reinterpret_cast<PyCFunction>(StoreContext_CanAcquireStoreLicenseForOptionalPackageAsync), METH_VARARGS, nullptr },
        { "download_and_install_store_packages_async", reinterpret_cast<PyCFunction>(StoreContext_DownloadAndInstallStorePackagesAsync), METH_VARARGS, nullptr },
        { "find_store_product_for_package_async", reinterpret_cast<PyCFunction>(StoreContext_FindStoreProductForPackageAsync), METH_VARARGS, nullptr },
        { "get_app_and_optional_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_GetAppAndOptionalStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "get_app_license_async", reinterpret_cast<PyCFunction>(StoreContext_GetAppLicenseAsync), METH_VARARGS, nullptr },
        { "get_associated_store_products_async", reinterpret_cast<PyCFunction>(StoreContext_GetAssociatedStoreProductsAsync), METH_VARARGS, nullptr },
        { "get_associated_store_products_with_paging_async", reinterpret_cast<PyCFunction>(StoreContext_GetAssociatedStoreProductsWithPagingAsync), METH_VARARGS, nullptr },
        { "get_associated_store_queue_items_async", reinterpret_cast<PyCFunction>(StoreContext_GetAssociatedStoreQueueItemsAsync), METH_VARARGS, nullptr },
        { "get_consumable_balance_remaining_async", reinterpret_cast<PyCFunction>(StoreContext_GetConsumableBalanceRemainingAsync), METH_VARARGS, nullptr },
        { "get_customer_collections_id_async", reinterpret_cast<PyCFunction>(StoreContext_GetCustomerCollectionsIdAsync), METH_VARARGS, nullptr },
        { "get_customer_purchase_id_async", reinterpret_cast<PyCFunction>(StoreContext_GetCustomerPurchaseIdAsync), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(StoreContext_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(StoreContext_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "get_store_product_for_current_app_async", reinterpret_cast<PyCFunction>(StoreContext_GetStoreProductForCurrentAppAsync), METH_VARARGS, nullptr },
        { "get_store_products_async", reinterpret_cast<PyCFunction>(StoreContext_GetStoreProductsAsync), METH_VARARGS, nullptr },
        { "get_store_queue_items_async", reinterpret_cast<PyCFunction>(StoreContext_GetStoreQueueItemsAsync), METH_VARARGS, nullptr },
        { "get_user_collection_async", reinterpret_cast<PyCFunction>(StoreContext_GetUserCollectionAsync), METH_VARARGS, nullptr },
        { "get_user_collection_with_paging_async", reinterpret_cast<PyCFunction>(StoreContext_GetUserCollectionWithPagingAsync), METH_VARARGS, nullptr },
        { "report_consumable_fulfillment_async", reinterpret_cast<PyCFunction>(StoreContext_ReportConsumableFulfillmentAsync), METH_VARARGS, nullptr },
        { "request_download_and_install_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_RequestDownloadAndInstallStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "request_download_and_install_store_packages_async", reinterpret_cast<PyCFunction>(StoreContext_RequestDownloadAndInstallStorePackagesAsync), METH_VARARGS, nullptr },
        { "request_download_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_RequestDownloadStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreContext_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "request_rate_and_review_app_async", reinterpret_cast<PyCFunction>(StoreContext_RequestRateAndReviewAppAsync), METH_VARARGS, nullptr },
        { "request_uninstall_store_package_async", reinterpret_cast<PyCFunction>(StoreContext_RequestUninstallStorePackageAsync), METH_VARARGS, nullptr },
        { "request_uninstall_store_package_by_store_id_async", reinterpret_cast<PyCFunction>(StoreContext_RequestUninstallStorePackageByStoreIdAsync), METH_VARARGS, nullptr },
        { "set_install_order_for_associated_store_queue_items_async", reinterpret_cast<PyCFunction>(StoreContext_SetInstallOrderForAssociatedStoreQueueItemsAsync), METH_VARARGS, nullptr },
        { "try_silent_download_and_install_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_TrySilentDownloadAndInstallStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "try_silent_download_store_package_updates_async", reinterpret_cast<PyCFunction>(StoreContext_TrySilentDownloadStorePackageUpdatesAsync), METH_VARARGS, nullptr },
        { "uninstall_store_package_async", reinterpret_cast<PyCFunction>(StoreContext_UninstallStorePackageAsync), METH_VARARGS, nullptr },
        { "uninstall_store_package_by_store_id_async", reinterpret_cast<PyCFunction>(StoreContext_UninstallStorePackageByStoreIdAsync), METH_VARARGS, nullptr },
        { "add_offline_licenses_changed", reinterpret_cast<PyCFunction>(StoreContext_add_OfflineLicensesChanged), METH_O, nullptr },
        { "remove_offline_licenses_changed", reinterpret_cast<PyCFunction>(StoreContext_remove_OfflineLicensesChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreContext[] = {
        { "user", reinterpret_cast<getter>(StoreContext_get_User), nullptr, nullptr, nullptr },
        { "can_silently_download_store_package_updates", reinterpret_cast<getter>(StoreContext_get_CanSilentlyDownloadStorePackageUpdates), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreContext[] = 
    {
        { Py_tp_new, _new_StoreContext },
        { Py_tp_dealloc, _dealloc_StoreContext },
        { Py_tp_methods, _methods_StoreContext },
        { Py_tp_getset, _getset_StoreContext },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreContext =
    {
        "_winsdk_Windows_Services_Store.StoreContext",
        sizeof(py::wrapper::Windows::Services::Store::StoreContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreContext
    };

    // ----- StoreImage class --------------------
    constexpr const char* const _type_name_StoreImage = "StoreImage";

    static PyObject* _new_StoreImage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreImage);
        return nullptr;
    }

    static void _dealloc_StoreImage(py::wrapper::Windows::Services::Store::StoreImage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreImage_get_Caption(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Caption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Height(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_ImagePurposeTag(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ImagePurposeTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Uri(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreImage_get_Width(py::wrapper::Windows::Services::Store::StoreImage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreImage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreImage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreImage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreImage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreImage[] = {
        { "caption", reinterpret_cast<getter>(StoreImage_get_Caption), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(StoreImage_get_Height), nullptr, nullptr, nullptr },
        { "image_purpose_tag", reinterpret_cast<getter>(StoreImage_get_ImagePurposeTag), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(StoreImage_get_Uri), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(StoreImage_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreImage[] = 
    {
        { Py_tp_new, _new_StoreImage },
        { Py_tp_dealloc, _dealloc_StoreImage },
        { Py_tp_methods, _methods_StoreImage },
        { Py_tp_getset, _getset_StoreImage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreImage =
    {
        "_winsdk_Windows_Services_Store.StoreImage",
        sizeof(py::wrapper::Windows::Services::Store::StoreImage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreImage
    };

    // ----- StoreLicense class --------------------
    constexpr const char* const _type_name_StoreLicense = "StoreLicense";

    static PyObject* _new_StoreLicense(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreLicense);
        return nullptr;
    }

    static void _dealloc_StoreLicense(py::wrapper::Windows::Services::Store::StoreLicense* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreLicense_get_ExpirationDate(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_InAppOfferToken(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InAppOfferToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_IsActive(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsActive());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreLicense_get_SkuStoreId(py::wrapper::Windows::Services::Store::StoreLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SkuStoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreLicense[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreLicense), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreLicense[] = {
        { "expiration_date", reinterpret_cast<getter>(StoreLicense_get_ExpirationDate), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreLicense_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "in_app_offer_token", reinterpret_cast<getter>(StoreLicense_get_InAppOfferToken), nullptr, nullptr, nullptr },
        { "is_active", reinterpret_cast<getter>(StoreLicense_get_IsActive), nullptr, nullptr, nullptr },
        { "sku_store_id", reinterpret_cast<getter>(StoreLicense_get_SkuStoreId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreLicense[] = 
    {
        { Py_tp_new, _new_StoreLicense },
        { Py_tp_dealloc, _dealloc_StoreLicense },
        { Py_tp_methods, _methods_StoreLicense },
        { Py_tp_getset, _getset_StoreLicense },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreLicense =
    {
        "_winsdk_Windows_Services_Store.StoreLicense",
        sizeof(py::wrapper::Windows::Services::Store::StoreLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreLicense
    };

    // ----- StorePackageInstallOptions class --------------------
    constexpr const char* const _type_name_StorePackageInstallOptions = "StorePackageInstallOptions";

    static PyObject* _new_StorePackageInstallOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StorePackageInstallOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorePackageInstallOptions(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorePackageInstallOptions_get_AllowForcedAppRestart(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowForcedAppRestart());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageInstallOptions_put_AllowForcedAppRestart(py::wrapper::Windows::Services::Store::StorePackageInstallOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowForcedAppRestart(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorePackageInstallOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageInstallOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageInstallOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageInstallOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePackageInstallOptions[] = {
        { "allow_forced_app_restart", reinterpret_cast<getter>(StorePackageInstallOptions_get_AllowForcedAppRestart), reinterpret_cast<setter>(StorePackageInstallOptions_put_AllowForcedAppRestart), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageInstallOptions[] = 
    {
        { Py_tp_new, _new_StorePackageInstallOptions },
        { Py_tp_dealloc, _dealloc_StorePackageInstallOptions },
        { Py_tp_methods, _methods_StorePackageInstallOptions },
        { Py_tp_getset, _getset_StorePackageInstallOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePackageInstallOptions =
    {
        "_winsdk_Windows_Services_Store.StorePackageInstallOptions",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageInstallOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageInstallOptions
    };

    // ----- StorePackageLicense class --------------------
    constexpr const char* const _type_name_StorePackageLicense = "StorePackageLicense";

    static PyObject* _new_StorePackageLicense(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorePackageLicense);
        return nullptr;
    }

    static void _dealloc_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorePackageLicense_Close(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_ReleaseLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ReleaseLicense();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_get_IsValid(py::wrapper::Windows::Services::Store::StorePackageLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsValid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_get_Package(py::wrapper::Windows::Services::Store::StorePackageLicense* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_add_LicenseLost(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StorePackageLicense, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.LicenseLost(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageLicense_remove_LicenseLost(py::wrapper::Windows::Services::Store::StorePackageLicense* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.LicenseLost(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorePackageLicense(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageLicense>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_StorePackageLicense(py::wrapper::Windows::Services::Store::StorePackageLicense* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageLicense[] = {
        { "close", reinterpret_cast<PyCFunction>(StorePackageLicense_Close), METH_VARARGS, nullptr },
        { "release_license", reinterpret_cast<PyCFunction>(StorePackageLicense_ReleaseLicense), METH_VARARGS, nullptr },
        { "add_license_lost", reinterpret_cast<PyCFunction>(StorePackageLicense_add_LicenseLost), METH_O, nullptr },
        { "remove_license_lost", reinterpret_cast<PyCFunction>(StorePackageLicense_remove_LicenseLost), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageLicense), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_StorePackageLicense), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_StorePackageLicense), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePackageLicense[] = {
        { "is_valid", reinterpret_cast<getter>(StorePackageLicense_get_IsValid), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(StorePackageLicense_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageLicense[] = 
    {
        { Py_tp_new, _new_StorePackageLicense },
        { Py_tp_dealloc, _dealloc_StorePackageLicense },
        { Py_tp_methods, _methods_StorePackageLicense },
        { Py_tp_getset, _getset_StorePackageLicense },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePackageLicense =
    {
        "_winsdk_Windows_Services_Store.StorePackageLicense",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageLicense),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageLicense
    };

    // ----- StorePackageUpdate class --------------------
    constexpr const char* const _type_name_StorePackageUpdate = "StorePackageUpdate";

    static PyObject* _new_StorePackageUpdate(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorePackageUpdate);
        return nullptr;
    }

    static void _dealloc_StorePackageUpdate(py::wrapper::Windows::Services::Store::StorePackageUpdate* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorePackageUpdate_get_Mandatory(py::wrapper::Windows::Services::Store::StorePackageUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mandatory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdate_get_Package(py::wrapper::Windows::Services::Store::StorePackageUpdate* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Package());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorePackageUpdate(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageUpdate>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageUpdate[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageUpdate), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePackageUpdate[] = {
        { "mandatory", reinterpret_cast<getter>(StorePackageUpdate_get_Mandatory), nullptr, nullptr, nullptr },
        { "package", reinterpret_cast<getter>(StorePackageUpdate_get_Package), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageUpdate[] = 
    {
        { Py_tp_new, _new_StorePackageUpdate },
        { Py_tp_dealloc, _dealloc_StorePackageUpdate },
        { Py_tp_methods, _methods_StorePackageUpdate },
        { Py_tp_getset, _getset_StorePackageUpdate },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePackageUpdate =
    {
        "_winsdk_Windows_Services_Store.StorePackageUpdate",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdate),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdate
    };

    // ----- StorePackageUpdateResult class --------------------
    constexpr const char* const _type_name_StorePackageUpdateResult = "StorePackageUpdateResult";

    static PyObject* _new_StorePackageUpdateResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorePackageUpdateResult);
        return nullptr;
    }

    static void _dealloc_StorePackageUpdateResult(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorePackageUpdateResult_get_OverallState(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OverallState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateResult_get_StorePackageUpdateStatuses(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StorePackageUpdateStatuses());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePackageUpdateResult_get_StoreQueueItems(py::wrapper::Windows::Services::Store::StorePackageUpdateResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoreQueueItems());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorePackageUpdateResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePackageUpdateResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePackageUpdateResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePackageUpdateResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePackageUpdateResult[] = {
        { "overall_state", reinterpret_cast<getter>(StorePackageUpdateResult_get_OverallState), nullptr, nullptr, nullptr },
        { "store_package_update_statuses", reinterpret_cast<getter>(StorePackageUpdateResult_get_StorePackageUpdateStatuses), nullptr, nullptr, nullptr },
        { "store_queue_items", reinterpret_cast<getter>(StorePackageUpdateResult_get_StoreQueueItems), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageUpdateResult[] = 
    {
        { Py_tp_new, _new_StorePackageUpdateResult },
        { Py_tp_dealloc, _dealloc_StorePackageUpdateResult },
        { Py_tp_methods, _methods_StorePackageUpdateResult },
        { Py_tp_getset, _getset_StorePackageUpdateResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePackageUpdateResult =
    {
        "_winsdk_Windows_Services_Store.StorePackageUpdateResult",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdateResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdateResult
    };

    // ----- StorePrice class --------------------
    constexpr const char* const _type_name_StorePrice = "StorePrice";

    static PyObject* _new_StorePrice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorePrice);
        return nullptr;
    }

    static void _dealloc_StorePrice(py::wrapper::Windows::Services::Store::StorePrice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorePrice_get_CurrencyCode(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrencyCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedBasePrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FormattedBasePrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedPrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FormattedPrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_FormattedRecurrencePrice(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FormattedRecurrencePrice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_IsOnSale(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOnSale());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePrice_get_SaleEndDate(py::wrapper::Windows::Services::Store::StorePrice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SaleEndDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorePrice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePrice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePrice[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePrice), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePrice[] = {
        { "currency_code", reinterpret_cast<getter>(StorePrice_get_CurrencyCode), nullptr, nullptr, nullptr },
        { "formatted_base_price", reinterpret_cast<getter>(StorePrice_get_FormattedBasePrice), nullptr, nullptr, nullptr },
        { "formatted_price", reinterpret_cast<getter>(StorePrice_get_FormattedPrice), nullptr, nullptr, nullptr },
        { "formatted_recurrence_price", reinterpret_cast<getter>(StorePrice_get_FormattedRecurrencePrice), nullptr, nullptr, nullptr },
        { "is_on_sale", reinterpret_cast<getter>(StorePrice_get_IsOnSale), nullptr, nullptr, nullptr },
        { "sale_end_date", reinterpret_cast<getter>(StorePrice_get_SaleEndDate), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePrice[] = 
    {
        { Py_tp_new, _new_StorePrice },
        { Py_tp_dealloc, _dealloc_StorePrice },
        { Py_tp_methods, _methods_StorePrice },
        { Py_tp_getset, _getset_StorePrice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePrice =
    {
        "_winsdk_Windows_Services_Store.StorePrice",
        sizeof(py::wrapper::Windows::Services::Store::StorePrice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePrice
    };

    // ----- StoreProduct class --------------------
    constexpr const char* const _type_name_StoreProduct = "StoreProduct";

    static PyObject* _new_StoreProduct(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreProduct);
        return nullptr;
    }

    static void _dealloc_StoreProduct(py::wrapper::Windows::Services::Store::StoreProduct* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreProduct_GetIsAnySkuInstalledAsync(py::wrapper::Windows::Services::Store::StoreProduct* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetIsAnySkuInstalledAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProduct_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreProduct* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestPurchaseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Description(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_HasDigitalDownload(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasDigitalDownload());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Images(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Images());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_InAppOfferToken(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InAppOfferToken());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_IsInUserCollection(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInUserCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Keywords(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Keywords());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Language(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_LinkUri(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinkUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Price(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Price());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_ProductKind(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProductKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Skus(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Skus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_StoreId(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Title(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProduct_get_Videos(py::wrapper::Windows::Services::Store::StoreProduct* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Videos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreProduct(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProduct>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProduct[] = {
        { "get_is_any_sku_installed_async", reinterpret_cast<PyCFunction>(StoreProduct_GetIsAnySkuInstalledAsync), METH_VARARGS, nullptr },
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreProduct_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProduct), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProduct[] = {
        { "description", reinterpret_cast<getter>(StoreProduct_get_Description), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreProduct_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "has_digital_download", reinterpret_cast<getter>(StoreProduct_get_HasDigitalDownload), nullptr, nullptr, nullptr },
        { "images", reinterpret_cast<getter>(StoreProduct_get_Images), nullptr, nullptr, nullptr },
        { "in_app_offer_token", reinterpret_cast<getter>(StoreProduct_get_InAppOfferToken), nullptr, nullptr, nullptr },
        { "is_in_user_collection", reinterpret_cast<getter>(StoreProduct_get_IsInUserCollection), nullptr, nullptr, nullptr },
        { "keywords", reinterpret_cast<getter>(StoreProduct_get_Keywords), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(StoreProduct_get_Language), nullptr, nullptr, nullptr },
        { "link_uri", reinterpret_cast<getter>(StoreProduct_get_LinkUri), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(StoreProduct_get_Price), nullptr, nullptr, nullptr },
        { "product_kind", reinterpret_cast<getter>(StoreProduct_get_ProductKind), nullptr, nullptr, nullptr },
        { "skus", reinterpret_cast<getter>(StoreProduct_get_Skus), nullptr, nullptr, nullptr },
        { "store_id", reinterpret_cast<getter>(StoreProduct_get_StoreId), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(StoreProduct_get_Title), nullptr, nullptr, nullptr },
        { "videos", reinterpret_cast<getter>(StoreProduct_get_Videos), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProduct[] = 
    {
        { Py_tp_new, _new_StoreProduct },
        { Py_tp_dealloc, _dealloc_StoreProduct },
        { Py_tp_methods, _methods_StoreProduct },
        { Py_tp_getset, _getset_StoreProduct },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreProduct =
    {
        "_winsdk_Windows_Services_Store.StoreProduct",
        sizeof(py::wrapper::Windows::Services::Store::StoreProduct),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProduct
    };

    // ----- StoreProductOptions class --------------------
    constexpr const char* const _type_name_StoreProductOptions = "StoreProductOptions";

    static PyObject* _new_StoreProductOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StoreProductOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StoreProductOptions(py::wrapper::Windows::Services::Store::StoreProductOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreProductOptions_get_ActionFilters(py::wrapper::Windows::Services::Store::StoreProductOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActionFilters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreProductOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProductOptions[] = {
        { "action_filters", reinterpret_cast<getter>(StoreProductOptions_get_ActionFilters), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProductOptions[] = 
    {
        { Py_tp_new, _new_StoreProductOptions },
        { Py_tp_dealloc, _dealloc_StoreProductOptions },
        { Py_tp_methods, _methods_StoreProductOptions },
        { Py_tp_getset, _getset_StoreProductOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreProductOptions =
    {
        "_winsdk_Windows_Services_Store.StoreProductOptions",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductOptions
    };

    // ----- StoreProductPagedQueryResult class --------------------
    constexpr const char* const _type_name_StoreProductPagedQueryResult = "StoreProductPagedQueryResult";

    static PyObject* _new_StoreProductPagedQueryResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreProductPagedQueryResult);
        return nullptr;
    }

    static void _dealloc_StoreProductPagedQueryResult(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreProductPagedQueryResult_GetNextAsync(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNextAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_HasMoreResults(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasMoreResults());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductPagedQueryResult_get_Products(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Products());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreProductPagedQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductPagedQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductPagedQueryResult[] = {
        { "get_next_async", reinterpret_cast<PyCFunction>(StoreProductPagedQueryResult_GetNextAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductPagedQueryResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProductPagedQueryResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreProductPagedQueryResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "has_more_results", reinterpret_cast<getter>(StoreProductPagedQueryResult_get_HasMoreResults), nullptr, nullptr, nullptr },
        { "products", reinterpret_cast<getter>(StoreProductPagedQueryResult_get_Products), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProductPagedQueryResult[] = 
    {
        { Py_tp_new, _new_StoreProductPagedQueryResult },
        { Py_tp_dealloc, _dealloc_StoreProductPagedQueryResult },
        { Py_tp_methods, _methods_StoreProductPagedQueryResult },
        { Py_tp_getset, _getset_StoreProductPagedQueryResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreProductPagedQueryResult =
    {
        "_winsdk_Windows_Services_Store.StoreProductPagedQueryResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductPagedQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductPagedQueryResult
    };

    // ----- StoreProductQueryResult class --------------------
    constexpr const char* const _type_name_StoreProductQueryResult = "StoreProductQueryResult";

    static PyObject* _new_StoreProductQueryResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreProductQueryResult);
        return nullptr;
    }

    static void _dealloc_StoreProductQueryResult(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreProductQueryResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductQueryResult_get_Products(py::wrapper::Windows::Services::Store::StoreProductQueryResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Products());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreProductQueryResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductQueryResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductQueryResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductQueryResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProductQueryResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreProductQueryResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "products", reinterpret_cast<getter>(StoreProductQueryResult_get_Products), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProductQueryResult[] = 
    {
        { Py_tp_new, _new_StoreProductQueryResult },
        { Py_tp_dealloc, _dealloc_StoreProductQueryResult },
        { Py_tp_methods, _methods_StoreProductQueryResult },
        { Py_tp_getset, _getset_StoreProductQueryResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreProductQueryResult =
    {
        "_winsdk_Windows_Services_Store.StoreProductQueryResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductQueryResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductQueryResult
    };

    // ----- StoreProductResult class --------------------
    constexpr const char* const _type_name_StoreProductResult = "StoreProductResult";

    static PyObject* _new_StoreProductResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreProductResult);
        return nullptr;
    }

    static void _dealloc_StoreProductResult(py::wrapper::Windows::Services::Store::StoreProductResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreProductResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreProductResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreProductResult_get_Product(py::wrapper::Windows::Services::Store::StoreProductResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Product());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreProductResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreProductResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreProductResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreProductResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreProductResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreProductResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "product", reinterpret_cast<getter>(StoreProductResult_get_Product), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreProductResult[] = 
    {
        { Py_tp_new, _new_StoreProductResult },
        { Py_tp_dealloc, _dealloc_StoreProductResult },
        { Py_tp_methods, _methods_StoreProductResult },
        { Py_tp_getset, _getset_StoreProductResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreProductResult =
    {
        "_winsdk_Windows_Services_Store.StoreProductResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreProductResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreProductResult
    };

    // ----- StorePurchaseProperties class --------------------
    constexpr const char* const _type_name_StorePurchaseProperties = "StorePurchaseProperties";

    static PyObject* _new_StorePurchaseProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Services::Store::StorePurchaseProperties instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Services::Store::StorePurchaseProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorePurchaseProperties(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorePurchaseProperties_get_Name(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePurchaseProperties_put_Name(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePurchaseProperties_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePurchaseProperties_put_ExtendedJsonData(py::wrapper::Windows::Services::Store::StorePurchaseProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ExtendedJsonData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorePurchaseProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePurchaseProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePurchaseProperties[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePurchaseProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePurchaseProperties[] = {
        { "name", reinterpret_cast<getter>(StorePurchaseProperties_get_Name), reinterpret_cast<setter>(StorePurchaseProperties_put_Name), nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StorePurchaseProperties_get_ExtendedJsonData), reinterpret_cast<setter>(StorePurchaseProperties_put_ExtendedJsonData), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePurchaseProperties[] = 
    {
        { Py_tp_new, _new_StorePurchaseProperties },
        { Py_tp_dealloc, _dealloc_StorePurchaseProperties },
        { Py_tp_methods, _methods_StorePurchaseProperties },
        { Py_tp_getset, _getset_StorePurchaseProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePurchaseProperties =
    {
        "_winsdk_Windows_Services_Store.StorePurchaseProperties",
        sizeof(py::wrapper::Windows::Services::Store::StorePurchaseProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePurchaseProperties
    };

    // ----- StorePurchaseResult class --------------------
    constexpr const char* const _type_name_StorePurchaseResult = "StorePurchaseResult";

    static PyObject* _new_StorePurchaseResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorePurchaseResult);
        return nullptr;
    }

    static void _dealloc_StorePurchaseResult(py::wrapper::Windows::Services::Store::StorePurchaseResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorePurchaseResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StorePurchaseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorePurchaseResult_get_Status(py::wrapper::Windows::Services::Store::StorePurchaseResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorePurchaseResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StorePurchaseResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorePurchaseResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorePurchaseResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorePurchaseResult[] = {
        { "extended_error", reinterpret_cast<getter>(StorePurchaseResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StorePurchaseResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePurchaseResult[] = 
    {
        { Py_tp_new, _new_StorePurchaseResult },
        { Py_tp_dealloc, _dealloc_StorePurchaseResult },
        { Py_tp_methods, _methods_StorePurchaseResult },
        { Py_tp_getset, _getset_StorePurchaseResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePurchaseResult =
    {
        "_winsdk_Windows_Services_Store.StorePurchaseResult",
        sizeof(py::wrapper::Windows::Services::Store::StorePurchaseResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePurchaseResult
    };

    // ----- StoreQueueItem class --------------------
    constexpr const char* const _type_name_StoreQueueItem = "StoreQueueItem";

    static PyObject* _new_StoreQueueItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreQueueItem);
        return nullptr;
    }

    static void _dealloc_StoreQueueItem(py::wrapper::Windows::Services::Store::StoreQueueItem* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreQueueItem_CancelInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.CancelInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_GetCurrentStatus(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_PauseInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.PauseInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_ResumeInstallAsync(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ResumeInstallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_InstallKind(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstallKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_PackageFamilyName(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_get_ProductId(py::wrapper::Windows::Services::Store::StoreQueueItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_add_Completed(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreQueueItem, winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>>(arg);

            return py::convert(self->obj.Completed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_remove_Completed(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Completed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_add_StatusChanged(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Services::Store::StoreQueueItem, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItem_remove_StatusChanged(py::wrapper::Windows::Services::Store::StoreQueueItem* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreQueueItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItem[] = {
        { "cancel_install_async", reinterpret_cast<PyCFunction>(StoreQueueItem_CancelInstallAsync), METH_VARARGS, nullptr },
        { "get_current_status", reinterpret_cast<PyCFunction>(StoreQueueItem_GetCurrentStatus), METH_VARARGS, nullptr },
        { "pause_install_async", reinterpret_cast<PyCFunction>(StoreQueueItem_PauseInstallAsync), METH_VARARGS, nullptr },
        { "resume_install_async", reinterpret_cast<PyCFunction>(StoreQueueItem_ResumeInstallAsync), METH_VARARGS, nullptr },
        { "add_completed", reinterpret_cast<PyCFunction>(StoreQueueItem_add_Completed), METH_O, nullptr },
        { "remove_completed", reinterpret_cast<PyCFunction>(StoreQueueItem_remove_Completed), METH_O, nullptr },
        { "add_status_changed", reinterpret_cast<PyCFunction>(StoreQueueItem_add_StatusChanged), METH_O, nullptr },
        { "remove_status_changed", reinterpret_cast<PyCFunction>(StoreQueueItem_remove_StatusChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreQueueItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreQueueItem[] = {
        { "install_kind", reinterpret_cast<getter>(StoreQueueItem_get_InstallKind), nullptr, nullptr, nullptr },
        { "package_family_name", reinterpret_cast<getter>(StoreQueueItem_get_PackageFamilyName), nullptr, nullptr, nullptr },
        { "product_id", reinterpret_cast<getter>(StoreQueueItem_get_ProductId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreQueueItem[] = 
    {
        { Py_tp_new, _new_StoreQueueItem },
        { Py_tp_dealloc, _dealloc_StoreQueueItem },
        { Py_tp_methods, _methods_StoreQueueItem },
        { Py_tp_getset, _getset_StoreQueueItem },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreQueueItem =
    {
        "_winsdk_Windows_Services_Store.StoreQueueItem",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItem
    };

    // ----- StoreQueueItemCompletedEventArgs class --------------------
    constexpr const char* const _type_name_StoreQueueItemCompletedEventArgs = "StoreQueueItemCompletedEventArgs";

    static PyObject* _new_StoreQueueItemCompletedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreQueueItemCompletedEventArgs);
        return nullptr;
    }

    static void _dealloc_StoreQueueItemCompletedEventArgs(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreQueueItemCompletedEventArgs_get_Status(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreQueueItemCompletedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItemCompletedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreQueueItemCompletedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreQueueItemCompletedEventArgs[] = {
        { "status", reinterpret_cast<getter>(StoreQueueItemCompletedEventArgs_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreQueueItemCompletedEventArgs[] = 
    {
        { Py_tp_new, _new_StoreQueueItemCompletedEventArgs },
        { Py_tp_dealloc, _dealloc_StoreQueueItemCompletedEventArgs },
        { Py_tp_methods, _methods_StoreQueueItemCompletedEventArgs },
        { Py_tp_getset, _getset_StoreQueueItemCompletedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreQueueItemCompletedEventArgs =
    {
        "_winsdk_Windows_Services_Store.StoreQueueItemCompletedEventArgs",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItemCompletedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItemCompletedEventArgs
    };

    // ----- StoreQueueItemStatus class --------------------
    constexpr const char* const _type_name_StoreQueueItemStatus = "StoreQueueItemStatus";

    static PyObject* _new_StoreQueueItemStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreQueueItemStatus);
        return nullptr;
    }

    static void _dealloc_StoreQueueItemStatus(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreQueueItemStatus_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_PackageInstallExtendedState(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageInstallExtendedState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_PackageInstallState(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageInstallState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreQueueItemStatus_get_UpdateStatus(py::wrapper::Windows::Services::Store::StoreQueueItemStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreQueueItemStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreQueueItemStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreQueueItemStatus[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreQueueItemStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreQueueItemStatus[] = {
        { "extended_error", reinterpret_cast<getter>(StoreQueueItemStatus_get_ExtendedError), nullptr, nullptr, nullptr },
        { "package_install_extended_state", reinterpret_cast<getter>(StoreQueueItemStatus_get_PackageInstallExtendedState), nullptr, nullptr, nullptr },
        { "package_install_state", reinterpret_cast<getter>(StoreQueueItemStatus_get_PackageInstallState), nullptr, nullptr, nullptr },
        { "update_status", reinterpret_cast<getter>(StoreQueueItemStatus_get_UpdateStatus), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreQueueItemStatus[] = 
    {
        { Py_tp_new, _new_StoreQueueItemStatus },
        { Py_tp_dealloc, _dealloc_StoreQueueItemStatus },
        { Py_tp_methods, _methods_StoreQueueItemStatus },
        { Py_tp_getset, _getset_StoreQueueItemStatus },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreQueueItemStatus =
    {
        "_winsdk_Windows_Services_Store.StoreQueueItemStatus",
        sizeof(py::wrapper::Windows::Services::Store::StoreQueueItemStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreQueueItemStatus
    };

    // ----- StoreRateAndReviewResult class --------------------
    constexpr const char* const _type_name_StoreRateAndReviewResult = "StoreRateAndReviewResult";

    static PyObject* _new_StoreRateAndReviewResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreRateAndReviewResult);
        return nullptr;
    }

    static void _dealloc_StoreRateAndReviewResult(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreRateAndReviewResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_Status(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreRateAndReviewResult_get_WasUpdated(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WasUpdated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreRateAndReviewResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreRateAndReviewResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreRateAndReviewResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreRateAndReviewResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreRateAndReviewResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreRateAndReviewResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreRateAndReviewResult_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreRateAndReviewResult_get_Status), nullptr, nullptr, nullptr },
        { "was_updated", reinterpret_cast<getter>(StoreRateAndReviewResult_get_WasUpdated), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreRateAndReviewResult[] = 
    {
        { Py_tp_new, _new_StoreRateAndReviewResult },
        { Py_tp_dealloc, _dealloc_StoreRateAndReviewResult },
        { Py_tp_methods, _methods_StoreRateAndReviewResult },
        { Py_tp_getset, _getset_StoreRateAndReviewResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreRateAndReviewResult =
    {
        "_winsdk_Windows_Services_Store.StoreRateAndReviewResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreRateAndReviewResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreRateAndReviewResult
    };

    // ----- StoreRequestHelper class --------------------
    constexpr const char* const _type_name_StoreRequestHelper = "StoreRequestHelper";

    static PyObject* _new_StoreRequestHelper(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreRequestHelper);
        return nullptr;
    }

    static PyObject* StoreRequestHelper_SendRequestAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StoreContext>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(winrt::Windows::Services::Store::StoreRequestHelper::SendRequestAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreRequestHelper[] = {
        { "send_request_async", reinterpret_cast<PyCFunction>(StoreRequestHelper_SendRequestAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreRequestHelper[] = {
        { }
    };

    static PyType_Slot _type_slots_StoreRequestHelper[] = 
    {
        { Py_tp_new, _new_StoreRequestHelper },
        { Py_tp_methods, _methods_StoreRequestHelper },
        { Py_tp_getset, _getset_StoreRequestHelper },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreRequestHelper =
    {
        "_winsdk_Windows_Services_Store.StoreRequestHelper",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreRequestHelper
    };

    // ----- StoreSendRequestResult class --------------------
    constexpr const char* const _type_name_StoreSendRequestResult = "StoreSendRequestResult";

    static PyObject* _new_StoreSendRequestResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreSendRequestResult);
        return nullptr;
    }

    static void _dealloc_StoreSendRequestResult(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreSendRequestResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSendRequestResult_get_Response(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Response());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSendRequestResult_get_HttpStatusCode(py::wrapper::Windows::Services::Store::StoreSendRequestResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HttpStatusCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreSendRequestResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSendRequestResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSendRequestResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreSendRequestResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreSendRequestResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreSendRequestResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "response", reinterpret_cast<getter>(StoreSendRequestResult_get_Response), nullptr, nullptr, nullptr },
        { "http_status_code", reinterpret_cast<getter>(StoreSendRequestResult_get_HttpStatusCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreSendRequestResult[] = 
    {
        { Py_tp_new, _new_StoreSendRequestResult },
        { Py_tp_dealloc, _dealloc_StoreSendRequestResult },
        { Py_tp_methods, _methods_StoreSendRequestResult },
        { Py_tp_getset, _getset_StoreSendRequestResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreSendRequestResult =
    {
        "_winsdk_Windows_Services_Store.StoreSendRequestResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreSendRequestResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSendRequestResult
    };

    // ----- StoreSku class --------------------
    constexpr const char* const _type_name_StoreSku = "StoreSku";

    static PyObject* _new_StoreSku(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreSku);
        return nullptr;
    }

    static void _dealloc_StoreSku(py::wrapper::Windows::Services::Store::StoreSku* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreSku_GetIsInstalledAsync(py::wrapper::Windows::Services::Store::StoreSku* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetIsInstalledAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreSku_RequestPurchaseAsync(py::wrapper::Windows::Services::Store::StoreSku* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.RequestPurchaseAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Services::Store::StorePurchaseProperties>(args, 0);

                return py::convert(self->obj.RequestPurchaseAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Availabilities(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Availabilities());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_BundledSkus(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BundledSkus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_CollectionData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CollectionData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_CustomDeveloperData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CustomDeveloperData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Description(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_ExtendedJsonData(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedJsonData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Images(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Images());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsInUserCollection(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsInUserCollection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsSubscription(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSubscription());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_IsTrial(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsTrial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Language(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Price(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Price());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_StoreId(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StoreId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_SubscriptionInfo(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubscriptionInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Title(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSku_get_Videos(py::wrapper::Windows::Services::Store::StoreSku* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Videos());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreSku(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSku>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSku[] = {
        { "get_is_installed_async", reinterpret_cast<PyCFunction>(StoreSku_GetIsInstalledAsync), METH_VARARGS, nullptr },
        { "request_purchase_async", reinterpret_cast<PyCFunction>(StoreSku_RequestPurchaseAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreSku), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreSku[] = {
        { "availabilities", reinterpret_cast<getter>(StoreSku_get_Availabilities), nullptr, nullptr, nullptr },
        { "bundled_skus", reinterpret_cast<getter>(StoreSku_get_BundledSkus), nullptr, nullptr, nullptr },
        { "collection_data", reinterpret_cast<getter>(StoreSku_get_CollectionData), nullptr, nullptr, nullptr },
        { "custom_developer_data", reinterpret_cast<getter>(StoreSku_get_CustomDeveloperData), nullptr, nullptr, nullptr },
        { "description", reinterpret_cast<getter>(StoreSku_get_Description), nullptr, nullptr, nullptr },
        { "extended_json_data", reinterpret_cast<getter>(StoreSku_get_ExtendedJsonData), nullptr, nullptr, nullptr },
        { "images", reinterpret_cast<getter>(StoreSku_get_Images), nullptr, nullptr, nullptr },
        { "is_in_user_collection", reinterpret_cast<getter>(StoreSku_get_IsInUserCollection), nullptr, nullptr, nullptr },
        { "is_subscription", reinterpret_cast<getter>(StoreSku_get_IsSubscription), nullptr, nullptr, nullptr },
        { "is_trial", reinterpret_cast<getter>(StoreSku_get_IsTrial), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(StoreSku_get_Language), nullptr, nullptr, nullptr },
        { "price", reinterpret_cast<getter>(StoreSku_get_Price), nullptr, nullptr, nullptr },
        { "store_id", reinterpret_cast<getter>(StoreSku_get_StoreId), nullptr, nullptr, nullptr },
        { "subscription_info", reinterpret_cast<getter>(StoreSku_get_SubscriptionInfo), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(StoreSku_get_Title), nullptr, nullptr, nullptr },
        { "videos", reinterpret_cast<getter>(StoreSku_get_Videos), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreSku[] = 
    {
        { Py_tp_new, _new_StoreSku },
        { Py_tp_dealloc, _dealloc_StoreSku },
        { Py_tp_methods, _methods_StoreSku },
        { Py_tp_getset, _getset_StoreSku },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreSku =
    {
        "_winsdk_Windows_Services_Store.StoreSku",
        sizeof(py::wrapper::Windows::Services::Store::StoreSku),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSku
    };

    // ----- StoreSubscriptionInfo class --------------------
    constexpr const char* const _type_name_StoreSubscriptionInfo = "StoreSubscriptionInfo";

    static PyObject* _new_StoreSubscriptionInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreSubscriptionInfo);
        return nullptr;
    }

    static void _dealloc_StoreSubscriptionInfo(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreSubscriptionInfo_get_BillingPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BillingPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_BillingPeriodUnit(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BillingPeriodUnit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_HasTrialPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasTrialPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_TrialPeriod(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrialPeriod());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreSubscriptionInfo_get_TrialPeriodUnit(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TrialPeriodUnit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreSubscriptionInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreSubscriptionInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreSubscriptionInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreSubscriptionInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreSubscriptionInfo[] = {
        { "billing_period", reinterpret_cast<getter>(StoreSubscriptionInfo_get_BillingPeriod), nullptr, nullptr, nullptr },
        { "billing_period_unit", reinterpret_cast<getter>(StoreSubscriptionInfo_get_BillingPeriodUnit), nullptr, nullptr, nullptr },
        { "has_trial_period", reinterpret_cast<getter>(StoreSubscriptionInfo_get_HasTrialPeriod), nullptr, nullptr, nullptr },
        { "trial_period", reinterpret_cast<getter>(StoreSubscriptionInfo_get_TrialPeriod), nullptr, nullptr, nullptr },
        { "trial_period_unit", reinterpret_cast<getter>(StoreSubscriptionInfo_get_TrialPeriodUnit), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreSubscriptionInfo[] = 
    {
        { Py_tp_new, _new_StoreSubscriptionInfo },
        { Py_tp_dealloc, _dealloc_StoreSubscriptionInfo },
        { Py_tp_methods, _methods_StoreSubscriptionInfo },
        { Py_tp_getset, _getset_StoreSubscriptionInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreSubscriptionInfo =
    {
        "_winsdk_Windows_Services_Store.StoreSubscriptionInfo",
        sizeof(py::wrapper::Windows::Services::Store::StoreSubscriptionInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreSubscriptionInfo
    };

    // ----- StoreUninstallStorePackageResult class --------------------
    constexpr const char* const _type_name_StoreUninstallStorePackageResult = "StoreUninstallStorePackageResult";

    static PyObject* _new_StoreUninstallStorePackageResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreUninstallStorePackageResult);
        return nullptr;
    }

    static void _dealloc_StoreUninstallStorePackageResult(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreUninstallStorePackageResult_get_ExtendedError(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreUninstallStorePackageResult_get_Status(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreUninstallStorePackageResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreUninstallStorePackageResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreUninstallStorePackageResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreUninstallStorePackageResult[] = {
        { "extended_error", reinterpret_cast<getter>(StoreUninstallStorePackageResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "status", reinterpret_cast<getter>(StoreUninstallStorePackageResult_get_Status), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreUninstallStorePackageResult[] = 
    {
        { Py_tp_new, _new_StoreUninstallStorePackageResult },
        { Py_tp_dealloc, _dealloc_StoreUninstallStorePackageResult },
        { Py_tp_methods, _methods_StoreUninstallStorePackageResult },
        { Py_tp_getset, _getset_StoreUninstallStorePackageResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreUninstallStorePackageResult =
    {
        "_winsdk_Windows_Services_Store.StoreUninstallStorePackageResult",
        sizeof(py::wrapper::Windows::Services::Store::StoreUninstallStorePackageResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreUninstallStorePackageResult
    };

    // ----- StoreVideo class --------------------
    constexpr const char* const _type_name_StoreVideo = "StoreVideo";

    static PyObject* _new_StoreVideo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StoreVideo);
        return nullptr;
    }

    static void _dealloc_StoreVideo(py::wrapper::Windows::Services::Store::StoreVideo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StoreVideo_get_Caption(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Caption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Height(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_PreviewImage(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviewImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Uri(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_VideoPurposeTag(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoPurposeTag());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StoreVideo_get_Width(py::wrapper::Windows::Services::Store::StoreVideo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StoreVideo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Services::Store::StoreVideo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StoreVideo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StoreVideo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StoreVideo[] = {
        { "caption", reinterpret_cast<getter>(StoreVideo_get_Caption), nullptr, nullptr, nullptr },
        { "height", reinterpret_cast<getter>(StoreVideo_get_Height), nullptr, nullptr, nullptr },
        { "preview_image", reinterpret_cast<getter>(StoreVideo_get_PreviewImage), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(StoreVideo_get_Uri), nullptr, nullptr, nullptr },
        { "video_purpose_tag", reinterpret_cast<getter>(StoreVideo_get_VideoPurposeTag), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(StoreVideo_get_Width), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StoreVideo[] = 
    {
        { Py_tp_new, _new_StoreVideo },
        { Py_tp_dealloc, _dealloc_StoreVideo },
        { Py_tp_methods, _methods_StoreVideo },
        { Py_tp_getset, _getset_StoreVideo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StoreVideo =
    {
        "_winsdk_Windows_Services_Store.StoreVideo",
        sizeof(py::wrapper::Windows::Services::Store::StoreVideo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StoreVideo
    };

    // ----- StorePackageUpdateStatus struct --------------------
    constexpr const char* const _type_name_StorePackageUpdateStatus = "StorePackageUpdateStatus";

    PyObject* _new_StorePackageUpdateStatus(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Services::Store::StorePackageUpdateStatus return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Services::Store::StorePackageUpdateStatus>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        winrt::hstring _PackageFamilyName{};
        uint64_t _PackageDownloadSizeInBytes{};
        uint64_t _PackageBytesDownloaded{};
        double _PackageDownloadProgress{};
        double _TotalDownloadProgress{};
        int32_t _PackageUpdateState{};

        static const char* kwlist[] = {"package_family_name", "package_download_size_in_bytes", "package_bytes_downloaded", "package_download_progress", "total_download_progress", "package_update_state", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "uKKddi", const_cast<char**>(kwlist), &_PackageFamilyName, &_PackageDownloadSizeInBytes, &_PackageBytesDownloaded, &_PackageDownloadProgress, &_TotalDownloadProgress, &_PackageUpdateState))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Services::Store::StorePackageUpdateStatus return_value{ _PackageFamilyName, _PackageDownloadSizeInBytes, _PackageBytesDownloaded, _PackageDownloadProgress, _TotalDownloadProgress, static_cast<winrt::Windows::Services::Store::StorePackageUpdateState>(_PackageUpdateState) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_StorePackageUpdateStatus(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self)
    {
    }

    static PyObject* StorePackageUpdateStatus_get_PackageFamilyName(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageFamilyName);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageFamilyName(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PackageFamilyName = py::converter<winrt::hstring>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageDownloadSizeInBytes(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageDownloadSizeInBytes);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageDownloadSizeInBytes(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PackageDownloadSizeInBytes = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageBytesDownloaded(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageBytesDownloaded);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageBytesDownloaded(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PackageBytesDownloaded = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageDownloadProgress);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PackageDownloadProgress = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_TotalDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalDownloadProgress);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_TotalDownloadProgress(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.TotalDownloadProgress = py::converter<double>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorePackageUpdateStatus_get_PackageUpdateState(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageUpdateState);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorePackageUpdateStatus_set_PackageUpdateState(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PackageUpdateState = py::converter<winrt::Windows::Services::Store::StorePackageUpdateState>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_StorePackageUpdateStatus[] = {
        { "package_family_name", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageFamilyName), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageFamilyName), nullptr, nullptr },
        { "package_download_size_in_bytes", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageDownloadSizeInBytes), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageDownloadSizeInBytes), nullptr, nullptr },
        { "package_bytes_downloaded", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageBytesDownloaded), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageBytesDownloaded), nullptr, nullptr },
        { "package_download_progress", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageDownloadProgress), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageDownloadProgress), nullptr, nullptr },
        { "total_download_progress", reinterpret_cast<getter>(StorePackageUpdateStatus_get_TotalDownloadProgress), reinterpret_cast<setter>(StorePackageUpdateStatus_set_TotalDownloadProgress), nullptr, nullptr },
        { "package_update_state", reinterpret_cast<getter>(StorePackageUpdateStatus_get_PackageUpdateState), reinterpret_cast<setter>(StorePackageUpdateStatus_set_PackageUpdateState), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorePackageUpdateStatus[] = 
    {
        { Py_tp_new, _new_StorePackageUpdateStatus },
        { Py_tp_dealloc, _dealloc_StorePackageUpdateStatus },
        { Py_tp_getset, _getset_StorePackageUpdateStatus },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorePackageUpdateStatus =
    {
        "_winsdk_Windows_Services_Store.StorePackageUpdateStatus",
        sizeof(py::wrapper::Windows::Services::Store::StorePackageUpdateStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorePackageUpdateStatus
    };

    // ----- Windows.Services.Store Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Services::Store::StoreAcquireLicenseResult>::python_type = py::register_python_type(module, _type_name_StoreAcquireLicenseResult, &_type_spec_StoreAcquireLicenseResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreAppLicense>::python_type = py::register_python_type(module, _type_name_StoreAppLicense, &_type_spec_StoreAppLicense, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreAvailability>::python_type = py::register_python_type(module, _type_name_StoreAvailability, &_type_spec_StoreAvailability, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreCanAcquireLicenseResult>::python_type = py::register_python_type(module, _type_name_StoreCanAcquireLicenseResult, &_type_spec_StoreCanAcquireLicenseResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreCollectionData>::python_type = py::register_python_type(module, _type_name_StoreCollectionData, &_type_spec_StoreCollectionData, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreConsumableResult>::python_type = py::register_python_type(module, _type_name_StoreConsumableResult, &_type_spec_StoreConsumableResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreContext>::python_type = py::register_python_type(module, _type_name_StoreContext, &_type_spec_StoreContext, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreImage>::python_type = py::register_python_type(module, _type_name_StoreImage, &_type_spec_StoreImage, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreLicense>::python_type = py::register_python_type(module, _type_name_StoreLicense, &_type_spec_StoreLicense, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePackageInstallOptions>::python_type = py::register_python_type(module, _type_name_StorePackageInstallOptions, &_type_spec_StorePackageInstallOptions, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePackageLicense>::python_type = py::register_python_type(module, _type_name_StorePackageLicense, &_type_spec_StorePackageLicense, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdate>::python_type = py::register_python_type(module, _type_name_StorePackageUpdate, &_type_spec_StorePackageUpdate, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdateResult>::python_type = py::register_python_type(module, _type_name_StorePackageUpdateResult, &_type_spec_StorePackageUpdateResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePrice>::python_type = py::register_python_type(module, _type_name_StorePrice, &_type_spec_StorePrice, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreProduct>::python_type = py::register_python_type(module, _type_name_StoreProduct, &_type_spec_StoreProduct, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreProductOptions>::python_type = py::register_python_type(module, _type_name_StoreProductOptions, &_type_spec_StoreProductOptions, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreProductPagedQueryResult>::python_type = py::register_python_type(module, _type_name_StoreProductPagedQueryResult, &_type_spec_StoreProductPagedQueryResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreProductQueryResult>::python_type = py::register_python_type(module, _type_name_StoreProductQueryResult, &_type_spec_StoreProductQueryResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreProductResult>::python_type = py::register_python_type(module, _type_name_StoreProductResult, &_type_spec_StoreProductResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePurchaseProperties>::python_type = py::register_python_type(module, _type_name_StorePurchaseProperties, &_type_spec_StorePurchaseProperties, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePurchaseResult>::python_type = py::register_python_type(module, _type_name_StorePurchaseResult, &_type_spec_StorePurchaseResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreQueueItem>::python_type = py::register_python_type(module, _type_name_StoreQueueItem, &_type_spec_StoreQueueItem, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreQueueItemCompletedEventArgs>::python_type = py::register_python_type(module, _type_name_StoreQueueItemCompletedEventArgs, &_type_spec_StoreQueueItemCompletedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreQueueItemStatus>::python_type = py::register_python_type(module, _type_name_StoreQueueItemStatus, &_type_spec_StoreQueueItemStatus, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreRateAndReviewResult>::python_type = py::register_python_type(module, _type_name_StoreRateAndReviewResult, &_type_spec_StoreRateAndReviewResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreRequestHelper>::python_type = py::register_python_type(module, _type_name_StoreRequestHelper, &_type_spec_StoreRequestHelper, nullptr);
            py::winrt_type<winrt::Windows::Services::Store::StoreSendRequestResult>::python_type = py::register_python_type(module, _type_name_StoreSendRequestResult, &_type_spec_StoreSendRequestResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreSku>::python_type = py::register_python_type(module, _type_name_StoreSku, &_type_spec_StoreSku, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreSubscriptionInfo>::python_type = py::register_python_type(module, _type_name_StoreSubscriptionInfo, &_type_spec_StoreSubscriptionInfo, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreUninstallStorePackageResult>::python_type = py::register_python_type(module, _type_name_StoreUninstallStorePackageResult, &_type_spec_StoreUninstallStorePackageResult, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StoreVideo>::python_type = py::register_python_type(module, _type_name_StoreVideo, &_type_spec_StoreVideo, bases.get());
            py::winrt_type<winrt::Windows::Services::Store::StorePackageUpdateStatus>::python_type = py::register_python_type(module, _type_name_StorePackageUpdateStatus, &_type_spec_StorePackageUpdateStatus, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Services.Store");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Services_Store",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Services::Store

PyMODINIT_FUNC
PyInit__winsdk_Windows_Services_Store (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Services::Store::module_def);
}
