// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.5

#include "pybase.h"
#include "py.Windows.Media.MediaProperties.h"


namespace py::cpp::Windows::Media::MediaProperties
{
    struct module_state
    {
        PyObject* type_AudioEncodingQuality;
        PyObject* type_MediaMirroringOptions;
        PyObject* type_MediaPixelFormat;
        PyObject* type_MediaRotation;
        PyObject* type_MediaThumbnailFormat;
        PyObject* type_SphericalVideoFrameFormat;
        PyObject* type_StereoscopicVideoPackingMode;
        PyObject* type_VideoEncodingQuality;
        PyTypeObject* type_AudioEncodingProperties;
        PyTypeObject* type_ContainerEncodingProperties;
        PyTypeObject* type_H264ProfileIds;
        PyTypeObject* type_ImageEncodingProperties;
        PyTypeObject* type_MediaEncodingProfile;
        PyTypeObject* type_MediaEncodingSubtypes;
        PyTypeObject* type_MediaPropertySet;
        PyTypeObject* type_MediaRatio;
        PyTypeObject* type_Mpeg2ProfileIds;
        PyTypeObject* type_TimedMetadataEncodingProperties;
        PyTypeObject* type_VideoEncodingProperties;
        PyTypeObject* type_IMediaEncodingProperties;
    };

    static PyObject* register_AudioEncodingQuality(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_AudioEncodingQuality)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_AudioEncodingQuality = type;
        Py_INCREF(state->type_AudioEncodingQuality);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaMirroringOptions(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaMirroringOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaMirroringOptions = type;
        Py_INCREF(state->type_MediaMirroringOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaPixelFormat(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaPixelFormat)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaPixelFormat = type;
        Py_INCREF(state->type_MediaPixelFormat);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaRotation(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaRotation)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaRotation = type;
        Py_INCREF(state->type_MediaRotation);


        Py_RETURN_NONE;
    }

    static PyObject* register_MediaThumbnailFormat(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MediaThumbnailFormat)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MediaThumbnailFormat = type;
        Py_INCREF(state->type_MediaThumbnailFormat);


        Py_RETURN_NONE;
    }

    static PyObject* register_SphericalVideoFrameFormat(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_SphericalVideoFrameFormat)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_SphericalVideoFrameFormat = type;
        Py_INCREF(state->type_SphericalVideoFrameFormat);


        Py_RETURN_NONE;
    }

    static PyObject* register_StereoscopicVideoPackingMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StereoscopicVideoPackingMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StereoscopicVideoPackingMode = type;
        Py_INCREF(state->type_StereoscopicVideoPackingMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_VideoEncodingQuality(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_VideoEncodingQuality)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_VideoEncodingQuality = type;
        Py_INCREF(state->type_VideoEncodingQuality);


        Py_RETURN_NONE;
    }

    // ----- AudioEncodingProperties class --------------------
    constexpr const char* const type_name_AudioEncodingProperties = "AudioEncodingProperties";

    static PyObject* _new_AudioEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::AudioEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioEncodingProperties(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AudioEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateAac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateAac(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateAacAdts(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateAacAdts(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateAlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateAlac(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateFlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateFlac(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateMp3(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateMp3(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreatePcm(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreatePcm(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_CreateWma(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::AudioEncodingProperties::CreateWma(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_GetFormatUserData(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetFormatUserData(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_SetFormatUserData(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetFormatUserData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_get_SampleRate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SampleRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_SampleRate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.SampleRate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_ChannelCount(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ChannelCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_ChannelCount(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.ChannelCount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_BitsPerSample(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BitsPerSample());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_BitsPerSample(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.BitsPerSample(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_Bitrate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_Bitrate(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Bitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_IsSpatial(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSpatial());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AudioEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AudioEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(AudioEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "create_aac", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateAac), METH_VARARGS | METH_STATIC, nullptr },
        { "create_aac_adts", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateAacAdts), METH_VARARGS | METH_STATIC, nullptr },
        { "create_alac", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateAlac), METH_VARARGS | METH_STATIC, nullptr },
        { "create_flac", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateFlac), METH_VARARGS | METH_STATIC, nullptr },
        { "create_mp3", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateMp3), METH_VARARGS | METH_STATIC, nullptr },
        { "create_pcm", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreatePcm), METH_VARARGS | METH_STATIC, nullptr },
        { "create_wma", reinterpret_cast<PyCFunction>(AudioEncodingProperties_CreateWma), METH_VARARGS | METH_STATIC, nullptr },
        { "get_format_user_data", reinterpret_cast<PyCFunction>(AudioEncodingProperties_GetFormatUserData), METH_VARARGS, nullptr },
        { "set_format_user_data", reinterpret_cast<PyCFunction>(AudioEncodingProperties_SetFormatUserData), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioEncodingProperties[] = {
        { "sample_rate", reinterpret_cast<getter>(AudioEncodingProperties_get_SampleRate), reinterpret_cast<setter>(AudioEncodingProperties_put_SampleRate), nullptr, nullptr },
        { "channel_count", reinterpret_cast<getter>(AudioEncodingProperties_get_ChannelCount), reinterpret_cast<setter>(AudioEncodingProperties_put_ChannelCount), nullptr, nullptr },
        { "bits_per_sample", reinterpret_cast<getter>(AudioEncodingProperties_get_BitsPerSample), reinterpret_cast<setter>(AudioEncodingProperties_put_BitsPerSample), nullptr, nullptr },
        { "bitrate", reinterpret_cast<getter>(AudioEncodingProperties_get_Bitrate), reinterpret_cast<setter>(AudioEncodingProperties_put_Bitrate), nullptr, nullptr },
        { "is_spatial", reinterpret_cast<getter>(AudioEncodingProperties_get_IsSpatial), nullptr, nullptr, nullptr },
        { "subtype", reinterpret_cast<getter>(AudioEncodingProperties_get_Subtype), reinterpret_cast<setter>(AudioEncodingProperties_put_Subtype), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(AudioEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(AudioEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioEncodingProperties[] = 
    {
        { Py_tp_new, _new_AudioEncodingProperties },
        { Py_tp_dealloc, _dealloc_AudioEncodingProperties },
        { Py_tp_methods, _methods_AudioEncodingProperties },
        { Py_tp_getset, _getset_AudioEncodingProperties },
        { },
    };

    static PyType_Spec type_spec_AudioEncodingProperties =
    {
        "_winsdk_Windows_Media_MediaProperties.AudioEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::AudioEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioEncodingProperties
    };

    // ----- ContainerEncodingProperties class --------------------
    constexpr const char* const type_name_ContainerEncodingProperties = "ContainerEncodingProperties";

    static PyObject* _new_ContainerEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::ContainerEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ContainerEncodingProperties(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContainerEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ContainerEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ContainerEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ContainerEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContainerEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContainerEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::ContainerEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContainerEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(ContainerEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ContainerEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContainerEncodingProperties[] = {
        { "subtype", reinterpret_cast<getter>(ContainerEncodingProperties_get_Subtype), reinterpret_cast<setter>(ContainerEncodingProperties_put_Subtype), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(ContainerEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ContainerEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContainerEncodingProperties[] = 
    {
        { Py_tp_new, _new_ContainerEncodingProperties },
        { Py_tp_dealloc, _dealloc_ContainerEncodingProperties },
        { Py_tp_methods, _methods_ContainerEncodingProperties },
        { Py_tp_getset, _getset_ContainerEncodingProperties },
        { },
    };

    static PyType_Spec type_spec_ContainerEncodingProperties =
    {
        "_winsdk_Windows_Media_MediaProperties.ContainerEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::ContainerEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContainerEncodingProperties
    };

    // ----- H264ProfileIds class --------------------
    constexpr const char* const type_name_H264ProfileIds = "H264ProfileIds";

    static PyObject* _new_H264ProfileIds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_H264ProfileIds);
        return nullptr;
    }

    static PyObject* H264ProfileIds_get_Baseline(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::Baseline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_ConstrainedBaseline(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::ConstrainedBaseline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_Extended(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::Extended());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High10(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High10());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High422(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High422());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_High444(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::High444());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_Main(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::Main());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_MultiviewHigh(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::MultiviewHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* H264ProfileIds_get_StereoHigh(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::H264ProfileIds::StereoHigh());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_H264ProfileIds[] = {
        { "get_baseline", reinterpret_cast<PyCFunction>(H264ProfileIds_get_Baseline), METH_NOARGS | METH_STATIC, nullptr },
        { "get_constrained_baseline", reinterpret_cast<PyCFunction>(H264ProfileIds_get_ConstrainedBaseline), METH_NOARGS | METH_STATIC, nullptr },
        { "get_extended", reinterpret_cast<PyCFunction>(H264ProfileIds_get_Extended), METH_NOARGS | METH_STATIC, nullptr },
        { "get_high", reinterpret_cast<PyCFunction>(H264ProfileIds_get_High), METH_NOARGS | METH_STATIC, nullptr },
        { "get_high10", reinterpret_cast<PyCFunction>(H264ProfileIds_get_High10), METH_NOARGS | METH_STATIC, nullptr },
        { "get_high422", reinterpret_cast<PyCFunction>(H264ProfileIds_get_High422), METH_NOARGS | METH_STATIC, nullptr },
        { "get_high444", reinterpret_cast<PyCFunction>(H264ProfileIds_get_High444), METH_NOARGS | METH_STATIC, nullptr },
        { "get_main", reinterpret_cast<PyCFunction>(H264ProfileIds_get_Main), METH_NOARGS | METH_STATIC, nullptr },
        { "get_multiview_high", reinterpret_cast<PyCFunction>(H264ProfileIds_get_MultiviewHigh), METH_NOARGS | METH_STATIC, nullptr },
        { "get_stereo_high", reinterpret_cast<PyCFunction>(H264ProfileIds_get_StereoHigh), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_H264ProfileIds[] = {
        { }
    };

    static PyType_Slot _type_slots_H264ProfileIds[] = 
    {
        { Py_tp_new, _new_H264ProfileIds },
        { Py_tp_methods, _methods_H264ProfileIds },
        { Py_tp_getset, _getset_H264ProfileIds },
        { },
    };

    static PyType_Spec type_spec_H264ProfileIds =
    {
        "_winsdk_Windows_Media_MediaProperties.H264ProfileIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_H264ProfileIds
    };

    // ----- ImageEncodingProperties class --------------------
    constexpr const char* const type_name_ImageEncodingProperties = "ImageEncodingProperties";

    static PyObject* _new_ImageEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::ImageEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ImageEncodingProperties(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ImageEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateBmp(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateBmp());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateHeif(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateHeif());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateJpeg(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateJpeg());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateJpegXR(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateJpegXR());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreatePng(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreatePng());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_CreateUncompressed(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaPixelFormat>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::ImageEncodingProperties::CreateUncompressed(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_get_Width(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageEncodingProperties_put_Width(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Width(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageEncodingProperties_get_Height(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageEncodingProperties_put_Height(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Height(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ImageEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ImageEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ImageEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ImageEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ImageEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(ImageEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "create_bmp", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateBmp), METH_VARARGS | METH_STATIC, nullptr },
        { "create_heif", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateHeif), METH_VARARGS | METH_STATIC, nullptr },
        { "create_jpeg", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateJpeg), METH_VARARGS | METH_STATIC, nullptr },
        { "create_jpeg_x_r", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateJpegXR), METH_VARARGS | METH_STATIC, nullptr },
        { "create_png", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreatePng), METH_VARARGS | METH_STATIC, nullptr },
        { "create_uncompressed", reinterpret_cast<PyCFunction>(ImageEncodingProperties_CreateUncompressed), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ImageEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ImageEncodingProperties[] = {
        { "width", reinterpret_cast<getter>(ImageEncodingProperties_get_Width), reinterpret_cast<setter>(ImageEncodingProperties_put_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(ImageEncodingProperties_get_Height), reinterpret_cast<setter>(ImageEncodingProperties_put_Height), nullptr, nullptr },
        { "subtype", reinterpret_cast<getter>(ImageEncodingProperties_get_Subtype), reinterpret_cast<setter>(ImageEncodingProperties_put_Subtype), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(ImageEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(ImageEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ImageEncodingProperties[] = 
    {
        { Py_tp_new, _new_ImageEncodingProperties },
        { Py_tp_dealloc, _dealloc_ImageEncodingProperties },
        { Py_tp_methods, _methods_ImageEncodingProperties },
        { Py_tp_getset, _getset_ImageEncodingProperties },
        { },
    };

    static PyType_Spec type_spec_ImageEncodingProperties =
    {
        "_winsdk_Windows_Media_MediaProperties.ImageEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::ImageEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ImageEncodingProperties
    };

    // ----- MediaEncodingProfile class --------------------
    constexpr const char* const type_name_MediaEncodingProfile = "MediaEncodingProfile";

    static PyObject* _new_MediaEncodingProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::MediaEncodingProfile instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaEncodingProfile(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaEncodingProfile_CreateAlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateAlac(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateAvi(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateAvi(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateFlac(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateFlac(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateFromFileAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateFromFileAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateFromStreamAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStream>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateFromStreamAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateHevc(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateHevc(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateM4a(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateM4a(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateMp3(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateMp3(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateMp4(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateMp4(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateWav(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateWav(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateWma(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateWma(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_CreateWmv(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingProfile::CreateWmv(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_GetAudioTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioTracks());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_GetTimedMetadataTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetTimedMetadataTracks());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_GetVideoTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetVideoTracks());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_SetAudioTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Core::AudioStreamDescriptor>>(args, 0);

                self->obj.SetAudioTracks(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_SetTimedMetadataTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Core::TimedMetadataStreamDescriptor>>(args, 0);

                self->obj.SetTimedMetadataTracks(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_SetVideoTracks(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Media::Core::VideoStreamDescriptor>>(args, 0);

                self->obj.SetVideoTracks(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaEncodingProfile_get_Video(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Video());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaEncodingProfile_put_Video(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(arg);

            self->obj.Video(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaEncodingProfile_get_Container(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Container());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaEncodingProfile_put_Container(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::ContainerEncodingProperties>(arg);

            self->obj.Container(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaEncodingProfile_get_Audio(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Audio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaEncodingProfile_put_Audio(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(arg);

            self->obj.Audio(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MediaEncodingProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaEncodingProfile[] = {
        { "create_alac", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateAlac), METH_VARARGS | METH_STATIC, nullptr },
        { "create_avi", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateAvi), METH_VARARGS | METH_STATIC, nullptr },
        { "create_flac", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateFlac), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_file_async", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateFromFileAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_from_stream_async", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateFromStreamAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "create_hevc", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateHevc), METH_VARARGS | METH_STATIC, nullptr },
        { "create_m4a", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateM4a), METH_VARARGS | METH_STATIC, nullptr },
        { "create_mp3", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateMp3), METH_VARARGS | METH_STATIC, nullptr },
        { "create_mp4", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateMp4), METH_VARARGS | METH_STATIC, nullptr },
        { "create_wav", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateWav), METH_VARARGS | METH_STATIC, nullptr },
        { "create_wma", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateWma), METH_VARARGS | METH_STATIC, nullptr },
        { "create_wmv", reinterpret_cast<PyCFunction>(MediaEncodingProfile_CreateWmv), METH_VARARGS | METH_STATIC, nullptr },
        { "get_audio_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_GetAudioTracks), METH_VARARGS, nullptr },
        { "get_timed_metadata_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_GetTimedMetadataTracks), METH_VARARGS, nullptr },
        { "get_video_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_GetVideoTracks), METH_VARARGS, nullptr },
        { "set_audio_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_SetAudioTracks), METH_VARARGS, nullptr },
        { "set_timed_metadata_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_SetTimedMetadataTracks), METH_VARARGS, nullptr },
        { "set_video_tracks", reinterpret_cast<PyCFunction>(MediaEncodingProfile_SetVideoTracks), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaEncodingProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaEncodingProfile[] = {
        { "video", reinterpret_cast<getter>(MediaEncodingProfile_get_Video), reinterpret_cast<setter>(MediaEncodingProfile_put_Video), nullptr, nullptr },
        { "container", reinterpret_cast<getter>(MediaEncodingProfile_get_Container), reinterpret_cast<setter>(MediaEncodingProfile_put_Container), nullptr, nullptr },
        { "audio", reinterpret_cast<getter>(MediaEncodingProfile_get_Audio), reinterpret_cast<setter>(MediaEncodingProfile_put_Audio), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaEncodingProfile[] = 
    {
        { Py_tp_new, _new_MediaEncodingProfile },
        { Py_tp_dealloc, _dealloc_MediaEncodingProfile },
        { Py_tp_methods, _methods_MediaEncodingProfile },
        { Py_tp_getset, _getset_MediaEncodingProfile },
        { },
    };

    static PyType_Spec type_spec_MediaEncodingProfile =
    {
        "_winsdk_Windows_Media_MediaProperties.MediaEncodingProfile",
        sizeof(py::wrapper::Windows::Media::MediaProperties::MediaEncodingProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaEncodingProfile
    };

    // ----- MediaEncodingSubtypes class --------------------
    constexpr const char* const type_name_MediaEncodingSubtypes = "MediaEncodingSubtypes";

    static PyObject* _new_MediaEncodingSubtypes(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaEncodingSubtypes);
        return nullptr;
    }

    static PyObject* MediaEncodingSubtypes_get_Asf(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Asf());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Aac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Aac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_AacAdts(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::AacAdts());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Ac3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Ac3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_AmrNb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::AmrNb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_AmrWb(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::AmrWb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Argb32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Argb32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Avi(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Avi());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Bgra8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Bgra8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Bmp(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Bmp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Eac3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Eac3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Float(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Float());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Gif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Gif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_H263(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::H263());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_H264(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::H264());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_H264Es(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::H264Es());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Hevc(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Hevc());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_HevcEs(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::HevcEs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Iyuv(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Iyuv());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Jpeg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Jpeg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_JpegXr(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::JpegXr());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mjpg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mjpg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mp3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mp3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Mpeg4(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Mpeg4());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Nv12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Nv12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Pcm(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Pcm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Png(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Png());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Rgb24(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Rgb24());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Rgb32(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Rgb32());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Tiff(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Tiff());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wave(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wave());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wma8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wma8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wma9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wma9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wmv3(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wmv3());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Wvc1(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Wvc1());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Yuy2(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Yuy2());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Yv12(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Yv12());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_D16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::D16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_L16(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::L16());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_L8(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::L8());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Vp9(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Vp9());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Alac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Alac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Flac(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Flac());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_P010(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::P010());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Heif(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Heif());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Srt(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Srt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Ssa(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Ssa());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_VobSub(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::VobSub());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MediaEncodingSubtypes_get_Pgs(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes::Pgs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaEncodingSubtypes[] = {
        { "get_asf", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Asf), METH_NOARGS | METH_STATIC, nullptr },
        { "get_aac", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Aac), METH_NOARGS | METH_STATIC, nullptr },
        { "get_aac_adts", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_AacAdts), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ac3", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Ac3), METH_NOARGS | METH_STATIC, nullptr },
        { "get_amr_nb", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_AmrNb), METH_NOARGS | METH_STATIC, nullptr },
        { "get_amr_wb", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_AmrWb), METH_NOARGS | METH_STATIC, nullptr },
        { "get_argb32", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Argb32), METH_NOARGS | METH_STATIC, nullptr },
        { "get_mpeg1", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Mpeg1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_avi", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Avi), METH_NOARGS | METH_STATIC, nullptr },
        { "get_bgra8", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Bgra8), METH_NOARGS | METH_STATIC, nullptr },
        { "get_bmp", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Bmp), METH_NOARGS | METH_STATIC, nullptr },
        { "get_eac3", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Eac3), METH_NOARGS | METH_STATIC, nullptr },
        { "get_float", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Float), METH_NOARGS | METH_STATIC, nullptr },
        { "get_gif", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Gif), METH_NOARGS | METH_STATIC, nullptr },
        { "get_h263", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_H263), METH_NOARGS | METH_STATIC, nullptr },
        { "get_h264", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_H264), METH_NOARGS | METH_STATIC, nullptr },
        { "get_h264_es", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_H264Es), METH_NOARGS | METH_STATIC, nullptr },
        { "get_hevc", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Hevc), METH_NOARGS | METH_STATIC, nullptr },
        { "get_hevc_es", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_HevcEs), METH_NOARGS | METH_STATIC, nullptr },
        { "get_iyuv", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Iyuv), METH_NOARGS | METH_STATIC, nullptr },
        { "get_jpeg", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Jpeg), METH_NOARGS | METH_STATIC, nullptr },
        { "get_jpeg_xr", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_JpegXr), METH_NOARGS | METH_STATIC, nullptr },
        { "get_mjpg", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Mjpg), METH_NOARGS | METH_STATIC, nullptr },
        { "get_mp3", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Mp3), METH_NOARGS | METH_STATIC, nullptr },
        { "get_mpeg", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Mpeg), METH_NOARGS | METH_STATIC, nullptr },
        { "get_mpeg2", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Mpeg2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_mpeg4", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Mpeg4), METH_NOARGS | METH_STATIC, nullptr },
        { "get_nv12", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Nv12), METH_NOARGS | METH_STATIC, nullptr },
        { "get_pcm", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Pcm), METH_NOARGS | METH_STATIC, nullptr },
        { "get_png", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Png), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rgb24", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Rgb24), METH_NOARGS | METH_STATIC, nullptr },
        { "get_rgb32", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Rgb32), METH_NOARGS | METH_STATIC, nullptr },
        { "get_tiff", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Tiff), METH_NOARGS | METH_STATIC, nullptr },
        { "get_wave", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Wave), METH_NOARGS | METH_STATIC, nullptr },
        { "get_wma8", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Wma8), METH_NOARGS | METH_STATIC, nullptr },
        { "get_wma9", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Wma9), METH_NOARGS | METH_STATIC, nullptr },
        { "get_wmv3", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Wmv3), METH_NOARGS | METH_STATIC, nullptr },
        { "get_wvc1", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Wvc1), METH_NOARGS | METH_STATIC, nullptr },
        { "get_yuy2", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Yuy2), METH_NOARGS | METH_STATIC, nullptr },
        { "get_yv12", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Yv12), METH_NOARGS | METH_STATIC, nullptr },
        { "get_d16", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_D16), METH_NOARGS | METH_STATIC, nullptr },
        { "get_l16", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_L16), METH_NOARGS | METH_STATIC, nullptr },
        { "get_l8", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_L8), METH_NOARGS | METH_STATIC, nullptr },
        { "get_vp9", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Vp9), METH_NOARGS | METH_STATIC, nullptr },
        { "get_alac", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Alac), METH_NOARGS | METH_STATIC, nullptr },
        { "get_flac", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Flac), METH_NOARGS | METH_STATIC, nullptr },
        { "get_p010", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_P010), METH_NOARGS | METH_STATIC, nullptr },
        { "get_heif", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Heif), METH_NOARGS | METH_STATIC, nullptr },
        { "get_srt", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Srt), METH_NOARGS | METH_STATIC, nullptr },
        { "get_ssa", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Ssa), METH_NOARGS | METH_STATIC, nullptr },
        { "get_vob_sub", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_VobSub), METH_NOARGS | METH_STATIC, nullptr },
        { "get_pgs", reinterpret_cast<PyCFunction>(MediaEncodingSubtypes_get_Pgs), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaEncodingSubtypes[] = {
        { }
    };

    static PyType_Slot _type_slots_MediaEncodingSubtypes[] = 
    {
        { Py_tp_new, _new_MediaEncodingSubtypes },
        { Py_tp_methods, _methods_MediaEncodingSubtypes },
        { Py_tp_getset, _getset_MediaEncodingSubtypes },
        { },
    };

    static PyType_Spec type_spec_MediaEncodingSubtypes =
    {
        "_winsdk_Windows_Media_MediaProperties.MediaEncodingSubtypes",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaEncodingSubtypes
    };

    // ----- MediaPropertySet class --------------------
    constexpr const char* const type_name_MediaPropertySet = "MediaPropertySet";

    static PyObject* _new_MediaPropertySet(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::MediaPropertySet instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaPropertySet_Clear(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Clear();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_First(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_GetView(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetView());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_HasKey(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.HasKey(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_Insert(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::IInspectable>(args, 1);

                return py::convert(self->obj.Insert(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_Lookup(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(self->obj.Lookup(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_Remove(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                self->obj.Remove(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MediaPropertySet_get_Size(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MediaPropertySet(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::MediaPropertySet>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self) noexcept
    {
        try
        {
            py::pyobj_handle iter{py::convert(self->obj.First())};
            return py::wrap_mapping_iter(iter.get());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_contains_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* key) noexcept
    {
        try
        {
            return static_cast<int>(self->obj.HasKey(py::convert_to<winrt::guid>(key)));
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static Py_ssize_t _map_length_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _map_subscript_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* key) noexcept
    {
        try
        {
            auto value = self->obj.TryLookup(py::convert_to<winrt::guid>(key));

            if (!value) {
                PyErr_SetObject(PyExc_KeyError, key);
                return nullptr;
            }

            return py::convert(value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int _map_assign_MediaPropertySet(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet* self, PyObject* key, PyObject* value) noexcept
    {
        try
        {
            auto _key = py::convert_to<winrt::guid>(key);

            if (value == nullptr) {
                if (!self->obj.TryRemove(_key)) {
                    PyErr_SetObject(PyExc_KeyError, key);
                    return -1;
                }

                return 0;
            }

            self->obj.Insert(_key, py::convert_to<winrt::Windows::Foundation::IInspectable>(value));

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyMethodDef _methods_MediaPropertySet[] = {
        { "clear", reinterpret_cast<PyCFunction>(MediaPropertySet_Clear), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(MediaPropertySet_First), METH_VARARGS, nullptr },
        { "get_view", reinterpret_cast<PyCFunction>(MediaPropertySet_GetView), METH_VARARGS, nullptr },
        { "has_key", reinterpret_cast<PyCFunction>(MediaPropertySet_HasKey), METH_VARARGS, nullptr },
        { "insert", reinterpret_cast<PyCFunction>(MediaPropertySet_Insert), METH_VARARGS, nullptr },
        { "lookup", reinterpret_cast<PyCFunction>(MediaPropertySet_Lookup), METH_VARARGS, nullptr },
        { "remove", reinterpret_cast<PyCFunction>(MediaPropertySet_Remove), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaPropertySet), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaPropertySet[] = {
        { "size", reinterpret_cast<getter>(MediaPropertySet_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaPropertySet[] = 
    {
        { Py_tp_new, _new_MediaPropertySet },
        { Py_tp_dealloc, _dealloc_MediaPropertySet },
        { Py_tp_methods, _methods_MediaPropertySet },
        { Py_tp_getset, _getset_MediaPropertySet },
        { Py_tp_iter, _iterator_MediaPropertySet },
        { Py_sq_contains, _map_contains_MediaPropertySet },
        { Py_mp_length, _map_length_MediaPropertySet },
        { Py_mp_subscript, _map_subscript_MediaPropertySet },
        { Py_mp_ass_subscript, _map_assign_MediaPropertySet },
        { },
    };

    static PyType_Spec type_spec_MediaPropertySet =
    {
        "_winsdk_Windows_Media_MediaProperties.MediaPropertySet",
        sizeof(py::wrapper::Windows::Media::MediaProperties::MediaPropertySet),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaPropertySet
    };

    // ----- MediaRatio class --------------------
    constexpr const char* const type_name_MediaRatio = "MediaRatio";

    static PyObject* _new_MediaRatio(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MediaRatio);
        return nullptr;
    }

    static void _dealloc_MediaRatio(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MediaRatio_get_Numerator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Numerator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaRatio_put_Numerator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Numerator(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MediaRatio_get_Denominator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Denominator());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MediaRatio_put_Denominator(py::wrapper::Windows::Media::MediaProperties::MediaRatio* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Denominator(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_MediaRatio(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::MediaRatio>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MediaRatio[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MediaRatio), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MediaRatio[] = {
        { "numerator", reinterpret_cast<getter>(MediaRatio_get_Numerator), reinterpret_cast<setter>(MediaRatio_put_Numerator), nullptr, nullptr },
        { "denominator", reinterpret_cast<getter>(MediaRatio_get_Denominator), reinterpret_cast<setter>(MediaRatio_put_Denominator), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MediaRatio[] = 
    {
        { Py_tp_new, _new_MediaRatio },
        { Py_tp_dealloc, _dealloc_MediaRatio },
        { Py_tp_methods, _methods_MediaRatio },
        { Py_tp_getset, _getset_MediaRatio },
        { },
    };

    static PyType_Spec type_spec_MediaRatio =
    {
        "_winsdk_Windows_Media_MediaProperties.MediaRatio",
        sizeof(py::wrapper::Windows::Media::MediaProperties::MediaRatio),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MediaRatio
    };

    // ----- Mpeg2ProfileIds class --------------------
    constexpr const char* const type_name_Mpeg2ProfileIds = "Mpeg2ProfileIds";

    static PyObject* _new_Mpeg2ProfileIds(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Mpeg2ProfileIds);
        return nullptr;
    }

    static PyObject* Mpeg2ProfileIds_get_High(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::High());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_Main(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::Main());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_SignalNoiseRatioScalable(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::SignalNoiseRatioScalable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_Simple(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::Simple());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Mpeg2ProfileIds_get_SpatiallyScalable(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds::SpatiallyScalable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Mpeg2ProfileIds[] = {
        { "get_high", reinterpret_cast<PyCFunction>(Mpeg2ProfileIds_get_High), METH_NOARGS | METH_STATIC, nullptr },
        { "get_main", reinterpret_cast<PyCFunction>(Mpeg2ProfileIds_get_Main), METH_NOARGS | METH_STATIC, nullptr },
        { "get_signal_noise_ratio_scalable", reinterpret_cast<PyCFunction>(Mpeg2ProfileIds_get_SignalNoiseRatioScalable), METH_NOARGS | METH_STATIC, nullptr },
        { "get_simple", reinterpret_cast<PyCFunction>(Mpeg2ProfileIds_get_Simple), METH_NOARGS | METH_STATIC, nullptr },
        { "get_spatially_scalable", reinterpret_cast<PyCFunction>(Mpeg2ProfileIds_get_SpatiallyScalable), METH_NOARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Mpeg2ProfileIds[] = {
        { }
    };

    static PyType_Slot _type_slots_Mpeg2ProfileIds[] = 
    {
        { Py_tp_new, _new_Mpeg2ProfileIds },
        { Py_tp_methods, _methods_Mpeg2ProfileIds },
        { Py_tp_getset, _getset_Mpeg2ProfileIds },
        { },
    };

    static PyType_Spec type_spec_Mpeg2ProfileIds =
    {
        "_winsdk_Windows_Media_MediaProperties.Mpeg2ProfileIds",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Mpeg2ProfileIds
    };

    // ----- TimedMetadataEncodingProperties class --------------------
    constexpr const char* const type_name_TimedMetadataEncodingProperties = "TimedMetadataEncodingProperties";

    static PyObject* _new_TimedMetadataEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_TimedMetadataEncodingProperties(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TimedMetadataEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreatePgs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreatePgs());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreateSrt(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreateSrt());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreateSsa(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreateSsa(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_CreateVobSub(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                return py::convert(winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties::CreateVobSub(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_GetFormatUserData(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetFormatUserData(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_SetFormatUserData(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetFormatUserData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int TimedMetadataEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* TimedMetadataEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TimedMetadataEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TimedMetadataEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "create_pgs", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_CreatePgs), METH_VARARGS | METH_STATIC, nullptr },
        { "create_srt", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_CreateSrt), METH_VARARGS | METH_STATIC, nullptr },
        { "create_ssa", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_CreateSsa), METH_VARARGS | METH_STATIC, nullptr },
        { "create_vob_sub", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_CreateVobSub), METH_VARARGS | METH_STATIC, nullptr },
        { "get_format_user_data", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_GetFormatUserData), METH_VARARGS, nullptr },
        { "set_format_user_data", reinterpret_cast<PyCFunction>(TimedMetadataEncodingProperties_SetFormatUserData), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_TimedMetadataEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TimedMetadataEncodingProperties[] = {
        { "subtype", reinterpret_cast<getter>(TimedMetadataEncodingProperties_get_Subtype), reinterpret_cast<setter>(TimedMetadataEncodingProperties_put_Subtype), nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(TimedMetadataEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(TimedMetadataEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TimedMetadataEncodingProperties[] = 
    {
        { Py_tp_new, _new_TimedMetadataEncodingProperties },
        { Py_tp_dealloc, _dealloc_TimedMetadataEncodingProperties },
        { Py_tp_methods, _methods_TimedMetadataEncodingProperties },
        { Py_tp_getset, _getset_TimedMetadataEncodingProperties },
        { },
    };

    static PyType_Spec type_spec_TimedMetadataEncodingProperties =
    {
        "_winsdk_Windows_Media_MediaProperties.TimedMetadataEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::TimedMetadataEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TimedMetadataEncodingProperties
    };

    // ----- VideoEncodingProperties class --------------------
    constexpr const char* const type_name_VideoEncodingProperties = "VideoEncodingProperties";

    static PyObject* _new_VideoEncodingProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::MediaProperties::VideoEncodingProperties instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoEncodingProperties(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VideoEncodingProperties_Copy(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.Copy());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateH264(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateH264());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateHevc(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateHevc());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateMpeg2(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateMpeg2());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_CreateUncompressed(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<uint32_t>(args, 2);

                return py::convert(winrt::Windows::Media::MediaProperties::VideoEncodingProperties::CreateUncompressed(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_GetFormatUserData(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                winrt::com_array<uint8_t> param0 { };

                self->obj.GetFormatUserData(param0);

                py::pyobj_handle out0{ py::convert(param0) };
                if (!out0)
                {
                    return nullptr;
                }
                return out0.detach();
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_SetFormatUserData(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<uint8_t>>(args, 0);

                self->obj.SetFormatUserData(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_Width(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Width());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Width(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Width(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_Height(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Height());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Height(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Height(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_Bitrate(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bitrate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_Bitrate(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Bitrate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_PixelAspectRatio(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelAspectRatio());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_FrameRate(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameRate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_ProfileId(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProfileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoEncodingProperties_put_ProfileId(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ProfileId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoEncodingProperties_get_StereoscopicVideoPackingMode(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StereoscopicVideoPackingMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEncodingProperties_get_SphericalVideoFrameFormat(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SphericalVideoFrameFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoEncodingProperties[] = {
        { "copy", reinterpret_cast<PyCFunction>(VideoEncodingProperties_Copy), METH_VARARGS, nullptr },
        { "create_h264", reinterpret_cast<PyCFunction>(VideoEncodingProperties_CreateH264), METH_VARARGS | METH_STATIC, nullptr },
        { "create_hevc", reinterpret_cast<PyCFunction>(VideoEncodingProperties_CreateHevc), METH_VARARGS | METH_STATIC, nullptr },
        { "create_mpeg2", reinterpret_cast<PyCFunction>(VideoEncodingProperties_CreateMpeg2), METH_VARARGS | METH_STATIC, nullptr },
        { "create_uncompressed", reinterpret_cast<PyCFunction>(VideoEncodingProperties_CreateUncompressed), METH_VARARGS | METH_STATIC, nullptr },
        { "get_format_user_data", reinterpret_cast<PyCFunction>(VideoEncodingProperties_GetFormatUserData), METH_VARARGS, nullptr },
        { "set_format_user_data", reinterpret_cast<PyCFunction>(VideoEncodingProperties_SetFormatUserData), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoEncodingProperties[] = {
        { "subtype", reinterpret_cast<getter>(VideoEncodingProperties_get_Subtype), reinterpret_cast<setter>(VideoEncodingProperties_put_Subtype), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(VideoEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "width", reinterpret_cast<getter>(VideoEncodingProperties_get_Width), reinterpret_cast<setter>(VideoEncodingProperties_put_Width), nullptr, nullptr },
        { "height", reinterpret_cast<getter>(VideoEncodingProperties_get_Height), reinterpret_cast<setter>(VideoEncodingProperties_put_Height), nullptr, nullptr },
        { "bitrate", reinterpret_cast<getter>(VideoEncodingProperties_get_Bitrate), reinterpret_cast<setter>(VideoEncodingProperties_put_Bitrate), nullptr, nullptr },
        { "pixel_aspect_ratio", reinterpret_cast<getter>(VideoEncodingProperties_get_PixelAspectRatio), nullptr, nullptr, nullptr },
        { "frame_rate", reinterpret_cast<getter>(VideoEncodingProperties_get_FrameRate), nullptr, nullptr, nullptr },
        { "profile_id", reinterpret_cast<getter>(VideoEncodingProperties_get_ProfileId), reinterpret_cast<setter>(VideoEncodingProperties_put_ProfileId), nullptr, nullptr },
        { "stereoscopic_video_packing_mode", reinterpret_cast<getter>(VideoEncodingProperties_get_StereoscopicVideoPackingMode), nullptr, nullptr, nullptr },
        { "spherical_video_frame_format", reinterpret_cast<getter>(VideoEncodingProperties_get_SphericalVideoFrameFormat), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoEncodingProperties[] = 
    {
        { Py_tp_new, _new_VideoEncodingProperties },
        { Py_tp_dealloc, _dealloc_VideoEncodingProperties },
        { Py_tp_methods, _methods_VideoEncodingProperties },
        { Py_tp_getset, _getset_VideoEncodingProperties },
        { },
    };

    static PyType_Spec type_spec_VideoEncodingProperties =
    {
        "_winsdk_Windows_Media_MediaProperties.VideoEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::VideoEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoEncodingProperties
    };

    // ----- IMediaEncodingProperties interface --------------------
    constexpr const char* const type_name_IMediaEncodingProperties = "IMediaEncodingProperties";

    static PyObject* _new_IMediaEncodingProperties(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IMediaEncodingProperties);
        return nullptr;
    }

    static void _dealloc_IMediaEncodingProperties(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMediaEncodingProperties_get_Properties(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMediaEncodingProperties_get_Subtype(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Subtype());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int IMediaEncodingProperties_put_Subtype(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Subtype(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* IMediaEncodingProperties_get_Type(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IMediaEncodingProperties(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMediaEncodingProperties[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IMediaEncodingProperties), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMediaEncodingProperties[] = {
        { "properties", reinterpret_cast<getter>(IMediaEncodingProperties_get_Properties), nullptr, nullptr, nullptr },
        { "subtype", reinterpret_cast<getter>(IMediaEncodingProperties_get_Subtype), reinterpret_cast<setter>(IMediaEncodingProperties_put_Subtype), nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IMediaEncodingProperties_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMediaEncodingProperties[] = 
    {
        { Py_tp_new, _new_IMediaEncodingProperties },
        { Py_tp_dealloc, _dealloc_IMediaEncodingProperties },
        { Py_tp_methods, _methods_IMediaEncodingProperties },
        { Py_tp_getset, _getset_IMediaEncodingProperties },
        { },
    };

    static PyType_Spec type_spec_IMediaEncodingProperties =
    {
        "_winsdk_Windows_Media_MediaProperties.IMediaEncodingProperties",
        sizeof(py::wrapper::Windows::Media::MediaProperties::IMediaEncodingProperties),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMediaEncodingProperties
    };

    // ----- Windows.Media.MediaProperties Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Media::MediaProperties");

    static PyMethodDef module_methods[] = {
        {"_register_AudioEncodingQuality", register_AudioEncodingQuality, METH_O, "registers type"},
        {"_register_MediaMirroringOptions", register_MediaMirroringOptions, METH_O, "registers type"},
        {"_register_MediaPixelFormat", register_MediaPixelFormat, METH_O, "registers type"},
        {"_register_MediaRotation", register_MediaRotation, METH_O, "registers type"},
        {"_register_MediaThumbnailFormat", register_MediaThumbnailFormat, METH_O, "registers type"},
        {"_register_SphericalVideoFrameFormat", register_SphericalVideoFrameFormat, METH_O, "registers type"},
        {"_register_StereoscopicVideoPackingMode", register_StereoscopicVideoPackingMode, METH_O, "registers type"},
        {"_register_VideoEncodingQuality", register_VideoEncodingQuality, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_AudioEncodingQuality);
        Py_VISIT(state->type_MediaMirroringOptions);
        Py_VISIT(state->type_MediaPixelFormat);
        Py_VISIT(state->type_MediaRotation);
        Py_VISIT(state->type_MediaThumbnailFormat);
        Py_VISIT(state->type_SphericalVideoFrameFormat);
        Py_VISIT(state->type_StereoscopicVideoPackingMode);
        Py_VISIT(state->type_VideoEncodingQuality);
        Py_VISIT(state->type_AudioEncodingProperties);
        Py_VISIT(state->type_ContainerEncodingProperties);
        Py_VISIT(state->type_H264ProfileIds);
        Py_VISIT(state->type_ImageEncodingProperties);
        Py_VISIT(state->type_MediaEncodingProfile);
        Py_VISIT(state->type_MediaEncodingSubtypes);
        Py_VISIT(state->type_MediaPropertySet);
        Py_VISIT(state->type_MediaRatio);
        Py_VISIT(state->type_Mpeg2ProfileIds);
        Py_VISIT(state->type_TimedMetadataEncodingProperties);
        Py_VISIT(state->type_VideoEncodingProperties);
        Py_VISIT(state->type_IMediaEncodingProperties);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_AudioEncodingQuality);
        Py_CLEAR(state->type_MediaMirroringOptions);
        Py_CLEAR(state->type_MediaPixelFormat);
        Py_CLEAR(state->type_MediaRotation);
        Py_CLEAR(state->type_MediaThumbnailFormat);
        Py_CLEAR(state->type_SphericalVideoFrameFormat);
        Py_CLEAR(state->type_StereoscopicVideoPackingMode);
        Py_CLEAR(state->type_VideoEncodingQuality);
        Py_CLEAR(state->type_AudioEncodingProperties);
        Py_CLEAR(state->type_ContainerEncodingProperties);
        Py_CLEAR(state->type_H264ProfileIds);
        Py_CLEAR(state->type_ImageEncodingProperties);
        Py_CLEAR(state->type_MediaEncodingProfile);
        Py_CLEAR(state->type_MediaEncodingSubtypes);
        Py_CLEAR(state->type_MediaPropertySet);
        Py_CLEAR(state->type_MediaRatio);
        Py_CLEAR(state->type_Mpeg2ProfileIds);
        Py_CLEAR(state->type_TimedMetadataEncodingProperties);
        Py_CLEAR(state->type_VideoEncodingProperties);
        Py_CLEAR(state->type_IMediaEncodingProperties);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_MediaProperties",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Media::MediaProperties

PyMODINIT_FUNC PyInit__winsdk_Windows_Media_MediaProperties(void) noexcept
{
    using namespace py::cpp::Windows::Media::MediaProperties;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AudioEncodingProperties = py::register_python_type(module.get(), type_name_AudioEncodingProperties, &type_spec_AudioEncodingProperties, bases.get());
    if (!state->type_AudioEncodingProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AudioEncodingProperties);

    state->type_ContainerEncodingProperties = py::register_python_type(module.get(), type_name_ContainerEncodingProperties, &type_spec_ContainerEncodingProperties, bases.get());
    if (!state->type_ContainerEncodingProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ContainerEncodingProperties);

    state->type_H264ProfileIds = py::register_python_type(module.get(), type_name_H264ProfileIds, &type_spec_H264ProfileIds, nullptr);
    if (!state->type_H264ProfileIds)
    {
        return nullptr;
    }

    Py_INCREF(state->type_H264ProfileIds);

    state->type_ImageEncodingProperties = py::register_python_type(module.get(), type_name_ImageEncodingProperties, &type_spec_ImageEncodingProperties, bases.get());
    if (!state->type_ImageEncodingProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ImageEncodingProperties);

    state->type_MediaEncodingProfile = py::register_python_type(module.get(), type_name_MediaEncodingProfile, &type_spec_MediaEncodingProfile, bases.get());
    if (!state->type_MediaEncodingProfile)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaEncodingProfile);

    state->type_MediaEncodingSubtypes = py::register_python_type(module.get(), type_name_MediaEncodingSubtypes, &type_spec_MediaEncodingSubtypes, nullptr);
    if (!state->type_MediaEncodingSubtypes)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaEncodingSubtypes);

    state->type_MediaPropertySet = py::register_python_type(module.get(), type_name_MediaPropertySet, &type_spec_MediaPropertySet, mutable_mapping_bases.get());
    if (!state->type_MediaPropertySet)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaPropertySet);

    state->type_MediaRatio = py::register_python_type(module.get(), type_name_MediaRatio, &type_spec_MediaRatio, bases.get());
    if (!state->type_MediaRatio)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MediaRatio);

    state->type_Mpeg2ProfileIds = py::register_python_type(module.get(), type_name_Mpeg2ProfileIds, &type_spec_Mpeg2ProfileIds, nullptr);
    if (!state->type_Mpeg2ProfileIds)
    {
        return nullptr;
    }

    Py_INCREF(state->type_Mpeg2ProfileIds);

    state->type_TimedMetadataEncodingProperties = py::register_python_type(module.get(), type_name_TimedMetadataEncodingProperties, &type_spec_TimedMetadataEncodingProperties, bases.get());
    if (!state->type_TimedMetadataEncodingProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TimedMetadataEncodingProperties);

    state->type_VideoEncodingProperties = py::register_python_type(module.get(), type_name_VideoEncodingProperties, &type_spec_VideoEncodingProperties, bases.get());
    if (!state->type_VideoEncodingProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_VideoEncodingProperties);

    state->type_IMediaEncodingProperties = py::register_python_type(module.get(), type_name_IMediaEncodingProperties, &type_spec_IMediaEncodingProperties, bases.get());
    if (!state->type_IMediaEncodingProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IMediaEncodingProperties);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Media::MediaProperties::AudioEncodingQuality>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioEncodingQuality;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::AudioEncodingQuality is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::MediaProperties::MediaMirroringOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaMirroringOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::MediaMirroringOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::MediaProperties::MediaPixelFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaPixelFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::MediaPixelFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::MediaProperties::MediaRotation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaRotation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::MediaRotation is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::MediaProperties::MediaThumbnailFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaThumbnailFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::MediaThumbnailFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::MediaProperties::SphericalVideoFrameFormat>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SphericalVideoFrameFormat;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::SphericalVideoFrameFormat is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::MediaProperties::StereoscopicVideoPackingMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StereoscopicVideoPackingMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::StereoscopicVideoPackingMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Media::MediaProperties::VideoEncodingQuality>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoEncodingQuality;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::VideoEncodingQuality is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AudioEncodingProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::AudioEncodingProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::ContainerEncodingProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContainerEncodingProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::ContainerEncodingProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::H264ProfileIds>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_H264ProfileIds;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::H264ProfileIds is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::ImageEncodingProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ImageEncodingProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::ImageEncodingProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::MediaEncodingProfile>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaEncodingProfile;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::MediaEncodingProfile is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaEncodingSubtypes;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::MediaEncodingSubtypes is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::MediaPropertySet>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaPropertySet;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::MediaPropertySet is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::MediaRatio>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MediaRatio;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::MediaRatio is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Mpeg2ProfileIds;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::Mpeg2ProfileIds is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TimedMetadataEncodingProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::TimedMetadataEncodingProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VideoEncodingProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::VideoEncodingProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Media::MediaProperties::IMediaEncodingProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Media::MediaProperties;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Media::MediaProperties");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMediaEncodingProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Media::MediaProperties::IMediaEncodingProperties is not registered");
        return nullptr;
    }

    return python_type;
}
