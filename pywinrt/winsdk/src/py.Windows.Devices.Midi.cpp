// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.5

#include "pybase.h"
#include "py.Windows.Devices.Midi.h"


namespace py::cpp::Windows::Devices::Midi
{
    struct module_state
    {
        PyObject* type_MidiMessageType;
        PyTypeObject* type_MidiActiveSensingMessage;
        PyTypeObject* type_MidiChannelPressureMessage;
        PyTypeObject* type_MidiContinueMessage;
        PyTypeObject* type_MidiControlChangeMessage;
        PyTypeObject* type_MidiInPort;
        PyTypeObject* type_MidiMessageReceivedEventArgs;
        PyTypeObject* type_MidiNoteOffMessage;
        PyTypeObject* type_MidiNoteOnMessage;
        PyTypeObject* type_MidiOutPort;
        PyTypeObject* type_MidiPitchBendChangeMessage;
        PyTypeObject* type_MidiPolyphonicKeyPressureMessage;
        PyTypeObject* type_MidiProgramChangeMessage;
        PyTypeObject* type_MidiSongPositionPointerMessage;
        PyTypeObject* type_MidiSongSelectMessage;
        PyTypeObject* type_MidiStartMessage;
        PyTypeObject* type_MidiStopMessage;
        PyTypeObject* type_MidiSynthesizer;
        PyTypeObject* type_MidiSystemExclusiveMessage;
        PyTypeObject* type_MidiSystemResetMessage;
        PyTypeObject* type_MidiTimeCodeMessage;
        PyTypeObject* type_MidiTimingClockMessage;
        PyTypeObject* type_MidiTuneRequestMessage;
        PyTypeObject* type_IMidiMessage;
        PyTypeObject* type_IMidiOutPort;
    };

    static PyObject* register_MidiMessageType(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_MidiMessageType)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_MidiMessageType = type;
        Py_INCREF(state->type_MidiMessageType);


        Py_RETURN_NONE;
    }

    // ----- MidiActiveSensingMessage class --------------------
    constexpr const char* const type_name_MidiActiveSensingMessage = "MidiActiveSensingMessage";

    static PyObject* _new_MidiActiveSensingMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiActiveSensingMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiActiveSensingMessage(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiActiveSensingMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiActiveSensingMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiActiveSensingMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiActiveSensingMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiActiveSensingMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiActiveSensingMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiActiveSensingMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiActiveSensingMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiActiveSensingMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiActiveSensingMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiActiveSensingMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiActiveSensingMessage[] = 
    {
        { Py_tp_new, _new_MidiActiveSensingMessage },
        { Py_tp_dealloc, _dealloc_MidiActiveSensingMessage },
        { Py_tp_methods, _methods_MidiActiveSensingMessage },
        { Py_tp_getset, _getset_MidiActiveSensingMessage },
        { },
    };

    static PyType_Spec type_spec_MidiActiveSensingMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiActiveSensingMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiActiveSensingMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiActiveSensingMessage
    };

    // ----- MidiChannelPressureMessage class --------------------
    constexpr const char* const type_name_MidiChannelPressureMessage = "MidiChannelPressureMessage";

    static PyObject* _new_MidiChannelPressureMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                winrt::Windows::Devices::Midi::MidiChannelPressureMessage instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiChannelPressureMessage(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiChannelPressureMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiChannelPressureMessage_get_Pressure(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiChannelPressureMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiChannelPressureMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiChannelPressureMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiChannelPressureMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiChannelPressureMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiChannelPressureMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiChannelPressureMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiChannelPressureMessage[] = {
        { "channel", reinterpret_cast<getter>(MidiChannelPressureMessage_get_Channel), nullptr, nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(MidiChannelPressureMessage_get_Pressure), nullptr, nullptr, nullptr },
        { "raw_data", reinterpret_cast<getter>(MidiChannelPressureMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiChannelPressureMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiChannelPressureMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiChannelPressureMessage[] = 
    {
        { Py_tp_new, _new_MidiChannelPressureMessage },
        { Py_tp_dealloc, _dealloc_MidiChannelPressureMessage },
        { Py_tp_methods, _methods_MidiChannelPressureMessage },
        { Py_tp_getset, _getset_MidiChannelPressureMessage },
        { },
    };

    static PyType_Spec type_spec_MidiChannelPressureMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiChannelPressureMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiChannelPressureMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiChannelPressureMessage
    };

    // ----- MidiContinueMessage class --------------------
    constexpr const char* const type_name_MidiContinueMessage = "MidiContinueMessage";

    static PyObject* _new_MidiContinueMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiContinueMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiContinueMessage(py::wrapper::Windows::Devices::Midi::MidiContinueMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiContinueMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiContinueMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiContinueMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiContinueMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiContinueMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiContinueMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiContinueMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiContinueMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiContinueMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiContinueMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiContinueMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiContinueMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiContinueMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiContinueMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiContinueMessage[] = 
    {
        { Py_tp_new, _new_MidiContinueMessage },
        { Py_tp_dealloc, _dealloc_MidiContinueMessage },
        { Py_tp_methods, _methods_MidiContinueMessage },
        { Py_tp_getset, _getset_MidiContinueMessage },
        { },
    };

    static PyType_Spec type_spec_MidiContinueMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiContinueMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiContinueMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiContinueMessage
    };

    // ----- MidiControlChangeMessage class --------------------
    constexpr const char* const type_name_MidiControlChangeMessage = "MidiControlChangeMessage";

    static PyObject* _new_MidiControlChangeMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);

                winrt::Windows::Devices::Midi::MidiControlChangeMessage instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiControlChangeMessage(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiControlChangeMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_ControlValue(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ControlValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_Controller(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Controller());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiControlChangeMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiControlChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiControlChangeMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiControlChangeMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiControlChangeMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiControlChangeMessage[] = {
        { "channel", reinterpret_cast<getter>(MidiControlChangeMessage_get_Channel), nullptr, nullptr, nullptr },
        { "control_value", reinterpret_cast<getter>(MidiControlChangeMessage_get_ControlValue), nullptr, nullptr, nullptr },
        { "controller", reinterpret_cast<getter>(MidiControlChangeMessage_get_Controller), nullptr, nullptr, nullptr },
        { "raw_data", reinterpret_cast<getter>(MidiControlChangeMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiControlChangeMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiControlChangeMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiControlChangeMessage[] = 
    {
        { Py_tp_new, _new_MidiControlChangeMessage },
        { Py_tp_dealloc, _dealloc_MidiControlChangeMessage },
        { Py_tp_methods, _methods_MidiControlChangeMessage },
        { Py_tp_getset, _getset_MidiControlChangeMessage },
        { },
    };

    static PyType_Spec type_spec_MidiControlChangeMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiControlChangeMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiControlChangeMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiControlChangeMessage
    };

    // ----- MidiInPort class --------------------
    constexpr const char* const type_name_MidiInPort = "MidiInPort";

    static PyObject* _new_MidiInPort(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MidiInPort);
        return nullptr;
    }

    static void _dealloc_MidiInPort(py::wrapper::Windows::Devices::Midi::MidiInPort* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiInPort_Close(py::wrapper::Windows::Devices::Midi::MidiInPort* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiInPort_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Midi::MidiInPort::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiInPort_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Midi::MidiInPort::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiInPort_get_DeviceId(py::wrapper::Windows::Devices::Midi::MidiInPort* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiInPort_add_MessageReceived(py::wrapper::Windows::Devices::Midi::MidiInPort* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Midi::MidiInPort, winrt::Windows::Devices::Midi::MidiMessageReceivedEventArgs>>(arg);

            return py::convert(self->obj.MessageReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiInPort_remove_MessageReceived(py::wrapper::Windows::Devices::Midi::MidiInPort* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.MessageReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiInPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiInPort>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MidiInPort(py::wrapper::Windows::Devices::Midi::MidiInPort* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MidiInPort(py::wrapper::Windows::Devices::Midi::MidiInPort* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiInPort[] = {
        { "close", reinterpret_cast<PyCFunction>(MidiInPort_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(MidiInPort_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(MidiInPort_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "add_message_received", reinterpret_cast<PyCFunction>(MidiInPort_add_MessageReceived), METH_O, nullptr },
        { "remove_message_received", reinterpret_cast<PyCFunction>(MidiInPort_remove_MessageReceived), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiInPort), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MidiInPort), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MidiInPort), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiInPort[] = {
        { "device_id", reinterpret_cast<getter>(MidiInPort_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiInPort[] = 
    {
        { Py_tp_new, _new_MidiInPort },
        { Py_tp_dealloc, _dealloc_MidiInPort },
        { Py_tp_methods, _methods_MidiInPort },
        { Py_tp_getset, _getset_MidiInPort },
        { },
    };

    static PyType_Spec type_spec_MidiInPort =
    {
        "_winsdk_Windows_Devices_Midi.MidiInPort",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiInPort),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiInPort
    };

    // ----- MidiMessageReceivedEventArgs class --------------------
    constexpr const char* const type_name_MidiMessageReceivedEventArgs = "MidiMessageReceivedEventArgs";

    static PyObject* _new_MidiMessageReceivedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MidiMessageReceivedEventArgs);
        return nullptr;
    }

    static void _dealloc_MidiMessageReceivedEventArgs(py::wrapper::Windows::Devices::Midi::MidiMessageReceivedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiMessageReceivedEventArgs_get_Message(py::wrapper::Windows::Devices::Midi::MidiMessageReceivedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiMessageReceivedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiMessageReceivedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiMessageReceivedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiMessageReceivedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiMessageReceivedEventArgs[] = {
        { "message", reinterpret_cast<getter>(MidiMessageReceivedEventArgs_get_Message), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiMessageReceivedEventArgs[] = 
    {
        { Py_tp_new, _new_MidiMessageReceivedEventArgs },
        { Py_tp_dealloc, _dealloc_MidiMessageReceivedEventArgs },
        { Py_tp_methods, _methods_MidiMessageReceivedEventArgs },
        { Py_tp_getset, _getset_MidiMessageReceivedEventArgs },
        { },
    };

    static PyType_Spec type_spec_MidiMessageReceivedEventArgs =
    {
        "_winsdk_Windows_Devices_Midi.MidiMessageReceivedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiMessageReceivedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiMessageReceivedEventArgs
    };

    // ----- MidiNoteOffMessage class --------------------
    constexpr const char* const type_name_MidiNoteOffMessage = "MidiNoteOffMessage";

    static PyObject* _new_MidiNoteOffMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);

                winrt::Windows::Devices::Midi::MidiNoteOffMessage instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiNoteOffMessage(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiNoteOffMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Note(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Note());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOffMessage_get_Velocity(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Velocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiNoteOffMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiNoteOffMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiNoteOffMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiNoteOffMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiNoteOffMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiNoteOffMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiNoteOffMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiNoteOffMessage_get_Type), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiNoteOffMessage_get_Channel), nullptr, nullptr, nullptr },
        { "note", reinterpret_cast<getter>(MidiNoteOffMessage_get_Note), nullptr, nullptr, nullptr },
        { "velocity", reinterpret_cast<getter>(MidiNoteOffMessage_get_Velocity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiNoteOffMessage[] = 
    {
        { Py_tp_new, _new_MidiNoteOffMessage },
        { Py_tp_dealloc, _dealloc_MidiNoteOffMessage },
        { Py_tp_methods, _methods_MidiNoteOffMessage },
        { Py_tp_getset, _getset_MidiNoteOffMessage },
        { },
    };

    static PyType_Spec type_spec_MidiNoteOffMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiNoteOffMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiNoteOffMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiNoteOffMessage
    };

    // ----- MidiNoteOnMessage class --------------------
    constexpr const char* const type_name_MidiNoteOnMessage = "MidiNoteOnMessage";

    static PyObject* _new_MidiNoteOnMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);

                winrt::Windows::Devices::Midi::MidiNoteOnMessage instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiNoteOnMessage(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiNoteOnMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Note(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Note());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiNoteOnMessage_get_Velocity(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Velocity());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiNoteOnMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiNoteOnMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiNoteOnMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiNoteOnMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiNoteOnMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiNoteOnMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiNoteOnMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiNoteOnMessage_get_Type), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiNoteOnMessage_get_Channel), nullptr, nullptr, nullptr },
        { "note", reinterpret_cast<getter>(MidiNoteOnMessage_get_Note), nullptr, nullptr, nullptr },
        { "velocity", reinterpret_cast<getter>(MidiNoteOnMessage_get_Velocity), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiNoteOnMessage[] = 
    {
        { Py_tp_new, _new_MidiNoteOnMessage },
        { Py_tp_dealloc, _dealloc_MidiNoteOnMessage },
        { Py_tp_methods, _methods_MidiNoteOnMessage },
        { Py_tp_getset, _getset_MidiNoteOnMessage },
        { },
    };

    static PyType_Spec type_spec_MidiNoteOnMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiNoteOnMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiNoteOnMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiNoteOnMessage
    };

    // ----- MidiOutPort class --------------------
    constexpr const char* const type_name_MidiOutPort = "MidiOutPort";

    static PyObject* _new_MidiOutPort(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MidiOutPort);
        return nullptr;
    }

    static void _dealloc_MidiOutPort(py::wrapper::Windows::Devices::Midi::MidiOutPort* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiOutPort_Close(py::wrapper::Windows::Devices::Midi::MidiOutPort* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Midi::MidiOutPort::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Midi::MidiOutPort::GetDeviceSelector());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_SendBuffer(py::wrapper::Windows::Devices::Midi::MidiOutPort* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.SendBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_SendMessage(py::wrapper::Windows::Devices::Midi::MidiOutPort* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Midi::IMidiMessage>(args, 0);

                self->obj.SendMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiOutPort_get_DeviceId(py::wrapper::Windows::Devices::Midi::MidiOutPort* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiOutPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiOutPort>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MidiOutPort(py::wrapper::Windows::Devices::Midi::MidiOutPort* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MidiOutPort(py::wrapper::Windows::Devices::Midi::MidiOutPort* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiOutPort[] = {
        { "close", reinterpret_cast<PyCFunction>(MidiOutPort_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(MidiOutPort_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(MidiOutPort_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "send_buffer", reinterpret_cast<PyCFunction>(MidiOutPort_SendBuffer), METH_VARARGS, nullptr },
        { "send_message", reinterpret_cast<PyCFunction>(MidiOutPort_SendMessage), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiOutPort), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MidiOutPort), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MidiOutPort), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiOutPort[] = {
        { "device_id", reinterpret_cast<getter>(MidiOutPort_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiOutPort[] = 
    {
        { Py_tp_new, _new_MidiOutPort },
        { Py_tp_dealloc, _dealloc_MidiOutPort },
        { Py_tp_methods, _methods_MidiOutPort },
        { Py_tp_getset, _getset_MidiOutPort },
        { },
    };

    static PyType_Spec type_spec_MidiOutPort =
    {
        "_winsdk_Windows_Devices_Midi.MidiOutPort",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiOutPort),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiOutPort
    };

    // ----- MidiPitchBendChangeMessage class --------------------
    constexpr const char* const type_name_MidiPitchBendChangeMessage = "MidiPitchBendChangeMessage";

    static PyObject* _new_MidiPitchBendChangeMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint16_t>(args, 1);

                winrt::Windows::Devices::Midi::MidiPitchBendChangeMessage instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiPitchBendChangeMessage(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiPitchBendChangeMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPitchBendChangeMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPitchBendChangeMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPitchBendChangeMessage_get_Bend(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bend());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPitchBendChangeMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiPitchBendChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiPitchBendChangeMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiPitchBendChangeMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiPitchBendChangeMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiPitchBendChangeMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_Type), nullptr, nullptr, nullptr },
        { "bend", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_Bend), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiPitchBendChangeMessage_get_Channel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiPitchBendChangeMessage[] = 
    {
        { Py_tp_new, _new_MidiPitchBendChangeMessage },
        { Py_tp_dealloc, _dealloc_MidiPitchBendChangeMessage },
        { Py_tp_methods, _methods_MidiPitchBendChangeMessage },
        { Py_tp_getset, _getset_MidiPitchBendChangeMessage },
        { },
    };

    static PyType_Spec type_spec_MidiPitchBendChangeMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiPitchBendChangeMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiPitchBendChangeMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiPitchBendChangeMessage
    };

    // ----- MidiPolyphonicKeyPressureMessage class --------------------
    constexpr const char* const type_name_MidiPolyphonicKeyPressureMessage = "MidiPolyphonicKeyPressureMessage";

    static PyObject* _new_MidiPolyphonicKeyPressureMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);
                auto param2 = py::convert_to<uint8_t>(args, 2);

                winrt::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiPolyphonicKeyPressureMessage(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Note(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Note());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiPolyphonicKeyPressureMessage_get_Pressure(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiPolyphonicKeyPressureMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiPolyphonicKeyPressureMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiPolyphonicKeyPressureMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiPolyphonicKeyPressureMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Type), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Channel), nullptr, nullptr, nullptr },
        { "note", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Note), nullptr, nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(MidiPolyphonicKeyPressureMessage_get_Pressure), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiPolyphonicKeyPressureMessage[] = 
    {
        { Py_tp_new, _new_MidiPolyphonicKeyPressureMessage },
        { Py_tp_dealloc, _dealloc_MidiPolyphonicKeyPressureMessage },
        { Py_tp_methods, _methods_MidiPolyphonicKeyPressureMessage },
        { Py_tp_getset, _getset_MidiPolyphonicKeyPressureMessage },
        { },
    };

    static PyType_Spec type_spec_MidiPolyphonicKeyPressureMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiPolyphonicKeyPressureMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiPolyphonicKeyPressureMessage
    };

    // ----- MidiProgramChangeMessage class --------------------
    constexpr const char* const type_name_MidiProgramChangeMessage = "MidiProgramChangeMessage";

    static PyObject* _new_MidiProgramChangeMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                winrt::Windows::Devices::Midi::MidiProgramChangeMessage instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiProgramChangeMessage(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiProgramChangeMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiProgramChangeMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiProgramChangeMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiProgramChangeMessage_get_Channel(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Channel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiProgramChangeMessage_get_Program(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Program());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiProgramChangeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiProgramChangeMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiProgramChangeMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiProgramChangeMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiProgramChangeMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiProgramChangeMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiProgramChangeMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiProgramChangeMessage_get_Type), nullptr, nullptr, nullptr },
        { "channel", reinterpret_cast<getter>(MidiProgramChangeMessage_get_Channel), nullptr, nullptr, nullptr },
        { "program", reinterpret_cast<getter>(MidiProgramChangeMessage_get_Program), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiProgramChangeMessage[] = 
    {
        { Py_tp_new, _new_MidiProgramChangeMessage },
        { Py_tp_dealloc, _dealloc_MidiProgramChangeMessage },
        { Py_tp_methods, _methods_MidiProgramChangeMessage },
        { Py_tp_getset, _getset_MidiProgramChangeMessage },
        { },
    };

    static PyType_Spec type_spec_MidiProgramChangeMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiProgramChangeMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiProgramChangeMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiProgramChangeMessage
    };

    // ----- MidiSongPositionPointerMessage class --------------------
    constexpr const char* const type_name_MidiSongPositionPointerMessage = "MidiSongPositionPointerMessage";

    static PyObject* _new_MidiSongPositionPointerMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint16_t>(args, 0);

                winrt::Windows::Devices::Midi::MidiSongPositionPointerMessage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiSongPositionPointerMessage(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSongPositionPointerMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongPositionPointerMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongPositionPointerMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongPositionPointerMessage_get_Beats(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Beats());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiSongPositionPointerMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSongPositionPointerMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSongPositionPointerMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSongPositionPointerMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSongPositionPointerMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiSongPositionPointerMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiSongPositionPointerMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiSongPositionPointerMessage_get_Type), nullptr, nullptr, nullptr },
        { "beats", reinterpret_cast<getter>(MidiSongPositionPointerMessage_get_Beats), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSongPositionPointerMessage[] = 
    {
        { Py_tp_new, _new_MidiSongPositionPointerMessage },
        { Py_tp_dealloc, _dealloc_MidiSongPositionPointerMessage },
        { Py_tp_methods, _methods_MidiSongPositionPointerMessage },
        { Py_tp_getset, _getset_MidiSongPositionPointerMessage },
        { },
    };

    static PyType_Spec type_spec_MidiSongPositionPointerMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiSongPositionPointerMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSongPositionPointerMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSongPositionPointerMessage
    };

    // ----- MidiSongSelectMessage class --------------------
    constexpr const char* const type_name_MidiSongSelectMessage = "MidiSongSelectMessage";

    static PyObject* _new_MidiSongSelectMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);

                winrt::Windows::Devices::Midi::MidiSongSelectMessage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiSongSelectMessage(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSongSelectMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongSelectMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongSelectMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSongSelectMessage_get_Song(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Song());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiSongSelectMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSongSelectMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSongSelectMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSongSelectMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSongSelectMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiSongSelectMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiSongSelectMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiSongSelectMessage_get_Type), nullptr, nullptr, nullptr },
        { "song", reinterpret_cast<getter>(MidiSongSelectMessage_get_Song), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSongSelectMessage[] = 
    {
        { Py_tp_new, _new_MidiSongSelectMessage },
        { Py_tp_dealloc, _dealloc_MidiSongSelectMessage },
        { Py_tp_methods, _methods_MidiSongSelectMessage },
        { Py_tp_getset, _getset_MidiSongSelectMessage },
        { },
    };

    static PyType_Spec type_spec_MidiSongSelectMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiSongSelectMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSongSelectMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSongSelectMessage
    };

    // ----- MidiStartMessage class --------------------
    constexpr const char* const type_name_MidiStartMessage = "MidiStartMessage";

    static PyObject* _new_MidiStartMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiStartMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiStartMessage(py::wrapper::Windows::Devices::Midi::MidiStartMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiStartMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiStartMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiStartMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiStartMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiStartMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiStartMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiStartMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiStartMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiStartMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiStartMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiStartMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiStartMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiStartMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiStartMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiStartMessage[] = 
    {
        { Py_tp_new, _new_MidiStartMessage },
        { Py_tp_dealloc, _dealloc_MidiStartMessage },
        { Py_tp_methods, _methods_MidiStartMessage },
        { Py_tp_getset, _getset_MidiStartMessage },
        { },
    };

    static PyType_Spec type_spec_MidiStartMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiStartMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiStartMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiStartMessage
    };

    // ----- MidiStopMessage class --------------------
    constexpr const char* const type_name_MidiStopMessage = "MidiStopMessage";

    static PyObject* _new_MidiStopMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiStopMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiStopMessage(py::wrapper::Windows::Devices::Midi::MidiStopMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiStopMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiStopMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiStopMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiStopMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiStopMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiStopMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiStopMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiStopMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiStopMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiStopMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiStopMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiStopMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiStopMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiStopMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiStopMessage[] = 
    {
        { Py_tp_new, _new_MidiStopMessage },
        { Py_tp_dealloc, _dealloc_MidiStopMessage },
        { Py_tp_methods, _methods_MidiStopMessage },
        { Py_tp_getset, _getset_MidiStopMessage },
        { },
    };

    static PyType_Spec type_spec_MidiStopMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiStopMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiStopMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiStopMessage
    };

    // ----- MidiSynthesizer class --------------------
    constexpr const char* const type_name_MidiSynthesizer = "MidiSynthesizer";

    static PyObject* _new_MidiSynthesizer(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_MidiSynthesizer);
        return nullptr;
    }

    static void _dealloc_MidiSynthesizer(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSynthesizer_Close(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_CreateAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Devices::Midi::MidiSynthesizer::CreateAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 0);

                return py::convert(winrt::Windows::Devices::Midi::MidiSynthesizer::CreateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_IsSynthesizer(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Enumeration::DeviceInformation>(args, 0);

                return py::convert(winrt::Windows::Devices::Midi::MidiSynthesizer::IsSynthesizer(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_SendBuffer(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.SendBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_SendMessage(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Midi::IMidiMessage>(args, 0);

                self->obj.SendMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_get_DeviceId(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSynthesizer_get_Volume(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Volume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int MidiSynthesizer_put_Volume(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Volume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* MidiSynthesizer_get_AudioDevice(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioDevice());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiSynthesizer(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSynthesizer>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_MidiSynthesizer(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_MidiSynthesizer(py::wrapper::Windows::Devices::Midi::MidiSynthesizer* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSynthesizer[] = {
        { "close", reinterpret_cast<PyCFunction>(MidiSynthesizer_Close), METH_VARARGS, nullptr },
        { "create_async", reinterpret_cast<PyCFunction>(MidiSynthesizer_CreateAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "is_synthesizer", reinterpret_cast<PyCFunction>(MidiSynthesizer_IsSynthesizer), METH_VARARGS | METH_STATIC, nullptr },
        { "send_buffer", reinterpret_cast<PyCFunction>(MidiSynthesizer_SendBuffer), METH_VARARGS, nullptr },
        { "send_message", reinterpret_cast<PyCFunction>(MidiSynthesizer_SendMessage), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSynthesizer), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_MidiSynthesizer), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_MidiSynthesizer), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSynthesizer[] = {
        { "device_id", reinterpret_cast<getter>(MidiSynthesizer_get_DeviceId), nullptr, nullptr, nullptr },
        { "volume", reinterpret_cast<getter>(MidiSynthesizer_get_Volume), reinterpret_cast<setter>(MidiSynthesizer_put_Volume), nullptr, nullptr },
        { "audio_device", reinterpret_cast<getter>(MidiSynthesizer_get_AudioDevice), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSynthesizer[] = 
    {
        { Py_tp_new, _new_MidiSynthesizer },
        { Py_tp_dealloc, _dealloc_MidiSynthesizer },
        { Py_tp_methods, _methods_MidiSynthesizer },
        { Py_tp_getset, _getset_MidiSynthesizer },
        { },
    };

    static PyType_Spec type_spec_MidiSynthesizer =
    {
        "_winsdk_Windows_Devices_Midi.MidiSynthesizer",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSynthesizer),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSynthesizer
    };

    // ----- MidiSystemExclusiveMessage class --------------------
    constexpr const char* const type_name_MidiSystemExclusiveMessage = "MidiSystemExclusiveMessage";

    static PyObject* _new_MidiSystemExclusiveMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Devices::Midi::MidiSystemExclusiveMessage instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiSystemExclusiveMessage(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSystemExclusiveMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSystemExclusiveMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSystemExclusiveMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiSystemExclusiveMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSystemExclusiveMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSystemExclusiveMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSystemExclusiveMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSystemExclusiveMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiSystemExclusiveMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiSystemExclusiveMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiSystemExclusiveMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSystemExclusiveMessage[] = 
    {
        { Py_tp_new, _new_MidiSystemExclusiveMessage },
        { Py_tp_dealloc, _dealloc_MidiSystemExclusiveMessage },
        { Py_tp_methods, _methods_MidiSystemExclusiveMessage },
        { Py_tp_getset, _getset_MidiSystemExclusiveMessage },
        { },
    };

    static PyType_Spec type_spec_MidiSystemExclusiveMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiSystemExclusiveMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSystemExclusiveMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSystemExclusiveMessage
    };

    // ----- MidiSystemResetMessage class --------------------
    constexpr const char* const type_name_MidiSystemResetMessage = "MidiSystemResetMessage";

    static PyObject* _new_MidiSystemResetMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiSystemResetMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiSystemResetMessage(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiSystemResetMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSystemResetMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiSystemResetMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiSystemResetMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiSystemResetMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiSystemResetMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiSystemResetMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiSystemResetMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiSystemResetMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiSystemResetMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiSystemResetMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiSystemResetMessage[] = 
    {
        { Py_tp_new, _new_MidiSystemResetMessage },
        { Py_tp_dealloc, _dealloc_MidiSystemResetMessage },
        { Py_tp_methods, _methods_MidiSystemResetMessage },
        { Py_tp_getset, _getset_MidiSystemResetMessage },
        { },
    };

    static PyType_Spec type_spec_MidiSystemResetMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiSystemResetMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiSystemResetMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiSystemResetMessage
    };

    // ----- MidiTimeCodeMessage class --------------------
    constexpr const char* const type_name_MidiTimeCodeMessage = "MidiTimeCodeMessage";

    static PyObject* _new_MidiTimeCodeMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint8_t>(args, 0);
                auto param1 = py::convert_to<uint8_t>(args, 1);

                winrt::Windows::Devices::Midi::MidiTimeCodeMessage instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiTimeCodeMessage(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiTimeCodeMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimeCodeMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimeCodeMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimeCodeMessage_get_FrameType(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimeCodeMessage_get_Values(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Values());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiTimeCodeMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiTimeCodeMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiTimeCodeMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiTimeCodeMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiTimeCodeMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiTimeCodeMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiTimeCodeMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiTimeCodeMessage_get_Type), nullptr, nullptr, nullptr },
        { "frame_type", reinterpret_cast<getter>(MidiTimeCodeMessage_get_FrameType), nullptr, nullptr, nullptr },
        { "values", reinterpret_cast<getter>(MidiTimeCodeMessage_get_Values), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiTimeCodeMessage[] = 
    {
        { Py_tp_new, _new_MidiTimeCodeMessage },
        { Py_tp_dealloc, _dealloc_MidiTimeCodeMessage },
        { Py_tp_methods, _methods_MidiTimeCodeMessage },
        { Py_tp_getset, _getset_MidiTimeCodeMessage },
        { },
    };

    static PyType_Spec type_spec_MidiTimeCodeMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiTimeCodeMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiTimeCodeMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiTimeCodeMessage
    };

    // ----- MidiTimingClockMessage class --------------------
    constexpr const char* const type_name_MidiTimingClockMessage = "MidiTimingClockMessage";

    static PyObject* _new_MidiTimingClockMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiTimingClockMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiTimingClockMessage(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiTimingClockMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimingClockMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTimingClockMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiTimingClockMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiTimingClockMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiTimingClockMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiTimingClockMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiTimingClockMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiTimingClockMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiTimingClockMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiTimingClockMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiTimingClockMessage[] = 
    {
        { Py_tp_new, _new_MidiTimingClockMessage },
        { Py_tp_dealloc, _dealloc_MidiTimingClockMessage },
        { Py_tp_methods, _methods_MidiTimingClockMessage },
        { Py_tp_getset, _getset_MidiTimingClockMessage },
        { },
    };

    static PyType_Spec type_spec_MidiTimingClockMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiTimingClockMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiTimingClockMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiTimingClockMessage
    };

    // ----- MidiTuneRequestMessage class --------------------
    constexpr const char* const type_name_MidiTuneRequestMessage = "MidiTuneRequestMessage";

    static PyObject* _new_MidiTuneRequestMessage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Midi::MidiTuneRequestMessage instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_MidiTuneRequestMessage(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* MidiTuneRequestMessage_get_RawData(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTuneRequestMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* MidiTuneRequestMessage_get_Type(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_MidiTuneRequestMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::MidiTuneRequestMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_MidiTuneRequestMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_MidiTuneRequestMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_MidiTuneRequestMessage[] = {
        { "raw_data", reinterpret_cast<getter>(MidiTuneRequestMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(MidiTuneRequestMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(MidiTuneRequestMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_MidiTuneRequestMessage[] = 
    {
        { Py_tp_new, _new_MidiTuneRequestMessage },
        { Py_tp_dealloc, _dealloc_MidiTuneRequestMessage },
        { Py_tp_methods, _methods_MidiTuneRequestMessage },
        { Py_tp_getset, _getset_MidiTuneRequestMessage },
        { },
    };

    static PyType_Spec type_spec_MidiTuneRequestMessage =
    {
        "_winsdk_Windows_Devices_Midi.MidiTuneRequestMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::MidiTuneRequestMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_MidiTuneRequestMessage
    };

    // ----- IMidiMessage interface --------------------
    constexpr const char* const type_name_IMidiMessage = "IMidiMessage";

    static PyObject* _new_IMidiMessage(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IMidiMessage);
        return nullptr;
    }

    static void _dealloc_IMidiMessage(py::wrapper::Windows::Devices::Midi::IMidiMessage* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMidiMessage_get_RawData(py::wrapper::Windows::Devices::Midi::IMidiMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMidiMessage_get_Timestamp(py::wrapper::Windows::Devices::Midi::IMidiMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Timestamp());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IMidiMessage_get_Type(py::wrapper::Windows::Devices::Midi::IMidiMessage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IMidiMessage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::IMidiMessage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMidiMessage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IMidiMessage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMidiMessage[] = {
        { "raw_data", reinterpret_cast<getter>(IMidiMessage_get_RawData), nullptr, nullptr, nullptr },
        { "timestamp", reinterpret_cast<getter>(IMidiMessage_get_Timestamp), nullptr, nullptr, nullptr },
        { "type", reinterpret_cast<getter>(IMidiMessage_get_Type), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMidiMessage[] = 
    {
        { Py_tp_new, _new_IMidiMessage },
        { Py_tp_dealloc, _dealloc_IMidiMessage },
        { Py_tp_methods, _methods_IMidiMessage },
        { Py_tp_getset, _getset_IMidiMessage },
        { },
    };

    static PyType_Spec type_spec_IMidiMessage =
    {
        "_winsdk_Windows_Devices_Midi.IMidiMessage",
        sizeof(py::wrapper::Windows::Devices::Midi::IMidiMessage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMidiMessage
    };

    // ----- IMidiOutPort interface --------------------
    constexpr const char* const type_name_IMidiOutPort = "IMidiOutPort";

    static PyObject* _new_IMidiOutPort(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IMidiOutPort);
        return nullptr;
    }

    static void _dealloc_IMidiOutPort(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IMidiOutPort_Close(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMidiOutPort_SendBuffer(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.SendBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMidiOutPort_SendMessage(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Midi::IMidiMessage>(args, 0);

                self->obj.SendMessage(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IMidiOutPort_get_DeviceId(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IMidiOutPort(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Midi::IMidiOutPort>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_IMidiOutPort(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_IMidiOutPort(py::wrapper::Windows::Devices::Midi::IMidiOutPort* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IMidiOutPort[] = {
        { "send_buffer", reinterpret_cast<PyCFunction>(IMidiOutPort_SendBuffer), METH_VARARGS, nullptr },
        { "send_message", reinterpret_cast<PyCFunction>(IMidiOutPort_SendMessage), METH_VARARGS, nullptr },
        { "close", reinterpret_cast<PyCFunction>(IMidiOutPort_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IMidiOutPort), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_IMidiOutPort), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_IMidiOutPort), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_IMidiOutPort[] = {
        { "device_id", reinterpret_cast<getter>(IMidiOutPort_get_DeviceId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IMidiOutPort[] = 
    {
        { Py_tp_new, _new_IMidiOutPort },
        { Py_tp_dealloc, _dealloc_IMidiOutPort },
        { Py_tp_methods, _methods_IMidiOutPort },
        { Py_tp_getset, _getset_IMidiOutPort },
        { },
    };

    static PyType_Spec type_spec_IMidiOutPort =
    {
        "_winsdk_Windows_Devices_Midi.IMidiOutPort",
        sizeof(py::wrapper::Windows::Devices::Midi::IMidiOutPort),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IMidiOutPort
    };

    // ----- Windows.Devices.Midi Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Devices::Midi");

    static PyMethodDef module_methods[] = {
        {"_register_MidiMessageType", register_MidiMessageType, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_MidiMessageType);
        Py_VISIT(state->type_MidiActiveSensingMessage);
        Py_VISIT(state->type_MidiChannelPressureMessage);
        Py_VISIT(state->type_MidiContinueMessage);
        Py_VISIT(state->type_MidiControlChangeMessage);
        Py_VISIT(state->type_MidiInPort);
        Py_VISIT(state->type_MidiMessageReceivedEventArgs);
        Py_VISIT(state->type_MidiNoteOffMessage);
        Py_VISIT(state->type_MidiNoteOnMessage);
        Py_VISIT(state->type_MidiOutPort);
        Py_VISIT(state->type_MidiPitchBendChangeMessage);
        Py_VISIT(state->type_MidiPolyphonicKeyPressureMessage);
        Py_VISIT(state->type_MidiProgramChangeMessage);
        Py_VISIT(state->type_MidiSongPositionPointerMessage);
        Py_VISIT(state->type_MidiSongSelectMessage);
        Py_VISIT(state->type_MidiStartMessage);
        Py_VISIT(state->type_MidiStopMessage);
        Py_VISIT(state->type_MidiSynthesizer);
        Py_VISIT(state->type_MidiSystemExclusiveMessage);
        Py_VISIT(state->type_MidiSystemResetMessage);
        Py_VISIT(state->type_MidiTimeCodeMessage);
        Py_VISIT(state->type_MidiTimingClockMessage);
        Py_VISIT(state->type_MidiTuneRequestMessage);
        Py_VISIT(state->type_IMidiMessage);
        Py_VISIT(state->type_IMidiOutPort);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_MidiMessageType);
        Py_CLEAR(state->type_MidiActiveSensingMessage);
        Py_CLEAR(state->type_MidiChannelPressureMessage);
        Py_CLEAR(state->type_MidiContinueMessage);
        Py_CLEAR(state->type_MidiControlChangeMessage);
        Py_CLEAR(state->type_MidiInPort);
        Py_CLEAR(state->type_MidiMessageReceivedEventArgs);
        Py_CLEAR(state->type_MidiNoteOffMessage);
        Py_CLEAR(state->type_MidiNoteOnMessage);
        Py_CLEAR(state->type_MidiOutPort);
        Py_CLEAR(state->type_MidiPitchBendChangeMessage);
        Py_CLEAR(state->type_MidiPolyphonicKeyPressureMessage);
        Py_CLEAR(state->type_MidiProgramChangeMessage);
        Py_CLEAR(state->type_MidiSongPositionPointerMessage);
        Py_CLEAR(state->type_MidiSongSelectMessage);
        Py_CLEAR(state->type_MidiStartMessage);
        Py_CLEAR(state->type_MidiStopMessage);
        Py_CLEAR(state->type_MidiSynthesizer);
        Py_CLEAR(state->type_MidiSystemExclusiveMessage);
        Py_CLEAR(state->type_MidiSystemResetMessage);
        Py_CLEAR(state->type_MidiTimeCodeMessage);
        Py_CLEAR(state->type_MidiTimingClockMessage);
        Py_CLEAR(state->type_MidiTuneRequestMessage);
        Py_CLEAR(state->type_IMidiMessage);
        Py_CLEAR(state->type_IMidiOutPort);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Midi",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Devices::Midi

PyMODINIT_FUNC PyInit__winsdk_Windows_Devices_Midi(void) noexcept
{
    using namespace py::cpp::Windows::Devices::Midi;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_MidiActiveSensingMessage = py::register_python_type(module.get(), type_name_MidiActiveSensingMessage, &type_spec_MidiActiveSensingMessage, bases.get());
    if (!state->type_MidiActiveSensingMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiActiveSensingMessage);

    state->type_MidiChannelPressureMessage = py::register_python_type(module.get(), type_name_MidiChannelPressureMessage, &type_spec_MidiChannelPressureMessage, bases.get());
    if (!state->type_MidiChannelPressureMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiChannelPressureMessage);

    state->type_MidiContinueMessage = py::register_python_type(module.get(), type_name_MidiContinueMessage, &type_spec_MidiContinueMessage, bases.get());
    if (!state->type_MidiContinueMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiContinueMessage);

    state->type_MidiControlChangeMessage = py::register_python_type(module.get(), type_name_MidiControlChangeMessage, &type_spec_MidiControlChangeMessage, bases.get());
    if (!state->type_MidiControlChangeMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiControlChangeMessage);

    state->type_MidiInPort = py::register_python_type(module.get(), type_name_MidiInPort, &type_spec_MidiInPort, bases.get());
    if (!state->type_MidiInPort)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiInPort);

    state->type_MidiMessageReceivedEventArgs = py::register_python_type(module.get(), type_name_MidiMessageReceivedEventArgs, &type_spec_MidiMessageReceivedEventArgs, bases.get());
    if (!state->type_MidiMessageReceivedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiMessageReceivedEventArgs);

    state->type_MidiNoteOffMessage = py::register_python_type(module.get(), type_name_MidiNoteOffMessage, &type_spec_MidiNoteOffMessage, bases.get());
    if (!state->type_MidiNoteOffMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiNoteOffMessage);

    state->type_MidiNoteOnMessage = py::register_python_type(module.get(), type_name_MidiNoteOnMessage, &type_spec_MidiNoteOnMessage, bases.get());
    if (!state->type_MidiNoteOnMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiNoteOnMessage);

    state->type_MidiOutPort = py::register_python_type(module.get(), type_name_MidiOutPort, &type_spec_MidiOutPort, bases.get());
    if (!state->type_MidiOutPort)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiOutPort);

    state->type_MidiPitchBendChangeMessage = py::register_python_type(module.get(), type_name_MidiPitchBendChangeMessage, &type_spec_MidiPitchBendChangeMessage, bases.get());
    if (!state->type_MidiPitchBendChangeMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiPitchBendChangeMessage);

    state->type_MidiPolyphonicKeyPressureMessage = py::register_python_type(module.get(), type_name_MidiPolyphonicKeyPressureMessage, &type_spec_MidiPolyphonicKeyPressureMessage, bases.get());
    if (!state->type_MidiPolyphonicKeyPressureMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiPolyphonicKeyPressureMessage);

    state->type_MidiProgramChangeMessage = py::register_python_type(module.get(), type_name_MidiProgramChangeMessage, &type_spec_MidiProgramChangeMessage, bases.get());
    if (!state->type_MidiProgramChangeMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiProgramChangeMessage);

    state->type_MidiSongPositionPointerMessage = py::register_python_type(module.get(), type_name_MidiSongPositionPointerMessage, &type_spec_MidiSongPositionPointerMessage, bases.get());
    if (!state->type_MidiSongPositionPointerMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiSongPositionPointerMessage);

    state->type_MidiSongSelectMessage = py::register_python_type(module.get(), type_name_MidiSongSelectMessage, &type_spec_MidiSongSelectMessage, bases.get());
    if (!state->type_MidiSongSelectMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiSongSelectMessage);

    state->type_MidiStartMessage = py::register_python_type(module.get(), type_name_MidiStartMessage, &type_spec_MidiStartMessage, bases.get());
    if (!state->type_MidiStartMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiStartMessage);

    state->type_MidiStopMessage = py::register_python_type(module.get(), type_name_MidiStopMessage, &type_spec_MidiStopMessage, bases.get());
    if (!state->type_MidiStopMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiStopMessage);

    state->type_MidiSynthesizer = py::register_python_type(module.get(), type_name_MidiSynthesizer, &type_spec_MidiSynthesizer, bases.get());
    if (!state->type_MidiSynthesizer)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiSynthesizer);

    state->type_MidiSystemExclusiveMessage = py::register_python_type(module.get(), type_name_MidiSystemExclusiveMessage, &type_spec_MidiSystemExclusiveMessage, bases.get());
    if (!state->type_MidiSystemExclusiveMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiSystemExclusiveMessage);

    state->type_MidiSystemResetMessage = py::register_python_type(module.get(), type_name_MidiSystemResetMessage, &type_spec_MidiSystemResetMessage, bases.get());
    if (!state->type_MidiSystemResetMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiSystemResetMessage);

    state->type_MidiTimeCodeMessage = py::register_python_type(module.get(), type_name_MidiTimeCodeMessage, &type_spec_MidiTimeCodeMessage, bases.get());
    if (!state->type_MidiTimeCodeMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiTimeCodeMessage);

    state->type_MidiTimingClockMessage = py::register_python_type(module.get(), type_name_MidiTimingClockMessage, &type_spec_MidiTimingClockMessage, bases.get());
    if (!state->type_MidiTimingClockMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiTimingClockMessage);

    state->type_MidiTuneRequestMessage = py::register_python_type(module.get(), type_name_MidiTuneRequestMessage, &type_spec_MidiTuneRequestMessage, bases.get());
    if (!state->type_MidiTuneRequestMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_MidiTuneRequestMessage);

    state->type_IMidiMessage = py::register_python_type(module.get(), type_name_IMidiMessage, &type_spec_IMidiMessage, bases.get());
    if (!state->type_IMidiMessage)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IMidiMessage);

    state->type_IMidiOutPort = py::register_python_type(module.get(), type_name_IMidiOutPort, &type_spec_IMidiOutPort, bases.get());
    if (!state->type_IMidiOutPort)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IMidiOutPort);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Devices::Midi::MidiMessageType>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiMessageType;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiMessageType is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiActiveSensingMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiActiveSensingMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiActiveSensingMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiChannelPressureMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiChannelPressureMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiChannelPressureMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiContinueMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiContinueMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiContinueMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiControlChangeMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiControlChangeMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiControlChangeMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiInPort>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiInPort;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiInPort is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiMessageReceivedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiMessageReceivedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiMessageReceivedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiNoteOffMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiNoteOffMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiNoteOffMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiNoteOnMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiNoteOnMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiNoteOnMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiOutPort>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiOutPort;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiOutPort is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiPitchBendChangeMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiPitchBendChangeMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiPitchBendChangeMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiPolyphonicKeyPressureMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiPolyphonicKeyPressureMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiProgramChangeMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiProgramChangeMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiProgramChangeMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiSongPositionPointerMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiSongPositionPointerMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiSongPositionPointerMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiSongSelectMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiSongSelectMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiSongSelectMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiStartMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiStartMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiStartMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiStopMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiStopMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiStopMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiSynthesizer>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiSynthesizer;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiSynthesizer is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiSystemExclusiveMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiSystemExclusiveMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiSystemExclusiveMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiSystemResetMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiSystemResetMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiSystemResetMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiTimeCodeMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiTimeCodeMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiTimeCodeMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiTimingClockMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiTimingClockMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiTimingClockMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::MidiTuneRequestMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_MidiTuneRequestMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::MidiTuneRequestMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::IMidiMessage>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMidiMessage;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::IMidiMessage is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Midi::IMidiOutPort>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Devices::Midi;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Devices::Midi");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IMidiOutPort;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Devices::Midi::IMidiOutPort is not registered");
        return nullptr;
    }

    return python_type;
}
