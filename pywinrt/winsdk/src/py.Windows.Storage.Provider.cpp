// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Storage.Provider.h"

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::CachedFileUpdater>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequest>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderError>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderErrorCommand>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemProperties>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemProperty>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderStatus>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderSyncRootManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderHandlerFactory>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderStatusSource>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderUriSource>::python_type;

namespace py::cpp::Windows::Storage::Provider
{
    // ----- CachedFileUpdater class --------------------
    constexpr const char* const _type_name_CachedFileUpdater = "CachedFileUpdater";

    static PyObject* _new_CachedFileUpdater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CachedFileUpdater);
        return nullptr;
    }

    static PyObject* CachedFileUpdater_SetUpdateInformation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Provider::ReadActivationMode>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Provider::WriteActivationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Provider::CachedFileOptions>(args, 4);

                winrt::Windows::Storage::Provider::CachedFileUpdater::SetUpdateInformation(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdater[] = {
        { "set_update_information", reinterpret_cast<PyCFunction>(CachedFileUpdater_SetUpdateInformation), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CachedFileUpdater[] = {
        { }
    };

    static PyType_Slot _type_slots_CachedFileUpdater[] = 
    {
        { Py_tp_new, _new_CachedFileUpdater },
        { Py_tp_methods, _methods_CachedFileUpdater },
        { Py_tp_getset, _getset_CachedFileUpdater },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CachedFileUpdater =
    {
        "_winsdk_Windows_Storage_Provider.CachedFileUpdater",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdater
    };

    // ----- CachedFileUpdaterUI class --------------------
    constexpr const char* const _type_name_CachedFileUpdaterUI = "CachedFileUpdaterUI";

    static PyObject* _new_CachedFileUpdaterUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CachedFileUpdaterUI);
        return nullptr;
    }

    static void _dealloc_CachedFileUpdaterUI(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CachedFileUpdaterUI_GetDeferral(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_Title(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CachedFileUpdaterUI_put_Title(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UIStatus(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UIStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UpdateTarget(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UpdateRequest(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateRequest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_add_FileUpdateRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>>(arg);

            return py::convert(self->obj.FileUpdateRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_remove_FileUpdateRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FileUpdateRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_add_UIRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UIRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_remove_UIRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UIRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CachedFileUpdaterUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdaterUI[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_GetDeferral), METH_VARARGS, nullptr },
        { "add_file_update_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_add_FileUpdateRequested), METH_O, nullptr },
        { "remove_file_update_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_remove_FileUpdateRequested), METH_O, nullptr },
        { "add_u_i_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_add_UIRequested), METH_O, nullptr },
        { "remove_u_i_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_remove_UIRequested), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CachedFileUpdaterUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CachedFileUpdaterUI[] = {
        { "title", reinterpret_cast<getter>(CachedFileUpdaterUI_get_Title), reinterpret_cast<setter>(CachedFileUpdaterUI_put_Title), nullptr, nullptr },
        { "u_i_status", reinterpret_cast<getter>(CachedFileUpdaterUI_get_UIStatus), nullptr, nullptr, nullptr },
        { "update_target", reinterpret_cast<getter>(CachedFileUpdaterUI_get_UpdateTarget), nullptr, nullptr, nullptr },
        { "update_request", reinterpret_cast<getter>(CachedFileUpdaterUI_get_UpdateRequest), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CachedFileUpdaterUI[] = 
    {
        { Py_tp_new, _new_CachedFileUpdaterUI },
        { Py_tp_dealloc, _dealloc_CachedFileUpdaterUI },
        { Py_tp_methods, _methods_CachedFileUpdaterUI },
        { Py_tp_getset, _getset_CachedFileUpdaterUI },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CachedFileUpdaterUI =
    {
        "_winsdk_Windows_Storage_Provider.CachedFileUpdaterUI",
        sizeof(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdaterUI
    };

    // ----- FileUpdateRequest class --------------------
    constexpr const char* const _type_name_FileUpdateRequest = "FileUpdateRequest";

    static PyObject* _new_FileUpdateRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FileUpdateRequest);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequest(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FileUpdateRequest_GetDeferral(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_UpdateLocalFile(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.UpdateLocalFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_Status(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FileUpdateRequest_put_Status(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::FileUpdateStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FileUpdateRequest_get_ContentId(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_File(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_UserInputNeededMessage(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserInputNeededMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FileUpdateRequest_put_UserInputNeededMessage(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UserInputNeededMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FileUpdateRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(FileUpdateRequest_GetDeferral), METH_VARARGS, nullptr },
        { "update_local_file", reinterpret_cast<PyCFunction>(FileUpdateRequest_UpdateLocalFile), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileUpdateRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileUpdateRequest[] = {
        { "status", reinterpret_cast<getter>(FileUpdateRequest_get_Status), reinterpret_cast<setter>(FileUpdateRequest_put_Status), nullptr, nullptr },
        { "content_id", reinterpret_cast<getter>(FileUpdateRequest_get_ContentId), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(FileUpdateRequest_get_File), nullptr, nullptr, nullptr },
        { "user_input_needed_message", reinterpret_cast<getter>(FileUpdateRequest_get_UserInputNeededMessage), reinterpret_cast<setter>(FileUpdateRequest_put_UserInputNeededMessage), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileUpdateRequest[] = 
    {
        { Py_tp_new, _new_FileUpdateRequest },
        { Py_tp_dealloc, _dealloc_FileUpdateRequest },
        { Py_tp_methods, _methods_FileUpdateRequest },
        { Py_tp_getset, _getset_FileUpdateRequest },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FileUpdateRequest =
    {
        "_winsdk_Windows_Storage_Provider.FileUpdateRequest",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequest
    };

    // ----- FileUpdateRequestDeferral class --------------------
    constexpr const char* const _type_name_FileUpdateRequestDeferral = "FileUpdateRequestDeferral";

    static PyObject* _new_FileUpdateRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FileUpdateRequestDeferral);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequestDeferral(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FileUpdateRequestDeferral_Complete(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_FileUpdateRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(FileUpdateRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileUpdateRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileUpdateRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_FileUpdateRequestDeferral[] = 
    {
        { Py_tp_new, _new_FileUpdateRequestDeferral },
        { Py_tp_dealloc, _dealloc_FileUpdateRequestDeferral },
        { Py_tp_methods, _methods_FileUpdateRequestDeferral },
        { Py_tp_getset, _getset_FileUpdateRequestDeferral },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FileUpdateRequestDeferral =
    {
        "_winsdk_Windows_Storage_Provider.FileUpdateRequestDeferral",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequestDeferral
    };

    // ----- FileUpdateRequestedEventArgs class --------------------
    constexpr const char* const _type_name_FileUpdateRequestedEventArgs = "FileUpdateRequestedEventArgs";

    static PyObject* _new_FileUpdateRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_FileUpdateRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequestedEventArgs(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* FileUpdateRequestedEventArgs_get_Request(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FileUpdateRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FileUpdateRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileUpdateRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(FileUpdateRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileUpdateRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_FileUpdateRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_FileUpdateRequestedEventArgs },
        { Py_tp_methods, _methods_FileUpdateRequestedEventArgs },
        { Py_tp_getset, _getset_FileUpdateRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_FileUpdateRequestedEventArgs =
    {
        "_winsdk_Windows_Storage_Provider.FileUpdateRequestedEventArgs",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequestedEventArgs
    };

    // ----- StorageProviderError class --------------------
    constexpr const char* const _type_name_StorageProviderError = "StorageProviderError";

    static PyObject* _new_StorageProviderError(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                winrt::Windows::Storage::Provider::StorageProviderError instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderError(py::wrapper::Windows::Storage::Provider::StorageProviderError* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderError_get_SecondaryAction(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SecondaryAction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderError_put_SecondaryAction(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderErrorCommand>(arg);

            self->obj.SecondaryAction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderError_get_PrimaryAction(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrimaryAction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderError_put_PrimaryAction(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderErrorCommand>(arg);

            self->obj.PrimaryAction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderError_get_InformationalLink(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InformationalLink());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderError_put_InformationalLink(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderErrorCommand>(arg);

            self->obj.InformationalLink(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderError_get_FilePath(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FilePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderError_put_FilePath(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.FilePath(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderError_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderError_get_Message(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderError_get_Title(py::wrapper::Windows::Storage::Provider::StorageProviderError* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageProviderError(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderError>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderError[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderError), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderError[] = {
        { "secondary_action", reinterpret_cast<getter>(StorageProviderError_get_SecondaryAction), reinterpret_cast<setter>(StorageProviderError_put_SecondaryAction), nullptr, nullptr },
        { "primary_action", reinterpret_cast<getter>(StorageProviderError_get_PrimaryAction), reinterpret_cast<setter>(StorageProviderError_put_PrimaryAction), nullptr, nullptr },
        { "informational_link", reinterpret_cast<getter>(StorageProviderError_get_InformationalLink), reinterpret_cast<setter>(StorageProviderError_put_InformationalLink), nullptr, nullptr },
        { "file_path", reinterpret_cast<getter>(StorageProviderError_get_FilePath), reinterpret_cast<setter>(StorageProviderError_put_FilePath), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(StorageProviderError_get_Id), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(StorageProviderError_get_Message), nullptr, nullptr, nullptr },
        { "title", reinterpret_cast<getter>(StorageProviderError_get_Title), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderError[] = 
    {
        { Py_tp_new, _new_StorageProviderError },
        { Py_tp_dealloc, _dealloc_StorageProviderError },
        { Py_tp_methods, _methods_StorageProviderError },
        { Py_tp_getset, _getset_StorageProviderError },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderError =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderError",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderError),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderError
    };

    // ----- StorageProviderErrorCommand class --------------------
    constexpr const char* const _type_name_StorageProviderErrorCommand = "StorageProviderErrorCommand";

    static PyObject* _new_StorageProviderErrorCommand(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 1);

                winrt::Windows::Storage::Provider::StorageProviderErrorCommand instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderErrorCommand(py::wrapper::Windows::Storage::Provider::StorageProviderErrorCommand* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderErrorCommand_get_ActionUri(py::wrapper::Windows::Storage::Provider::StorageProviderErrorCommand* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActionUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderErrorCommand_get_Label(py::wrapper::Windows::Storage::Provider::StorageProviderErrorCommand* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageProviderErrorCommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderErrorCommand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderErrorCommand[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderErrorCommand), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderErrorCommand[] = {
        { "action_uri", reinterpret_cast<getter>(StorageProviderErrorCommand_get_ActionUri), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(StorageProviderErrorCommand_get_Label), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderErrorCommand[] = 
    {
        { Py_tp_new, _new_StorageProviderErrorCommand },
        { Py_tp_dealloc, _dealloc_StorageProviderErrorCommand },
        { Py_tp_methods, _methods_StorageProviderErrorCommand },
        { Py_tp_getset, _getset_StorageProviderErrorCommand },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderErrorCommand =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderErrorCommand",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderErrorCommand),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderErrorCommand
    };

    // ----- StorageProviderFileTypeInfo class --------------------
    constexpr const char* const _type_name_StorageProviderFileTypeInfo = "StorageProviderFileTypeInfo";

    static PyObject* _new_StorageProviderFileTypeInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderFileTypeInfo(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderFileTypeInfo_get_FileExtension(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileExtension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderFileTypeInfo_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IconResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageProviderFileTypeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderFileTypeInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderFileTypeInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderFileTypeInfo[] = {
        { "file_extension", reinterpret_cast<getter>(StorageProviderFileTypeInfo_get_FileExtension), nullptr, nullptr, nullptr },
        { "icon_resource", reinterpret_cast<getter>(StorageProviderFileTypeInfo_get_IconResource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderFileTypeInfo[] = 
    {
        { Py_tp_new, _new_StorageProviderFileTypeInfo },
        { Py_tp_dealloc, _dealloc_StorageProviderFileTypeInfo },
        { Py_tp_methods, _methods_StorageProviderFileTypeInfo },
        { Py_tp_getset, _getset_StorageProviderFileTypeInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderFileTypeInfo =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderFileTypeInfo",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderFileTypeInfo
    };

    // ----- StorageProviderGetContentInfoForPathResult class --------------------
    constexpr const char* const _type_name_StorageProviderGetContentInfoForPathResult = "StorageProviderGetContentInfoForPathResult";

    static PyObject* _new_StorageProviderGetContentInfoForPathResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderGetContentInfoForPathResult(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_ContentUri(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_ContentUri(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_ContentId(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_ContentId(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderGetContentInfoForPathResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderGetContentInfoForPathResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderGetContentInfoForPathResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderGetContentInfoForPathResult[] = {
        { "status", reinterpret_cast<getter>(StorageProviderGetContentInfoForPathResult_get_Status), reinterpret_cast<setter>(StorageProviderGetContentInfoForPathResult_put_Status), nullptr, nullptr },
        { "content_uri", reinterpret_cast<getter>(StorageProviderGetContentInfoForPathResult_get_ContentUri), reinterpret_cast<setter>(StorageProviderGetContentInfoForPathResult_put_ContentUri), nullptr, nullptr },
        { "content_id", reinterpret_cast<getter>(StorageProviderGetContentInfoForPathResult_get_ContentId), reinterpret_cast<setter>(StorageProviderGetContentInfoForPathResult_put_ContentId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderGetContentInfoForPathResult[] = 
    {
        { Py_tp_new, _new_StorageProviderGetContentInfoForPathResult },
        { Py_tp_dealloc, _dealloc_StorageProviderGetContentInfoForPathResult },
        { Py_tp_methods, _methods_StorageProviderGetContentInfoForPathResult },
        { Py_tp_getset, _getset_StorageProviderGetContentInfoForPathResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderGetContentInfoForPathResult =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderGetContentInfoForPathResult",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderGetContentInfoForPathResult
    };

    // ----- StorageProviderGetPathForContentUriResult class --------------------
    constexpr const char* const _type_name_StorageProviderGetPathForContentUriResult = "StorageProviderGetPathForContentUriResult";

    static PyObject* _new_StorageProviderGetPathForContentUriResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderGetPathForContentUriResult(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderGetPathForContentUriResult_get_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetPathForContentUriResult_put_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetPathForContentUriResult_get_Path(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetPathForContentUriResult_put_Path(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderGetPathForContentUriResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderGetPathForContentUriResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderGetPathForContentUriResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderGetPathForContentUriResult[] = {
        { "status", reinterpret_cast<getter>(StorageProviderGetPathForContentUriResult_get_Status), reinterpret_cast<setter>(StorageProviderGetPathForContentUriResult_put_Status), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageProviderGetPathForContentUriResult_get_Path), reinterpret_cast<setter>(StorageProviderGetPathForContentUriResult_put_Path), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderGetPathForContentUriResult[] = 
    {
        { Py_tp_new, _new_StorageProviderGetPathForContentUriResult },
        { Py_tp_dealloc, _dealloc_StorageProviderGetPathForContentUriResult },
        { Py_tp_methods, _methods_StorageProviderGetPathForContentUriResult },
        { Py_tp_getset, _getset_StorageProviderGetPathForContentUriResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderGetPathForContentUriResult =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderGetPathForContentUriResult",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderGetPathForContentUriResult
    };

    // ----- StorageProviderItemProperties class --------------------
    constexpr const char* const _type_name_StorageProviderItemProperties = "StorageProviderItemProperties";

    static PyObject* _new_StorageProviderItemProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageProviderItemProperties);
        return nullptr;
    }

    static PyObject* StorageProviderItemProperties_SetAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Provider::StorageProviderItemProperty>>(args, 1);

                return py::convert(winrt::Windows::Storage::Provider::StorageProviderItemProperties::SetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemProperties[] = {
        { "set_async", reinterpret_cast<PyCFunction>(StorageProviderItemProperties_SetAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderItemProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageProviderItemProperties[] = 
    {
        { Py_tp_new, _new_StorageProviderItemProperties },
        { Py_tp_methods, _methods_StorageProviderItemProperties },
        { Py_tp_getset, _getset_StorageProviderItemProperties },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderItemProperties =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderItemProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemProperties
    };

    // ----- StorageProviderItemProperty class --------------------
    constexpr const char* const _type_name_StorageProviderItemProperty = "StorageProviderItemProperty";

    static PyObject* _new_StorageProviderItemProperty(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderItemProperty instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderItemProperty(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderItemProperty_get_Value(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_Value(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemProperty_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemProperty_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IconResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IconResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderItemProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderItemProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemProperty[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderItemProperty), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderItemProperty[] = {
        { "value", reinterpret_cast<getter>(StorageProviderItemProperty_get_Value), reinterpret_cast<setter>(StorageProviderItemProperty_put_Value), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(StorageProviderItemProperty_get_Id), reinterpret_cast<setter>(StorageProviderItemProperty_put_Id), nullptr, nullptr },
        { "icon_resource", reinterpret_cast<getter>(StorageProviderItemProperty_get_IconResource), reinterpret_cast<setter>(StorageProviderItemProperty_put_IconResource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderItemProperty[] = 
    {
        { Py_tp_new, _new_StorageProviderItemProperty },
        { Py_tp_dealloc, _dealloc_StorageProviderItemProperty },
        { Py_tp_methods, _methods_StorageProviderItemProperty },
        { Py_tp_getset, _getset_StorageProviderItemProperty },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderItemProperty =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderItemProperty",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemProperty
    };

    // ----- StorageProviderItemPropertyDefinition class --------------------
    constexpr const char* const _type_name_StorageProviderItemPropertyDefinition = "StorageProviderItemPropertyDefinition";

    static PyObject* _new_StorageProviderItemPropertyDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderItemPropertyDefinition(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderItemPropertyDefinition_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemPropertyDefinition_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemPropertyDefinition_get_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayNameResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemPropertyDefinition_put_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayNameResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderItemPropertyDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemPropertyDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderItemPropertyDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderItemPropertyDefinition[] = {
        { "id", reinterpret_cast<getter>(StorageProviderItemPropertyDefinition_get_Id), reinterpret_cast<setter>(StorageProviderItemPropertyDefinition_put_Id), nullptr, nullptr },
        { "display_name_resource", reinterpret_cast<getter>(StorageProviderItemPropertyDefinition_get_DisplayNameResource), reinterpret_cast<setter>(StorageProviderItemPropertyDefinition_put_DisplayNameResource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderItemPropertyDefinition[] = 
    {
        { Py_tp_new, _new_StorageProviderItemPropertyDefinition },
        { Py_tp_dealloc, _dealloc_StorageProviderItemPropertyDefinition },
        { Py_tp_methods, _methods_StorageProviderItemPropertyDefinition },
        { Py_tp_getset, _getset_StorageProviderItemPropertyDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderItemPropertyDefinition =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderItemPropertyDefinition",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemPropertyDefinition
    };

    // ----- StorageProviderStatus class --------------------
    constexpr const char* const _type_name_StorageProviderStatus = "StorageProviderStatus";

    static PyObject* _new_StorageProviderStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderState>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Storage::Provider::StorageProviderStatus instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderState>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Provider::StorageProviderError>>(args, 2);

                winrt::Windows::Storage::Provider::StorageProviderStatus instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderStatus(py::wrapper::Windows::Storage::Provider::StorageProviderStatus* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderStatus_get_ErrorMessages(py::wrapper::Windows::Storage::Provider::StorageProviderStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorMessages());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderStatus_get_Message(py::wrapper::Windows::Storage::Provider::StorageProviderStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderStatus_get_State(py::wrapper::Windows::Storage::Provider::StorageProviderStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageProviderStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderStatus[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderStatus[] = {
        { "error_messages", reinterpret_cast<getter>(StorageProviderStatus_get_ErrorMessages), nullptr, nullptr, nullptr },
        { "message", reinterpret_cast<getter>(StorageProviderStatus_get_Message), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(StorageProviderStatus_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderStatus[] = 
    {
        { Py_tp_new, _new_StorageProviderStatus },
        { Py_tp_dealloc, _dealloc_StorageProviderStatus },
        { Py_tp_methods, _methods_StorageProviderStatus },
        { Py_tp_getset, _getset_StorageProviderStatus },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderStatus =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderStatus",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderStatus
    };

    // ----- StorageProviderSyncRootInfo class --------------------
    constexpr const char* const _type_name_StorageProviderSyncRootInfo = "StorageProviderSyncRootInfo";

    static PyObject* _new_StorageProviderSyncRootInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderSyncRootInfo(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StorageProviderSyncRootInfo_get_Version(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Version(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Version(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ShowSiblingsAsGroup(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShowSiblingsAsGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ShowSiblingsAsGroup(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowSiblingsAsGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_RecycleBinUri(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecycleBinUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_RecycleBinUri(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.RecycleBinUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ProtectionMode(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ProtectionMode(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderProtectionMode>(arg);

            self->obj.ProtectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_PopulationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PopulationPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_PopulationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderPopulationPolicy>(arg);

            self->obj.PopulationPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Path(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Path(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_InSyncPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InSyncPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_InSyncPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderInSyncPolicy>(arg);

            self->obj.InSyncPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IconResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IconResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HydrationPolicyModifier(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HydrationPolicyModifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HydrationPolicyModifier(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicyModifier>(arg);

            self->obj.HydrationPolicyModifier(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HydrationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HydrationPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HydrationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicy>(arg);

            self->obj.HydrationPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HardlinkPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardlinkPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HardlinkPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHardlinkPolicy>(arg);

            self->obj.HardlinkPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayNameResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayNameResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Context(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Context(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.Context(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_AllowPinning(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowPinning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_AllowPinning(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowPinning(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_StorageProviderItemPropertyDefinitions(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StorageProviderItemPropertyDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ProviderId(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ProviderId(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.ProviderId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_FallbackFileTypeInfo(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FallbackFileTypeInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageProviderSyncRootInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderSyncRootInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderSyncRootInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderSyncRootInfo[] = {
        { "version", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Version), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Version), nullptr, nullptr },
        { "show_siblings_as_group", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_ShowSiblingsAsGroup), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_ShowSiblingsAsGroup), nullptr, nullptr },
        { "recycle_bin_uri", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_RecycleBinUri), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_RecycleBinUri), nullptr, nullptr },
        { "protection_mode", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_ProtectionMode), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_ProtectionMode), nullptr, nullptr },
        { "population_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_PopulationPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_PopulationPolicy), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Path), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Path), nullptr, nullptr },
        { "in_sync_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_InSyncPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_InSyncPolicy), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Id), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Id), nullptr, nullptr },
        { "icon_resource", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_IconResource), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_IconResource), nullptr, nullptr },
        { "hydration_policy_modifier", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_HydrationPolicyModifier), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_HydrationPolicyModifier), nullptr, nullptr },
        { "hydration_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_HydrationPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_HydrationPolicy), nullptr, nullptr },
        { "hardlink_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_HardlinkPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_HardlinkPolicy), nullptr, nullptr },
        { "display_name_resource", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_DisplayNameResource), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_DisplayNameResource), nullptr, nullptr },
        { "context", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Context), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Context), nullptr, nullptr },
        { "allow_pinning", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_AllowPinning), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_AllowPinning), nullptr, nullptr },
        { "storage_provider_item_property_definitions", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_StorageProviderItemPropertyDefinitions), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_ProviderId), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_ProviderId), nullptr, nullptr },
        { "fallback_file_type_info", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_FallbackFileTypeInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderSyncRootInfo[] = 
    {
        { Py_tp_new, _new_StorageProviderSyncRootInfo },
        { Py_tp_dealloc, _dealloc_StorageProviderSyncRootInfo },
        { Py_tp_methods, _methods_StorageProviderSyncRootInfo },
        { Py_tp_getset, _getset_StorageProviderSyncRootInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderSyncRootInfo =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderSyncRootInfo",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderSyncRootInfo
    };

    // ----- StorageProviderSyncRootManager class --------------------
    constexpr const char* const _type_name_StorageProviderSyncRootManager = "StorageProviderSyncRootManager";

    static PyObject* _new_StorageProviderSyncRootManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_StorageProviderSyncRootManager);
        return nullptr;
    }

    static PyObject* StorageProviderSyncRootManager_GetCurrentSyncRoots(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetCurrentSyncRoots());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_GetSyncRootInformationForFolder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetSyncRootInformationForFolder(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_GetSyncRootInformationForId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetSyncRootInformationForId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_Register(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>(args, 0);

                winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::Register(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_Unregister(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderSyncRootManager[] = {
        { "get_current_sync_roots", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_GetCurrentSyncRoots), METH_VARARGS | METH_STATIC, nullptr },
        { "get_sync_root_information_for_folder", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_GetSyncRootInformationForFolder), METH_VARARGS | METH_STATIC, nullptr },
        { "get_sync_root_information_for_id", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_GetSyncRootInformationForId), METH_VARARGS | METH_STATIC, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_IsSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "register", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_Register), METH_VARARGS | METH_STATIC, nullptr },
        { "unregister", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_Unregister), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderSyncRootManager[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageProviderSyncRootManager[] = 
    {
        { Py_tp_new, _new_StorageProviderSyncRootManager },
        { Py_tp_methods, _methods_StorageProviderSyncRootManager },
        { Py_tp_getset, _getset_StorageProviderSyncRootManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StorageProviderSyncRootManager =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderSyncRootManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderSyncRootManager
    };

    // ----- IStorageProviderHandlerFactory interface --------------------
    constexpr const char* const _type_name_IStorageProviderHandlerFactory = "IStorageProviderHandlerFactory";

    static PyObject* _new_IStorageProviderHandlerFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageProviderHandlerFactory);
        return nullptr;
    }

    static void _dealloc_IStorageProviderHandlerFactory(py::wrapper::Windows::Storage::Provider::IStorageProviderHandlerFactory* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageProviderHandlerFactory_GetStatusSource(py::wrapper::Windows::Storage::Provider::IStorageProviderHandlerFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetStatusSource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderHandlerFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderHandlerFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderHandlerFactory[] = {
        { "get_status_source", reinterpret_cast<PyCFunction>(IStorageProviderHandlerFactory_GetStatusSource), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderHandlerFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderHandlerFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderHandlerFactory[] = 
    {
        { Py_tp_new, _new_IStorageProviderHandlerFactory },
        { Py_tp_dealloc, _dealloc_IStorageProviderHandlerFactory },
        { Py_tp_methods, _methods_IStorageProviderHandlerFactory },
        { Py_tp_getset, _getset_IStorageProviderHandlerFactory },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageProviderHandlerFactory =
    {
        "_winsdk_Windows_Storage_Provider.IStorageProviderHandlerFactory",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderHandlerFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderHandlerFactory
    };

    // ----- IStorageProviderItemPropertySource interface --------------------
    constexpr const char* const _type_name_IStorageProviderItemPropertySource = "IStorageProviderItemPropertySource";

    static PyObject* _new_IStorageProviderItemPropertySource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageProviderItemPropertySource);
        return nullptr;
    }

    static void _dealloc_IStorageProviderItemPropertySource(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageProviderItemPropertySource_GetItemProperties(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetItemProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderItemPropertySource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderItemPropertySource[] = {
        { "get_item_properties", reinterpret_cast<PyCFunction>(IStorageProviderItemPropertySource_GetItemProperties), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderItemPropertySource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderItemPropertySource[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderItemPropertySource[] = 
    {
        { Py_tp_new, _new_IStorageProviderItemPropertySource },
        { Py_tp_dealloc, _dealloc_IStorageProviderItemPropertySource },
        { Py_tp_methods, _methods_IStorageProviderItemPropertySource },
        { Py_tp_getset, _getset_IStorageProviderItemPropertySource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageProviderItemPropertySource =
    {
        "_winsdk_Windows_Storage_Provider.IStorageProviderItemPropertySource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderItemPropertySource
    };

    // ----- IStorageProviderPropertyCapabilities interface --------------------
    constexpr const char* const _type_name_IStorageProviderPropertyCapabilities = "IStorageProviderPropertyCapabilities";

    static PyObject* _new_IStorageProviderPropertyCapabilities(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageProviderPropertyCapabilities);
        return nullptr;
    }

    static void _dealloc_IStorageProviderPropertyCapabilities(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageProviderPropertyCapabilities_IsPropertySupported(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsPropertySupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderPropertyCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderPropertyCapabilities[] = {
        { "is_property_supported", reinterpret_cast<PyCFunction>(IStorageProviderPropertyCapabilities_IsPropertySupported), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderPropertyCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderPropertyCapabilities[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderPropertyCapabilities[] = 
    {
        { Py_tp_new, _new_IStorageProviderPropertyCapabilities },
        { Py_tp_dealloc, _dealloc_IStorageProviderPropertyCapabilities },
        { Py_tp_methods, _methods_IStorageProviderPropertyCapabilities },
        { Py_tp_getset, _getset_IStorageProviderPropertyCapabilities },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageProviderPropertyCapabilities =
    {
        "_winsdk_Windows_Storage_Provider.IStorageProviderPropertyCapabilities",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderPropertyCapabilities
    };

    // ----- IStorageProviderStatusSource interface --------------------
    constexpr const char* const _type_name_IStorageProviderStatusSource = "IStorageProviderStatusSource";

    static PyObject* _new_IStorageProviderStatusSource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageProviderStatusSource);
        return nullptr;
    }

    static void _dealloc_IStorageProviderStatusSource(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageProviderStatusSource_GetStatus(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderStatusSource_add_Changed(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderStatusSource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Changed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderStatusSource_remove_Changed(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusSource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Changed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderStatusSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderStatusSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderStatusSource[] = {
        { "get_status", reinterpret_cast<PyCFunction>(IStorageProviderStatusSource_GetStatus), METH_VARARGS, nullptr },
        { "add_changed", reinterpret_cast<PyCFunction>(IStorageProviderStatusSource_add_Changed), METH_O, nullptr },
        { "remove_changed", reinterpret_cast<PyCFunction>(IStorageProviderStatusSource_remove_Changed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderStatusSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderStatusSource[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderStatusSource[] = 
    {
        { Py_tp_new, _new_IStorageProviderStatusSource },
        { Py_tp_dealloc, _dealloc_IStorageProviderStatusSource },
        { Py_tp_methods, _methods_IStorageProviderStatusSource },
        { Py_tp_getset, _getset_IStorageProviderStatusSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageProviderStatusSource =
    {
        "_winsdk_Windows_Storage_Provider.IStorageProviderStatusSource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderStatusSource
    };

    // ----- IStorageProviderUriSource interface --------------------
    constexpr const char* const _type_name_IStorageProviderUriSource = "IStorageProviderUriSource";

    static PyObject* _new_IStorageProviderUriSource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IStorageProviderUriSource);
        return nullptr;
    }

    static void _dealloc_IStorageProviderUriSource(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IStorageProviderUriSource_GetContentInfoForPath(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>(args, 1);

                self->obj.GetContentInfoForPath(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUriSource_GetPathForContentUri(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>(args, 1);

                self->obj.GetPathForContentUri(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderUriSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderUriSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderUriSource[] = {
        { "get_content_info_for_path", reinterpret_cast<PyCFunction>(IStorageProviderUriSource_GetContentInfoForPath), METH_VARARGS, nullptr },
        { "get_path_for_content_uri", reinterpret_cast<PyCFunction>(IStorageProviderUriSource_GetPathForContentUri), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderUriSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderUriSource[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderUriSource[] = 
    {
        { Py_tp_new, _new_IStorageProviderUriSource },
        { Py_tp_dealloc, _dealloc_IStorageProviderUriSource },
        { Py_tp_methods, _methods_IStorageProviderUriSource },
        { Py_tp_getset, _getset_IStorageProviderUriSource },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IStorageProviderUriSource =
    {
        "_winsdk_Windows_Storage_Provider.IStorageProviderUriSource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderUriSource
    };

    // ----- Windows.Storage.Provider Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Storage::Provider::CachedFileUpdater>::python_type = py::register_python_type(module, _type_name_CachedFileUpdater, &_type_spec_CachedFileUpdater, nullptr);
            py::winrt_type<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>::python_type = py::register_python_type(module, _type_name_CachedFileUpdaterUI, &_type_spec_CachedFileUpdaterUI, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequest>::python_type = py::register_python_type(module, _type_name_FileUpdateRequest, &_type_spec_FileUpdateRequest, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>::python_type = py::register_python_type(module, _type_name_FileUpdateRequestDeferral, &_type_spec_FileUpdateRequestDeferral, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_FileUpdateRequestedEventArgs, &_type_spec_FileUpdateRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderError>::python_type = py::register_python_type(module, _type_name_StorageProviderError, &_type_spec_StorageProviderError, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderErrorCommand>::python_type = py::register_python_type(module, _type_name_StorageProviderErrorCommand, &_type_spec_StorageProviderErrorCommand, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>::python_type = py::register_python_type(module, _type_name_StorageProviderFileTypeInfo, &_type_spec_StorageProviderFileTypeInfo, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>::python_type = py::register_python_type(module, _type_name_StorageProviderGetContentInfoForPathResult, &_type_spec_StorageProviderGetContentInfoForPathResult, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>::python_type = py::register_python_type(module, _type_name_StorageProviderGetPathForContentUriResult, &_type_spec_StorageProviderGetPathForContentUriResult, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemProperties>::python_type = py::register_python_type(module, _type_name_StorageProviderItemProperties, &_type_spec_StorageProviderItemProperties, nullptr);
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemProperty>::python_type = py::register_python_type(module, _type_name_StorageProviderItemProperty, &_type_spec_StorageProviderItemProperty, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition>::python_type = py::register_python_type(module, _type_name_StorageProviderItemPropertyDefinition, &_type_spec_StorageProviderItemPropertyDefinition, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderStatus>::python_type = py::register_python_type(module, _type_name_StorageProviderStatus, &_type_spec_StorageProviderStatus, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>::python_type = py::register_python_type(module, _type_name_StorageProviderSyncRootInfo, &_type_spec_StorageProviderSyncRootInfo, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderSyncRootManager>::python_type = py::register_python_type(module, _type_name_StorageProviderSyncRootManager, &_type_spec_StorageProviderSyncRootManager, nullptr);
            py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderHandlerFactory>::python_type = py::register_python_type(module, _type_name_IStorageProviderHandlerFactory, &_type_spec_IStorageProviderHandlerFactory, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>::python_type = py::register_python_type(module, _type_name_IStorageProviderItemPropertySource, &_type_spec_IStorageProviderItemPropertySource, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>::python_type = py::register_python_type(module, _type_name_IStorageProviderPropertyCapabilities, &_type_spec_IStorageProviderPropertyCapabilities, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderStatusSource>::python_type = py::register_python_type(module, _type_name_IStorageProviderStatusSource, &_type_spec_IStorageProviderStatusSource, bases.get());
            py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderUriSource>::python_type = py::register_python_type(module, _type_name_IStorageProviderUriSource, &_type_spec_IStorageProviderUriSource, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Storage.Provider");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Storage_Provider",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Storage::Provider

PyMODINIT_FUNC
PyInit__winsdk_Windows_Storage_Provider (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Storage::Provider::module_def);
}
