// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.5

#include "pybase.h"
#include "py.Windows.Storage.Provider.h"


namespace py::cpp::Windows::Storage::Provider
{
    struct module_state
    {
        PyObject* type_CachedFileOptions;
        PyObject* type_CachedFileTarget;
        PyObject* type_FileUpdateStatus;
        PyObject* type_ReadActivationMode;
        PyObject* type_StorageProviderHardlinkPolicy;
        PyObject* type_StorageProviderHydrationPolicy;
        PyObject* type_StorageProviderHydrationPolicyModifier;
        PyObject* type_StorageProviderInSyncPolicy;
        PyObject* type_StorageProviderPopulationPolicy;
        PyObject* type_StorageProviderProtectionMode;
        PyObject* type_StorageProviderState;
        PyObject* type_StorageProviderUICommandState;
        PyObject* type_StorageProviderUriSourceStatus;
        PyObject* type_UIStatus;
        PyObject* type_WriteActivationMode;
        PyTypeObject* type_CachedFileUpdater;
        PyTypeObject* type_CachedFileUpdaterUI;
        PyTypeObject* type_FileUpdateRequest;
        PyTypeObject* type_FileUpdateRequestDeferral;
        PyTypeObject* type_FileUpdateRequestedEventArgs;
        PyTypeObject* type_StorageProviderFileTypeInfo;
        PyTypeObject* type_StorageProviderGetContentInfoForPathResult;
        PyTypeObject* type_StorageProviderGetPathForContentUriResult;
        PyTypeObject* type_StorageProviderItemProperties;
        PyTypeObject* type_StorageProviderItemProperty;
        PyTypeObject* type_StorageProviderItemPropertyDefinition;
        PyTypeObject* type_StorageProviderMoreInfoUI;
        PyTypeObject* type_StorageProviderQuotaUI;
        PyTypeObject* type_StorageProviderStatusUI;
        PyTypeObject* type_StorageProviderSyncRootInfo;
        PyTypeObject* type_StorageProviderSyncRootManager;
        PyTypeObject* type_IStorageProviderItemPropertySource;
        PyTypeObject* type_IStorageProviderPropertyCapabilities;
        PyTypeObject* type_IStorageProviderStatusUISource;
        PyTypeObject* type_IStorageProviderStatusUISourceFactory;
        PyTypeObject* type_IStorageProviderUICommand;
        PyTypeObject* type_IStorageProviderUriSource;
    };

    static PyObject* register_CachedFileOptions(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CachedFileOptions)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CachedFileOptions = type;
        Py_INCREF(state->type_CachedFileOptions);


        Py_RETURN_NONE;
    }

    static PyObject* register_CachedFileTarget(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_CachedFileTarget)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_CachedFileTarget = type;
        Py_INCREF(state->type_CachedFileTarget);


        Py_RETURN_NONE;
    }

    static PyObject* register_FileUpdateStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_FileUpdateStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_FileUpdateStatus = type;
        Py_INCREF(state->type_FileUpdateStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_ReadActivationMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ReadActivationMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ReadActivationMode = type;
        Py_INCREF(state->type_ReadActivationMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_StorageProviderHardlinkPolicy(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StorageProviderHardlinkPolicy)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StorageProviderHardlinkPolicy = type;
        Py_INCREF(state->type_StorageProviderHardlinkPolicy);


        Py_RETURN_NONE;
    }

    static PyObject* register_StorageProviderHydrationPolicy(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StorageProviderHydrationPolicy)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StorageProviderHydrationPolicy = type;
        Py_INCREF(state->type_StorageProviderHydrationPolicy);


        Py_RETURN_NONE;
    }

    static PyObject* register_StorageProviderHydrationPolicyModifier(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StorageProviderHydrationPolicyModifier)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StorageProviderHydrationPolicyModifier = type;
        Py_INCREF(state->type_StorageProviderHydrationPolicyModifier);


        Py_RETURN_NONE;
    }

    static PyObject* register_StorageProviderInSyncPolicy(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StorageProviderInSyncPolicy)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StorageProviderInSyncPolicy = type;
        Py_INCREF(state->type_StorageProviderInSyncPolicy);


        Py_RETURN_NONE;
    }

    static PyObject* register_StorageProviderPopulationPolicy(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StorageProviderPopulationPolicy)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StorageProviderPopulationPolicy = type;
        Py_INCREF(state->type_StorageProviderPopulationPolicy);


        Py_RETURN_NONE;
    }

    static PyObject* register_StorageProviderProtectionMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StorageProviderProtectionMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StorageProviderProtectionMode = type;
        Py_INCREF(state->type_StorageProviderProtectionMode);


        Py_RETURN_NONE;
    }

    static PyObject* register_StorageProviderState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StorageProviderState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StorageProviderState = type;
        Py_INCREF(state->type_StorageProviderState);


        Py_RETURN_NONE;
    }

    static PyObject* register_StorageProviderUICommandState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StorageProviderUICommandState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StorageProviderUICommandState = type;
        Py_INCREF(state->type_StorageProviderUICommandState);


        Py_RETURN_NONE;
    }

    static PyObject* register_StorageProviderUriSourceStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_StorageProviderUriSourceStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_StorageProviderUriSourceStatus = type;
        Py_INCREF(state->type_StorageProviderUriSourceStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_UIStatus(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_UIStatus)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_UIStatus = type;
        Py_INCREF(state->type_UIStatus);


        Py_RETURN_NONE;
    }

    static PyObject* register_WriteActivationMode(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_WriteActivationMode)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_WriteActivationMode = type;
        Py_INCREF(state->type_WriteActivationMode);


        Py_RETURN_NONE;
    }

    // ----- CachedFileUpdater class --------------------
    constexpr const char* const type_name_CachedFileUpdater = "CachedFileUpdater";

    static PyObject* _new_CachedFileUpdater(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CachedFileUpdater);
        return nullptr;
    }

    static PyObject* CachedFileUpdater_SetUpdateInformation(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Storage::Provider::ReadActivationMode>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Storage::Provider::WriteActivationMode>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Storage::Provider::CachedFileOptions>(args, 4);

                winrt::Windows::Storage::Provider::CachedFileUpdater::SetUpdateInformation(param0, param1, param2, param3, param4);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdater[] = {
        { "set_update_information", reinterpret_cast<PyCFunction>(CachedFileUpdater_SetUpdateInformation), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CachedFileUpdater[] = {
        { }
    };

    static PyType_Slot _type_slots_CachedFileUpdater[] = 
    {
        { Py_tp_new, _new_CachedFileUpdater },
        { Py_tp_methods, _methods_CachedFileUpdater },
        { Py_tp_getset, _getset_CachedFileUpdater },
        { },
    };

    static PyType_Spec type_spec_CachedFileUpdater =
    {
        "_winsdk_Windows_Storage_Provider.CachedFileUpdater",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdater
    };

    // ----- CachedFileUpdaterUI class --------------------
    constexpr const char* const type_name_CachedFileUpdaterUI = "CachedFileUpdaterUI";

    static PyObject* _new_CachedFileUpdaterUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CachedFileUpdaterUI);
        return nullptr;
    }

    static void _dealloc_CachedFileUpdaterUI(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CachedFileUpdaterUI_GetDeferral(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_Title(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Title());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CachedFileUpdaterUI_put_Title(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Title(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UIStatus(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UIStatus());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UpdateTarget(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateTarget());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_get_UpdateRequest(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateRequest());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_add_FileUpdateRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>>(arg);

            return py::convert(self->obj.FileUpdateRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_remove_FileUpdateRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.FileUpdateRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_add_UIRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::CachedFileUpdaterUI, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.UIRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterUI_remove_UIRequested(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UIRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CachedFileUpdaterUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdaterUI[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_GetDeferral), METH_VARARGS, nullptr },
        { "add_file_update_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_add_FileUpdateRequested), METH_O, nullptr },
        { "remove_file_update_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_remove_FileUpdateRequested), METH_O, nullptr },
        { "add_u_i_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_add_UIRequested), METH_O, nullptr },
        { "remove_u_i_requested", reinterpret_cast<PyCFunction>(CachedFileUpdaterUI_remove_UIRequested), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CachedFileUpdaterUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CachedFileUpdaterUI[] = {
        { "title", reinterpret_cast<getter>(CachedFileUpdaterUI_get_Title), reinterpret_cast<setter>(CachedFileUpdaterUI_put_Title), nullptr, nullptr },
        { "u_i_status", reinterpret_cast<getter>(CachedFileUpdaterUI_get_UIStatus), nullptr, nullptr, nullptr },
        { "update_target", reinterpret_cast<getter>(CachedFileUpdaterUI_get_UpdateTarget), nullptr, nullptr, nullptr },
        { "update_request", reinterpret_cast<getter>(CachedFileUpdaterUI_get_UpdateRequest), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CachedFileUpdaterUI[] = 
    {
        { Py_tp_new, _new_CachedFileUpdaterUI },
        { Py_tp_dealloc, _dealloc_CachedFileUpdaterUI },
        { Py_tp_methods, _methods_CachedFileUpdaterUI },
        { Py_tp_getset, _getset_CachedFileUpdaterUI },
        { },
    };

    static PyType_Spec type_spec_CachedFileUpdaterUI =
    {
        "_winsdk_Windows_Storage_Provider.CachedFileUpdaterUI",
        sizeof(py::wrapper::Windows::Storage::Provider::CachedFileUpdaterUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdaterUI
    };

    // ----- FileUpdateRequest class --------------------
    constexpr const char* const type_name_FileUpdateRequest = "FileUpdateRequest";

    static PyObject* _new_FileUpdateRequest(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FileUpdateRequest);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequest(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileUpdateRequest_GetDeferral(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_UpdateLocalFile(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFile>(args, 0);

                self->obj.UpdateLocalFile(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_Status(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FileUpdateRequest_put_Status(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::FileUpdateStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* FileUpdateRequest_get_ContentId(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_File(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileUpdateRequest_get_UserInputNeededMessage(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserInputNeededMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int FileUpdateRequest_put_UserInputNeededMessage(py::wrapper::Windows::Storage::Provider::FileUpdateRequest* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UserInputNeededMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_FileUpdateRequest(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequest>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequest[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(FileUpdateRequest_GetDeferral), METH_VARARGS, nullptr },
        { "update_local_file", reinterpret_cast<PyCFunction>(FileUpdateRequest_UpdateLocalFile), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileUpdateRequest), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileUpdateRequest[] = {
        { "status", reinterpret_cast<getter>(FileUpdateRequest_get_Status), reinterpret_cast<setter>(FileUpdateRequest_put_Status), nullptr, nullptr },
        { "content_id", reinterpret_cast<getter>(FileUpdateRequest_get_ContentId), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(FileUpdateRequest_get_File), nullptr, nullptr, nullptr },
        { "user_input_needed_message", reinterpret_cast<getter>(FileUpdateRequest_get_UserInputNeededMessage), reinterpret_cast<setter>(FileUpdateRequest_put_UserInputNeededMessage), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileUpdateRequest[] = 
    {
        { Py_tp_new, _new_FileUpdateRequest },
        { Py_tp_dealloc, _dealloc_FileUpdateRequest },
        { Py_tp_methods, _methods_FileUpdateRequest },
        { Py_tp_getset, _getset_FileUpdateRequest },
        { },
    };

    static PyType_Spec type_spec_FileUpdateRequest =
    {
        "_winsdk_Windows_Storage_Provider.FileUpdateRequest",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequest),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequest
    };

    // ----- FileUpdateRequestDeferral class --------------------
    constexpr const char* const type_name_FileUpdateRequestDeferral = "FileUpdateRequestDeferral";

    static PyObject* _new_FileUpdateRequestDeferral(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FileUpdateRequestDeferral);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequestDeferral(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileUpdateRequestDeferral_Complete(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Complete();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_FileUpdateRequestDeferral(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequestDeferral[] = {
        { "complete", reinterpret_cast<PyCFunction>(FileUpdateRequestDeferral_Complete), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_FileUpdateRequestDeferral), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileUpdateRequestDeferral[] = {
        { }
    };

    static PyType_Slot _type_slots_FileUpdateRequestDeferral[] = 
    {
        { Py_tp_new, _new_FileUpdateRequestDeferral },
        { Py_tp_dealloc, _dealloc_FileUpdateRequestDeferral },
        { Py_tp_methods, _methods_FileUpdateRequestDeferral },
        { Py_tp_getset, _getset_FileUpdateRequestDeferral },
        { },
    };

    static PyType_Spec type_spec_FileUpdateRequestDeferral =
    {
        "_winsdk_Windows_Storage_Provider.FileUpdateRequestDeferral",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequestDeferral),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequestDeferral
    };

    // ----- FileUpdateRequestedEventArgs class --------------------
    constexpr const char* const type_name_FileUpdateRequestedEventArgs = "FileUpdateRequestedEventArgs";

    static PyObject* _new_FileUpdateRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FileUpdateRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_FileUpdateRequestedEventArgs(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileUpdateRequestedEventArgs_get_Request(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FileUpdateRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileUpdateRequestedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FileUpdateRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileUpdateRequestedEventArgs[] = {
        { "request", reinterpret_cast<getter>(FileUpdateRequestedEventArgs_get_Request), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileUpdateRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_FileUpdateRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_FileUpdateRequestedEventArgs },
        { Py_tp_methods, _methods_FileUpdateRequestedEventArgs },
        { Py_tp_getset, _getset_FileUpdateRequestedEventArgs },
        { },
    };

    static PyType_Spec type_spec_FileUpdateRequestedEventArgs =
    {
        "_winsdk_Windows_Storage_Provider.FileUpdateRequestedEventArgs",
        sizeof(py::wrapper::Windows::Storage::Provider::FileUpdateRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileUpdateRequestedEventArgs
    };

    // ----- StorageProviderFileTypeInfo class --------------------
    constexpr const char* const type_name_StorageProviderFileTypeInfo = "StorageProviderFileTypeInfo";

    static PyObject* _new_StorageProviderFileTypeInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderFileTypeInfo(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderFileTypeInfo_get_FileExtension(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileExtension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderFileTypeInfo_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IconResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageProviderFileTypeInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderFileTypeInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderFileTypeInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderFileTypeInfo[] = {
        { "file_extension", reinterpret_cast<getter>(StorageProviderFileTypeInfo_get_FileExtension), nullptr, nullptr, nullptr },
        { "icon_resource", reinterpret_cast<getter>(StorageProviderFileTypeInfo_get_IconResource), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderFileTypeInfo[] = 
    {
        { Py_tp_new, _new_StorageProviderFileTypeInfo },
        { Py_tp_dealloc, _dealloc_StorageProviderFileTypeInfo },
        { Py_tp_methods, _methods_StorageProviderFileTypeInfo },
        { Py_tp_getset, _getset_StorageProviderFileTypeInfo },
        { },
    };

    static PyType_Spec type_spec_StorageProviderFileTypeInfo =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderFileTypeInfo",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderFileTypeInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderFileTypeInfo
    };

    // ----- StorageProviderGetContentInfoForPathResult class --------------------
    constexpr const char* const type_name_StorageProviderGetContentInfoForPathResult = "StorageProviderGetContentInfoForPathResult";

    static PyObject* _new_StorageProviderGetContentInfoForPathResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderGetContentInfoForPathResult(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_ContentUri(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_ContentUri(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetContentInfoForPathResult_get_ContentId(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContentId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetContentInfoForPathResult_put_ContentId(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ContentId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderGetContentInfoForPathResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderGetContentInfoForPathResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderGetContentInfoForPathResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderGetContentInfoForPathResult[] = {
        { "status", reinterpret_cast<getter>(StorageProviderGetContentInfoForPathResult_get_Status), reinterpret_cast<setter>(StorageProviderGetContentInfoForPathResult_put_Status), nullptr, nullptr },
        { "content_uri", reinterpret_cast<getter>(StorageProviderGetContentInfoForPathResult_get_ContentUri), reinterpret_cast<setter>(StorageProviderGetContentInfoForPathResult_put_ContentUri), nullptr, nullptr },
        { "content_id", reinterpret_cast<getter>(StorageProviderGetContentInfoForPathResult_get_ContentId), reinterpret_cast<setter>(StorageProviderGetContentInfoForPathResult_put_ContentId), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderGetContentInfoForPathResult[] = 
    {
        { Py_tp_new, _new_StorageProviderGetContentInfoForPathResult },
        { Py_tp_dealloc, _dealloc_StorageProviderGetContentInfoForPathResult },
        { Py_tp_methods, _methods_StorageProviderGetContentInfoForPathResult },
        { Py_tp_getset, _getset_StorageProviderGetContentInfoForPathResult },
        { },
    };

    static PyType_Spec type_spec_StorageProviderGetContentInfoForPathResult =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderGetContentInfoForPathResult",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderGetContentInfoForPathResult
    };

    // ----- StorageProviderGetPathForContentUriResult class --------------------
    constexpr const char* const type_name_StorageProviderGetPathForContentUriResult = "StorageProviderGetPathForContentUriResult";

    static PyObject* _new_StorageProviderGetPathForContentUriResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderGetPathForContentUriResult(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderGetPathForContentUriResult_get_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Status());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetPathForContentUriResult_put_Status(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus>(arg);

            self->obj.Status(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderGetPathForContentUriResult_get_Path(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderGetPathForContentUriResult_put_Path(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderGetPathForContentUriResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderGetPathForContentUriResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderGetPathForContentUriResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderGetPathForContentUriResult[] = {
        { "status", reinterpret_cast<getter>(StorageProviderGetPathForContentUriResult_get_Status), reinterpret_cast<setter>(StorageProviderGetPathForContentUriResult_put_Status), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageProviderGetPathForContentUriResult_get_Path), reinterpret_cast<setter>(StorageProviderGetPathForContentUriResult_put_Path), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderGetPathForContentUriResult[] = 
    {
        { Py_tp_new, _new_StorageProviderGetPathForContentUriResult },
        { Py_tp_dealloc, _dealloc_StorageProviderGetPathForContentUriResult },
        { Py_tp_methods, _methods_StorageProviderGetPathForContentUriResult },
        { Py_tp_getset, _getset_StorageProviderGetPathForContentUriResult },
        { },
    };

    static PyType_Spec type_spec_StorageProviderGetPathForContentUriResult =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderGetPathForContentUriResult",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderGetPathForContentUriResult
    };

    // ----- StorageProviderItemProperties class --------------------
    constexpr const char* const type_name_StorageProviderItemProperties = "StorageProviderItemProperties";

    static PyObject* _new_StorageProviderItemProperties(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StorageProviderItemProperties);
        return nullptr;
    }

    static PyObject* StorageProviderItemProperties_SetAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageItem>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Storage::Provider::StorageProviderItemProperty>>(args, 1);

                return py::convert(winrt::Windows::Storage::Provider::StorageProviderItemProperties::SetAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemProperties[] = {
        { "set_async", reinterpret_cast<PyCFunction>(StorageProviderItemProperties_SetAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderItemProperties[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageProviderItemProperties[] = 
    {
        { Py_tp_new, _new_StorageProviderItemProperties },
        { Py_tp_methods, _methods_StorageProviderItemProperties },
        { Py_tp_getset, _getset_StorageProviderItemProperties },
        { },
    };

    static PyType_Spec type_spec_StorageProviderItemProperties =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderItemProperties",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemProperties
    };

    // ----- StorageProviderItemProperty class --------------------
    constexpr const char* const type_name_StorageProviderItemProperty = "StorageProviderItemProperty";

    static PyObject* _new_StorageProviderItemProperty(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderItemProperty instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderItemProperty(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderItemProperty_get_Value(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_Value(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemProperty_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemProperty_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IconResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemProperty_put_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IconResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderItemProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderItemProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemProperty[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderItemProperty), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderItemProperty[] = {
        { "value", reinterpret_cast<getter>(StorageProviderItemProperty_get_Value), reinterpret_cast<setter>(StorageProviderItemProperty_put_Value), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(StorageProviderItemProperty_get_Id), reinterpret_cast<setter>(StorageProviderItemProperty_put_Id), nullptr, nullptr },
        { "icon_resource", reinterpret_cast<getter>(StorageProviderItemProperty_get_IconResource), reinterpret_cast<setter>(StorageProviderItemProperty_put_IconResource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderItemProperty[] = 
    {
        { Py_tp_new, _new_StorageProviderItemProperty },
        { Py_tp_dealloc, _dealloc_StorageProviderItemProperty },
        { Py_tp_methods, _methods_StorageProviderItemProperty },
        { Py_tp_getset, _getset_StorageProviderItemProperty },
        { },
    };

    static PyType_Spec type_spec_StorageProviderItemProperty =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderItemProperty",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderItemProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemProperty
    };

    // ----- StorageProviderItemPropertyDefinition class --------------------
    constexpr const char* const type_name_StorageProviderItemPropertyDefinition = "StorageProviderItemPropertyDefinition";

    static PyObject* _new_StorageProviderItemPropertyDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderItemPropertyDefinition(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderItemPropertyDefinition_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemPropertyDefinition_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderItemPropertyDefinition_get_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayNameResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderItemPropertyDefinition_put_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayNameResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderItemPropertyDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderItemPropertyDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderItemPropertyDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderItemPropertyDefinition[] = {
        { "id", reinterpret_cast<getter>(StorageProviderItemPropertyDefinition_get_Id), reinterpret_cast<setter>(StorageProviderItemPropertyDefinition_put_Id), nullptr, nullptr },
        { "display_name_resource", reinterpret_cast<getter>(StorageProviderItemPropertyDefinition_get_DisplayNameResource), reinterpret_cast<setter>(StorageProviderItemPropertyDefinition_put_DisplayNameResource), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderItemPropertyDefinition[] = 
    {
        { Py_tp_new, _new_StorageProviderItemPropertyDefinition },
        { Py_tp_dealloc, _dealloc_StorageProviderItemPropertyDefinition },
        { Py_tp_methods, _methods_StorageProviderItemPropertyDefinition },
        { Py_tp_getset, _getset_StorageProviderItemPropertyDefinition },
        { },
    };

    static PyType_Spec type_spec_StorageProviderItemPropertyDefinition =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderItemPropertyDefinition",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderItemPropertyDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderItemPropertyDefinition
    };

    // ----- StorageProviderMoreInfoUI class --------------------
    constexpr const char* const type_name_StorageProviderMoreInfoUI = "StorageProviderMoreInfoUI";

    static PyObject* _new_StorageProviderMoreInfoUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderMoreInfoUI(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderMoreInfoUI_get_Message(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Message());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderMoreInfoUI_put_Message(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Message(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderMoreInfoUI_get_Command(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Command());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderMoreInfoUI_put_Command(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::IStorageProviderUICommand>(arg);

            self->obj.Command(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderMoreInfoUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderMoreInfoUI[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderMoreInfoUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderMoreInfoUI[] = {
        { "message", reinterpret_cast<getter>(StorageProviderMoreInfoUI_get_Message), reinterpret_cast<setter>(StorageProviderMoreInfoUI_put_Message), nullptr, nullptr },
        { "command", reinterpret_cast<getter>(StorageProviderMoreInfoUI_get_Command), reinterpret_cast<setter>(StorageProviderMoreInfoUI_put_Command), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderMoreInfoUI[] = 
    {
        { Py_tp_new, _new_StorageProviderMoreInfoUI },
        { Py_tp_dealloc, _dealloc_StorageProviderMoreInfoUI },
        { Py_tp_methods, _methods_StorageProviderMoreInfoUI },
        { Py_tp_getset, _getset_StorageProviderMoreInfoUI },
        { },
    };

    static PyType_Spec type_spec_StorageProviderMoreInfoUI =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderMoreInfoUI",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderMoreInfoUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderMoreInfoUI
    };

    // ----- StorageProviderQuotaUI class --------------------
    constexpr const char* const type_name_StorageProviderQuotaUI = "StorageProviderQuotaUI";

    static PyObject* _new_StorageProviderQuotaUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderQuotaUI instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderQuotaUI(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderQuotaUI_get_QuotaUsedLabel(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QuotaUsedLabel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderQuotaUI_put_QuotaUsedLabel(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.QuotaUsedLabel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderQuotaUI_get_QuotaUsedInBytes(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QuotaUsedInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderQuotaUI_put_QuotaUsedInBytes(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.QuotaUsedInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderQuotaUI_get_QuotaUsedColor(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QuotaUsedColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderQuotaUI_put_QuotaUsedColor(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::UI::Color>>(arg);

            self->obj.QuotaUsedColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderQuotaUI_get_QuotaTotalInBytes(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QuotaTotalInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderQuotaUI_put_QuotaTotalInBytes(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint64_t>(arg);

            self->obj.QuotaTotalInBytes(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderQuotaUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderQuotaUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderQuotaUI[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderQuotaUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderQuotaUI[] = {
        { "quota_used_label", reinterpret_cast<getter>(StorageProviderQuotaUI_get_QuotaUsedLabel), reinterpret_cast<setter>(StorageProviderQuotaUI_put_QuotaUsedLabel), nullptr, nullptr },
        { "quota_used_in_bytes", reinterpret_cast<getter>(StorageProviderQuotaUI_get_QuotaUsedInBytes), reinterpret_cast<setter>(StorageProviderQuotaUI_put_QuotaUsedInBytes), nullptr, nullptr },
        { "quota_used_color", reinterpret_cast<getter>(StorageProviderQuotaUI_get_QuotaUsedColor), reinterpret_cast<setter>(StorageProviderQuotaUI_put_QuotaUsedColor), nullptr, nullptr },
        { "quota_total_in_bytes", reinterpret_cast<getter>(StorageProviderQuotaUI_get_QuotaTotalInBytes), reinterpret_cast<setter>(StorageProviderQuotaUI_put_QuotaTotalInBytes), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderQuotaUI[] = 
    {
        { Py_tp_new, _new_StorageProviderQuotaUI },
        { Py_tp_dealloc, _dealloc_StorageProviderQuotaUI },
        { Py_tp_methods, _methods_StorageProviderQuotaUI },
        { Py_tp_getset, _getset_StorageProviderQuotaUI },
        { },
    };

    static PyType_Spec type_spec_StorageProviderQuotaUI =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderQuotaUI",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderQuotaUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderQuotaUI
    };

    // ----- StorageProviderStatusUI class --------------------
    constexpr const char* const type_name_StorageProviderStatusUI = "StorageProviderStatusUI";

    static PyObject* _new_StorageProviderStatusUI(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderStatusUI instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderStatusUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderStatusUI_get_SyncStatusCommand(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SyncStatusCommand());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_SyncStatusCommand(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::IStorageProviderUICommand>(arg);

            self->obj.SyncStatusCommand(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_QuotaUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QuotaUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_QuotaUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderQuotaUI>(arg);

            self->obj.QuotaUI(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderStateLabel(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderStateLabel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderStateLabel(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProviderStateLabel(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderStateIcon(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderStateIcon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderStateIcon(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ProviderStateIcon(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderState(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderState(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderState>(arg);

            self->obj.ProviderState(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderSecondaryCommands(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderSecondaryCommands());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderSecondaryCommands(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IVector<winrt::Windows::Storage::Provider::IStorageProviderUICommand>>(arg);

            self->obj.ProviderSecondaryCommands(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_ProviderPrimaryCommand(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderPrimaryCommand());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_ProviderPrimaryCommand(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::IStorageProviderUICommand>(arg);

            self->obj.ProviderPrimaryCommand(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderStatusUI_get_MoreInfoUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MoreInfoUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderStatusUI_put_MoreInfoUI(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI>(arg);

            self->obj.MoreInfoUI(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_StorageProviderStatusUI(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderStatusUI>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderStatusUI[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderStatusUI), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderStatusUI[] = {
        { "sync_status_command", reinterpret_cast<getter>(StorageProviderStatusUI_get_SyncStatusCommand), reinterpret_cast<setter>(StorageProviderStatusUI_put_SyncStatusCommand), nullptr, nullptr },
        { "quota_u_i", reinterpret_cast<getter>(StorageProviderStatusUI_get_QuotaUI), reinterpret_cast<setter>(StorageProviderStatusUI_put_QuotaUI), nullptr, nullptr },
        { "provider_state_label", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderStateLabel), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderStateLabel), nullptr, nullptr },
        { "provider_state_icon", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderStateIcon), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderStateIcon), nullptr, nullptr },
        { "provider_state", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderState), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderState), nullptr, nullptr },
        { "provider_secondary_commands", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderSecondaryCommands), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderSecondaryCommands), nullptr, nullptr },
        { "provider_primary_command", reinterpret_cast<getter>(StorageProviderStatusUI_get_ProviderPrimaryCommand), reinterpret_cast<setter>(StorageProviderStatusUI_put_ProviderPrimaryCommand), nullptr, nullptr },
        { "more_info_u_i", reinterpret_cast<getter>(StorageProviderStatusUI_get_MoreInfoUI), reinterpret_cast<setter>(StorageProviderStatusUI_put_MoreInfoUI), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderStatusUI[] = 
    {
        { Py_tp_new, _new_StorageProviderStatusUI },
        { Py_tp_dealloc, _dealloc_StorageProviderStatusUI },
        { Py_tp_methods, _methods_StorageProviderStatusUI },
        { Py_tp_getset, _getset_StorageProviderStatusUI },
        { },
    };

    static PyType_Spec type_spec_StorageProviderStatusUI =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderStatusUI",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderStatusUI),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderStatusUI
    };

    // ----- StorageProviderSyncRootInfo class --------------------
    constexpr const char* const type_name_StorageProviderSyncRootInfo = "StorageProviderSyncRootInfo";

    static PyObject* _new_StorageProviderSyncRootInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StorageProviderSyncRootInfo(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StorageProviderSyncRootInfo_get_Version(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Version(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Version(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ShowSiblingsAsGroup(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShowSiblingsAsGroup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ShowSiblingsAsGroup(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowSiblingsAsGroup(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_RecycleBinUri(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecycleBinUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_RecycleBinUri(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.RecycleBinUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ProtectionMode(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ProtectionMode(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderProtectionMode>(arg);

            self->obj.ProtectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_PopulationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PopulationPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_PopulationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderPopulationPolicy>(arg);

            self->obj.PopulationPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Path(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Path());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Path(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(arg);

            self->obj.Path(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_InSyncPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InSyncPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_InSyncPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderInSyncPolicy>(arg);

            self->obj.InSyncPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Id(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Id(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Id(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IconResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_IconResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IconResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HydrationPolicyModifier(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HydrationPolicyModifier());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HydrationPolicyModifier(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicyModifier>(arg);

            self->obj.HydrationPolicyModifier(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HydrationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HydrationPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HydrationPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicy>(arg);

            self->obj.HydrationPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_HardlinkPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HardlinkPolicy());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_HardlinkPolicy(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderHardlinkPolicy>(arg);

            self->obj.HardlinkPolicy(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayNameResource());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_DisplayNameResource(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayNameResource(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_Context(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Context());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_Context(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(arg);

            self->obj.Context(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_AllowPinning(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowPinning());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_AllowPinning(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowPinning(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_StorageProviderItemPropertyDefinitions(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StorageProviderItemPropertyDefinitions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_ProviderId(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StorageProviderSyncRootInfo_put_ProviderId(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::guid>(arg);

            self->obj.ProviderId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StorageProviderSyncRootInfo_get_FallbackFileTypeInfo(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FallbackFileTypeInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StorageProviderSyncRootInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderSyncRootInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StorageProviderSyncRootInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderSyncRootInfo[] = {
        { "version", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Version), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Version), nullptr, nullptr },
        { "show_siblings_as_group", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_ShowSiblingsAsGroup), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_ShowSiblingsAsGroup), nullptr, nullptr },
        { "recycle_bin_uri", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_RecycleBinUri), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_RecycleBinUri), nullptr, nullptr },
        { "protection_mode", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_ProtectionMode), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_ProtectionMode), nullptr, nullptr },
        { "population_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_PopulationPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_PopulationPolicy), nullptr, nullptr },
        { "path", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Path), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Path), nullptr, nullptr },
        { "in_sync_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_InSyncPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_InSyncPolicy), nullptr, nullptr },
        { "id", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Id), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Id), nullptr, nullptr },
        { "icon_resource", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_IconResource), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_IconResource), nullptr, nullptr },
        { "hydration_policy_modifier", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_HydrationPolicyModifier), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_HydrationPolicyModifier), nullptr, nullptr },
        { "hydration_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_HydrationPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_HydrationPolicy), nullptr, nullptr },
        { "hardlink_policy", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_HardlinkPolicy), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_HardlinkPolicy), nullptr, nullptr },
        { "display_name_resource", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_DisplayNameResource), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_DisplayNameResource), nullptr, nullptr },
        { "context", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_Context), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_Context), nullptr, nullptr },
        { "allow_pinning", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_AllowPinning), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_AllowPinning), nullptr, nullptr },
        { "storage_provider_item_property_definitions", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_StorageProviderItemPropertyDefinitions), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_ProviderId), reinterpret_cast<setter>(StorageProviderSyncRootInfo_put_ProviderId), nullptr, nullptr },
        { "fallback_file_type_info", reinterpret_cast<getter>(StorageProviderSyncRootInfo_get_FallbackFileTypeInfo), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StorageProviderSyncRootInfo[] = 
    {
        { Py_tp_new, _new_StorageProviderSyncRootInfo },
        { Py_tp_dealloc, _dealloc_StorageProviderSyncRootInfo },
        { Py_tp_methods, _methods_StorageProviderSyncRootInfo },
        { Py_tp_getset, _getset_StorageProviderSyncRootInfo },
        { },
    };

    static PyType_Spec type_spec_StorageProviderSyncRootInfo =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderSyncRootInfo",
        sizeof(py::wrapper::Windows::Storage::Provider::StorageProviderSyncRootInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderSyncRootInfo
    };

    // ----- StorageProviderSyncRootManager class --------------------
    constexpr const char* const type_name_StorageProviderSyncRootManager = "StorageProviderSyncRootManager";

    static PyObject* _new_StorageProviderSyncRootManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StorageProviderSyncRootManager);
        return nullptr;
    }

    static PyObject* StorageProviderSyncRootManager_GetCurrentSyncRoots(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetCurrentSyncRoots());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_GetSyncRootInformationForFolder(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::IStorageFolder>(args, 0);

                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetSyncRootInformationForFolder(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_GetSyncRootInformationForId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::GetSyncRootInformationForId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_IsSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::IsSupported());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_Register(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>(args, 0);

                winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::Register(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* StorageProviderSyncRootManager_Unregister(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Storage::Provider::StorageProviderSyncRootManager::Unregister(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_StorageProviderSyncRootManager[] = {
        { "get_current_sync_roots", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_GetCurrentSyncRoots), METH_VARARGS | METH_STATIC, nullptr },
        { "get_sync_root_information_for_folder", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_GetSyncRootInformationForFolder), METH_VARARGS | METH_STATIC, nullptr },
        { "get_sync_root_information_for_id", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_GetSyncRootInformationForId), METH_VARARGS | METH_STATIC, nullptr },
        { "is_supported", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_IsSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "register", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_Register), METH_VARARGS | METH_STATIC, nullptr },
        { "unregister", reinterpret_cast<PyCFunction>(StorageProviderSyncRootManager_Unregister), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StorageProviderSyncRootManager[] = {
        { }
    };

    static PyType_Slot _type_slots_StorageProviderSyncRootManager[] = 
    {
        { Py_tp_new, _new_StorageProviderSyncRootManager },
        { Py_tp_methods, _methods_StorageProviderSyncRootManager },
        { Py_tp_getset, _getset_StorageProviderSyncRootManager },
        { },
    };

    static PyType_Spec type_spec_StorageProviderSyncRootManager =
    {
        "_winsdk_Windows_Storage_Provider.StorageProviderSyncRootManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StorageProviderSyncRootManager
    };

    // ----- IStorageProviderItemPropertySource interface --------------------
    constexpr const char* const type_name_IStorageProviderItemPropertySource = "IStorageProviderItemPropertySource";

    static PyObject* _new_IStorageProviderItemPropertySource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IStorageProviderItemPropertySource);
        return nullptr;
    }

    static void _dealloc_IStorageProviderItemPropertySource(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderItemPropertySource_GetItemProperties(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetItemProperties(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderItemPropertySource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderItemPropertySource[] = {
        { "get_item_properties", reinterpret_cast<PyCFunction>(IStorageProviderItemPropertySource_GetItemProperties), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderItemPropertySource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderItemPropertySource[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderItemPropertySource[] = 
    {
        { Py_tp_new, _new_IStorageProviderItemPropertySource },
        { Py_tp_dealloc, _dealloc_IStorageProviderItemPropertySource },
        { Py_tp_methods, _methods_IStorageProviderItemPropertySource },
        { Py_tp_getset, _getset_IStorageProviderItemPropertySource },
        { },
    };

    static PyType_Spec type_spec_IStorageProviderItemPropertySource =
    {
        "_winsdk_Windows_Storage_Provider.IStorageProviderItemPropertySource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderItemPropertySource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderItemPropertySource
    };

    // ----- IStorageProviderPropertyCapabilities interface --------------------
    constexpr const char* const type_name_IStorageProviderPropertyCapabilities = "IStorageProviderPropertyCapabilities";

    static PyObject* _new_IStorageProviderPropertyCapabilities(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IStorageProviderPropertyCapabilities);
        return nullptr;
    }

    static void _dealloc_IStorageProviderPropertyCapabilities(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderPropertyCapabilities_IsPropertySupported(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.IsPropertySupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderPropertyCapabilities(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderPropertyCapabilities[] = {
        { "is_property_supported", reinterpret_cast<PyCFunction>(IStorageProviderPropertyCapabilities_IsPropertySupported), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderPropertyCapabilities), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderPropertyCapabilities[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderPropertyCapabilities[] = 
    {
        { Py_tp_new, _new_IStorageProviderPropertyCapabilities },
        { Py_tp_dealloc, _dealloc_IStorageProviderPropertyCapabilities },
        { Py_tp_methods, _methods_IStorageProviderPropertyCapabilities },
        { Py_tp_getset, _getset_IStorageProviderPropertyCapabilities },
        { },
    };

    static PyType_Spec type_spec_IStorageProviderPropertyCapabilities =
    {
        "_winsdk_Windows_Storage_Provider.IStorageProviderPropertyCapabilities",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderPropertyCapabilities),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderPropertyCapabilities
    };

    // ----- IStorageProviderStatusUISource interface --------------------
    constexpr const char* const type_name_IStorageProviderStatusUISource = "IStorageProviderStatusUISource";

    static PyObject* _new_IStorageProviderStatusUISource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IStorageProviderStatusUISource);
        return nullptr;
    }

    static void _dealloc_IStorageProviderStatusUISource(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderStatusUISource_GetStatusUI(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetStatusUI());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderStatusUISource_add_StatusUIChanged(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.StatusUIChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderStatusUISource_remove_StatusUIChanged(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.StatusUIChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderStatusUISource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderStatusUISource[] = {
        { "get_status_u_i", reinterpret_cast<PyCFunction>(IStorageProviderStatusUISource_GetStatusUI), METH_VARARGS, nullptr },
        { "add_status_u_i_changed", reinterpret_cast<PyCFunction>(IStorageProviderStatusUISource_add_StatusUIChanged), METH_O, nullptr },
        { "remove_status_u_i_changed", reinterpret_cast<PyCFunction>(IStorageProviderStatusUISource_remove_StatusUIChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderStatusUISource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderStatusUISource[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderStatusUISource[] = 
    {
        { Py_tp_new, _new_IStorageProviderStatusUISource },
        { Py_tp_dealloc, _dealloc_IStorageProviderStatusUISource },
        { Py_tp_methods, _methods_IStorageProviderStatusUISource },
        { Py_tp_getset, _getset_IStorageProviderStatusUISource },
        { },
    };

    static PyType_Spec type_spec_IStorageProviderStatusUISource =
    {
        "_winsdk_Windows_Storage_Provider.IStorageProviderStatusUISource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderStatusUISource
    };

    // ----- IStorageProviderStatusUISourceFactory interface --------------------
    constexpr const char* const type_name_IStorageProviderStatusUISourceFactory = "IStorageProviderStatusUISourceFactory";

    static PyObject* _new_IStorageProviderStatusUISourceFactory(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IStorageProviderStatusUISourceFactory);
        return nullptr;
    }

    static void _dealloc_IStorageProviderStatusUISourceFactory(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderStatusUISourceFactory_GetStatusUISource(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetStatusUISource(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderStatusUISourceFactory(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderStatusUISourceFactory[] = {
        { "get_status_u_i_source", reinterpret_cast<PyCFunction>(IStorageProviderStatusUISourceFactory_GetStatusUISource), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderStatusUISourceFactory), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderStatusUISourceFactory[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderStatusUISourceFactory[] = 
    {
        { Py_tp_new, _new_IStorageProviderStatusUISourceFactory },
        { Py_tp_dealloc, _dealloc_IStorageProviderStatusUISourceFactory },
        { Py_tp_methods, _methods_IStorageProviderStatusUISourceFactory },
        { Py_tp_getset, _getset_IStorageProviderStatusUISourceFactory },
        { },
    };

    static PyType_Spec type_spec_IStorageProviderStatusUISourceFactory =
    {
        "_winsdk_Windows_Storage_Provider.IStorageProviderStatusUISourceFactory",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderStatusUISourceFactory
    };

    // ----- IStorageProviderUICommand interface --------------------
    constexpr const char* const type_name_IStorageProviderUICommand = "IStorageProviderUICommand";

    static PyObject* _new_IStorageProviderUICommand(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IStorageProviderUICommand);
        return nullptr;
    }

    static void _dealloc_IStorageProviderUICommand(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderUICommand_Invoke(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Invoke();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUICommand_get_Description(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUICommand_get_Icon(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Icon());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUICommand_get_Label(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Label());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUICommand_get_State(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.State());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderUICommand(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderUICommand>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderUICommand[] = {
        { "invoke", reinterpret_cast<PyCFunction>(IStorageProviderUICommand_Invoke), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderUICommand), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderUICommand[] = {
        { "description", reinterpret_cast<getter>(IStorageProviderUICommand_get_Description), nullptr, nullptr, nullptr },
        { "icon", reinterpret_cast<getter>(IStorageProviderUICommand_get_Icon), nullptr, nullptr, nullptr },
        { "label", reinterpret_cast<getter>(IStorageProviderUICommand_get_Label), nullptr, nullptr, nullptr },
        { "state", reinterpret_cast<getter>(IStorageProviderUICommand_get_State), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderUICommand[] = 
    {
        { Py_tp_new, _new_IStorageProviderUICommand },
        { Py_tp_dealloc, _dealloc_IStorageProviderUICommand },
        { Py_tp_methods, _methods_IStorageProviderUICommand },
        { Py_tp_getset, _getset_IStorageProviderUICommand },
        { },
    };

    static PyType_Spec type_spec_IStorageProviderUICommand =
    {
        "_winsdk_Windows_Storage_Provider.IStorageProviderUICommand",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderUICommand),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderUICommand
    };

    // ----- IStorageProviderUriSource interface --------------------
    constexpr const char* const type_name_IStorageProviderUriSource = "IStorageProviderUriSource";

    static PyObject* _new_IStorageProviderUriSource(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IStorageProviderUriSource);
        return nullptr;
    }

    static void _dealloc_IStorageProviderUriSource(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStorageProviderUriSource_GetContentInfoForPath(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>(args, 1);

                self->obj.GetContentInfoForPath(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IStorageProviderUriSource_GetPathForContentUri(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>(args, 1);

                self->obj.GetPathForContentUri(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_IStorageProviderUriSource(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Storage::Provider::IStorageProviderUriSource>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStorageProviderUriSource[] = {
        { "get_content_info_for_path", reinterpret_cast<PyCFunction>(IStorageProviderUriSource_GetContentInfoForPath), METH_VARARGS, nullptr },
        { "get_path_for_content_uri", reinterpret_cast<PyCFunction>(IStorageProviderUriSource_GetPathForContentUri), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IStorageProviderUriSource), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStorageProviderUriSource[] = {
        { }
    };

    static PyType_Slot _type_slots_IStorageProviderUriSource[] = 
    {
        { Py_tp_new, _new_IStorageProviderUriSource },
        { Py_tp_dealloc, _dealloc_IStorageProviderUriSource },
        { Py_tp_methods, _methods_IStorageProviderUriSource },
        { Py_tp_getset, _getset_IStorageProviderUriSource },
        { },
    };

    static PyType_Spec type_spec_IStorageProviderUriSource =
    {
        "_winsdk_Windows_Storage_Provider.IStorageProviderUriSource",
        sizeof(py::wrapper::Windows::Storage::Provider::IStorageProviderUriSource),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStorageProviderUriSource
    };

    // ----- Windows.Storage.Provider Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::Storage::Provider");

    static PyMethodDef module_methods[] = {
        {"_register_CachedFileOptions", register_CachedFileOptions, METH_O, "registers type"},
        {"_register_CachedFileTarget", register_CachedFileTarget, METH_O, "registers type"},
        {"_register_FileUpdateStatus", register_FileUpdateStatus, METH_O, "registers type"},
        {"_register_ReadActivationMode", register_ReadActivationMode, METH_O, "registers type"},
        {"_register_StorageProviderHardlinkPolicy", register_StorageProviderHardlinkPolicy, METH_O, "registers type"},
        {"_register_StorageProviderHydrationPolicy", register_StorageProviderHydrationPolicy, METH_O, "registers type"},
        {"_register_StorageProviderHydrationPolicyModifier", register_StorageProviderHydrationPolicyModifier, METH_O, "registers type"},
        {"_register_StorageProviderInSyncPolicy", register_StorageProviderInSyncPolicy, METH_O, "registers type"},
        {"_register_StorageProviderPopulationPolicy", register_StorageProviderPopulationPolicy, METH_O, "registers type"},
        {"_register_StorageProviderProtectionMode", register_StorageProviderProtectionMode, METH_O, "registers type"},
        {"_register_StorageProviderState", register_StorageProviderState, METH_O, "registers type"},
        {"_register_StorageProviderUICommandState", register_StorageProviderUICommandState, METH_O, "registers type"},
        {"_register_StorageProviderUriSourceStatus", register_StorageProviderUriSourceStatus, METH_O, "registers type"},
        {"_register_UIStatus", register_UIStatus, METH_O, "registers type"},
        {"_register_WriteActivationMode", register_WriteActivationMode, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_CachedFileOptions);
        Py_VISIT(state->type_CachedFileTarget);
        Py_VISIT(state->type_FileUpdateStatus);
        Py_VISIT(state->type_ReadActivationMode);
        Py_VISIT(state->type_StorageProviderHardlinkPolicy);
        Py_VISIT(state->type_StorageProviderHydrationPolicy);
        Py_VISIT(state->type_StorageProviderHydrationPolicyModifier);
        Py_VISIT(state->type_StorageProviderInSyncPolicy);
        Py_VISIT(state->type_StorageProviderPopulationPolicy);
        Py_VISIT(state->type_StorageProviderProtectionMode);
        Py_VISIT(state->type_StorageProviderState);
        Py_VISIT(state->type_StorageProviderUICommandState);
        Py_VISIT(state->type_StorageProviderUriSourceStatus);
        Py_VISIT(state->type_UIStatus);
        Py_VISIT(state->type_WriteActivationMode);
        Py_VISIT(state->type_CachedFileUpdater);
        Py_VISIT(state->type_CachedFileUpdaterUI);
        Py_VISIT(state->type_FileUpdateRequest);
        Py_VISIT(state->type_FileUpdateRequestDeferral);
        Py_VISIT(state->type_FileUpdateRequestedEventArgs);
        Py_VISIT(state->type_StorageProviderFileTypeInfo);
        Py_VISIT(state->type_StorageProviderGetContentInfoForPathResult);
        Py_VISIT(state->type_StorageProviderGetPathForContentUriResult);
        Py_VISIT(state->type_StorageProviderItemProperties);
        Py_VISIT(state->type_StorageProviderItemProperty);
        Py_VISIT(state->type_StorageProviderItemPropertyDefinition);
        Py_VISIT(state->type_StorageProviderMoreInfoUI);
        Py_VISIT(state->type_StorageProviderQuotaUI);
        Py_VISIT(state->type_StorageProviderStatusUI);
        Py_VISIT(state->type_StorageProviderSyncRootInfo);
        Py_VISIT(state->type_StorageProviderSyncRootManager);
        Py_VISIT(state->type_IStorageProviderItemPropertySource);
        Py_VISIT(state->type_IStorageProviderPropertyCapabilities);
        Py_VISIT(state->type_IStorageProviderStatusUISource);
        Py_VISIT(state->type_IStorageProviderStatusUISourceFactory);
        Py_VISIT(state->type_IStorageProviderUICommand);
        Py_VISIT(state->type_IStorageProviderUriSource);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_CachedFileOptions);
        Py_CLEAR(state->type_CachedFileTarget);
        Py_CLEAR(state->type_FileUpdateStatus);
        Py_CLEAR(state->type_ReadActivationMode);
        Py_CLEAR(state->type_StorageProviderHardlinkPolicy);
        Py_CLEAR(state->type_StorageProviderHydrationPolicy);
        Py_CLEAR(state->type_StorageProviderHydrationPolicyModifier);
        Py_CLEAR(state->type_StorageProviderInSyncPolicy);
        Py_CLEAR(state->type_StorageProviderPopulationPolicy);
        Py_CLEAR(state->type_StorageProviderProtectionMode);
        Py_CLEAR(state->type_StorageProviderState);
        Py_CLEAR(state->type_StorageProviderUICommandState);
        Py_CLEAR(state->type_StorageProviderUriSourceStatus);
        Py_CLEAR(state->type_UIStatus);
        Py_CLEAR(state->type_WriteActivationMode);
        Py_CLEAR(state->type_CachedFileUpdater);
        Py_CLEAR(state->type_CachedFileUpdaterUI);
        Py_CLEAR(state->type_FileUpdateRequest);
        Py_CLEAR(state->type_FileUpdateRequestDeferral);
        Py_CLEAR(state->type_FileUpdateRequestedEventArgs);
        Py_CLEAR(state->type_StorageProviderFileTypeInfo);
        Py_CLEAR(state->type_StorageProviderGetContentInfoForPathResult);
        Py_CLEAR(state->type_StorageProviderGetPathForContentUriResult);
        Py_CLEAR(state->type_StorageProviderItemProperties);
        Py_CLEAR(state->type_StorageProviderItemProperty);
        Py_CLEAR(state->type_StorageProviderItemPropertyDefinition);
        Py_CLEAR(state->type_StorageProviderMoreInfoUI);
        Py_CLEAR(state->type_StorageProviderQuotaUI);
        Py_CLEAR(state->type_StorageProviderStatusUI);
        Py_CLEAR(state->type_StorageProviderSyncRootInfo);
        Py_CLEAR(state->type_StorageProviderSyncRootManager);
        Py_CLEAR(state->type_IStorageProviderItemPropertySource);
        Py_CLEAR(state->type_IStorageProviderPropertyCapabilities);
        Py_CLEAR(state->type_IStorageProviderStatusUISource);
        Py_CLEAR(state->type_IStorageProviderStatusUISourceFactory);
        Py_CLEAR(state->type_IStorageProviderUICommand);
        Py_CLEAR(state->type_IStorageProviderUriSource);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Storage_Provider",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::Storage::Provider

PyMODINIT_FUNC PyInit__winsdk_Windows_Storage_Provider(void) noexcept
{
    using namespace py::cpp::Windows::Storage::Provider;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_CachedFileUpdater = py::register_python_type(module.get(), type_name_CachedFileUpdater, &type_spec_CachedFileUpdater, nullptr);
    if (!state->type_CachedFileUpdater)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CachedFileUpdater);

    state->type_CachedFileUpdaterUI = py::register_python_type(module.get(), type_name_CachedFileUpdaterUI, &type_spec_CachedFileUpdaterUI, bases.get());
    if (!state->type_CachedFileUpdaterUI)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CachedFileUpdaterUI);

    state->type_FileUpdateRequest = py::register_python_type(module.get(), type_name_FileUpdateRequest, &type_spec_FileUpdateRequest, bases.get());
    if (!state->type_FileUpdateRequest)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FileUpdateRequest);

    state->type_FileUpdateRequestDeferral = py::register_python_type(module.get(), type_name_FileUpdateRequestDeferral, &type_spec_FileUpdateRequestDeferral, bases.get());
    if (!state->type_FileUpdateRequestDeferral)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FileUpdateRequestDeferral);

    state->type_FileUpdateRequestedEventArgs = py::register_python_type(module.get(), type_name_FileUpdateRequestedEventArgs, &type_spec_FileUpdateRequestedEventArgs, bases.get());
    if (!state->type_FileUpdateRequestedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FileUpdateRequestedEventArgs);

    state->type_StorageProviderFileTypeInfo = py::register_python_type(module.get(), type_name_StorageProviderFileTypeInfo, &type_spec_StorageProviderFileTypeInfo, bases.get());
    if (!state->type_StorageProviderFileTypeInfo)
    {
        return nullptr;
    }

    Py_INCREF(state->type_StorageProviderFileTypeInfo);

    state->type_StorageProviderGetContentInfoForPathResult = py::register_python_type(module.get(), type_name_StorageProviderGetContentInfoForPathResult, &type_spec_StorageProviderGetContentInfoForPathResult, bases.get());
    if (!state->type_StorageProviderGetContentInfoForPathResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_StorageProviderGetContentInfoForPathResult);

    state->type_StorageProviderGetPathForContentUriResult = py::register_python_type(module.get(), type_name_StorageProviderGetPathForContentUriResult, &type_spec_StorageProviderGetPathForContentUriResult, bases.get());
    if (!state->type_StorageProviderGetPathForContentUriResult)
    {
        return nullptr;
    }

    Py_INCREF(state->type_StorageProviderGetPathForContentUriResult);

    state->type_StorageProviderItemProperties = py::register_python_type(module.get(), type_name_StorageProviderItemProperties, &type_spec_StorageProviderItemProperties, nullptr);
    if (!state->type_StorageProviderItemProperties)
    {
        return nullptr;
    }

    Py_INCREF(state->type_StorageProviderItemProperties);

    state->type_StorageProviderItemProperty = py::register_python_type(module.get(), type_name_StorageProviderItemProperty, &type_spec_StorageProviderItemProperty, bases.get());
    if (!state->type_StorageProviderItemProperty)
    {
        return nullptr;
    }

    Py_INCREF(state->type_StorageProviderItemProperty);

    state->type_StorageProviderItemPropertyDefinition = py::register_python_type(module.get(), type_name_StorageProviderItemPropertyDefinition, &type_spec_StorageProviderItemPropertyDefinition, bases.get());
    if (!state->type_StorageProviderItemPropertyDefinition)
    {
        return nullptr;
    }

    Py_INCREF(state->type_StorageProviderItemPropertyDefinition);

    state->type_StorageProviderMoreInfoUI = py::register_python_type(module.get(), type_name_StorageProviderMoreInfoUI, &type_spec_StorageProviderMoreInfoUI, bases.get());
    if (!state->type_StorageProviderMoreInfoUI)
    {
        return nullptr;
    }

    Py_INCREF(state->type_StorageProviderMoreInfoUI);

    state->type_StorageProviderQuotaUI = py::register_python_type(module.get(), type_name_StorageProviderQuotaUI, &type_spec_StorageProviderQuotaUI, bases.get());
    if (!state->type_StorageProviderQuotaUI)
    {
        return nullptr;
    }

    Py_INCREF(state->type_StorageProviderQuotaUI);

    state->type_StorageProviderStatusUI = py::register_python_type(module.get(), type_name_StorageProviderStatusUI, &type_spec_StorageProviderStatusUI, bases.get());
    if (!state->type_StorageProviderStatusUI)
    {
        return nullptr;
    }

    Py_INCREF(state->type_StorageProviderStatusUI);

    state->type_StorageProviderSyncRootInfo = py::register_python_type(module.get(), type_name_StorageProviderSyncRootInfo, &type_spec_StorageProviderSyncRootInfo, bases.get());
    if (!state->type_StorageProviderSyncRootInfo)
    {
        return nullptr;
    }

    Py_INCREF(state->type_StorageProviderSyncRootInfo);

    state->type_StorageProviderSyncRootManager = py::register_python_type(module.get(), type_name_StorageProviderSyncRootManager, &type_spec_StorageProviderSyncRootManager, nullptr);
    if (!state->type_StorageProviderSyncRootManager)
    {
        return nullptr;
    }

    Py_INCREF(state->type_StorageProviderSyncRootManager);

    state->type_IStorageProviderItemPropertySource = py::register_python_type(module.get(), type_name_IStorageProviderItemPropertySource, &type_spec_IStorageProviderItemPropertySource, bases.get());
    if (!state->type_IStorageProviderItemPropertySource)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IStorageProviderItemPropertySource);

    state->type_IStorageProviderPropertyCapabilities = py::register_python_type(module.get(), type_name_IStorageProviderPropertyCapabilities, &type_spec_IStorageProviderPropertyCapabilities, bases.get());
    if (!state->type_IStorageProviderPropertyCapabilities)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IStorageProviderPropertyCapabilities);

    state->type_IStorageProviderStatusUISource = py::register_python_type(module.get(), type_name_IStorageProviderStatusUISource, &type_spec_IStorageProviderStatusUISource, bases.get());
    if (!state->type_IStorageProviderStatusUISource)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IStorageProviderStatusUISource);

    state->type_IStorageProviderStatusUISourceFactory = py::register_python_type(module.get(), type_name_IStorageProviderStatusUISourceFactory, &type_spec_IStorageProviderStatusUISourceFactory, bases.get());
    if (!state->type_IStorageProviderStatusUISourceFactory)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IStorageProviderStatusUISourceFactory);

    state->type_IStorageProviderUICommand = py::register_python_type(module.get(), type_name_IStorageProviderUICommand, &type_spec_IStorageProviderUICommand, bases.get());
    if (!state->type_IStorageProviderUICommand)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IStorageProviderUICommand);

    state->type_IStorageProviderUriSource = py::register_python_type(module.get(), type_name_IStorageProviderUriSource, &type_spec_IStorageProviderUriSource, bases.get());
    if (!state->type_IStorageProviderUriSource)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IStorageProviderUriSource);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::CachedFileOptions>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CachedFileOptions;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::CachedFileOptions is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::CachedFileTarget>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CachedFileTarget;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::CachedFileTarget is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::FileUpdateStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FileUpdateStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::FileUpdateStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::ReadActivationMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ReadActivationMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::ReadActivationMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::StorageProviderHardlinkPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderHardlinkPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderHardlinkPolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderHydrationPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderHydrationPolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::StorageProviderHydrationPolicyModifier>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderHydrationPolicyModifier;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderHydrationPolicyModifier is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::StorageProviderInSyncPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderInSyncPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderInSyncPolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::StorageProviderPopulationPolicy>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderPopulationPolicy;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderPopulationPolicy is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::StorageProviderProtectionMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderProtectionMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderProtectionMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::StorageProviderState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::StorageProviderUICommandState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderUICommandState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderUICommandState is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderUriSourceStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderUriSourceStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::UIStatus>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UIStatus;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::UIStatus is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::Storage::Provider::WriteActivationMode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WriteActivationMode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::WriteActivationMode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::CachedFileUpdater>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CachedFileUpdater;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::CachedFileUpdater is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::CachedFileUpdaterUI>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CachedFileUpdaterUI;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::CachedFileUpdaterUI is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequest>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FileUpdateRequest;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::FileUpdateRequest is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequestDeferral>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FileUpdateRequestDeferral;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::FileUpdateRequestDeferral is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FileUpdateRequestedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::FileUpdateRequestedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderFileTypeInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderFileTypeInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderGetContentInfoForPathResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderGetContentInfoForPathResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderGetPathForContentUriResult;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderGetPathForContentUriResult is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemProperties>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderItemProperties;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderItemProperties is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemProperty>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderItemProperty;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderItemProperty is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderItemPropertyDefinition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderItemPropertyDefinition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderMoreInfoUI;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderMoreInfoUI is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderQuotaUI>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderQuotaUI;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderQuotaUI is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderStatusUI>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderStatusUI;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderStatusUI is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderSyncRootInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderSyncRootInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::StorageProviderSyncRootManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StorageProviderSyncRootManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::StorageProviderSyncRootManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IStorageProviderItemPropertySource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::IStorageProviderItemPropertySource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IStorageProviderPropertyCapabilities;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::IStorageProviderPropertyCapabilities is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderStatusUISource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IStorageProviderStatusUISource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::IStorageProviderStatusUISource is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IStorageProviderStatusUISourceFactory;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::IStorageProviderStatusUISourceFactory is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderUICommand>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IStorageProviderUICommand;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::IStorageProviderUICommand is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::Storage::Provider::IStorageProviderUriSource>::get_python_type() noexcept {
    using namespace py::cpp::Windows::Storage::Provider;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::Storage::Provider");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IStorageProviderUriSource;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::Storage::Provider::IStorageProviderUriSource is not registered");
        return nullptr;
    }

    return python_type;
}
