// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Devices.Usb.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkInEndpointDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkInPipe>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkOutPipe>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbConfigurationDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbControlRequestType>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDevice>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceClass>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceClasses>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbEndpointDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterface>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterfaceDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterfaceSetting>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInPipe>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptOutPipe>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Usb::UsbSetupPacket>::python_type;

namespace py::cpp::Windows::Devices::Usb
{
    // ----- UsbBulkInEndpointDescriptor class --------------------
    constexpr const char* const _type_name_UsbBulkInEndpointDescriptor = "UsbBulkInEndpointDescriptor";

    static PyObject* _new_UsbBulkInEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbBulkInEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbBulkInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbBulkInEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbBulkInEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkInEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkInEndpointDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbBulkInEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbBulkInEndpointDescriptor[] = {
        { "endpoint_number", reinterpret_cast<getter>(UsbBulkInEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "max_packet_size", reinterpret_cast<getter>(UsbBulkInEndpointDescriptor_get_MaxPacketSize), nullptr, nullptr, nullptr },
        { "pipe", reinterpret_cast<getter>(UsbBulkInEndpointDescriptor_get_Pipe), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbBulkInEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbBulkInEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbBulkInEndpointDescriptor },
        { Py_tp_methods, _methods_UsbBulkInEndpointDescriptor },
        { Py_tp_getset, _getset_UsbBulkInEndpointDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbBulkInEndpointDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbBulkInEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkInEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkInEndpointDescriptor
    };

    // ----- UsbBulkInPipe class --------------------
    constexpr const char* const _type_name_UsbBulkInPipe = "UsbBulkInPipe";

    static PyObject* _new_UsbBulkInPipe(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbBulkInPipe);
        return nullptr;
    }

    static void _dealloc_UsbBulkInPipe(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbBulkInPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_FlushBuffer(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.FlushBuffer();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_get_ReadOptions(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbBulkInPipe_put_ReadOptions(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbReadOptions>(arg);

            self->obj.ReadOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbBulkInPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_get_InputStream(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkInPipe_get_MaxTransferSizeBytes(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxTransferSizeBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbBulkInPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkInPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkInPipe[] = {
        { "clear_stall_async", reinterpret_cast<PyCFunction>(UsbBulkInPipe_ClearStallAsync), METH_VARARGS, nullptr },
        { "flush_buffer", reinterpret_cast<PyCFunction>(UsbBulkInPipe_FlushBuffer), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbBulkInPipe), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbBulkInPipe[] = {
        { "read_options", reinterpret_cast<getter>(UsbBulkInPipe_get_ReadOptions), reinterpret_cast<setter>(UsbBulkInPipe_put_ReadOptions), nullptr, nullptr },
        { "endpoint_descriptor", reinterpret_cast<getter>(UsbBulkInPipe_get_EndpointDescriptor), nullptr, nullptr, nullptr },
        { "input_stream", reinterpret_cast<getter>(UsbBulkInPipe_get_InputStream), nullptr, nullptr, nullptr },
        { "max_transfer_size_bytes", reinterpret_cast<getter>(UsbBulkInPipe_get_MaxTransferSizeBytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbBulkInPipe[] = 
    {
        { Py_tp_new, _new_UsbBulkInPipe },
        { Py_tp_dealloc, _dealloc_UsbBulkInPipe },
        { Py_tp_methods, _methods_UsbBulkInPipe },
        { Py_tp_getset, _getset_UsbBulkInPipe },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbBulkInPipe =
    {
        "_winsdk_Windows_Devices_Usb.UsbBulkInPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkInPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkInPipe
    };

    // ----- UsbBulkOutEndpointDescriptor class --------------------
    constexpr const char* const _type_name_UsbBulkOutEndpointDescriptor = "UsbBulkOutEndpointDescriptor";

    static PyObject* _new_UsbBulkOutEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbBulkOutEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbBulkOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbBulkOutEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbBulkOutEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkOutEndpointDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbBulkOutEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbBulkOutEndpointDescriptor[] = {
        { "endpoint_number", reinterpret_cast<getter>(UsbBulkOutEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "max_packet_size", reinterpret_cast<getter>(UsbBulkOutEndpointDescriptor_get_MaxPacketSize), nullptr, nullptr, nullptr },
        { "pipe", reinterpret_cast<getter>(UsbBulkOutEndpointDescriptor_get_Pipe), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbBulkOutEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbBulkOutEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbBulkOutEndpointDescriptor },
        { Py_tp_methods, _methods_UsbBulkOutEndpointDescriptor },
        { Py_tp_getset, _getset_UsbBulkOutEndpointDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbBulkOutEndpointDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbBulkOutEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkOutEndpointDescriptor
    };

    // ----- UsbBulkOutPipe class --------------------
    constexpr const char* const _type_name_UsbBulkOutPipe = "UsbBulkOutPipe";

    static PyObject* _new_UsbBulkOutPipe(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbBulkOutPipe);
        return nullptr;
    }

    static void _dealloc_UsbBulkOutPipe(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbBulkOutPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutPipe_get_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WriteOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbBulkOutPipe_put_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbWriteOptions>(arg);

            self->obj.WriteOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbBulkOutPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbBulkOutPipe_get_OutputStream(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbBulkOutPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbBulkOutPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbBulkOutPipe[] = {
        { "clear_stall_async", reinterpret_cast<PyCFunction>(UsbBulkOutPipe_ClearStallAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbBulkOutPipe), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbBulkOutPipe[] = {
        { "write_options", reinterpret_cast<getter>(UsbBulkOutPipe_get_WriteOptions), reinterpret_cast<setter>(UsbBulkOutPipe_put_WriteOptions), nullptr, nullptr },
        { "endpoint_descriptor", reinterpret_cast<getter>(UsbBulkOutPipe_get_EndpointDescriptor), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(UsbBulkOutPipe_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbBulkOutPipe[] = 
    {
        { Py_tp_new, _new_UsbBulkOutPipe },
        { Py_tp_dealloc, _dealloc_UsbBulkOutPipe },
        { Py_tp_methods, _methods_UsbBulkOutPipe },
        { Py_tp_getset, _getset_UsbBulkOutPipe },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbBulkOutPipe =
    {
        "_winsdk_Windows_Devices_Usb.UsbBulkOutPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbBulkOutPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbBulkOutPipe
    };

    // ----- UsbConfiguration class --------------------
    constexpr const char* const _type_name_UsbConfiguration = "UsbConfiguration";

    static PyObject* _new_UsbConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbConfiguration);
        return nullptr;
    }

    static void _dealloc_UsbConfiguration(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbConfiguration_get_ConfigurationDescriptor(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConfigurationDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfiguration_get_Descriptors(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Descriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfiguration_get_UsbInterfaces(py::wrapper::Windows::Devices::Usb::UsbConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UsbInterfaces());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbConfiguration[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbConfiguration[] = {
        { "configuration_descriptor", reinterpret_cast<getter>(UsbConfiguration_get_ConfigurationDescriptor), nullptr, nullptr, nullptr },
        { "descriptors", reinterpret_cast<getter>(UsbConfiguration_get_Descriptors), nullptr, nullptr, nullptr },
        { "usb_interfaces", reinterpret_cast<getter>(UsbConfiguration_get_UsbInterfaces), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbConfiguration[] = 
    {
        { Py_tp_new, _new_UsbConfiguration },
        { Py_tp_dealloc, _dealloc_UsbConfiguration },
        { Py_tp_methods, _methods_UsbConfiguration },
        { Py_tp_getset, _getset_UsbConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbConfiguration =
    {
        "_winsdk_Windows_Devices_Usb.UsbConfiguration",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbConfiguration
    };

    // ----- UsbConfigurationDescriptor class --------------------
    constexpr const char* const _type_name_UsbConfigurationDescriptor = "UsbConfigurationDescriptor";

    static PyObject* _new_UsbConfigurationDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbConfigurationDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbConfigurationDescriptor(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbConfigurationDescriptor_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbConfigurationDescriptor::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);
                winrt::Windows::Devices::Usb::UsbConfigurationDescriptor param1 { nullptr };

                auto return_value = winrt::Windows::Devices::Usb::UsbConfigurationDescriptor::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_ConfigurationValue(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConfigurationValue());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_MaxPowerMilliamps(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPowerMilliamps());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_RemoteWakeup(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoteWakeup());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbConfigurationDescriptor_get_SelfPowered(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SelfPowered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbConfigurationDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbConfigurationDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbConfigurationDescriptor[] = {
        { "parse", reinterpret_cast<PyCFunction>(UsbConfigurationDescriptor_Parse), METH_VARARGS | METH_STATIC, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(UsbConfigurationDescriptor_TryParse), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbConfigurationDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbConfigurationDescriptor[] = {
        { "configuration_value", reinterpret_cast<getter>(UsbConfigurationDescriptor_get_ConfigurationValue), nullptr, nullptr, nullptr },
        { "max_power_milliamps", reinterpret_cast<getter>(UsbConfigurationDescriptor_get_MaxPowerMilliamps), nullptr, nullptr, nullptr },
        { "remote_wakeup", reinterpret_cast<getter>(UsbConfigurationDescriptor_get_RemoteWakeup), nullptr, nullptr, nullptr },
        { "self_powered", reinterpret_cast<getter>(UsbConfigurationDescriptor_get_SelfPowered), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbConfigurationDescriptor[] = 
    {
        { Py_tp_new, _new_UsbConfigurationDescriptor },
        { Py_tp_dealloc, _dealloc_UsbConfigurationDescriptor },
        { Py_tp_methods, _methods_UsbConfigurationDescriptor },
        { Py_tp_getset, _getset_UsbConfigurationDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbConfigurationDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbConfigurationDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbConfigurationDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbConfigurationDescriptor
    };

    // ----- UsbControlRequestType class --------------------
    constexpr const char* const _type_name_UsbControlRequestType = "UsbControlRequestType";

    static PyObject* _new_UsbControlRequestType(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Usb::UsbControlRequestType instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UsbControlRequestType(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbControlRequestType_get_Recipient(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Recipient());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_Recipient(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbControlRecipient>(arg);

            self->obj.Recipient(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbControlRequestType_get_Direction(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_Direction(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbTransferDirection>(arg);

            self->obj.Direction(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbControlRequestType_get_ControlTransferType(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ControlTransferType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_ControlTransferType(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbControlTransferType>(arg);

            self->obj.ControlTransferType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbControlRequestType_get_AsByte(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AsByte());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbControlRequestType_put_AsByte(py::wrapper::Windows::Devices::Usb::UsbControlRequestType* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.AsByte(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_UsbControlRequestType(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbControlRequestType>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbControlRequestType[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbControlRequestType), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbControlRequestType[] = {
        { "recipient", reinterpret_cast<getter>(UsbControlRequestType_get_Recipient), reinterpret_cast<setter>(UsbControlRequestType_put_Recipient), nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(UsbControlRequestType_get_Direction), reinterpret_cast<setter>(UsbControlRequestType_put_Direction), nullptr, nullptr },
        { "control_transfer_type", reinterpret_cast<getter>(UsbControlRequestType_get_ControlTransferType), reinterpret_cast<setter>(UsbControlRequestType_put_ControlTransferType), nullptr, nullptr },
        { "as_byte", reinterpret_cast<getter>(UsbControlRequestType_get_AsByte), reinterpret_cast<setter>(UsbControlRequestType_put_AsByte), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbControlRequestType[] = 
    {
        { Py_tp_new, _new_UsbControlRequestType },
        { Py_tp_dealloc, _dealloc_UsbControlRequestType },
        { Py_tp_methods, _methods_UsbControlRequestType },
        { Py_tp_getset, _getset_UsbControlRequestType },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbControlRequestType =
    {
        "_winsdk_Windows_Devices_Usb.UsbControlRequestType",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbControlRequestType),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbControlRequestType
    };

    // ----- UsbDescriptor class --------------------
    constexpr const char* const _type_name_UsbDescriptor = "UsbDescriptor";

    static PyObject* _new_UsbDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbDescriptor(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbDescriptor_ReadDescriptorBuffer(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                self->obj.ReadDescriptorBuffer(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDescriptor_get_DescriptorType(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DescriptorType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDescriptor_get_Length(py::wrapper::Windows::Devices::Usb::UsbDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDescriptor[] = {
        { "read_descriptor_buffer", reinterpret_cast<PyCFunction>(UsbDescriptor_ReadDescriptorBuffer), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDescriptor[] = {
        { "descriptor_type", reinterpret_cast<getter>(UsbDescriptor_get_DescriptorType), nullptr, nullptr, nullptr },
        { "length", reinterpret_cast<getter>(UsbDescriptor_get_Length), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbDescriptor[] = 
    {
        { Py_tp_new, _new_UsbDescriptor },
        { Py_tp_dealloc, _dealloc_UsbDescriptor },
        { Py_tp_methods, _methods_UsbDescriptor },
        { Py_tp_getset, _getset_UsbDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDescriptor
    };

    // ----- UsbDevice class --------------------
    constexpr const char* const _type_name_UsbDevice = "UsbDevice";

    static PyObject* _new_UsbDevice(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbDevice);
        return nullptr;
    }

    static void _dealloc_UsbDevice(py::wrapper::Windows::Devices::Usb::UsbDevice* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbDevice_Close(py::wrapper::Windows::Devices::Usb::UsbDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_FromIdAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::FromIdAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_GetDeviceClassSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDeviceClass>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceClassSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_GetDeviceSelector(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::guid>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1 = py::convert_to<uint32_t>(args, 1);
                auto param2 = py::convert_to<winrt::guid>(args, 2);

                return py::convert(winrt::Windows::Devices::Usb::UsbDevice::GetDeviceSelector(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_SendControlInTransferAsync(py::wrapper::Windows::Devices::Usb::UsbDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);

                return py::convert(self->obj.SendControlInTransferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.SendControlInTransferAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_SendControlOutTransferAsync(py::wrapper::Windows::Devices::Usb::UsbDevice* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);

                return py::convert(self->obj.SendControlOutTransferAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbSetupPacket>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 1);

                return py::convert(self->obj.SendControlOutTransferAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbDevice_get_Configuration(py::wrapper::Windows::Devices::Usb::UsbDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDevice_get_DefaultInterface(py::wrapper::Windows::Devices::Usb::UsbDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DefaultInterface());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDevice_get_DeviceDescriptor(py::wrapper::Windows::Devices::Usb::UsbDevice* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbDevice(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDevice>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_UsbDevice(py::wrapper::Windows::Devices::Usb::UsbDevice* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_UsbDevice(py::wrapper::Windows::Devices::Usb::UsbDevice* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDevice[] = {
        { "close", reinterpret_cast<PyCFunction>(UsbDevice_Close), METH_VARARGS, nullptr },
        { "from_id_async", reinterpret_cast<PyCFunction>(UsbDevice_FromIdAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_class_selector", reinterpret_cast<PyCFunction>(UsbDevice_GetDeviceClassSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "get_device_selector", reinterpret_cast<PyCFunction>(UsbDevice_GetDeviceSelector), METH_VARARGS | METH_STATIC, nullptr },
        { "send_control_in_transfer_async", reinterpret_cast<PyCFunction>(UsbDevice_SendControlInTransferAsync), METH_VARARGS, nullptr },
        { "send_control_out_transfer_async", reinterpret_cast<PyCFunction>(UsbDevice_SendControlOutTransferAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDevice), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_UsbDevice), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_UsbDevice), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDevice[] = {
        { "configuration", reinterpret_cast<getter>(UsbDevice_get_Configuration), nullptr, nullptr, nullptr },
        { "default_interface", reinterpret_cast<getter>(UsbDevice_get_DefaultInterface), nullptr, nullptr, nullptr },
        { "device_descriptor", reinterpret_cast<getter>(UsbDevice_get_DeviceDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbDevice[] = 
    {
        { Py_tp_new, _new_UsbDevice },
        { Py_tp_dealloc, _dealloc_UsbDevice },
        { Py_tp_methods, _methods_UsbDevice },
        { Py_tp_getset, _getset_UsbDevice },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbDevice =
    {
        "_winsdk_Windows_Devices_Usb.UsbDevice",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDevice),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDevice
    };

    // ----- UsbDeviceClass class --------------------
    constexpr const char* const _type_name_UsbDeviceClass = "UsbDeviceClass";

    static PyObject* _new_UsbDeviceClass(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Usb::UsbDeviceClass instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UsbDeviceClass(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbDeviceClass_get_SubclassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubclassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbDeviceClass_put_SubclassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint8_t>>(arg);

            self->obj.SubclassCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbDeviceClass_get_ProtocolCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtocolCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbDeviceClass_put_ProtocolCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<uint8_t>>(arg);

            self->obj.ProtocolCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbDeviceClass_get_ClassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbDeviceClass_put_ClassCode(py::wrapper::Windows::Devices::Usb::UsbDeviceClass* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.ClassCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_UsbDeviceClass(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDeviceClass>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDeviceClass[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDeviceClass), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDeviceClass[] = {
        { "subclass_code", reinterpret_cast<getter>(UsbDeviceClass_get_SubclassCode), reinterpret_cast<setter>(UsbDeviceClass_put_SubclassCode), nullptr, nullptr },
        { "protocol_code", reinterpret_cast<getter>(UsbDeviceClass_get_ProtocolCode), reinterpret_cast<setter>(UsbDeviceClass_put_ProtocolCode), nullptr, nullptr },
        { "class_code", reinterpret_cast<getter>(UsbDeviceClass_get_ClassCode), reinterpret_cast<setter>(UsbDeviceClass_put_ClassCode), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbDeviceClass[] = 
    {
        { Py_tp_new, _new_UsbDeviceClass },
        { Py_tp_dealloc, _dealloc_UsbDeviceClass },
        { Py_tp_methods, _methods_UsbDeviceClass },
        { Py_tp_getset, _getset_UsbDeviceClass },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbDeviceClass =
    {
        "_winsdk_Windows_Devices_Usb.UsbDeviceClass",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDeviceClass),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDeviceClass
    };

    // ----- UsbDeviceClasses class --------------------
    constexpr const char* const _type_name_UsbDeviceClasses = "UsbDeviceClasses";

    static PyObject* _new_UsbDeviceClasses(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbDeviceClasses);
        return nullptr;
    }

    static void _dealloc_UsbDeviceClasses(py::wrapper::Windows::Devices::Usb::UsbDeviceClasses* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbDeviceClasses_get_ActiveSync(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::ActiveSync());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_CdcControl(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::CdcControl());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_DeviceFirmwareUpdate(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::DeviceFirmwareUpdate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_Irda(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::Irda());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_Measurement(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::Measurement());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_PalmSync(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::PalmSync());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_PersonalHealthcare(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::PersonalHealthcare());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_Physical(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::Physical());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceClasses_get_VendorSpecific(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::Devices::Usb::UsbDeviceClasses::VendorSpecific());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbDeviceClasses(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDeviceClasses>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDeviceClasses[] = {
        { "get_active_sync", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_ActiveSync), METH_NOARGS | METH_STATIC, nullptr },
        { "get_cdc_control", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_CdcControl), METH_NOARGS | METH_STATIC, nullptr },
        { "get_device_firmware_update", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_DeviceFirmwareUpdate), METH_NOARGS | METH_STATIC, nullptr },
        { "get_irda", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_Irda), METH_NOARGS | METH_STATIC, nullptr },
        { "get_measurement", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_Measurement), METH_NOARGS | METH_STATIC, nullptr },
        { "get_palm_sync", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_PalmSync), METH_NOARGS | METH_STATIC, nullptr },
        { "get_personal_healthcare", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_PersonalHealthcare), METH_NOARGS | METH_STATIC, nullptr },
        { "get_physical", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_Physical), METH_NOARGS | METH_STATIC, nullptr },
        { "get_vendor_specific", reinterpret_cast<PyCFunction>(UsbDeviceClasses_get_VendorSpecific), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDeviceClasses), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDeviceClasses[] = {
        { }
    };

    static PyType_Slot _type_slots_UsbDeviceClasses[] = 
    {
        { Py_tp_new, _new_UsbDeviceClasses },
        { Py_tp_dealloc, _dealloc_UsbDeviceClasses },
        { Py_tp_methods, _methods_UsbDeviceClasses },
        { Py_tp_getset, _getset_UsbDeviceClasses },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbDeviceClasses =
    {
        "_winsdk_Windows_Devices_Usb.UsbDeviceClasses",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDeviceClasses),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDeviceClasses
    };

    // ----- UsbDeviceDescriptor class --------------------
    constexpr const char* const _type_name_UsbDeviceDescriptor = "UsbDeviceDescriptor";

    static PyObject* _new_UsbDeviceDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbDeviceDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbDeviceDescriptor(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbDeviceDescriptor_get_BcdDeviceRevision(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BcdDeviceRevision());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_BcdUsb(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BcdUsb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_MaxPacketSize0(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPacketSize0());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_NumberOfConfigurations(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NumberOfConfigurations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_ProductId(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProductId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbDeviceDescriptor_get_VendorId(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VendorId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbDeviceDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbDeviceDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbDeviceDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbDeviceDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbDeviceDescriptor[] = {
        { "bcd_device_revision", reinterpret_cast<getter>(UsbDeviceDescriptor_get_BcdDeviceRevision), nullptr, nullptr, nullptr },
        { "bcd_usb", reinterpret_cast<getter>(UsbDeviceDescriptor_get_BcdUsb), nullptr, nullptr, nullptr },
        { "max_packet_size0", reinterpret_cast<getter>(UsbDeviceDescriptor_get_MaxPacketSize0), nullptr, nullptr, nullptr },
        { "number_of_configurations", reinterpret_cast<getter>(UsbDeviceDescriptor_get_NumberOfConfigurations), nullptr, nullptr, nullptr },
        { "product_id", reinterpret_cast<getter>(UsbDeviceDescriptor_get_ProductId), nullptr, nullptr, nullptr },
        { "vendor_id", reinterpret_cast<getter>(UsbDeviceDescriptor_get_VendorId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbDeviceDescriptor[] = 
    {
        { Py_tp_new, _new_UsbDeviceDescriptor },
        { Py_tp_dealloc, _dealloc_UsbDeviceDescriptor },
        { Py_tp_methods, _methods_UsbDeviceDescriptor },
        { Py_tp_getset, _getset_UsbDeviceDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbDeviceDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbDeviceDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbDeviceDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbDeviceDescriptor
    };

    // ----- UsbEndpointDescriptor class --------------------
    constexpr const char* const _type_name_UsbEndpointDescriptor = "UsbEndpointDescriptor";

    static PyObject* _new_UsbEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbEndpointDescriptor_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbEndpointDescriptor::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);
                winrt::Windows::Devices::Usb::UsbEndpointDescriptor param1 { nullptr };

                auto return_value = winrt::Windows::Devices::Usb::UsbEndpointDescriptor::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsBulkInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AsBulkInEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsBulkOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AsBulkOutEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsInterruptInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AsInterruptInEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_AsInterruptOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AsInterruptOutEndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_Direction(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Direction());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbEndpointDescriptor_get_EndpointType(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbEndpointDescriptor[] = {
        { "parse", reinterpret_cast<PyCFunction>(UsbEndpointDescriptor_Parse), METH_VARARGS | METH_STATIC, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(UsbEndpointDescriptor_TryParse), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbEndpointDescriptor[] = {
        { "as_bulk_in_endpoint_descriptor", reinterpret_cast<getter>(UsbEndpointDescriptor_get_AsBulkInEndpointDescriptor), nullptr, nullptr, nullptr },
        { "as_bulk_out_endpoint_descriptor", reinterpret_cast<getter>(UsbEndpointDescriptor_get_AsBulkOutEndpointDescriptor), nullptr, nullptr, nullptr },
        { "as_interrupt_in_endpoint_descriptor", reinterpret_cast<getter>(UsbEndpointDescriptor_get_AsInterruptInEndpointDescriptor), nullptr, nullptr, nullptr },
        { "as_interrupt_out_endpoint_descriptor", reinterpret_cast<getter>(UsbEndpointDescriptor_get_AsInterruptOutEndpointDescriptor), nullptr, nullptr, nullptr },
        { "direction", reinterpret_cast<getter>(UsbEndpointDescriptor_get_Direction), nullptr, nullptr, nullptr },
        { "endpoint_number", reinterpret_cast<getter>(UsbEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "endpoint_type", reinterpret_cast<getter>(UsbEndpointDescriptor_get_EndpointType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbEndpointDescriptor },
        { Py_tp_methods, _methods_UsbEndpointDescriptor },
        { Py_tp_getset, _getset_UsbEndpointDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbEndpointDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbEndpointDescriptor
    };

    // ----- UsbInterface class --------------------
    constexpr const char* const _type_name_UsbInterface = "UsbInterface";

    static PyObject* _new_UsbInterface(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterface);
        return nullptr;
    }

    static void _dealloc_UsbInterface(py::wrapper::Windows::Devices::Usb::UsbInterface* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterface_get_BulkInPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BulkInPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_BulkOutPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BulkOutPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_Descriptors(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Descriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterfaceNumber(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterfaceNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterfaceSettings(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterfaceSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterruptInPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterruptInPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterface_get_InterruptOutPipes(py::wrapper::Windows::Devices::Usb::UsbInterface* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterruptOutPipes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterface(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterface>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterface[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterface), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterface[] = {
        { "bulk_in_pipes", reinterpret_cast<getter>(UsbInterface_get_BulkInPipes), nullptr, nullptr, nullptr },
        { "bulk_out_pipes", reinterpret_cast<getter>(UsbInterface_get_BulkOutPipes), nullptr, nullptr, nullptr },
        { "descriptors", reinterpret_cast<getter>(UsbInterface_get_Descriptors), nullptr, nullptr, nullptr },
        { "interface_number", reinterpret_cast<getter>(UsbInterface_get_InterfaceNumber), nullptr, nullptr, nullptr },
        { "interface_settings", reinterpret_cast<getter>(UsbInterface_get_InterfaceSettings), nullptr, nullptr, nullptr },
        { "interrupt_in_pipes", reinterpret_cast<getter>(UsbInterface_get_InterruptInPipes), nullptr, nullptr, nullptr },
        { "interrupt_out_pipes", reinterpret_cast<getter>(UsbInterface_get_InterruptOutPipes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterface[] = 
    {
        { Py_tp_new, _new_UsbInterface },
        { Py_tp_dealloc, _dealloc_UsbInterface },
        { Py_tp_methods, _methods_UsbInterface },
        { Py_tp_getset, _getset_UsbInterface },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterface =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterface",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterface),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterface
    };

    // ----- UsbInterfaceDescriptor class --------------------
    constexpr const char* const _type_name_UsbInterfaceDescriptor = "UsbInterfaceDescriptor";

    static PyObject* _new_UsbInterfaceDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterfaceDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbInterfaceDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterfaceDescriptor_Parse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);

                return py::convert(winrt::Windows::Devices::Usb::UsbInterfaceDescriptor::Parse(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_TryParse(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbDescriptor>(args, 0);
                winrt::Windows::Devices::Usb::UsbInterfaceDescriptor param1 { nullptr };

                auto return_value = winrt::Windows::Devices::Usb::UsbInterfaceDescriptor::TryParse(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_AlternateSettingNumber(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AlternateSettingNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_ClassCode(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ClassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_InterfaceNumber(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterfaceNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_ProtocolCode(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtocolCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceDescriptor_get_SubclassCode(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SubclassCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterfaceDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterfaceDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterfaceDescriptor[] = {
        { "parse", reinterpret_cast<PyCFunction>(UsbInterfaceDescriptor_Parse), METH_VARARGS | METH_STATIC, nullptr },
        { "try_parse", reinterpret_cast<PyCFunction>(UsbInterfaceDescriptor_TryParse), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterfaceDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterfaceDescriptor[] = {
        { "alternate_setting_number", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_AlternateSettingNumber), nullptr, nullptr, nullptr },
        { "class_code", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_ClassCode), nullptr, nullptr, nullptr },
        { "interface_number", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_InterfaceNumber), nullptr, nullptr, nullptr },
        { "protocol_code", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_ProtocolCode), nullptr, nullptr, nullptr },
        { "subclass_code", reinterpret_cast<getter>(UsbInterfaceDescriptor_get_SubclassCode), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterfaceDescriptor[] = 
    {
        { Py_tp_new, _new_UsbInterfaceDescriptor },
        { Py_tp_dealloc, _dealloc_UsbInterfaceDescriptor },
        { Py_tp_methods, _methods_UsbInterfaceDescriptor },
        { Py_tp_getset, _getset_UsbInterfaceDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterfaceDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterfaceDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterfaceDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterfaceDescriptor
    };

    // ----- UsbInterfaceSetting class --------------------
    constexpr const char* const _type_name_UsbInterfaceSetting = "UsbInterfaceSetting";

    static PyObject* _new_UsbInterfaceSetting(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterfaceSetting);
        return nullptr;
    }

    static void _dealloc_UsbInterfaceSetting(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterfaceSetting_SelectSettingAsync(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.SelectSettingAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_BulkInEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BulkInEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_BulkOutEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BulkOutEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_Descriptors(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Descriptors());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_InterfaceDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterfaceDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_InterruptInEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterruptInEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_InterruptOutEndpoints(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterruptOutEndpoints());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterfaceSetting_get_Selected(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Selected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterfaceSetting(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterfaceSetting>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterfaceSetting[] = {
        { "select_setting_async", reinterpret_cast<PyCFunction>(UsbInterfaceSetting_SelectSettingAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterfaceSetting), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterfaceSetting[] = {
        { "bulk_in_endpoints", reinterpret_cast<getter>(UsbInterfaceSetting_get_BulkInEndpoints), nullptr, nullptr, nullptr },
        { "bulk_out_endpoints", reinterpret_cast<getter>(UsbInterfaceSetting_get_BulkOutEndpoints), nullptr, nullptr, nullptr },
        { "descriptors", reinterpret_cast<getter>(UsbInterfaceSetting_get_Descriptors), nullptr, nullptr, nullptr },
        { "interface_descriptor", reinterpret_cast<getter>(UsbInterfaceSetting_get_InterfaceDescriptor), nullptr, nullptr, nullptr },
        { "interrupt_in_endpoints", reinterpret_cast<getter>(UsbInterfaceSetting_get_InterruptInEndpoints), nullptr, nullptr, nullptr },
        { "interrupt_out_endpoints", reinterpret_cast<getter>(UsbInterfaceSetting_get_InterruptOutEndpoints), nullptr, nullptr, nullptr },
        { "selected", reinterpret_cast<getter>(UsbInterfaceSetting_get_Selected), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterfaceSetting[] = 
    {
        { Py_tp_new, _new_UsbInterfaceSetting },
        { Py_tp_dealloc, _dealloc_UsbInterfaceSetting },
        { Py_tp_methods, _methods_UsbInterfaceSetting },
        { Py_tp_getset, _getset_UsbInterfaceSetting },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterfaceSetting =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterfaceSetting",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterfaceSetting),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterfaceSetting
    };

    // ----- UsbInterruptInEndpointDescriptor class --------------------
    constexpr const char* const _type_name_UsbInterruptInEndpointDescriptor = "UsbInterruptInEndpointDescriptor";

    static PyObject* _new_UsbInterruptInEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterruptInEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbInterruptInEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_Interval(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptInEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptInEndpointDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptInEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptInEndpointDescriptor[] = {
        { "endpoint_number", reinterpret_cast<getter>(UsbInterruptInEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "interval", reinterpret_cast<getter>(UsbInterruptInEndpointDescriptor_get_Interval), nullptr, nullptr, nullptr },
        { "max_packet_size", reinterpret_cast<getter>(UsbInterruptInEndpointDescriptor_get_MaxPacketSize), nullptr, nullptr, nullptr },
        { "pipe", reinterpret_cast<getter>(UsbInterruptInEndpointDescriptor_get_Pipe), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptInEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbInterruptInEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbInterruptInEndpointDescriptor },
        { Py_tp_methods, _methods_UsbInterruptInEndpointDescriptor },
        { Py_tp_getset, _getset_UsbInterruptInEndpointDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterruptInEndpointDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterruptInEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptInEndpointDescriptor
    };

    // ----- UsbInterruptInEventArgs class --------------------
    constexpr const char* const _type_name_UsbInterruptInEventArgs = "UsbInterruptInEventArgs";

    static PyObject* _new_UsbInterruptInEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterruptInEventArgs);
        return nullptr;
    }

    static void _dealloc_UsbInterruptInEventArgs(py::wrapper::Windows::Devices::Usb::UsbInterruptInEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterruptInEventArgs_get_InterruptData(py::wrapper::Windows::Devices::Usb::UsbInterruptInEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InterruptData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptInEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptInEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptInEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptInEventArgs[] = {
        { "interrupt_data", reinterpret_cast<getter>(UsbInterruptInEventArgs_get_InterruptData), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptInEventArgs[] = 
    {
        { Py_tp_new, _new_UsbInterruptInEventArgs },
        { Py_tp_dealloc, _dealloc_UsbInterruptInEventArgs },
        { Py_tp_methods, _methods_UsbInterruptInEventArgs },
        { Py_tp_getset, _getset_UsbInterruptInEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterruptInEventArgs =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterruptInEventArgs",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptInEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptInEventArgs
    };

    // ----- UsbInterruptInPipe class --------------------
    constexpr const char* const _type_name_UsbInterruptInPipe = "UsbInterruptInPipe";

    static PyObject* _new_UsbInterruptInPipe(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterruptInPipe);
        return nullptr;
    }

    static void _dealloc_UsbInterruptInPipe(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterruptInPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInPipe_add_DataReceived(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Usb::UsbInterruptInPipe, winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>>(arg);

            return py::convert(self->obj.DataReceived(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptInPipe_remove_DataReceived(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.DataReceived(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptInPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptInPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptInPipe[] = {
        { "clear_stall_async", reinterpret_cast<PyCFunction>(UsbInterruptInPipe_ClearStallAsync), METH_VARARGS, nullptr },
        { "add_data_received", reinterpret_cast<PyCFunction>(UsbInterruptInPipe_add_DataReceived), METH_O, nullptr },
        { "remove_data_received", reinterpret_cast<PyCFunction>(UsbInterruptInPipe_remove_DataReceived), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptInPipe), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptInPipe[] = {
        { "endpoint_descriptor", reinterpret_cast<getter>(UsbInterruptInPipe_get_EndpointDescriptor), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptInPipe[] = 
    {
        { Py_tp_new, _new_UsbInterruptInPipe },
        { Py_tp_dealloc, _dealloc_UsbInterruptInPipe },
        { Py_tp_methods, _methods_UsbInterruptInPipe },
        { Py_tp_getset, _getset_UsbInterruptInPipe },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterruptInPipe =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterruptInPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptInPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptInPipe
    };

    // ----- UsbInterruptOutEndpointDescriptor class --------------------
    constexpr const char* const _type_name_UsbInterruptOutEndpointDescriptor = "UsbInterruptOutEndpointDescriptor";

    static PyObject* _new_UsbInterruptOutEndpointDescriptor(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterruptOutEndpointDescriptor);
        return nullptr;
    }

    static void _dealloc_UsbInterruptOutEndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_EndpointNumber(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointNumber());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_Interval(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Interval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_MaxPacketSize(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxPacketSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutEndpointDescriptor_get_Pipe(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pipe());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptOutEndpointDescriptor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptOutEndpointDescriptor[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptOutEndpointDescriptor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptOutEndpointDescriptor[] = {
        { "endpoint_number", reinterpret_cast<getter>(UsbInterruptOutEndpointDescriptor_get_EndpointNumber), nullptr, nullptr, nullptr },
        { "interval", reinterpret_cast<getter>(UsbInterruptOutEndpointDescriptor_get_Interval), nullptr, nullptr, nullptr },
        { "max_packet_size", reinterpret_cast<getter>(UsbInterruptOutEndpointDescriptor_get_MaxPacketSize), nullptr, nullptr, nullptr },
        { "pipe", reinterpret_cast<getter>(UsbInterruptOutEndpointDescriptor_get_Pipe), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptOutEndpointDescriptor[] = 
    {
        { Py_tp_new, _new_UsbInterruptOutEndpointDescriptor },
        { Py_tp_dealloc, _dealloc_UsbInterruptOutEndpointDescriptor },
        { Py_tp_methods, _methods_UsbInterruptOutEndpointDescriptor },
        { Py_tp_getset, _getset_UsbInterruptOutEndpointDescriptor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterruptOutEndpointDescriptor =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterruptOutEndpointDescriptor",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptOutEndpointDescriptor
    };

    // ----- UsbInterruptOutPipe class --------------------
    constexpr const char* const _type_name_UsbInterruptOutPipe = "UsbInterruptOutPipe";

    static PyObject* _new_UsbInterruptOutPipe(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_UsbInterruptOutPipe);
        return nullptr;
    }

    static void _dealloc_UsbInterruptOutPipe(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbInterruptOutPipe_ClearStallAsync(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearStallAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutPipe_get_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WriteOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbInterruptOutPipe_put_WriteOptions(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbWriteOptions>(arg);

            self->obj.WriteOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbInterruptOutPipe_get_EndpointDescriptor(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EndpointDescriptor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UsbInterruptOutPipe_get_OutputStream(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputStream());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UsbInterruptOutPipe(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbInterruptOutPipe>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbInterruptOutPipe[] = {
        { "clear_stall_async", reinterpret_cast<PyCFunction>(UsbInterruptOutPipe_ClearStallAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbInterruptOutPipe), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbInterruptOutPipe[] = {
        { "write_options", reinterpret_cast<getter>(UsbInterruptOutPipe_get_WriteOptions), reinterpret_cast<setter>(UsbInterruptOutPipe_put_WriteOptions), nullptr, nullptr },
        { "endpoint_descriptor", reinterpret_cast<getter>(UsbInterruptOutPipe_get_EndpointDescriptor), nullptr, nullptr, nullptr },
        { "output_stream", reinterpret_cast<getter>(UsbInterruptOutPipe_get_OutputStream), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbInterruptOutPipe[] = 
    {
        { Py_tp_new, _new_UsbInterruptOutPipe },
        { Py_tp_dealloc, _dealloc_UsbInterruptOutPipe },
        { Py_tp_methods, _methods_UsbInterruptOutPipe },
        { Py_tp_getset, _getset_UsbInterruptOutPipe },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbInterruptOutPipe =
    {
        "_winsdk_Windows_Devices_Usb.UsbInterruptOutPipe",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbInterruptOutPipe),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbInterruptOutPipe
    };

    // ----- UsbSetupPacket class --------------------
    constexpr const char* const _type_name_UsbSetupPacket = "UsbSetupPacket";

    static PyObject* _new_UsbSetupPacket(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IBuffer>(args, 0);

                winrt::Windows::Devices::Usb::UsbSetupPacket instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Usb::UsbSetupPacket instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_UsbSetupPacket(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* UsbSetupPacket_get_Value(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Value(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_RequestType(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequestType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_RequestType(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Usb::UsbControlRequestType>(arg);

            self->obj.RequestType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_Request(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Request());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Request(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint8_t>(arg);

            self->obj.Request(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_Length(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Length());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Length(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Length(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* UsbSetupPacket_get_Index(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Index());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int UsbSetupPacket_put_Index(py::wrapper::Windows::Devices::Usb::UsbSetupPacket* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.Index(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_UsbSetupPacket(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Usb::UsbSetupPacket>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UsbSetupPacket[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UsbSetupPacket), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UsbSetupPacket[] = {
        { "value", reinterpret_cast<getter>(UsbSetupPacket_get_Value), reinterpret_cast<setter>(UsbSetupPacket_put_Value), nullptr, nullptr },
        { "request_type", reinterpret_cast<getter>(UsbSetupPacket_get_RequestType), reinterpret_cast<setter>(UsbSetupPacket_put_RequestType), nullptr, nullptr },
        { "request", reinterpret_cast<getter>(UsbSetupPacket_get_Request), reinterpret_cast<setter>(UsbSetupPacket_put_Request), nullptr, nullptr },
        { "length", reinterpret_cast<getter>(UsbSetupPacket_get_Length), reinterpret_cast<setter>(UsbSetupPacket_put_Length), nullptr, nullptr },
        { "index", reinterpret_cast<getter>(UsbSetupPacket_get_Index), reinterpret_cast<setter>(UsbSetupPacket_put_Index), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UsbSetupPacket[] = 
    {
        { Py_tp_new, _new_UsbSetupPacket },
        { Py_tp_dealloc, _dealloc_UsbSetupPacket },
        { Py_tp_methods, _methods_UsbSetupPacket },
        { Py_tp_getset, _getset_UsbSetupPacket },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_UsbSetupPacket =
    {
        "_winsdk_Windows_Devices_Usb.UsbSetupPacket",
        sizeof(py::wrapper::Windows::Devices::Usb::UsbSetupPacket),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UsbSetupPacket
    };

    // ----- Windows.Devices.Usb Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkInEndpointDescriptor>::python_type = py::register_python_type(module, _type_name_UsbBulkInEndpointDescriptor, &_type_spec_UsbBulkInEndpointDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkInPipe>::python_type = py::register_python_type(module, _type_name_UsbBulkInPipe, &_type_spec_UsbBulkInPipe, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkOutEndpointDescriptor>::python_type = py::register_python_type(module, _type_name_UsbBulkOutEndpointDescriptor, &_type_spec_UsbBulkOutEndpointDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbBulkOutPipe>::python_type = py::register_python_type(module, _type_name_UsbBulkOutPipe, &_type_spec_UsbBulkOutPipe, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbConfiguration>::python_type = py::register_python_type(module, _type_name_UsbConfiguration, &_type_spec_UsbConfiguration, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbConfigurationDescriptor>::python_type = py::register_python_type(module, _type_name_UsbConfigurationDescriptor, &_type_spec_UsbConfigurationDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbControlRequestType>::python_type = py::register_python_type(module, _type_name_UsbControlRequestType, &_type_spec_UsbControlRequestType, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbDescriptor>::python_type = py::register_python_type(module, _type_name_UsbDescriptor, &_type_spec_UsbDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbDevice>::python_type = py::register_python_type(module, _type_name_UsbDevice, &_type_spec_UsbDevice, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceClass>::python_type = py::register_python_type(module, _type_name_UsbDeviceClass, &_type_spec_UsbDeviceClass, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceClasses>::python_type = py::register_python_type(module, _type_name_UsbDeviceClasses, &_type_spec_UsbDeviceClasses, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbDeviceDescriptor>::python_type = py::register_python_type(module, _type_name_UsbDeviceDescriptor, &_type_spec_UsbDeviceDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbEndpointDescriptor>::python_type = py::register_python_type(module, _type_name_UsbEndpointDescriptor, &_type_spec_UsbEndpointDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterface>::python_type = py::register_python_type(module, _type_name_UsbInterface, &_type_spec_UsbInterface, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterfaceDescriptor>::python_type = py::register_python_type(module, _type_name_UsbInterfaceDescriptor, &_type_spec_UsbInterfaceDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterfaceSetting>::python_type = py::register_python_type(module, _type_name_UsbInterfaceSetting, &_type_spec_UsbInterfaceSetting, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInEndpointDescriptor>::python_type = py::register_python_type(module, _type_name_UsbInterruptInEndpointDescriptor, &_type_spec_UsbInterruptInEndpointDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInEventArgs>::python_type = py::register_python_type(module, _type_name_UsbInterruptInEventArgs, &_type_spec_UsbInterruptInEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptInPipe>::python_type = py::register_python_type(module, _type_name_UsbInterruptInPipe, &_type_spec_UsbInterruptInPipe, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptOutEndpointDescriptor>::python_type = py::register_python_type(module, _type_name_UsbInterruptOutEndpointDescriptor, &_type_spec_UsbInterruptOutEndpointDescriptor, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbInterruptOutPipe>::python_type = py::register_python_type(module, _type_name_UsbInterruptOutPipe, &_type_spec_UsbInterruptOutPipe, bases.get());
            py::winrt_type<winrt::Windows::Devices::Usb::UsbSetupPacket>::python_type = py::register_python_type(module, _type_name_UsbSetupPacket, &_type_spec_UsbSetupPacket, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Devices.Usb");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Usb",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Devices::Usb

PyMODINIT_FUNC
PyInit__winsdk_Windows_Devices_Usb (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::Usb::module_def);
}
