// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Management.Deployment.h"

PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::AddPackageOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::AppInstallerManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::DeploymentResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::PackageAllUserProvisioningOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::PackageManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::PackageManagerDebugSettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::PackageUserInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::PackageVolume>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::RegisterPackageOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::StagePackageOptions>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Management::Deployment::DeploymentProgress>::python_type;

PyObject* py::converter<winrt::Windows::Management::Deployment::DeploymentProgress>::convert(winrt::Windows::Management::Deployment::DeploymentProgress instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Management::Deployment::DeploymentProgress>());
}
winrt::Windows::Management::Deployment::DeploymentProgress py::converter<winrt::Windows::Management::Deployment::DeploymentProgress>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Management::Deployment::DeploymentProgress>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Management::Deployment::DeploymentProgress>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Management::Deployment::DeploymentProgress return_value{};

    PyObject* py_state = PyDict_GetItemString(obj, "state");
    if (!py_state) { throw winrt::hresult_invalid_argument(); }
    return_value.state = converter<winrt::Windows::Management::Deployment::DeploymentProgressState>::convert_to(py_state);

    PyObject* py_percentage = PyDict_GetItemString(obj, "percentage");
    if (!py_percentage) { throw winrt::hresult_invalid_argument(); }
    return_value.percentage = converter<uint32_t>::convert_to(py_percentage);

    return return_value;
}

namespace py::cpp::Windows::Management::Deployment
{
    // ----- AddPackageOptions class --------------------
    constexpr const char* const _type_name_AddPackageOptions = "AddPackageOptions";

    static PyObject* _new_AddPackageOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::AddPackageOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AddPackageOptions(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AddPackageOptions_get_TargetVolume(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TargetVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_TargetVolume(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(arg);

            self->obj.TargetVolume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_StubPackageOption(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StubPackageOption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_StubPackageOption(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::StubPackageOption>(arg);

            self->obj.StubPackageOption(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_StageInPlace(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StageInPlace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_StageInPlace(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StageInPlace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_RetainFilesOnFailure(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RetainFilesOnFailure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_RetainFilesOnFailure(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RetainFilesOnFailure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_RequiredContentGroupOnly(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequiredContentGroupOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_RequiredContentGroupOnly(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequiredContentGroupOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_InstallAllResources(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstallAllResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_InstallAllResources(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.InstallAllResources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ForceTargetAppShutdown(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceTargetAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ForceTargetAppShutdown(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceTargetAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExternalLocationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ExternalLocationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_DeveloperMode(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeveloperMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_DeveloperMode(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeveloperMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeferRegistrationWhenPackagesAreInUse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeferRegistrationWhenPackagesAreInUse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_AllowUnsigned(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowUnsigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AddPackageOptions_put_AllowUnsigned(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowUnsigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AddPackageOptions_get_DependencyPackageUris(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_OptionalPackageFamilyNames(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_OptionalPackageUris(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AddPackageOptions_get_RelatedPackageUris(py::wrapper::Windows::Management::Deployment::AddPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelatedPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AddPackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::AddPackageOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AddPackageOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AddPackageOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AddPackageOptions[] = {
        { "target_volume", reinterpret_cast<getter>(AddPackageOptions_get_TargetVolume), reinterpret_cast<setter>(AddPackageOptions_put_TargetVolume), nullptr, nullptr },
        { "stub_package_option", reinterpret_cast<getter>(AddPackageOptions_get_StubPackageOption), reinterpret_cast<setter>(AddPackageOptions_put_StubPackageOption), nullptr, nullptr },
        { "stage_in_place", reinterpret_cast<getter>(AddPackageOptions_get_StageInPlace), reinterpret_cast<setter>(AddPackageOptions_put_StageInPlace), nullptr, nullptr },
        { "retain_files_on_failure", reinterpret_cast<getter>(AddPackageOptions_get_RetainFilesOnFailure), reinterpret_cast<setter>(AddPackageOptions_put_RetainFilesOnFailure), nullptr, nullptr },
        { "required_content_group_only", reinterpret_cast<getter>(AddPackageOptions_get_RequiredContentGroupOnly), reinterpret_cast<setter>(AddPackageOptions_put_RequiredContentGroupOnly), nullptr, nullptr },
        { "install_all_resources", reinterpret_cast<getter>(AddPackageOptions_get_InstallAllResources), reinterpret_cast<setter>(AddPackageOptions_put_InstallAllResources), nullptr, nullptr },
        { "force_update_from_any_version", reinterpret_cast<getter>(AddPackageOptions_get_ForceUpdateFromAnyVersion), reinterpret_cast<setter>(AddPackageOptions_put_ForceUpdateFromAnyVersion), nullptr, nullptr },
        { "force_target_app_shutdown", reinterpret_cast<getter>(AddPackageOptions_get_ForceTargetAppShutdown), reinterpret_cast<setter>(AddPackageOptions_put_ForceTargetAppShutdown), nullptr, nullptr },
        { "force_app_shutdown", reinterpret_cast<getter>(AddPackageOptions_get_ForceAppShutdown), reinterpret_cast<setter>(AddPackageOptions_put_ForceAppShutdown), nullptr, nullptr },
        { "external_location_uri", reinterpret_cast<getter>(AddPackageOptions_get_ExternalLocationUri), reinterpret_cast<setter>(AddPackageOptions_put_ExternalLocationUri), nullptr, nullptr },
        { "developer_mode", reinterpret_cast<getter>(AddPackageOptions_get_DeveloperMode), reinterpret_cast<setter>(AddPackageOptions_put_DeveloperMode), nullptr, nullptr },
        { "defer_registration_when_packages_are_in_use", reinterpret_cast<getter>(AddPackageOptions_get_DeferRegistrationWhenPackagesAreInUse), reinterpret_cast<setter>(AddPackageOptions_put_DeferRegistrationWhenPackagesAreInUse), nullptr, nullptr },
        { "allow_unsigned", reinterpret_cast<getter>(AddPackageOptions_get_AllowUnsigned), reinterpret_cast<setter>(AddPackageOptions_put_AllowUnsigned), nullptr, nullptr },
        { "dependency_package_uris", reinterpret_cast<getter>(AddPackageOptions_get_DependencyPackageUris), nullptr, nullptr, nullptr },
        { "optional_package_family_names", reinterpret_cast<getter>(AddPackageOptions_get_OptionalPackageFamilyNames), nullptr, nullptr, nullptr },
        { "optional_package_uris", reinterpret_cast<getter>(AddPackageOptions_get_OptionalPackageUris), nullptr, nullptr, nullptr },
        { "related_package_uris", reinterpret_cast<getter>(AddPackageOptions_get_RelatedPackageUris), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AddPackageOptions[] = 
    {
        { Py_tp_new, _new_AddPackageOptions },
        { Py_tp_dealloc, _dealloc_AddPackageOptions },
        { Py_tp_methods, _methods_AddPackageOptions },
        { Py_tp_getset, _getset_AddPackageOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AddPackageOptions =
    {
        "_winsdk_Windows_Management_Deployment.AddPackageOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::AddPackageOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AddPackageOptions
    };

    // ----- AppInstallerManager class --------------------
    constexpr const char* const _type_name_AppInstallerManager = "AppInstallerManager";

    static PyObject* _new_AppInstallerManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AppInstallerManager);
        return nullptr;
    }

    static void _dealloc_AppInstallerManager(py::wrapper::Windows::Management::Deployment::AppInstallerManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AppInstallerManager_ClearAutoUpdateSettings(py::wrapper::Windows::Management::Deployment::AppInstallerManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                self->obj.ClearAutoUpdateSettings(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstallerManager_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Management::Deployment::AppInstallerManager::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstallerManager_GetForSystem(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Management::Deployment::AppInstallerManager::GetForSystem());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstallerManager_PauseAutoUpdatesUntil(py::wrapper::Windows::Management::Deployment::AppInstallerManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                self->obj.PauseAutoUpdatesUntil(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AppInstallerManager_SetAutoUpdateSettings(py::wrapper::Windows::Management::Deployment::AppInstallerManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions>(args, 1);

                self->obj.SetAutoUpdateSettings(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_AppInstallerManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::AppInstallerManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppInstallerManager[] = {
        { "clear_auto_update_settings", reinterpret_cast<PyCFunction>(AppInstallerManager_ClearAutoUpdateSettings), METH_VARARGS, nullptr },
        { "get_default", reinterpret_cast<PyCFunction>(AppInstallerManager_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_system", reinterpret_cast<PyCFunction>(AppInstallerManager_GetForSystem), METH_VARARGS | METH_STATIC, nullptr },
        { "pause_auto_updates_until", reinterpret_cast<PyCFunction>(AppInstallerManager_PauseAutoUpdatesUntil), METH_VARARGS, nullptr },
        { "set_auto_update_settings", reinterpret_cast<PyCFunction>(AppInstallerManager_SetAutoUpdateSettings), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AppInstallerManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppInstallerManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AppInstallerManager[] = 
    {
        { Py_tp_new, _new_AppInstallerManager },
        { Py_tp_dealloc, _dealloc_AppInstallerManager },
        { Py_tp_methods, _methods_AppInstallerManager },
        { Py_tp_getset, _getset_AppInstallerManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AppInstallerManager =
    {
        "_winsdk_Windows_Management_Deployment.AppInstallerManager",
        sizeof(py::wrapper::Windows::Management::Deployment::AppInstallerManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppInstallerManager
    };

    // ----- AutoUpdateSettingsOptions class --------------------
    constexpr const char* const _type_name_AutoUpdateSettingsOptions = "AutoUpdateSettingsOptions";

    static PyObject* _new_AutoUpdateSettingsOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AutoUpdateSettingsOptions(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AutoUpdateSettingsOptions_CreateFromAppInstallerInfo(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::AppInstallerInfo>(args, 0);

                return py::convert(winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions::CreateFromAppInstallerInfo(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_Version(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Version());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_Version(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::PackageVersion>(arg);

            self->obj.Version(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_UpdateBlocksActivation(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateBlocksActivation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_UpdateBlocksActivation(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.UpdateBlocksActivation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_ShowPrompt(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShowPrompt());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_ShowPrompt(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ShowPrompt(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_OnLaunch(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OnLaunch());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_OnLaunch(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.OnLaunch(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_IsAutoRepairEnabled(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAutoRepairEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_IsAutoRepairEnabled(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAutoRepairEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_HoursBetweenUpdateChecks(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HoursBetweenUpdateChecks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_HoursBetweenUpdateChecks(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.HoursBetweenUpdateChecks(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_AutomaticBackgroundTask(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutomaticBackgroundTask());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_AutomaticBackgroundTask(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutomaticBackgroundTask(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_AppInstallerUri(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppInstallerUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int AutoUpdateSettingsOptions_put_AppInstallerUri(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.AppInstallerUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_DependencyPackageUris(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_OptionalPackageUris(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_RepairUris(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepairUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AutoUpdateSettingsOptions_get_UpdateUris(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AutoUpdateSettingsOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AutoUpdateSettingsOptions[] = {
        { "create_from_app_installer_info", reinterpret_cast<PyCFunction>(AutoUpdateSettingsOptions_CreateFromAppInstallerInfo), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AutoUpdateSettingsOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AutoUpdateSettingsOptions[] = {
        { "version", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_Version), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_Version), nullptr, nullptr },
        { "update_blocks_activation", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_UpdateBlocksActivation), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_UpdateBlocksActivation), nullptr, nullptr },
        { "show_prompt", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_ShowPrompt), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_ShowPrompt), nullptr, nullptr },
        { "on_launch", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_OnLaunch), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_OnLaunch), nullptr, nullptr },
        { "is_auto_repair_enabled", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_IsAutoRepairEnabled), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_IsAutoRepairEnabled), nullptr, nullptr },
        { "hours_between_update_checks", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_HoursBetweenUpdateChecks), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_HoursBetweenUpdateChecks), nullptr, nullptr },
        { "force_update_from_any_version", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_ForceUpdateFromAnyVersion), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_ForceUpdateFromAnyVersion), nullptr, nullptr },
        { "automatic_background_task", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_AutomaticBackgroundTask), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_AutomaticBackgroundTask), nullptr, nullptr },
        { "app_installer_uri", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_AppInstallerUri), reinterpret_cast<setter>(AutoUpdateSettingsOptions_put_AppInstallerUri), nullptr, nullptr },
        { "dependency_package_uris", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_DependencyPackageUris), nullptr, nullptr, nullptr },
        { "optional_package_uris", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_OptionalPackageUris), nullptr, nullptr, nullptr },
        { "repair_uris", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_RepairUris), nullptr, nullptr, nullptr },
        { "update_uris", reinterpret_cast<getter>(AutoUpdateSettingsOptions_get_UpdateUris), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AutoUpdateSettingsOptions[] = 
    {
        { Py_tp_new, _new_AutoUpdateSettingsOptions },
        { Py_tp_dealloc, _dealloc_AutoUpdateSettingsOptions },
        { Py_tp_methods, _methods_AutoUpdateSettingsOptions },
        { Py_tp_getset, _getset_AutoUpdateSettingsOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AutoUpdateSettingsOptions =
    {
        "_winsdk_Windows_Management_Deployment.AutoUpdateSettingsOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::AutoUpdateSettingsOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AutoUpdateSettingsOptions
    };

    // ----- DeploymentResult class --------------------
    constexpr const char* const _type_name_DeploymentResult = "DeploymentResult";

    static PyObject* _new_DeploymentResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DeploymentResult);
        return nullptr;
    }

    static void _dealloc_DeploymentResult(py::wrapper::Windows::Management::Deployment::DeploymentResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DeploymentResult_get_ActivityId(py::wrapper::Windows::Management::Deployment::DeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeploymentResult_get_ErrorText(py::wrapper::Windows::Management::Deployment::DeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ErrorText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeploymentResult_get_ExtendedErrorCode(py::wrapper::Windows::Management::Deployment::DeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedErrorCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeploymentResult_get_IsRegistered(py::wrapper::Windows::Management::Deployment::DeploymentResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRegistered());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeploymentResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::DeploymentResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeploymentResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DeploymentResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeploymentResult[] = {
        { "activity_id", reinterpret_cast<getter>(DeploymentResult_get_ActivityId), nullptr, nullptr, nullptr },
        { "error_text", reinterpret_cast<getter>(DeploymentResult_get_ErrorText), nullptr, nullptr, nullptr },
        { "extended_error_code", reinterpret_cast<getter>(DeploymentResult_get_ExtendedErrorCode), nullptr, nullptr, nullptr },
        { "is_registered", reinterpret_cast<getter>(DeploymentResult_get_IsRegistered), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeploymentResult[] = 
    {
        { Py_tp_new, _new_DeploymentResult },
        { Py_tp_dealloc, _dealloc_DeploymentResult },
        { Py_tp_methods, _methods_DeploymentResult },
        { Py_tp_getset, _getset_DeploymentResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeploymentResult =
    {
        "_winsdk_Windows_Management_Deployment.DeploymentResult",
        sizeof(py::wrapper::Windows::Management::Deployment::DeploymentResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeploymentResult
    };

    // ----- PackageAllUserProvisioningOptions class --------------------
    constexpr const char* const _type_name_PackageAllUserProvisioningOptions = "PackageAllUserProvisioningOptions";

    static PyObject* _new_PackageAllUserProvisioningOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::PackageAllUserProvisioningOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PackageAllUserProvisioningOptions(py::wrapper::Windows::Management::Deployment::PackageAllUserProvisioningOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageAllUserProvisioningOptions_get_OptionalPackageFamilyNames(py::wrapper::Windows::Management::Deployment::PackageAllUserProvisioningOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageAllUserProvisioningOptions_get_ProjectionOrderPackageFamilyNames(py::wrapper::Windows::Management::Deployment::PackageAllUserProvisioningOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProjectionOrderPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageAllUserProvisioningOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageAllUserProvisioningOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageAllUserProvisioningOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageAllUserProvisioningOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageAllUserProvisioningOptions[] = {
        { "optional_package_family_names", reinterpret_cast<getter>(PackageAllUserProvisioningOptions_get_OptionalPackageFamilyNames), nullptr, nullptr, nullptr },
        { "projection_order_package_family_names", reinterpret_cast<getter>(PackageAllUserProvisioningOptions_get_ProjectionOrderPackageFamilyNames), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageAllUserProvisioningOptions[] = 
    {
        { Py_tp_new, _new_PackageAllUserProvisioningOptions },
        { Py_tp_dealloc, _dealloc_PackageAllUserProvisioningOptions },
        { Py_tp_methods, _methods_PackageAllUserProvisioningOptions },
        { Py_tp_getset, _getset_PackageAllUserProvisioningOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageAllUserProvisioningOptions =
    {
        "_winsdk_Windows_Management_Deployment.PackageAllUserProvisioningOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageAllUserProvisioningOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageAllUserProvisioningOptions
    };

    // ----- PackageManager class --------------------
    constexpr const char* const _type_name_PackageManager = "PackageManager";

    static PyObject* _new_PackageManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::PackageManager instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_PackageManager(py::wrapper::Windows::Management::Deployment::PackageManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageManager_AddPackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.AddPackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);

                return py::convert(self->obj.AddPackageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);

                return py::convert(self->obj.AddPackageAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 6);

                return py::convert(self->obj.AddPackageAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_AddPackageByAppInstallerFileAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::AddPackageByAppInstallerOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 2);

                return py::convert(self->obj.AddPackageByAppInstallerFileAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_AddPackageByUriAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::AddPackageOptions>(args, 1);

                return py::convert(self->obj.AddPackageByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_AddPackageVolumeAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.AddPackageVolumeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_CleanupPackageForUserAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.CleanupPackageForUserAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_ClearPackageStatus(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageStatus>(args, 1);

                self->obj.ClearPackageStatus(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_DeprovisionPackageForAllUsersAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeprovisionPackageForAllUsersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackage(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackageForUser(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackageForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackageVolume(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackageVolume(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackageVolumes(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindPackageVolumes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackages(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindPackages());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackages(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackages(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackagesForUser(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackagesForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackagesForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindPackagesForUser(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackagesForUserWithPackageTypes(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 2);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 3);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindPackagesWithPackageTypes(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 0);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 2);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindProvisionedPackages(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindProvisionedPackages());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_FindUsers(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindUsers(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_GetDefaultPackageVolume(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDefaultPackageVolume());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_GetPackageStubPreference(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetPackageStubPreference(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_GetPackageVolumesAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetPackageVolumesAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_MovePackageToVolumeAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 2);

                return py::convert(self->obj.MovePackageToVolumeAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_ProvisionPackageForAllUsersAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ProvisionPackageForAllUsersAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageAllUserProvisioningOptions>(args, 1);

                return py::convert(self->obj.ProvisionPackageForAllUsersAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.RegisterPackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);

                return py::convert(self->obj.RegisterPackageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackageByFamilyNameAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 5)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);

                return py::convert(self->obj.RegisterPackageByFamilyNameAsync(param0, param1, param2, param3, param4));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackageByFullNameAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.RegisterPackageByFullNameAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackageByUriAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::RegisterPackageOptions>(args, 1);

                return py::convert(self->obj.RegisterPackageByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RegisterPackagesByFullNameAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::RegisterPackageOptions>(args, 1);

                return py::convert(self->obj.RegisterPackagesByFullNameAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RemovePackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RemovePackageAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::RemovalOptions>(args, 1);

                return py::convert(self->obj.RemovePackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RemovePackageVolumeAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 0);

                return py::convert(self->obj.RemovePackageVolumeAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RequestAddPackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);

                return py::convert(self->obj.RequestAddPackageAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 6);

                return py::convert(self->obj.RequestAddPackageAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_RequestAddPackageByAppInstallerFileAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::AddPackageByAppInstallerOptions>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 2);

                return py::convert(self->obj.RequestAddPackageByAppInstallerFileAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetDefaultPackageVolume(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 0);

                self->obj.SetDefaultPackageVolume(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageState(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageState>(args, 1);

                self->obj.SetPackageState(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageStatus(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageStatus>(args, 1);

                self->obj.SetPackageStatus(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageStubPreference(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageStubPreference>(args, 1);

                self->obj.SetPackageStubPreference(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageVolumeOfflineAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 0);

                return py::convert(self->obj.SetPackageVolumeOfflineAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_SetPackageVolumeOnlineAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 0);

                return py::convert(self->obj.SetPackageVolumeOnlineAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_StagePackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);

                return py::convert(self->obj.StagePackageAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.StagePackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);

                return py::convert(self->obj.StagePackageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 6)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);

                return py::convert(self->obj.StagePackageAsync(param0, param1, param2, param3, param4, param5));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 7)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(args, 3);
                auto param4 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::hstring>>(args, 4);
                auto param5 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 5);
                auto param6 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 6);

                return py::convert(self->obj.StagePackageAsync(param0, param1, param2, param3, param4, param5, param6));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_StagePackageByUriAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::StagePackageOptions>(args, 1);

                return py::convert(self->obj.StagePackageByUriAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_StageUserDataAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.StageUserDataAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 1);

                return py::convert(self->obj.StageUserDataAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_UpdatePackageAsync(py::wrapper::Windows::Management::Deployment::PackageManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Foundation::Uri>>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Management::Deployment::DeploymentOptions>(args, 2);

                return py::convert(self->obj.UpdatePackageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageManager_get_DebugSettings(py::wrapper::Windows::Management::Deployment::PackageManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DebugSettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageManager[] = {
        { "add_package_async", reinterpret_cast<PyCFunction>(PackageManager_AddPackageAsync), METH_VARARGS, nullptr },
        { "add_package_by_app_installer_file_async", reinterpret_cast<PyCFunction>(PackageManager_AddPackageByAppInstallerFileAsync), METH_VARARGS, nullptr },
        { "add_package_by_uri_async", reinterpret_cast<PyCFunction>(PackageManager_AddPackageByUriAsync), METH_VARARGS, nullptr },
        { "add_package_volume_async", reinterpret_cast<PyCFunction>(PackageManager_AddPackageVolumeAsync), METH_VARARGS, nullptr },
        { "cleanup_package_for_user_async", reinterpret_cast<PyCFunction>(PackageManager_CleanupPackageForUserAsync), METH_VARARGS, nullptr },
        { "clear_package_status", reinterpret_cast<PyCFunction>(PackageManager_ClearPackageStatus), METH_VARARGS, nullptr },
        { "deprovision_package_for_all_users_async", reinterpret_cast<PyCFunction>(PackageManager_DeprovisionPackageForAllUsersAsync), METH_VARARGS, nullptr },
        { "find_package", reinterpret_cast<PyCFunction>(PackageManager_FindPackage), METH_VARARGS, nullptr },
        { "find_package_for_user", reinterpret_cast<PyCFunction>(PackageManager_FindPackageForUser), METH_VARARGS, nullptr },
        { "find_package_volume", reinterpret_cast<PyCFunction>(PackageManager_FindPackageVolume), METH_VARARGS, nullptr },
        { "find_package_volumes", reinterpret_cast<PyCFunction>(PackageManager_FindPackageVolumes), METH_VARARGS, nullptr },
        { "find_packages", reinterpret_cast<PyCFunction>(PackageManager_FindPackages), METH_VARARGS, nullptr },
        { "find_packages_for_user", reinterpret_cast<PyCFunction>(PackageManager_FindPackagesForUser), METH_VARARGS, nullptr },
        { "find_packages_for_user_with_package_types", reinterpret_cast<PyCFunction>(PackageManager_FindPackagesForUserWithPackageTypes), METH_VARARGS, nullptr },
        { "find_packages_with_package_types", reinterpret_cast<PyCFunction>(PackageManager_FindPackagesWithPackageTypes), METH_VARARGS, nullptr },
        { "find_provisioned_packages", reinterpret_cast<PyCFunction>(PackageManager_FindProvisionedPackages), METH_VARARGS, nullptr },
        { "find_users", reinterpret_cast<PyCFunction>(PackageManager_FindUsers), METH_VARARGS, nullptr },
        { "get_default_package_volume", reinterpret_cast<PyCFunction>(PackageManager_GetDefaultPackageVolume), METH_VARARGS, nullptr },
        { "get_package_stub_preference", reinterpret_cast<PyCFunction>(PackageManager_GetPackageStubPreference), METH_VARARGS, nullptr },
        { "get_package_volumes_async", reinterpret_cast<PyCFunction>(PackageManager_GetPackageVolumesAsync), METH_VARARGS, nullptr },
        { "move_package_to_volume_async", reinterpret_cast<PyCFunction>(PackageManager_MovePackageToVolumeAsync), METH_VARARGS, nullptr },
        { "provision_package_for_all_users_async", reinterpret_cast<PyCFunction>(PackageManager_ProvisionPackageForAllUsersAsync), METH_VARARGS, nullptr },
        { "register_package_async", reinterpret_cast<PyCFunction>(PackageManager_RegisterPackageAsync), METH_VARARGS, nullptr },
        { "register_package_by_family_name_async", reinterpret_cast<PyCFunction>(PackageManager_RegisterPackageByFamilyNameAsync), METH_VARARGS, nullptr },
        { "register_package_by_full_name_async", reinterpret_cast<PyCFunction>(PackageManager_RegisterPackageByFullNameAsync), METH_VARARGS, nullptr },
        { "register_package_by_uri_async", reinterpret_cast<PyCFunction>(PackageManager_RegisterPackageByUriAsync), METH_VARARGS, nullptr },
        { "register_packages_by_full_name_async", reinterpret_cast<PyCFunction>(PackageManager_RegisterPackagesByFullNameAsync), METH_VARARGS, nullptr },
        { "remove_package_async", reinterpret_cast<PyCFunction>(PackageManager_RemovePackageAsync), METH_VARARGS, nullptr },
        { "remove_package_volume_async", reinterpret_cast<PyCFunction>(PackageManager_RemovePackageVolumeAsync), METH_VARARGS, nullptr },
        { "request_add_package_async", reinterpret_cast<PyCFunction>(PackageManager_RequestAddPackageAsync), METH_VARARGS, nullptr },
        { "request_add_package_by_app_installer_file_async", reinterpret_cast<PyCFunction>(PackageManager_RequestAddPackageByAppInstallerFileAsync), METH_VARARGS, nullptr },
        { "set_default_package_volume", reinterpret_cast<PyCFunction>(PackageManager_SetDefaultPackageVolume), METH_VARARGS, nullptr },
        { "set_package_state", reinterpret_cast<PyCFunction>(PackageManager_SetPackageState), METH_VARARGS, nullptr },
        { "set_package_status", reinterpret_cast<PyCFunction>(PackageManager_SetPackageStatus), METH_VARARGS, nullptr },
        { "set_package_stub_preference", reinterpret_cast<PyCFunction>(PackageManager_SetPackageStubPreference), METH_VARARGS, nullptr },
        { "set_package_volume_offline_async", reinterpret_cast<PyCFunction>(PackageManager_SetPackageVolumeOfflineAsync), METH_VARARGS, nullptr },
        { "set_package_volume_online_async", reinterpret_cast<PyCFunction>(PackageManager_SetPackageVolumeOnlineAsync), METH_VARARGS, nullptr },
        { "stage_package_async", reinterpret_cast<PyCFunction>(PackageManager_StagePackageAsync), METH_VARARGS, nullptr },
        { "stage_package_by_uri_async", reinterpret_cast<PyCFunction>(PackageManager_StagePackageByUriAsync), METH_VARARGS, nullptr },
        { "stage_user_data_async", reinterpret_cast<PyCFunction>(PackageManager_StageUserDataAsync), METH_VARARGS, nullptr },
        { "update_package_async", reinterpret_cast<PyCFunction>(PackageManager_UpdatePackageAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageManager[] = {
        { "debug_settings", reinterpret_cast<getter>(PackageManager_get_DebugSettings), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageManager[] = 
    {
        { Py_tp_new, _new_PackageManager },
        { Py_tp_dealloc, _dealloc_PackageManager },
        { Py_tp_methods, _methods_PackageManager },
        { Py_tp_getset, _getset_PackageManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageManager =
    {
        "_winsdk_Windows_Management_Deployment.PackageManager",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageManager
    };

    // ----- PackageManagerDebugSettings class --------------------
    constexpr const char* const _type_name_PackageManagerDebugSettings = "PackageManagerDebugSettings";

    static PyObject* _new_PackageManagerDebugSettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageManagerDebugSettings);
        return nullptr;
    }

    static void _dealloc_PackageManagerDebugSettings(py::wrapper::Windows::Management::Deployment::PackageManagerDebugSettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageManagerDebugSettings_SetContentGroupStateAsync(py::wrapper::Windows::Management::Deployment::PackageManagerDebugSettings* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::PackageContentGroupState>(args, 2);

                return py::convert(self->obj.SetContentGroupStateAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Package>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::ApplicationModel::PackageContentGroupState>(args, 2);
                auto param3 = py::convert_to<double>(args, 3);

                return py::convert(self->obj.SetContentGroupStateAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_PackageManagerDebugSettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageManagerDebugSettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageManagerDebugSettings[] = {
        { "set_content_group_state_async", reinterpret_cast<PyCFunction>(PackageManagerDebugSettings_SetContentGroupStateAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageManagerDebugSettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageManagerDebugSettings[] = {
        { }
    };

    static PyType_Slot _type_slots_PackageManagerDebugSettings[] = 
    {
        { Py_tp_new, _new_PackageManagerDebugSettings },
        { Py_tp_dealloc, _dealloc_PackageManagerDebugSettings },
        { Py_tp_methods, _methods_PackageManagerDebugSettings },
        { Py_tp_getset, _getset_PackageManagerDebugSettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageManagerDebugSettings =
    {
        "_winsdk_Windows_Management_Deployment.PackageManagerDebugSettings",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageManagerDebugSettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageManagerDebugSettings
    };

    // ----- PackageUserInformation class --------------------
    constexpr const char* const _type_name_PackageUserInformation = "PackageUserInformation";

    static PyObject* _new_PackageUserInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageUserInformation);
        return nullptr;
    }

    static void _dealloc_PackageUserInformation(py::wrapper::Windows::Management::Deployment::PackageUserInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageUserInformation_get_InstallState(py::wrapper::Windows::Management::Deployment::PackageUserInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstallState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageUserInformation_get_UserSecurityId(py::wrapper::Windows::Management::Deployment::PackageUserInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserSecurityId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageUserInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageUserInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageUserInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageUserInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageUserInformation[] = {
        { "install_state", reinterpret_cast<getter>(PackageUserInformation_get_InstallState), nullptr, nullptr, nullptr },
        { "user_security_id", reinterpret_cast<getter>(PackageUserInformation_get_UserSecurityId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageUserInformation[] = 
    {
        { Py_tp_new, _new_PackageUserInformation },
        { Py_tp_dealloc, _dealloc_PackageUserInformation },
        { Py_tp_methods, _methods_PackageUserInformation },
        { Py_tp_getset, _getset_PackageUserInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageUserInformation =
    {
        "_winsdk_Windows_Management_Deployment.PackageUserInformation",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageUserInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageUserInformation
    };

    // ----- PackageVolume class --------------------
    constexpr const char* const _type_name_PackageVolume = "PackageVolume";

    static PyObject* _new_PackageVolume(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_PackageVolume);
        return nullptr;
    }

    static void _dealloc_PackageVolume(py::wrapper::Windows::Management::Deployment::PackageVolume* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* PackageVolume_FindPackage(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackage(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackageForUser(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackageForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackages(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.FindPackages());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackages(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackages(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackagesForUser(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.FindPackagesForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackagesForUser(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindPackagesForUser(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackagesForUserWithPackageTypes(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);
                auto param3 = py::convert_to<winrt::hstring>(args, 3);

                return py::convert(self->obj.FindPackagesForUserWithPackageTypes(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_FindPackagesWithPackageTypes(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 0);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageTypes>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);
                auto param2 = py::convert_to<winrt::hstring>(args, 2);

                return py::convert(self->obj.FindPackagesWithPackageTypes(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_GetAvailableSpaceAsync(py::wrapper::Windows::Management::Deployment::PackageVolume* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAvailableSpaceAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsOffline(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOffline());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsSystemVolume(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsSystemVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_MountPoint(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MountPoint());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_Name(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_PackageStorePath(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PackageStorePath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_SupportsHardLinks(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportsHardLinks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsAppxInstallSupported(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAppxInstallSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PackageVolume_get_IsFullTrustPackageSupported(py::wrapper::Windows::Management::Deployment::PackageVolume* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsFullTrustPackageSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PackageVolume(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::PackageVolume>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PackageVolume[] = {
        { "find_package", reinterpret_cast<PyCFunction>(PackageVolume_FindPackage), METH_VARARGS, nullptr },
        { "find_package_for_user", reinterpret_cast<PyCFunction>(PackageVolume_FindPackageForUser), METH_VARARGS, nullptr },
        { "find_packages", reinterpret_cast<PyCFunction>(PackageVolume_FindPackages), METH_VARARGS, nullptr },
        { "find_packages_for_user", reinterpret_cast<PyCFunction>(PackageVolume_FindPackagesForUser), METH_VARARGS, nullptr },
        { "find_packages_for_user_with_package_types", reinterpret_cast<PyCFunction>(PackageVolume_FindPackagesForUserWithPackageTypes), METH_VARARGS, nullptr },
        { "find_packages_with_package_types", reinterpret_cast<PyCFunction>(PackageVolume_FindPackagesWithPackageTypes), METH_VARARGS, nullptr },
        { "get_available_space_async", reinterpret_cast<PyCFunction>(PackageVolume_GetAvailableSpaceAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_PackageVolume), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PackageVolume[] = {
        { "is_offline", reinterpret_cast<getter>(PackageVolume_get_IsOffline), nullptr, nullptr, nullptr },
        { "is_system_volume", reinterpret_cast<getter>(PackageVolume_get_IsSystemVolume), nullptr, nullptr, nullptr },
        { "mount_point", reinterpret_cast<getter>(PackageVolume_get_MountPoint), nullptr, nullptr, nullptr },
        { "name", reinterpret_cast<getter>(PackageVolume_get_Name), nullptr, nullptr, nullptr },
        { "package_store_path", reinterpret_cast<getter>(PackageVolume_get_PackageStorePath), nullptr, nullptr, nullptr },
        { "supports_hard_links", reinterpret_cast<getter>(PackageVolume_get_SupportsHardLinks), nullptr, nullptr, nullptr },
        { "is_appx_install_supported", reinterpret_cast<getter>(PackageVolume_get_IsAppxInstallSupported), nullptr, nullptr, nullptr },
        { "is_full_trust_package_supported", reinterpret_cast<getter>(PackageVolume_get_IsFullTrustPackageSupported), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PackageVolume[] = 
    {
        { Py_tp_new, _new_PackageVolume },
        { Py_tp_dealloc, _dealloc_PackageVolume },
        { Py_tp_methods, _methods_PackageVolume },
        { Py_tp_getset, _getset_PackageVolume },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_PackageVolume =
    {
        "_winsdk_Windows_Management_Deployment.PackageVolume",
        sizeof(py::wrapper::Windows::Management::Deployment::PackageVolume),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PackageVolume
    };

    // ----- RegisterPackageOptions class --------------------
    constexpr const char* const _type_name_RegisterPackageOptions = "RegisterPackageOptions";

    static PyObject* _new_RegisterPackageOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::RegisterPackageOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RegisterPackageOptions(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RegisterPackageOptions_get_StageInPlace(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StageInPlace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_StageInPlace(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StageInPlace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_InstallAllResources(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstallAllResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_InstallAllResources(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.InstallAllResources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ForceTargetAppShutdown(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceTargetAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ForceTargetAppShutdown(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceTargetAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceAppShutdown());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ForceAppShutdown(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceAppShutdown(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExternalLocationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ExternalLocationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_DeveloperMode(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeveloperMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_DeveloperMode(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeveloperMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeferRegistrationWhenPackagesAreInUse());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_DeferRegistrationWhenPackagesAreInUse(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeferRegistrationWhenPackagesAreInUse(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_AppDataVolume(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppDataVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_AppDataVolume(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(arg);

            self->obj.AppDataVolume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_AllowUnsigned(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowUnsigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int RegisterPackageOptions_put_AllowUnsigned(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowUnsigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* RegisterPackageOptions_get_DependencyPackageUris(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RegisterPackageOptions_get_OptionalPackageFamilyNames(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RegisterPackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::RegisterPackageOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RegisterPackageOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_RegisterPackageOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RegisterPackageOptions[] = {
        { "stage_in_place", reinterpret_cast<getter>(RegisterPackageOptions_get_StageInPlace), reinterpret_cast<setter>(RegisterPackageOptions_put_StageInPlace), nullptr, nullptr },
        { "install_all_resources", reinterpret_cast<getter>(RegisterPackageOptions_get_InstallAllResources), reinterpret_cast<setter>(RegisterPackageOptions_put_InstallAllResources), nullptr, nullptr },
        { "force_update_from_any_version", reinterpret_cast<getter>(RegisterPackageOptions_get_ForceUpdateFromAnyVersion), reinterpret_cast<setter>(RegisterPackageOptions_put_ForceUpdateFromAnyVersion), nullptr, nullptr },
        { "force_target_app_shutdown", reinterpret_cast<getter>(RegisterPackageOptions_get_ForceTargetAppShutdown), reinterpret_cast<setter>(RegisterPackageOptions_put_ForceTargetAppShutdown), nullptr, nullptr },
        { "force_app_shutdown", reinterpret_cast<getter>(RegisterPackageOptions_get_ForceAppShutdown), reinterpret_cast<setter>(RegisterPackageOptions_put_ForceAppShutdown), nullptr, nullptr },
        { "external_location_uri", reinterpret_cast<getter>(RegisterPackageOptions_get_ExternalLocationUri), reinterpret_cast<setter>(RegisterPackageOptions_put_ExternalLocationUri), nullptr, nullptr },
        { "developer_mode", reinterpret_cast<getter>(RegisterPackageOptions_get_DeveloperMode), reinterpret_cast<setter>(RegisterPackageOptions_put_DeveloperMode), nullptr, nullptr },
        { "defer_registration_when_packages_are_in_use", reinterpret_cast<getter>(RegisterPackageOptions_get_DeferRegistrationWhenPackagesAreInUse), reinterpret_cast<setter>(RegisterPackageOptions_put_DeferRegistrationWhenPackagesAreInUse), nullptr, nullptr },
        { "app_data_volume", reinterpret_cast<getter>(RegisterPackageOptions_get_AppDataVolume), reinterpret_cast<setter>(RegisterPackageOptions_put_AppDataVolume), nullptr, nullptr },
        { "allow_unsigned", reinterpret_cast<getter>(RegisterPackageOptions_get_AllowUnsigned), reinterpret_cast<setter>(RegisterPackageOptions_put_AllowUnsigned), nullptr, nullptr },
        { "dependency_package_uris", reinterpret_cast<getter>(RegisterPackageOptions_get_DependencyPackageUris), nullptr, nullptr, nullptr },
        { "optional_package_family_names", reinterpret_cast<getter>(RegisterPackageOptions_get_OptionalPackageFamilyNames), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RegisterPackageOptions[] = 
    {
        { Py_tp_new, _new_RegisterPackageOptions },
        { Py_tp_dealloc, _dealloc_RegisterPackageOptions },
        { Py_tp_methods, _methods_RegisterPackageOptions },
        { Py_tp_getset, _getset_RegisterPackageOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RegisterPackageOptions =
    {
        "_winsdk_Windows_Management_Deployment.RegisterPackageOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::RegisterPackageOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RegisterPackageOptions
    };

    // ----- StagePackageOptions class --------------------
    constexpr const char* const _type_name_StagePackageOptions = "StagePackageOptions";

    static PyObject* _new_StagePackageOptions(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Management::Deployment::StagePackageOptions instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_StagePackageOptions(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* StagePackageOptions_get_TargetVolume(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TargetVolume());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_TargetVolume(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::PackageVolume>(arg);

            self->obj.TargetVolume(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_StubPackageOption(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StubPackageOption());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_StubPackageOption(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Management::Deployment::StubPackageOption>(arg);

            self->obj.StubPackageOption(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_StageInPlace(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StageInPlace());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_StageInPlace(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.StageInPlace(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_RequiredContentGroupOnly(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RequiredContentGroupOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_RequiredContentGroupOnly(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.RequiredContentGroupOnly(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_InstallAllResources(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstallAllResources());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_InstallAllResources(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.InstallAllResources(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ForceUpdateFromAnyVersion());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_ForceUpdateFromAnyVersion(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.ForceUpdateFromAnyVersion(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExternalLocationUri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_ExternalLocationUri(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(arg);

            self->obj.ExternalLocationUri(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_DeveloperMode(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeveloperMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_DeveloperMode(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.DeveloperMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_AllowUnsigned(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AllowUnsigned());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int StagePackageOptions_put_AllowUnsigned(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AllowUnsigned(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* StagePackageOptions_get_DependencyPackageUris(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DependencyPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_OptionalPackageFamilyNames(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageFamilyNames());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_OptionalPackageUris(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OptionalPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StagePackageOptions_get_RelatedPackageUris(py::wrapper::Windows::Management::Deployment::StagePackageOptions* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelatedPackageUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StagePackageOptions(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Management::Deployment::StagePackageOptions>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StagePackageOptions[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StagePackageOptions), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StagePackageOptions[] = {
        { "target_volume", reinterpret_cast<getter>(StagePackageOptions_get_TargetVolume), reinterpret_cast<setter>(StagePackageOptions_put_TargetVolume), nullptr, nullptr },
        { "stub_package_option", reinterpret_cast<getter>(StagePackageOptions_get_StubPackageOption), reinterpret_cast<setter>(StagePackageOptions_put_StubPackageOption), nullptr, nullptr },
        { "stage_in_place", reinterpret_cast<getter>(StagePackageOptions_get_StageInPlace), reinterpret_cast<setter>(StagePackageOptions_put_StageInPlace), nullptr, nullptr },
        { "required_content_group_only", reinterpret_cast<getter>(StagePackageOptions_get_RequiredContentGroupOnly), reinterpret_cast<setter>(StagePackageOptions_put_RequiredContentGroupOnly), nullptr, nullptr },
        { "install_all_resources", reinterpret_cast<getter>(StagePackageOptions_get_InstallAllResources), reinterpret_cast<setter>(StagePackageOptions_put_InstallAllResources), nullptr, nullptr },
        { "force_update_from_any_version", reinterpret_cast<getter>(StagePackageOptions_get_ForceUpdateFromAnyVersion), reinterpret_cast<setter>(StagePackageOptions_put_ForceUpdateFromAnyVersion), nullptr, nullptr },
        { "external_location_uri", reinterpret_cast<getter>(StagePackageOptions_get_ExternalLocationUri), reinterpret_cast<setter>(StagePackageOptions_put_ExternalLocationUri), nullptr, nullptr },
        { "developer_mode", reinterpret_cast<getter>(StagePackageOptions_get_DeveloperMode), reinterpret_cast<setter>(StagePackageOptions_put_DeveloperMode), nullptr, nullptr },
        { "allow_unsigned", reinterpret_cast<getter>(StagePackageOptions_get_AllowUnsigned), reinterpret_cast<setter>(StagePackageOptions_put_AllowUnsigned), nullptr, nullptr },
        { "dependency_package_uris", reinterpret_cast<getter>(StagePackageOptions_get_DependencyPackageUris), nullptr, nullptr, nullptr },
        { "optional_package_family_names", reinterpret_cast<getter>(StagePackageOptions_get_OptionalPackageFamilyNames), nullptr, nullptr, nullptr },
        { "optional_package_uris", reinterpret_cast<getter>(StagePackageOptions_get_OptionalPackageUris), nullptr, nullptr, nullptr },
        { "related_package_uris", reinterpret_cast<getter>(StagePackageOptions_get_RelatedPackageUris), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StagePackageOptions[] = 
    {
        { Py_tp_new, _new_StagePackageOptions },
        { Py_tp_dealloc, _dealloc_StagePackageOptions },
        { Py_tp_methods, _methods_StagePackageOptions },
        { Py_tp_getset, _getset_StagePackageOptions },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_StagePackageOptions =
    {
        "_winsdk_Windows_Management_Deployment.StagePackageOptions",
        sizeof(py::wrapper::Windows::Management::Deployment::StagePackageOptions),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StagePackageOptions
    };

    // ----- DeploymentProgress struct --------------------
    constexpr const char* const _type_name_DeploymentProgress = "DeploymentProgress";

    PyObject* _new_DeploymentProgress(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Management::Deployment::DeploymentProgress return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Management::Deployment::DeploymentProgress>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _state{};
        uint32_t _percentage{};

        static const char* kwlist[] = {"state", "percentage", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iI", const_cast<char**>(kwlist), &_state, &_percentage))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Management::Deployment::DeploymentProgress return_value{ static_cast<winrt::Windows::Management::Deployment::DeploymentProgressState>(_state), _percentage };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_DeploymentProgress(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self)
    {
    }

    static PyObject* DeploymentProgress_get_state(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.state);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentProgress_set_state(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.state = py::converter<winrt::Windows::Management::Deployment::DeploymentProgressState>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* DeploymentProgress_get_percentage(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.percentage);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int DeploymentProgress_set_percentage(py::wrapper::Windows::Management::Deployment::DeploymentProgress* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.percentage = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_DeploymentProgress[] = {
        { "state", reinterpret_cast<getter>(DeploymentProgress_get_state), reinterpret_cast<setter>(DeploymentProgress_set_state), nullptr, nullptr },
        { "percentage", reinterpret_cast<getter>(DeploymentProgress_get_percentage), reinterpret_cast<setter>(DeploymentProgress_set_percentage), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeploymentProgress[] = 
    {
        { Py_tp_new, _new_DeploymentProgress },
        { Py_tp_dealloc, _dealloc_DeploymentProgress },
        { Py_tp_getset, _getset_DeploymentProgress },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DeploymentProgress =
    {
        "_winsdk_Windows_Management_Deployment.DeploymentProgress",
        sizeof(py::wrapper::Windows::Management::Deployment::DeploymentProgress),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeploymentProgress
    };

    // ----- Windows.Management.Deployment Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Management::Deployment::AddPackageOptions>::python_type = py::register_python_type(module, _type_name_AddPackageOptions, &_type_spec_AddPackageOptions, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::AppInstallerManager>::python_type = py::register_python_type(module, _type_name_AppInstallerManager, &_type_spec_AppInstallerManager, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::AutoUpdateSettingsOptions>::python_type = py::register_python_type(module, _type_name_AutoUpdateSettingsOptions, &_type_spec_AutoUpdateSettingsOptions, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::DeploymentResult>::python_type = py::register_python_type(module, _type_name_DeploymentResult, &_type_spec_DeploymentResult, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::PackageAllUserProvisioningOptions>::python_type = py::register_python_type(module, _type_name_PackageAllUserProvisioningOptions, &_type_spec_PackageAllUserProvisioningOptions, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::PackageManager>::python_type = py::register_python_type(module, _type_name_PackageManager, &_type_spec_PackageManager, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::PackageManagerDebugSettings>::python_type = py::register_python_type(module, _type_name_PackageManagerDebugSettings, &_type_spec_PackageManagerDebugSettings, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::PackageUserInformation>::python_type = py::register_python_type(module, _type_name_PackageUserInformation, &_type_spec_PackageUserInformation, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::PackageVolume>::python_type = py::register_python_type(module, _type_name_PackageVolume, &_type_spec_PackageVolume, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::RegisterPackageOptions>::python_type = py::register_python_type(module, _type_name_RegisterPackageOptions, &_type_spec_RegisterPackageOptions, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::StagePackageOptions>::python_type = py::register_python_type(module, _type_name_StagePackageOptions, &_type_spec_StagePackageOptions, bases.get());
            py::winrt_type<winrt::Windows::Management::Deployment::DeploymentProgress>::python_type = py::register_python_type(module, _type_name_DeploymentProgress, &_type_spec_DeploymentProgress, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Management.Deployment");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Management_Deployment",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Management::Deployment

PyMODINIT_FUNC
PyInit__winsdk_Windows_Management_Deployment (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Management::Deployment::module_def);
}
