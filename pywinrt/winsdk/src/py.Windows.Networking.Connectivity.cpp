// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Networking.Connectivity.h"

PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::AttributedNetworkUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::CellularApnContext>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionCost>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionProfile>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionProfileFilter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionSession>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectivityInterval>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectivityManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::DataPlanStatus>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::DataPlanUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::DataUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::IPInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::LanIdentifier>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::LanIdentifierData>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkAdapter>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkInformation>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkItem>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkSecuritySettings>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkStateChangeEventDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ProviderNetworkUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::ProxyConfiguration>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::RoutePolicy>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::WlanConnectionProfileDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::WwanConnectionProfileDetails>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkUsageStates>::python_type;

PyObject* py::converter<winrt::Windows::Networking::Connectivity::NetworkUsageStates>::convert(winrt::Windows::Networking::Connectivity::NetworkUsageStates instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::Networking::Connectivity::NetworkUsageStates>());
}
winrt::Windows::Networking::Connectivity::NetworkUsageStates py::converter<winrt::Windows::Networking::Connectivity::NetworkUsageStates>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::Networking::Connectivity::NetworkUsageStates>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::Networking::Connectivity::NetworkUsageStates>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::Networking::Connectivity::NetworkUsageStates return_value{};

    PyObject* py_Roaming = PyDict_GetItemString(obj, "roaming");
    if (!py_Roaming) { throw winrt::hresult_invalid_argument(); }
    return_value.Roaming = converter<winrt::Windows::Networking::Connectivity::TriStates>::convert_to(py_Roaming);

    PyObject* py_Shared = PyDict_GetItemString(obj, "shared");
    if (!py_Shared) { throw winrt::hresult_invalid_argument(); }
    return_value.Shared = converter<winrt::Windows::Networking::Connectivity::TriStates>::convert_to(py_Shared);

    return return_value;
}

namespace py::cpp::Windows::Networking::Connectivity
{
    // ----- AttributedNetworkUsage class --------------------
    constexpr const char* const _type_name_AttributedNetworkUsage = "AttributedNetworkUsage";

    static PyObject* _new_AttributedNetworkUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AttributedNetworkUsage);
        return nullptr;
    }

    static void _dealloc_AttributedNetworkUsage(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AttributedNetworkUsage_get_AttributionId(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttributionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_AttributionName(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttributionName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_AttributionThumbnail(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttributionThumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AttributedNetworkUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AttributedNetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::AttributedNetworkUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AttributedNetworkUsage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AttributedNetworkUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AttributedNetworkUsage[] = {
        { "attribution_id", reinterpret_cast<getter>(AttributedNetworkUsage_get_AttributionId), nullptr, nullptr, nullptr },
        { "attribution_name", reinterpret_cast<getter>(AttributedNetworkUsage_get_AttributionName), nullptr, nullptr, nullptr },
        { "attribution_thumbnail", reinterpret_cast<getter>(AttributedNetworkUsage_get_AttributionThumbnail), nullptr, nullptr, nullptr },
        { "bytes_received", reinterpret_cast<getter>(AttributedNetworkUsage_get_BytesReceived), nullptr, nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(AttributedNetworkUsage_get_BytesSent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AttributedNetworkUsage[] = 
    {
        { Py_tp_new, _new_AttributedNetworkUsage },
        { Py_tp_dealloc, _dealloc_AttributedNetworkUsage },
        { Py_tp_methods, _methods_AttributedNetworkUsage },
        { Py_tp_getset, _getset_AttributedNetworkUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AttributedNetworkUsage =
    {
        "_winsdk_Windows_Networking_Connectivity.AttributedNetworkUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::AttributedNetworkUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AttributedNetworkUsage
    };

    // ----- CellularApnContext class --------------------
    constexpr const char* const _type_name_CellularApnContext = "CellularApnContext";

    static PyObject* _new_CellularApnContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Connectivity::CellularApnContext instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_CellularApnContext(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CellularApnContext_get_UserName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_UserName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.UserName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_ProviderId(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_ProviderId(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProviderId(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_Password(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Password());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_Password(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Password(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_IsCompressionEnabled(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsCompressionEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_IsCompressionEnabled(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsCompressionEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_AuthenticationType(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AuthenticationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_AuthenticationType(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::CellularApnAuthenticationType>(arg);

            self->obj.AuthenticationType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_AccessPointName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccessPointName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_AccessPointName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.AccessPointName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CellularApnContext_get_ProfileName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CellularApnContext_put_ProfileName(py::wrapper::Windows::Networking::Connectivity::CellularApnContext* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.ProfileName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_CellularApnContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::CellularApnContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CellularApnContext[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CellularApnContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CellularApnContext[] = {
        { "user_name", reinterpret_cast<getter>(CellularApnContext_get_UserName), reinterpret_cast<setter>(CellularApnContext_put_UserName), nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(CellularApnContext_get_ProviderId), reinterpret_cast<setter>(CellularApnContext_put_ProviderId), nullptr, nullptr },
        { "password", reinterpret_cast<getter>(CellularApnContext_get_Password), reinterpret_cast<setter>(CellularApnContext_put_Password), nullptr, nullptr },
        { "is_compression_enabled", reinterpret_cast<getter>(CellularApnContext_get_IsCompressionEnabled), reinterpret_cast<setter>(CellularApnContext_put_IsCompressionEnabled), nullptr, nullptr },
        { "authentication_type", reinterpret_cast<getter>(CellularApnContext_get_AuthenticationType), reinterpret_cast<setter>(CellularApnContext_put_AuthenticationType), nullptr, nullptr },
        { "access_point_name", reinterpret_cast<getter>(CellularApnContext_get_AccessPointName), reinterpret_cast<setter>(CellularApnContext_put_AccessPointName), nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(CellularApnContext_get_ProfileName), reinterpret_cast<setter>(CellularApnContext_put_ProfileName), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CellularApnContext[] = 
    {
        { Py_tp_new, _new_CellularApnContext },
        { Py_tp_dealloc, _dealloc_CellularApnContext },
        { Py_tp_methods, _methods_CellularApnContext },
        { Py_tp_getset, _getset_CellularApnContext },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CellularApnContext =
    {
        "_winsdk_Windows_Networking_Connectivity.CellularApnContext",
        sizeof(py::wrapper::Windows::Networking::Connectivity::CellularApnContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CellularApnContext
    };

    // ----- ConnectionCost class --------------------
    constexpr const char* const _type_name_ConnectionCost = "ConnectionCost";

    static PyObject* _new_ConnectionCost(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConnectionCost);
        return nullptr;
    }

    static void _dealloc_ConnectionCost(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConnectionCost_get_ApproachingDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ApproachingDataLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_NetworkCostType(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkCostType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_OverDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OverDataLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_Roaming(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Roaming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionCost_get_BackgroundDataUsageRestricted(py::wrapper::Windows::Networking::Connectivity::ConnectionCost* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundDataUsageRestricted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConnectionCost(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionCost>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionCost[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectionCost), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectionCost[] = {
        { "approaching_data_limit", reinterpret_cast<getter>(ConnectionCost_get_ApproachingDataLimit), nullptr, nullptr, nullptr },
        { "network_cost_type", reinterpret_cast<getter>(ConnectionCost_get_NetworkCostType), nullptr, nullptr, nullptr },
        { "over_data_limit", reinterpret_cast<getter>(ConnectionCost_get_OverDataLimit), nullptr, nullptr, nullptr },
        { "roaming", reinterpret_cast<getter>(ConnectionCost_get_Roaming), nullptr, nullptr, nullptr },
        { "background_data_usage_restricted", reinterpret_cast<getter>(ConnectionCost_get_BackgroundDataUsageRestricted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectionCost[] = 
    {
        { Py_tp_new, _new_ConnectionCost },
        { Py_tp_dealloc, _dealloc_ConnectionCost },
        { Py_tp_methods, _methods_ConnectionCost },
        { Py_tp_getset, _getset_ConnectionCost },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConnectionCost =
    {
        "_winsdk_Windows_Networking_Connectivity.ConnectionCost",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionCost),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionCost
    };

    // ----- ConnectionProfile class --------------------
    constexpr const char* const _type_name_ConnectionProfile = "ConnectionProfile";

    static PyObject* _new_ConnectionProfile(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConnectionProfile);
        return nullptr;
    }

    static void _dealloc_ConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConnectionProfile_GetAttributedNetworkUsageAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 2);

                return py::convert(self->obj.GetAttributedNetworkUsageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetConnectionCost(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConnectionCost());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetConnectivityIntervalsAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 2);

                return py::convert(self->obj.GetConnectivityIntervalsAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetDataPlanStatus(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDataPlanStatus());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetDomainConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDomainConnectivityLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetLocalUsage(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);

                return py::convert(self->obj.GetLocalUsage(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::RoamingStates>(args, 2);

                return py::convert(self->obj.GetLocalUsage(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetNetworkConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNetworkConnectivityLevel());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetNetworkNames(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNetworkNames());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetNetworkUsageAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 4)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::DataUsageGranularity>(args, 2);
                auto param3 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 3);

                return py::convert(self->obj.GetNetworkUsageAsync(param0, param1, param2, param3));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetProviderNetworkUsageAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::DateTime>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(args, 2);

                return py::convert(self->obj.GetProviderNetworkUsageAsync(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_GetSignalBars(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetSignalBars());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_TryDeleteAsync(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.TryDeleteAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_NetworkAdapter(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_NetworkSecuritySettings(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkSecuritySettings());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_ProfileName(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProfileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_IsWlanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWlanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_IsWwanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWwanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_ServiceProviderGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceProviderGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_WlanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WlanConnectionProfileDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_WwanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WwanConnectionProfileDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfile_get_CanDelete(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanDelete());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConnectionProfile(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionProfile>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionProfile[] = {
        { "get_attributed_network_usage_async", reinterpret_cast<PyCFunction>(ConnectionProfile_GetAttributedNetworkUsageAsync), METH_VARARGS, nullptr },
        { "get_connection_cost", reinterpret_cast<PyCFunction>(ConnectionProfile_GetConnectionCost), METH_VARARGS, nullptr },
        { "get_connectivity_intervals_async", reinterpret_cast<PyCFunction>(ConnectionProfile_GetConnectivityIntervalsAsync), METH_VARARGS, nullptr },
        { "get_data_plan_status", reinterpret_cast<PyCFunction>(ConnectionProfile_GetDataPlanStatus), METH_VARARGS, nullptr },
        { "get_domain_connectivity_level", reinterpret_cast<PyCFunction>(ConnectionProfile_GetDomainConnectivityLevel), METH_VARARGS, nullptr },
        { "get_local_usage", reinterpret_cast<PyCFunction>(ConnectionProfile_GetLocalUsage), METH_VARARGS, nullptr },
        { "get_network_connectivity_level", reinterpret_cast<PyCFunction>(ConnectionProfile_GetNetworkConnectivityLevel), METH_VARARGS, nullptr },
        { "get_network_names", reinterpret_cast<PyCFunction>(ConnectionProfile_GetNetworkNames), METH_VARARGS, nullptr },
        { "get_network_usage_async", reinterpret_cast<PyCFunction>(ConnectionProfile_GetNetworkUsageAsync), METH_VARARGS, nullptr },
        { "get_provider_network_usage_async", reinterpret_cast<PyCFunction>(ConnectionProfile_GetProviderNetworkUsageAsync), METH_VARARGS, nullptr },
        { "get_signal_bars", reinterpret_cast<PyCFunction>(ConnectionProfile_GetSignalBars), METH_VARARGS, nullptr },
        { "try_delete_async", reinterpret_cast<PyCFunction>(ConnectionProfile_TryDeleteAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectionProfile), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectionProfile[] = {
        { "network_adapter", reinterpret_cast<getter>(ConnectionProfile_get_NetworkAdapter), nullptr, nullptr, nullptr },
        { "network_security_settings", reinterpret_cast<getter>(ConnectionProfile_get_NetworkSecuritySettings), nullptr, nullptr, nullptr },
        { "profile_name", reinterpret_cast<getter>(ConnectionProfile_get_ProfileName), nullptr, nullptr, nullptr },
        { "is_wlan_connection_profile", reinterpret_cast<getter>(ConnectionProfile_get_IsWlanConnectionProfile), nullptr, nullptr, nullptr },
        { "is_wwan_connection_profile", reinterpret_cast<getter>(ConnectionProfile_get_IsWwanConnectionProfile), nullptr, nullptr, nullptr },
        { "service_provider_guid", reinterpret_cast<getter>(ConnectionProfile_get_ServiceProviderGuid), nullptr, nullptr, nullptr },
        { "wlan_connection_profile_details", reinterpret_cast<getter>(ConnectionProfile_get_WlanConnectionProfileDetails), nullptr, nullptr, nullptr },
        { "wwan_connection_profile_details", reinterpret_cast<getter>(ConnectionProfile_get_WwanConnectionProfileDetails), nullptr, nullptr, nullptr },
        { "can_delete", reinterpret_cast<getter>(ConnectionProfile_get_CanDelete), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectionProfile[] = 
    {
        { Py_tp_new, _new_ConnectionProfile },
        { Py_tp_dealloc, _dealloc_ConnectionProfile },
        { Py_tp_methods, _methods_ConnectionProfile },
        { Py_tp_getset, _getset_ConnectionProfile },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConnectionProfile =
    {
        "_winsdk_Windows_Networking_Connectivity.ConnectionProfile",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionProfile),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionProfile
    };

    // ----- ConnectionProfileFilter class --------------------
    constexpr const char* const _type_name_ConnectionProfileFilter = "ConnectionProfileFilter";

    static PyObject* _new_ConnectionProfileFilter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Networking::Connectivity::ConnectionProfileFilter instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_ConnectionProfileFilter(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConnectionProfileFilter_get_ServiceProviderGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceProviderGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_ServiceProviderGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::guid>>(arg);

            self->obj.ServiceProviderGuid(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_NetworkCostType(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkCostType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_NetworkCostType(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkCostType>(arg);

            self->obj.NetworkCostType(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsWwanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWwanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsWwanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsWwanConnectionProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsWlanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsWlanConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsWlanConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsWlanConnectionProfile(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsConnected(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsConnected());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsConnected(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsConnected(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsRoaming(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsRoaming());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsRoaming(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsRoaming(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsOverDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsOverDataLimit());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsOverDataLimit(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsOverDataLimit(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_IsBackgroundDataUsageRestricted(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsBackgroundDataUsageRestricted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_IsBackgroundDataUsageRestricted(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<bool>>(arg);

            self->obj.IsBackgroundDataUsageRestricted(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* ConnectionProfileFilter_get_RawData(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RawData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectionProfileFilter_get_PurposeGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PurposeGuid());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ConnectionProfileFilter_put_PurposeGuid(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::guid>>(arg);

            self->obj.PurposeGuid(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ConnectionProfileFilter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionProfileFilter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionProfileFilter[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectionProfileFilter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectionProfileFilter[] = {
        { "service_provider_guid", reinterpret_cast<getter>(ConnectionProfileFilter_get_ServiceProviderGuid), reinterpret_cast<setter>(ConnectionProfileFilter_put_ServiceProviderGuid), nullptr, nullptr },
        { "network_cost_type", reinterpret_cast<getter>(ConnectionProfileFilter_get_NetworkCostType), reinterpret_cast<setter>(ConnectionProfileFilter_put_NetworkCostType), nullptr, nullptr },
        { "is_wwan_connection_profile", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsWwanConnectionProfile), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsWwanConnectionProfile), nullptr, nullptr },
        { "is_wlan_connection_profile", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsWlanConnectionProfile), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsWlanConnectionProfile), nullptr, nullptr },
        { "is_connected", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsConnected), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsConnected), nullptr, nullptr },
        { "is_roaming", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsRoaming), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsRoaming), nullptr, nullptr },
        { "is_over_data_limit", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsOverDataLimit), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsOverDataLimit), nullptr, nullptr },
        { "is_background_data_usage_restricted", reinterpret_cast<getter>(ConnectionProfileFilter_get_IsBackgroundDataUsageRestricted), reinterpret_cast<setter>(ConnectionProfileFilter_put_IsBackgroundDataUsageRestricted), nullptr, nullptr },
        { "raw_data", reinterpret_cast<getter>(ConnectionProfileFilter_get_RawData), nullptr, nullptr, nullptr },
        { "purpose_guid", reinterpret_cast<getter>(ConnectionProfileFilter_get_PurposeGuid), reinterpret_cast<setter>(ConnectionProfileFilter_put_PurposeGuid), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectionProfileFilter[] = 
    {
        { Py_tp_new, _new_ConnectionProfileFilter },
        { Py_tp_dealloc, _dealloc_ConnectionProfileFilter },
        { Py_tp_methods, _methods_ConnectionProfileFilter },
        { Py_tp_getset, _getset_ConnectionProfileFilter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConnectionProfileFilter =
    {
        "_winsdk_Windows_Networking_Connectivity.ConnectionProfileFilter",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionProfileFilter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionProfileFilter
    };

    // ----- ConnectionSession class --------------------
    constexpr const char* const _type_name_ConnectionSession = "ConnectionSession";

    static PyObject* _new_ConnectionSession(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConnectionSession);
        return nullptr;
    }

    static void _dealloc_ConnectionSession(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConnectionSession_Close(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Close();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectionSession_get_ConnectionProfile(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConnectionSession(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectionSession>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _enter_ConnectionSession(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self) noexcept
    {
        Py_INCREF(self);
        return reinterpret_cast<PyObject*>(self);
    }

    static PyObject* _exit_ConnectionSession(py::wrapper::Windows::Networking::Connectivity::ConnectionSession* self) noexcept
    {
        try
        {
            self->obj.Close();
            Py_RETURN_FALSE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectionSession[] = {
        { "close", reinterpret_cast<PyCFunction>(ConnectionSession_Close), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectionSession), METH_O | METH_STATIC, nullptr },
        { "__enter__", reinterpret_cast<PyCFunction>(_enter_ConnectionSession), METH_NOARGS, nullptr },
        { "__exit__",  reinterpret_cast<PyCFunction>(_exit_ConnectionSession), METH_VARARGS, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectionSession[] = {
        { "connection_profile", reinterpret_cast<getter>(ConnectionSession_get_ConnectionProfile), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectionSession[] = 
    {
        { Py_tp_new, _new_ConnectionSession },
        { Py_tp_dealloc, _dealloc_ConnectionSession },
        { Py_tp_methods, _methods_ConnectionSession },
        { Py_tp_getset, _getset_ConnectionSession },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConnectionSession =
    {
        "_winsdk_Windows_Networking_Connectivity.ConnectionSession",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectionSession),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectionSession
    };

    // ----- ConnectivityInterval class --------------------
    constexpr const char* const _type_name_ConnectivityInterval = "ConnectivityInterval";

    static PyObject* _new_ConnectivityInterval(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConnectivityInterval);
        return nullptr;
    }

    static void _dealloc_ConnectivityInterval(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ConnectivityInterval_get_ConnectionDuration(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ConnectivityInterval_get_StartTime(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ConnectivityInterval(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ConnectivityInterval>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectivityInterval[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ConnectivityInterval), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectivityInterval[] = {
        { "connection_duration", reinterpret_cast<getter>(ConnectivityInterval_get_ConnectionDuration), nullptr, nullptr, nullptr },
        { "start_time", reinterpret_cast<getter>(ConnectivityInterval_get_StartTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ConnectivityInterval[] = 
    {
        { Py_tp_new, _new_ConnectivityInterval },
        { Py_tp_dealloc, _dealloc_ConnectivityInterval },
        { Py_tp_methods, _methods_ConnectivityInterval },
        { Py_tp_getset, _getset_ConnectivityInterval },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConnectivityInterval =
    {
        "_winsdk_Windows_Networking_Connectivity.ConnectivityInterval",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ConnectivityInterval),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectivityInterval
    };

    // ----- ConnectivityManager class --------------------
    constexpr const char* const _type_name_ConnectivityManager = "ConnectivityManager";

    static PyObject* _new_ConnectivityManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ConnectivityManager);
        return nullptr;
    }

    static PyObject* ConnectivityManager_AcquireConnectionAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::CellularApnContext>(args, 0);

                return py::convert(winrt::Windows::Networking::Connectivity::ConnectivityManager::AcquireConnectionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectivityManager_AddHttpRoutePolicy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::RoutePolicy>(args, 0);

                winrt::Windows::Networking::Connectivity::ConnectivityManager::AddHttpRoutePolicy(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ConnectivityManager_RemoveHttpRoutePolicy(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::RoutePolicy>(args, 0);

                winrt::Windows::Networking::Connectivity::ConnectivityManager::RemoveHttpRoutePolicy(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_ConnectivityManager[] = {
        { "acquire_connection_async", reinterpret_cast<PyCFunction>(ConnectivityManager_AcquireConnectionAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "add_http_route_policy", reinterpret_cast<PyCFunction>(ConnectivityManager_AddHttpRoutePolicy), METH_VARARGS | METH_STATIC, nullptr },
        { "remove_http_route_policy", reinterpret_cast<PyCFunction>(ConnectivityManager_RemoveHttpRoutePolicy), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ConnectivityManager[] = {
        { }
    };

    static PyType_Slot _type_slots_ConnectivityManager[] = 
    {
        { Py_tp_new, _new_ConnectivityManager },
        { Py_tp_methods, _methods_ConnectivityManager },
        { Py_tp_getset, _getset_ConnectivityManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ConnectivityManager =
    {
        "_winsdk_Windows_Networking_Connectivity.ConnectivityManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ConnectivityManager
    };

    // ----- DataPlanStatus class --------------------
    constexpr const char* const _type_name_DataPlanStatus = "DataPlanStatus";

    static PyObject* _new_DataPlanStatus(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataPlanStatus);
        return nullptr;
    }

    static void _dealloc_DataPlanStatus(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataPlanStatus_get_DataLimitInMegabytes(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataLimitInMegabytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_DataPlanUsage(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DataPlanUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_InboundBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_MaxTransferSizeInMegabytes(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MaxTransferSizeInMegabytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_NextBillingCycle(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NextBillingCycle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanStatus_get_OutboundBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataPlanStatus(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::DataPlanStatus>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataPlanStatus[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DataPlanStatus), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataPlanStatus[] = {
        { "data_limit_in_megabytes", reinterpret_cast<getter>(DataPlanStatus_get_DataLimitInMegabytes), nullptr, nullptr, nullptr },
        { "data_plan_usage", reinterpret_cast<getter>(DataPlanStatus_get_DataPlanUsage), nullptr, nullptr, nullptr },
        { "inbound_bits_per_second", reinterpret_cast<getter>(DataPlanStatus_get_InboundBitsPerSecond), nullptr, nullptr, nullptr },
        { "max_transfer_size_in_megabytes", reinterpret_cast<getter>(DataPlanStatus_get_MaxTransferSizeInMegabytes), nullptr, nullptr, nullptr },
        { "next_billing_cycle", reinterpret_cast<getter>(DataPlanStatus_get_NextBillingCycle), nullptr, nullptr, nullptr },
        { "outbound_bits_per_second", reinterpret_cast<getter>(DataPlanStatus_get_OutboundBitsPerSecond), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataPlanStatus[] = 
    {
        { Py_tp_new, _new_DataPlanStatus },
        { Py_tp_dealloc, _dealloc_DataPlanStatus },
        { Py_tp_methods, _methods_DataPlanStatus },
        { Py_tp_getset, _getset_DataPlanStatus },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataPlanStatus =
    {
        "_winsdk_Windows_Networking_Connectivity.DataPlanStatus",
        sizeof(py::wrapper::Windows::Networking::Connectivity::DataPlanStatus),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPlanStatus
    };

    // ----- DataPlanUsage class --------------------
    constexpr const char* const _type_name_DataPlanUsage = "DataPlanUsage";

    static PyObject* _new_DataPlanUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataPlanUsage);
        return nullptr;
    }

    static void _dealloc_DataPlanUsage(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataPlanUsage_get_LastSyncTime(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastSyncTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataPlanUsage_get_MegabytesUsed(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MegabytesUsed());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataPlanUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::DataPlanUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataPlanUsage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DataPlanUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataPlanUsage[] = {
        { "last_sync_time", reinterpret_cast<getter>(DataPlanUsage_get_LastSyncTime), nullptr, nullptr, nullptr },
        { "megabytes_used", reinterpret_cast<getter>(DataPlanUsage_get_MegabytesUsed), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataPlanUsage[] = 
    {
        { Py_tp_new, _new_DataPlanUsage },
        { Py_tp_dealloc, _dealloc_DataPlanUsage },
        { Py_tp_methods, _methods_DataPlanUsage },
        { Py_tp_getset, _getset_DataPlanUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataPlanUsage =
    {
        "_winsdk_Windows_Networking_Connectivity.DataPlanUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::DataPlanUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataPlanUsage
    };

    // ----- DataUsage class --------------------
    constexpr const char* const _type_name_DataUsage = "DataUsage";

    static PyObject* _new_DataUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DataUsage);
        return nullptr;
    }

    static void _dealloc_DataUsage(py::wrapper::Windows::Networking::Connectivity::DataUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DataUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::DataUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DataUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::DataUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DataUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::DataUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DataUsage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DataUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DataUsage[] = {
        { "bytes_received", reinterpret_cast<getter>(DataUsage_get_BytesReceived), nullptr, nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(DataUsage_get_BytesSent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DataUsage[] = 
    {
        { Py_tp_new, _new_DataUsage },
        { Py_tp_dealloc, _dealloc_DataUsage },
        { Py_tp_methods, _methods_DataUsage },
        { Py_tp_getset, _getset_DataUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DataUsage =
    {
        "_winsdk_Windows_Networking_Connectivity.DataUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::DataUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DataUsage
    };

    // ----- IPInformation class --------------------
    constexpr const char* const _type_name_IPInformation = "IPInformation";

    static PyObject* _new_IPInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_IPInformation);
        return nullptr;
    }

    static void _dealloc_IPInformation(py::wrapper::Windows::Networking::Connectivity::IPInformation* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IPInformation_get_NetworkAdapter(py::wrapper::Windows::Networking::Connectivity::IPInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAdapter());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPInformation_get_PrefixLength(py::wrapper::Windows::Networking::Connectivity::IPInformation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrefixLength());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPInformation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::IPInformation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPInformation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IPInformation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPInformation[] = {
        { "network_adapter", reinterpret_cast<getter>(IPInformation_get_NetworkAdapter), nullptr, nullptr, nullptr },
        { "prefix_length", reinterpret_cast<getter>(IPInformation_get_PrefixLength), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPInformation[] = 
    {
        { Py_tp_new, _new_IPInformation },
        { Py_tp_dealloc, _dealloc_IPInformation },
        { Py_tp_methods, _methods_IPInformation },
        { Py_tp_getset, _getset_IPInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IPInformation =
    {
        "_winsdk_Windows_Networking_Connectivity.IPInformation",
        sizeof(py::wrapper::Windows::Networking::Connectivity::IPInformation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPInformation
    };

    // ----- LanIdentifier class --------------------
    constexpr const char* const _type_name_LanIdentifier = "LanIdentifier";

    static PyObject* _new_LanIdentifier(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LanIdentifier);
        return nullptr;
    }

    static void _dealloc_LanIdentifier(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LanIdentifier_get_InfrastructureId(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InfrastructureId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LanIdentifier_get_NetworkAdapterId(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LanIdentifier_get_PortId(py::wrapper::Windows::Networking::Connectivity::LanIdentifier* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PortId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LanIdentifier(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::LanIdentifier>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LanIdentifier[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LanIdentifier), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LanIdentifier[] = {
        { "infrastructure_id", reinterpret_cast<getter>(LanIdentifier_get_InfrastructureId), nullptr, nullptr, nullptr },
        { "network_adapter_id", reinterpret_cast<getter>(LanIdentifier_get_NetworkAdapterId), nullptr, nullptr, nullptr },
        { "port_id", reinterpret_cast<getter>(LanIdentifier_get_PortId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LanIdentifier[] = 
    {
        { Py_tp_new, _new_LanIdentifier },
        { Py_tp_dealloc, _dealloc_LanIdentifier },
        { Py_tp_methods, _methods_LanIdentifier },
        { Py_tp_getset, _getset_LanIdentifier },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LanIdentifier =
    {
        "_winsdk_Windows_Networking_Connectivity.LanIdentifier",
        sizeof(py::wrapper::Windows::Networking::Connectivity::LanIdentifier),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LanIdentifier
    };

    // ----- LanIdentifierData class --------------------
    constexpr const char* const _type_name_LanIdentifierData = "LanIdentifierData";

    static PyObject* _new_LanIdentifierData(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LanIdentifierData);
        return nullptr;
    }

    static void _dealloc_LanIdentifierData(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LanIdentifierData_get_Type(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Type());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LanIdentifierData_get_Value(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LanIdentifierData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::LanIdentifierData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LanIdentifierData[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LanIdentifierData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LanIdentifierData[] = {
        { "type", reinterpret_cast<getter>(LanIdentifierData_get_Type), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(LanIdentifierData_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LanIdentifierData[] = 
    {
        { Py_tp_new, _new_LanIdentifierData },
        { Py_tp_dealloc, _dealloc_LanIdentifierData },
        { Py_tp_methods, _methods_LanIdentifierData },
        { Py_tp_getset, _getset_LanIdentifierData },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LanIdentifierData =
    {
        "_winsdk_Windows_Networking_Connectivity.LanIdentifierData",
        sizeof(py::wrapper::Windows::Networking::Connectivity::LanIdentifierData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LanIdentifierData
    };

    // ----- NetworkAdapter class --------------------
    constexpr const char* const _type_name_NetworkAdapter = "NetworkAdapter";

    static PyObject* _new_NetworkAdapter(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_NetworkAdapter);
        return nullptr;
    }

    static void _dealloc_NetworkAdapter(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NetworkAdapter_GetConnectedProfileAsync(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConnectedProfileAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_IanaInterfaceType(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IanaInterfaceType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_InboundMaxBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InboundMaxBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_NetworkAdapterId(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAdapterId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_NetworkItem(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkItem());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkAdapter_get_OutboundMaxBitsPerSecond(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutboundMaxBitsPerSecond());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkAdapter(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkAdapter>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkAdapter[] = {
        { "get_connected_profile_async", reinterpret_cast<PyCFunction>(NetworkAdapter_GetConnectedProfileAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkAdapter), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkAdapter[] = {
        { "iana_interface_type", reinterpret_cast<getter>(NetworkAdapter_get_IanaInterfaceType), nullptr, nullptr, nullptr },
        { "inbound_max_bits_per_second", reinterpret_cast<getter>(NetworkAdapter_get_InboundMaxBitsPerSecond), nullptr, nullptr, nullptr },
        { "network_adapter_id", reinterpret_cast<getter>(NetworkAdapter_get_NetworkAdapterId), nullptr, nullptr, nullptr },
        { "network_item", reinterpret_cast<getter>(NetworkAdapter_get_NetworkItem), nullptr, nullptr, nullptr },
        { "outbound_max_bits_per_second", reinterpret_cast<getter>(NetworkAdapter_get_OutboundMaxBitsPerSecond), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkAdapter[] = 
    {
        { Py_tp_new, _new_NetworkAdapter },
        { Py_tp_dealloc, _dealloc_NetworkAdapter },
        { Py_tp_methods, _methods_NetworkAdapter },
        { Py_tp_getset, _getset_NetworkAdapter },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkAdapter =
    {
        "_winsdk_Windows_Networking_Connectivity.NetworkAdapter",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkAdapter),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkAdapter
    };

    // ----- NetworkInformation class --------------------
    constexpr const char* const _type_name_NetworkInformation = "NetworkInformation";

    static PyObject* _new_NetworkInformation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_NetworkInformation);
        return nullptr;
    }

    static PyObject* NetworkInformation_FindConnectionProfilesAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfileFilter>(args, 0);

                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::FindConnectionProfilesAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetConnectionProfiles(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetConnectionProfiles());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetHostNames(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetHostNames());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetInternetConnectionProfile(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetInternetConnectionProfile());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetLanIdentifiers(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetLanIdentifiers());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetProxyConfigurationAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Uri>(args, 0);

                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetProxyConfigurationAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_GetSortedEndpointPairs(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Networking::EndpointPair>>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostNameSortOptions>(args, 1);

                return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::GetSortedEndpointPairs(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_add_NetworkStatusChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkStatusChangedEventHandler>(arg);

            return py::convert(winrt::Windows::Networking::Connectivity::NetworkInformation::NetworkStatusChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkInformation_remove_NetworkStatusChanged(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            winrt::Windows::Networking::Connectivity::NetworkInformation::NetworkStatusChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkInformation[] = {
        { "find_connection_profiles_async", reinterpret_cast<PyCFunction>(NetworkInformation_FindConnectionProfilesAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_connection_profiles", reinterpret_cast<PyCFunction>(NetworkInformation_GetConnectionProfiles), METH_VARARGS | METH_STATIC, nullptr },
        { "get_host_names", reinterpret_cast<PyCFunction>(NetworkInformation_GetHostNames), METH_VARARGS | METH_STATIC, nullptr },
        { "get_internet_connection_profile", reinterpret_cast<PyCFunction>(NetworkInformation_GetInternetConnectionProfile), METH_VARARGS | METH_STATIC, nullptr },
        { "get_lan_identifiers", reinterpret_cast<PyCFunction>(NetworkInformation_GetLanIdentifiers), METH_VARARGS | METH_STATIC, nullptr },
        { "get_proxy_configuration_async", reinterpret_cast<PyCFunction>(NetworkInformation_GetProxyConfigurationAsync), METH_VARARGS | METH_STATIC, nullptr },
        { "get_sorted_endpoint_pairs", reinterpret_cast<PyCFunction>(NetworkInformation_GetSortedEndpointPairs), METH_VARARGS | METH_STATIC, nullptr },
        { "add_network_status_changed", reinterpret_cast<PyCFunction>(NetworkInformation_add_NetworkStatusChanged), METH_O | METH_STATIC, nullptr },
        { "remove_network_status_changed", reinterpret_cast<PyCFunction>(NetworkInformation_remove_NetworkStatusChanged), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkInformation[] = {
        { }
    };

    static PyType_Slot _type_slots_NetworkInformation[] = 
    {
        { Py_tp_new, _new_NetworkInformation },
        { Py_tp_methods, _methods_NetworkInformation },
        { Py_tp_getset, _getset_NetworkInformation },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkInformation =
    {
        "_winsdk_Windows_Networking_Connectivity.NetworkInformation",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkInformation
    };

    // ----- NetworkItem class --------------------
    constexpr const char* const _type_name_NetworkItem = "NetworkItem";

    static PyObject* _new_NetworkItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_NetworkItem);
        return nullptr;
    }

    static void _dealloc_NetworkItem(py::wrapper::Windows::Networking::Connectivity::NetworkItem* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NetworkItem_GetNetworkTypes(py::wrapper::Windows::Networking::Connectivity::NetworkItem* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNetworkTypes());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* NetworkItem_get_NetworkId(py::wrapper::Windows::Networking::Connectivity::NetworkItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkItem[] = {
        { "get_network_types", reinterpret_cast<PyCFunction>(NetworkItem_GetNetworkTypes), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkItem[] = {
        { "network_id", reinterpret_cast<getter>(NetworkItem_get_NetworkId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkItem[] = 
    {
        { Py_tp_new, _new_NetworkItem },
        { Py_tp_dealloc, _dealloc_NetworkItem },
        { Py_tp_methods, _methods_NetworkItem },
        { Py_tp_getset, _getset_NetworkItem },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkItem =
    {
        "_winsdk_Windows_Networking_Connectivity.NetworkItem",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkItem
    };

    // ----- NetworkSecuritySettings class --------------------
    constexpr const char* const _type_name_NetworkSecuritySettings = "NetworkSecuritySettings";

    static PyObject* _new_NetworkSecuritySettings(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_NetworkSecuritySettings);
        return nullptr;
    }

    static void _dealloc_NetworkSecuritySettings(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NetworkSecuritySettings_get_NetworkAuthenticationType(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkAuthenticationType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkSecuritySettings_get_NetworkEncryptionType(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NetworkEncryptionType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkSecuritySettings(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkSecuritySettings>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkSecuritySettings[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkSecuritySettings), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkSecuritySettings[] = {
        { "network_authentication_type", reinterpret_cast<getter>(NetworkSecuritySettings_get_NetworkAuthenticationType), nullptr, nullptr, nullptr },
        { "network_encryption_type", reinterpret_cast<getter>(NetworkSecuritySettings_get_NetworkEncryptionType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkSecuritySettings[] = 
    {
        { Py_tp_new, _new_NetworkSecuritySettings },
        { Py_tp_dealloc, _dealloc_NetworkSecuritySettings },
        { Py_tp_methods, _methods_NetworkSecuritySettings },
        { Py_tp_getset, _getset_NetworkSecuritySettings },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkSecuritySettings =
    {
        "_winsdk_Windows_Networking_Connectivity.NetworkSecuritySettings",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkSecuritySettings),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkSecuritySettings
    };

    // ----- NetworkStateChangeEventDetails class --------------------
    constexpr const char* const _type_name_NetworkStateChangeEventDetails = "NetworkStateChangeEventDetails";

    static PyObject* _new_NetworkStateChangeEventDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_NetworkStateChangeEventDetails);
        return nullptr;
    }

    static void _dealloc_NetworkStateChangeEventDetails(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewConnectionCost(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewConnectionCost());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewDomainConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewDomainConnectivityLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewHostNameList(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewHostNameList());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewInternetConnectionProfile(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewInternetConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewNetworkConnectivityLevel(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewNetworkConnectivityLevel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewWwanRegistrationState(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewWwanRegistrationState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewTetheringClientCount(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewTetheringClientCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkStateChangeEventDetails_get_HasNewTetheringOperationalState(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HasNewTetheringOperationalState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkStateChangeEventDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkStateChangeEventDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkStateChangeEventDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkStateChangeEventDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkStateChangeEventDetails[] = {
        { "has_new_connection_cost", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewConnectionCost), nullptr, nullptr, nullptr },
        { "has_new_domain_connectivity_level", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewDomainConnectivityLevel), nullptr, nullptr, nullptr },
        { "has_new_host_name_list", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewHostNameList), nullptr, nullptr, nullptr },
        { "has_new_internet_connection_profile", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewInternetConnectionProfile), nullptr, nullptr, nullptr },
        { "has_new_network_connectivity_level", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewNetworkConnectivityLevel), nullptr, nullptr, nullptr },
        { "has_new_wwan_registration_state", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewWwanRegistrationState), nullptr, nullptr, nullptr },
        { "has_new_tethering_client_count", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewTetheringClientCount), nullptr, nullptr, nullptr },
        { "has_new_tethering_operational_state", reinterpret_cast<getter>(NetworkStateChangeEventDetails_get_HasNewTetheringOperationalState), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkStateChangeEventDetails[] = 
    {
        { Py_tp_new, _new_NetworkStateChangeEventDetails },
        { Py_tp_dealloc, _dealloc_NetworkStateChangeEventDetails },
        { Py_tp_methods, _methods_NetworkStateChangeEventDetails },
        { Py_tp_getset, _getset_NetworkStateChangeEventDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkStateChangeEventDetails =
    {
        "_winsdk_Windows_Networking_Connectivity.NetworkStateChangeEventDetails",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkStateChangeEventDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkStateChangeEventDetails
    };

    // ----- NetworkUsage class --------------------
    constexpr const char* const _type_name_NetworkUsage = "NetworkUsage";

    static PyObject* _new_NetworkUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_NetworkUsage);
        return nullptr;
    }

    static void _dealloc_NetworkUsage(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* NetworkUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* NetworkUsage_get_ConnectionDuration(py::wrapper::Windows::Networking::Connectivity::NetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_NetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::NetworkUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_NetworkUsage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_NetworkUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_NetworkUsage[] = {
        { "bytes_received", reinterpret_cast<getter>(NetworkUsage_get_BytesReceived), nullptr, nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(NetworkUsage_get_BytesSent), nullptr, nullptr, nullptr },
        { "connection_duration", reinterpret_cast<getter>(NetworkUsage_get_ConnectionDuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkUsage[] = 
    {
        { Py_tp_new, _new_NetworkUsage },
        { Py_tp_dealloc, _dealloc_NetworkUsage },
        { Py_tp_methods, _methods_NetworkUsage },
        { Py_tp_getset, _getset_NetworkUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkUsage =
    {
        "_winsdk_Windows_Networking_Connectivity.NetworkUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkUsage
    };

    // ----- ProviderNetworkUsage class --------------------
    constexpr const char* const _type_name_ProviderNetworkUsage = "ProviderNetworkUsage";

    static PyObject* _new_ProviderNetworkUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProviderNetworkUsage);
        return nullptr;
    }

    static void _dealloc_ProviderNetworkUsage(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProviderNetworkUsage_get_BytesReceived(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReceived());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProviderNetworkUsage_get_BytesSent(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesSent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProviderNetworkUsage_get_ProviderId(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProviderNetworkUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ProviderNetworkUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProviderNetworkUsage[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ProviderNetworkUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProviderNetworkUsage[] = {
        { "bytes_received", reinterpret_cast<getter>(ProviderNetworkUsage_get_BytesReceived), nullptr, nullptr, nullptr },
        { "bytes_sent", reinterpret_cast<getter>(ProviderNetworkUsage_get_BytesSent), nullptr, nullptr, nullptr },
        { "provider_id", reinterpret_cast<getter>(ProviderNetworkUsage_get_ProviderId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProviderNetworkUsage[] = 
    {
        { Py_tp_new, _new_ProviderNetworkUsage },
        { Py_tp_dealloc, _dealloc_ProviderNetworkUsage },
        { Py_tp_methods, _methods_ProviderNetworkUsage },
        { Py_tp_getset, _getset_ProviderNetworkUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProviderNetworkUsage =
    {
        "_winsdk_Windows_Networking_Connectivity.ProviderNetworkUsage",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ProviderNetworkUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProviderNetworkUsage
    };

    // ----- ProxyConfiguration class --------------------
    constexpr const char* const _type_name_ProxyConfiguration = "ProxyConfiguration";

    static PyObject* _new_ProxyConfiguration(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProxyConfiguration);
        return nullptr;
    }

    static void _dealloc_ProxyConfiguration(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProxyConfiguration_get_CanConnectDirectly(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CanConnectDirectly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProxyConfiguration_get_ProxyUris(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProxyUris());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProxyConfiguration(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::ProxyConfiguration>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProxyConfiguration[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ProxyConfiguration), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProxyConfiguration[] = {
        { "can_connect_directly", reinterpret_cast<getter>(ProxyConfiguration_get_CanConnectDirectly), nullptr, nullptr, nullptr },
        { "proxy_uris", reinterpret_cast<getter>(ProxyConfiguration_get_ProxyUris), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProxyConfiguration[] = 
    {
        { Py_tp_new, _new_ProxyConfiguration },
        { Py_tp_dealloc, _dealloc_ProxyConfiguration },
        { Py_tp_methods, _methods_ProxyConfiguration },
        { Py_tp_getset, _getset_ProxyConfiguration },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProxyConfiguration =
    {
        "_winsdk_Windows_Networking_Connectivity.ProxyConfiguration",
        sizeof(py::wrapper::Windows::Networking::Connectivity::ProxyConfiguration),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProxyConfiguration
    };

    // ----- RoutePolicy class --------------------
    constexpr const char* const _type_name_RoutePolicy = "RoutePolicy";

    static PyObject* _new_RoutePolicy(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Networking::Connectivity::ConnectionProfile>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Networking::HostName>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Networking::DomainNameType>(args, 2);

                winrt::Windows::Networking::Connectivity::RoutePolicy instance{ param0, param1, param2 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_RoutePolicy(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* RoutePolicy_get_ConnectionProfile(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionProfile());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RoutePolicy_get_HostName(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HostName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RoutePolicy_get_HostNameType(py::wrapper::Windows::Networking::Connectivity::RoutePolicy* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HostNameType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RoutePolicy(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::RoutePolicy>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RoutePolicy[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_RoutePolicy), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RoutePolicy[] = {
        { "connection_profile", reinterpret_cast<getter>(RoutePolicy_get_ConnectionProfile), nullptr, nullptr, nullptr },
        { "host_name", reinterpret_cast<getter>(RoutePolicy_get_HostName), nullptr, nullptr, nullptr },
        { "host_name_type", reinterpret_cast<getter>(RoutePolicy_get_HostNameType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RoutePolicy[] = 
    {
        { Py_tp_new, _new_RoutePolicy },
        { Py_tp_dealloc, _dealloc_RoutePolicy },
        { Py_tp_methods, _methods_RoutePolicy },
        { Py_tp_getset, _getset_RoutePolicy },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_RoutePolicy =
    {
        "_winsdk_Windows_Networking_Connectivity.RoutePolicy",
        sizeof(py::wrapper::Windows::Networking::Connectivity::RoutePolicy),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RoutePolicy
    };

    // ----- WlanConnectionProfileDetails class --------------------
    constexpr const char* const _type_name_WlanConnectionProfileDetails = "WlanConnectionProfileDetails";

    static PyObject* _new_WlanConnectionProfileDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_WlanConnectionProfileDetails);
        return nullptr;
    }

    static void _dealloc_WlanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::WlanConnectionProfileDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WlanConnectionProfileDetails_GetConnectedSsid(py::wrapper::Windows::Networking::Connectivity::WlanConnectionProfileDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetConnectedSsid());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_WlanConnectionProfileDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::WlanConnectionProfileDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WlanConnectionProfileDetails[] = {
        { "get_connected_ssid", reinterpret_cast<PyCFunction>(WlanConnectionProfileDetails_GetConnectedSsid), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WlanConnectionProfileDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WlanConnectionProfileDetails[] = {
        { }
    };

    static PyType_Slot _type_slots_WlanConnectionProfileDetails[] = 
    {
        { Py_tp_new, _new_WlanConnectionProfileDetails },
        { Py_tp_dealloc, _dealloc_WlanConnectionProfileDetails },
        { Py_tp_methods, _methods_WlanConnectionProfileDetails },
        { Py_tp_getset, _getset_WlanConnectionProfileDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WlanConnectionProfileDetails =
    {
        "_winsdk_Windows_Networking_Connectivity.WlanConnectionProfileDetails",
        sizeof(py::wrapper::Windows::Networking::Connectivity::WlanConnectionProfileDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WlanConnectionProfileDetails
    };

    // ----- WwanConnectionProfileDetails class --------------------
    constexpr const char* const _type_name_WwanConnectionProfileDetails = "WwanConnectionProfileDetails";

    static PyObject* _new_WwanConnectionProfileDetails(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_WwanConnectionProfileDetails);
        return nullptr;
    }

    static void _dealloc_WwanConnectionProfileDetails(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* WwanConnectionProfileDetails_GetCurrentDataClass(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetCurrentDataClass());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_GetNetworkRegistrationState(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetNetworkRegistrationState());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_AccessPointName(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AccessPointName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_HomeProviderId(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HomeProviderId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_IPKind(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IPKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WwanConnectionProfileDetails_get_PurposeGuids(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PurposeGuids());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WwanConnectionProfileDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Networking::Connectivity::WwanConnectionProfileDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WwanConnectionProfileDetails[] = {
        { "get_current_data_class", reinterpret_cast<PyCFunction>(WwanConnectionProfileDetails_GetCurrentDataClass), METH_VARARGS, nullptr },
        { "get_network_registration_state", reinterpret_cast<PyCFunction>(WwanConnectionProfileDetails_GetNetworkRegistrationState), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WwanConnectionProfileDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WwanConnectionProfileDetails[] = {
        { "access_point_name", reinterpret_cast<getter>(WwanConnectionProfileDetails_get_AccessPointName), nullptr, nullptr, nullptr },
        { "home_provider_id", reinterpret_cast<getter>(WwanConnectionProfileDetails_get_HomeProviderId), nullptr, nullptr, nullptr },
        { "i_p_kind", reinterpret_cast<getter>(WwanConnectionProfileDetails_get_IPKind), nullptr, nullptr, nullptr },
        { "purpose_guids", reinterpret_cast<getter>(WwanConnectionProfileDetails_get_PurposeGuids), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WwanConnectionProfileDetails[] = 
    {
        { Py_tp_new, _new_WwanConnectionProfileDetails },
        { Py_tp_dealloc, _dealloc_WwanConnectionProfileDetails },
        { Py_tp_methods, _methods_WwanConnectionProfileDetails },
        { Py_tp_getset, _getset_WwanConnectionProfileDetails },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_WwanConnectionProfileDetails =
    {
        "_winsdk_Windows_Networking_Connectivity.WwanConnectionProfileDetails",
        sizeof(py::wrapper::Windows::Networking::Connectivity::WwanConnectionProfileDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WwanConnectionProfileDetails
    };

    // ----- NetworkUsageStates struct --------------------
    constexpr const char* const _type_name_NetworkUsageStates = "NetworkUsageStates";

    PyObject* _new_NetworkUsageStates(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::Networking::Connectivity::NetworkUsageStates return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::Networking::Connectivity::NetworkUsageStates>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _Roaming{};
        int32_t _Shared{};

        static const char* kwlist[] = {"roaming", "shared", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_Roaming, &_Shared))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::Networking::Connectivity::NetworkUsageStates return_value{ static_cast<winrt::Windows::Networking::Connectivity::TriStates>(_Roaming), static_cast<winrt::Windows::Networking::Connectivity::TriStates>(_Shared) };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_NetworkUsageStates(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self)
    {
    }

    static PyObject* NetworkUsageStates_get_Roaming(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Roaming);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkUsageStates_set_Roaming(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Roaming = py::converter<winrt::Windows::Networking::Connectivity::TriStates>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* NetworkUsageStates_get_Shared(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Shared);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int NetworkUsageStates_set_Shared(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Shared = py::converter<winrt::Windows::Networking::Connectivity::TriStates>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_NetworkUsageStates[] = {
        { "roaming", reinterpret_cast<getter>(NetworkUsageStates_get_Roaming), reinterpret_cast<setter>(NetworkUsageStates_set_Roaming), nullptr, nullptr },
        { "shared", reinterpret_cast<getter>(NetworkUsageStates_get_Shared), reinterpret_cast<setter>(NetworkUsageStates_set_Shared), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_NetworkUsageStates[] = 
    {
        { Py_tp_new, _new_NetworkUsageStates },
        { Py_tp_dealloc, _dealloc_NetworkUsageStates },
        { Py_tp_getset, _getset_NetworkUsageStates },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_NetworkUsageStates =
    {
        "_winsdk_Windows_Networking_Connectivity.NetworkUsageStates",
        sizeof(py::wrapper::Windows::Networking::Connectivity::NetworkUsageStates),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_NetworkUsageStates
    };

    // ----- Windows.Networking.Connectivity Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Networking::Connectivity::AttributedNetworkUsage>::python_type = py::register_python_type(module, _type_name_AttributedNetworkUsage, &_type_spec_AttributedNetworkUsage, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::CellularApnContext>::python_type = py::register_python_type(module, _type_name_CellularApnContext, &_type_spec_CellularApnContext, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionCost>::python_type = py::register_python_type(module, _type_name_ConnectionCost, &_type_spec_ConnectionCost, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionProfile>::python_type = py::register_python_type(module, _type_name_ConnectionProfile, &_type_spec_ConnectionProfile, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionProfileFilter>::python_type = py::register_python_type(module, _type_name_ConnectionProfileFilter, &_type_spec_ConnectionProfileFilter, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectionSession>::python_type = py::register_python_type(module, _type_name_ConnectionSession, &_type_spec_ConnectionSession, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectivityInterval>::python_type = py::register_python_type(module, _type_name_ConnectivityInterval, &_type_spec_ConnectivityInterval, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ConnectivityManager>::python_type = py::register_python_type(module, _type_name_ConnectivityManager, &_type_spec_ConnectivityManager, nullptr);
            py::winrt_type<winrt::Windows::Networking::Connectivity::DataPlanStatus>::python_type = py::register_python_type(module, _type_name_DataPlanStatus, &_type_spec_DataPlanStatus, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::DataPlanUsage>::python_type = py::register_python_type(module, _type_name_DataPlanUsage, &_type_spec_DataPlanUsage, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::DataUsage>::python_type = py::register_python_type(module, _type_name_DataUsage, &_type_spec_DataUsage, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::IPInformation>::python_type = py::register_python_type(module, _type_name_IPInformation, &_type_spec_IPInformation, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::LanIdentifier>::python_type = py::register_python_type(module, _type_name_LanIdentifier, &_type_spec_LanIdentifier, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::LanIdentifierData>::python_type = py::register_python_type(module, _type_name_LanIdentifierData, &_type_spec_LanIdentifierData, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkAdapter>::python_type = py::register_python_type(module, _type_name_NetworkAdapter, &_type_spec_NetworkAdapter, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkInformation>::python_type = py::register_python_type(module, _type_name_NetworkInformation, &_type_spec_NetworkInformation, nullptr);
            py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkItem>::python_type = py::register_python_type(module, _type_name_NetworkItem, &_type_spec_NetworkItem, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkSecuritySettings>::python_type = py::register_python_type(module, _type_name_NetworkSecuritySettings, &_type_spec_NetworkSecuritySettings, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkStateChangeEventDetails>::python_type = py::register_python_type(module, _type_name_NetworkStateChangeEventDetails, &_type_spec_NetworkStateChangeEventDetails, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkUsage>::python_type = py::register_python_type(module, _type_name_NetworkUsage, &_type_spec_NetworkUsage, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ProviderNetworkUsage>::python_type = py::register_python_type(module, _type_name_ProviderNetworkUsage, &_type_spec_ProviderNetworkUsage, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::ProxyConfiguration>::python_type = py::register_python_type(module, _type_name_ProxyConfiguration, &_type_spec_ProxyConfiguration, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::RoutePolicy>::python_type = py::register_python_type(module, _type_name_RoutePolicy, &_type_spec_RoutePolicy, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::WlanConnectionProfileDetails>::python_type = py::register_python_type(module, _type_name_WlanConnectionProfileDetails, &_type_spec_WlanConnectionProfileDetails, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::WwanConnectionProfileDetails>::python_type = py::register_python_type(module, _type_name_WwanConnectionProfileDetails, &_type_spec_WwanConnectionProfileDetails, bases.get());
            py::winrt_type<winrt::Windows::Networking::Connectivity::NetworkUsageStates>::python_type = py::register_python_type(module, _type_name_NetworkUsageStates, &_type_spec_NetworkUsageStates, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Networking.Connectivity");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Networking_Connectivity",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Networking::Connectivity

PyMODINIT_FUNC
PyInit__winsdk_Windows_Networking_Connectivity (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Networking::Connectivity::module_def);
}
