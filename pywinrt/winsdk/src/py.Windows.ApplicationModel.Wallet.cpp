// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.5

#include "pybase.h"
#include "py.Windows.ApplicationModel.Wallet.h"


namespace py::cpp::Windows::ApplicationModel::Wallet
{
    struct module_state
    {
        PyObject* type_WalletActionKind;
        PyObject* type_WalletBarcodeSymbology;
        PyObject* type_WalletDetailViewPosition;
        PyObject* type_WalletItemKind;
        PyObject* type_WalletSummaryViewPosition;
        PyTypeObject* type_WalletBarcode;
        PyTypeObject* type_WalletItem;
        PyTypeObject* type_WalletItemCustomProperty;
        PyTypeObject* type_WalletItemStore;
        PyTypeObject* type_WalletManager;
        PyTypeObject* type_WalletRelevantLocation;
        PyTypeObject* type_WalletTransaction;
        PyTypeObject* type_WalletVerb;
    };

    static PyObject* register_WalletActionKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_WalletActionKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_WalletActionKind = type;
        Py_INCREF(state->type_WalletActionKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_WalletBarcodeSymbology(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_WalletBarcodeSymbology)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_WalletBarcodeSymbology = type;
        Py_INCREF(state->type_WalletBarcodeSymbology);


        Py_RETURN_NONE;
    }

    static PyObject* register_WalletDetailViewPosition(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_WalletDetailViewPosition)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_WalletDetailViewPosition = type;
        Py_INCREF(state->type_WalletDetailViewPosition);


        Py_RETURN_NONE;
    }

    static PyObject* register_WalletItemKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_WalletItemKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_WalletItemKind = type;
        Py_INCREF(state->type_WalletItemKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_WalletSummaryViewPosition(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_WalletSummaryViewPosition)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_WalletSummaryViewPosition = type;
        Py_INCREF(state->type_WalletSummaryViewPosition);


        Py_RETURN_NONE;
    }

    // ----- WalletBarcode class --------------------
    constexpr const char* const type_name_WalletBarcode = "WalletBarcode";

    static PyObject* _new_WalletBarcode(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletBarcodeSymbology>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Wallet::WalletBarcode instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                winrt::Windows::ApplicationModel::Wallet::WalletBarcode instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletBarcode(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletBarcode_GetImageAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetImageAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletBarcode_get_Symbology(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Symbology());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletBarcode_get_Value(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WalletBarcode(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletBarcode>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletBarcode[] = {
        { "get_image_async", reinterpret_cast<PyCFunction>(WalletBarcode_GetImageAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletBarcode), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletBarcode[] = {
        { "symbology", reinterpret_cast<getter>(WalletBarcode_get_Symbology), nullptr, nullptr, nullptr },
        { "value", reinterpret_cast<getter>(WalletBarcode_get_Value), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WalletBarcode[] = 
    {
        { Py_tp_new, _new_WalletBarcode },
        { Py_tp_dealloc, _dealloc_WalletBarcode },
        { Py_tp_methods, _methods_WalletBarcode },
        { Py_tp_getset, _getset_WalletBarcode },
        { },
    };

    static PyType_Spec type_spec_WalletBarcode =
    {
        "_winsdk_Windows_ApplicationModel_Wallet.WalletBarcode",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletBarcode),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletBarcode
    };

    // ----- WalletItem class --------------------
    constexpr const char* const type_name_WalletItem = "WalletItem";

    static PyObject* _new_WalletItem(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletItemKind>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Wallet::WalletItem instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletItem(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletItem_get_DisplayName(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_DisplayName(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_DisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_DisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_LogoText(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LogoText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_LogoText(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.LogoText(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_BodyFontColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BodyFontColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_BodyFontColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BodyFontColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_BodyColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BodyColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_BodyColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.BodyColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_BodyBackgroundImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BodyBackgroundImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_BodyBackgroundImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.BodyBackgroundImage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_IsDisplayMessageLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsDisplayMessageLaunchable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_IsDisplayMessageLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsDisplayMessageLaunchable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_IsAcknowledged(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsAcknowledged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_IsAcknowledged(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsAcknowledged(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_IsMoreTransactionHistoryLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsMoreTransactionHistoryLaunchable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_IsMoreTransactionHistoryLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsMoreTransactionHistoryLaunchable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_HeaderFontColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HeaderFontColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_HeaderFontColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.HeaderFontColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_HeaderColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HeaderColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_HeaderColor(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.HeaderColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_HeaderBackgroundImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HeaderBackgroundImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_HeaderBackgroundImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.HeaderBackgroundImage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_ExpirationDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExpirationDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_ExpirationDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.ExpirationDate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Logo99x99(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Logo99x99());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_Logo99x99(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Logo99x99(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_LogoImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LogoImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_LogoImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.LogoImage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_PromotionalImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PromotionalImage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_PromotionalImage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.PromotionalImage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Logo159x159(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Logo159x159());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_Logo159x159(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Logo159x159(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_LastUpdated(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LastUpdated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_LastUpdated(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.LastUpdated(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_IssuerDisplayName(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IssuerDisplayName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_IssuerDisplayName(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.IssuerDisplayName(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Barcode(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Barcode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_Barcode(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletBarcode>(arg);

            self->obj.Barcode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_RelevantDateDisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelevantDateDisplayMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_RelevantDateDisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.RelevantDateDisplayMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_RelevantDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelevantDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_RelevantDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.RelevantDate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Logo336x336(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Logo336x336());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItem_put_Logo336x336(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(arg);

            self->obj.Logo336x336(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItem_get_Kind(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_DisplayProperties(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_Id(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Id());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_RelevantLocations(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RelevantLocations());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_TransactionHistory(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransactionHistory());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletItem_get_Verbs(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verbs());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WalletItem(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletItem>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletItem[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletItem), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletItem[] = {
        { "display_name", reinterpret_cast<getter>(WalletItem_get_DisplayName), reinterpret_cast<setter>(WalletItem_put_DisplayName), nullptr, nullptr },
        { "display_message", reinterpret_cast<getter>(WalletItem_get_DisplayMessage), reinterpret_cast<setter>(WalletItem_put_DisplayMessage), nullptr, nullptr },
        { "logo_text", reinterpret_cast<getter>(WalletItem_get_LogoText), reinterpret_cast<setter>(WalletItem_put_LogoText), nullptr, nullptr },
        { "body_font_color", reinterpret_cast<getter>(WalletItem_get_BodyFontColor), reinterpret_cast<setter>(WalletItem_put_BodyFontColor), nullptr, nullptr },
        { "body_color", reinterpret_cast<getter>(WalletItem_get_BodyColor), reinterpret_cast<setter>(WalletItem_put_BodyColor), nullptr, nullptr },
        { "body_background_image", reinterpret_cast<getter>(WalletItem_get_BodyBackgroundImage), reinterpret_cast<setter>(WalletItem_put_BodyBackgroundImage), nullptr, nullptr },
        { "is_display_message_launchable", reinterpret_cast<getter>(WalletItem_get_IsDisplayMessageLaunchable), reinterpret_cast<setter>(WalletItem_put_IsDisplayMessageLaunchable), nullptr, nullptr },
        { "is_acknowledged", reinterpret_cast<getter>(WalletItem_get_IsAcknowledged), reinterpret_cast<setter>(WalletItem_put_IsAcknowledged), nullptr, nullptr },
        { "is_more_transaction_history_launchable", reinterpret_cast<getter>(WalletItem_get_IsMoreTransactionHistoryLaunchable), reinterpret_cast<setter>(WalletItem_put_IsMoreTransactionHistoryLaunchable), nullptr, nullptr },
        { "header_font_color", reinterpret_cast<getter>(WalletItem_get_HeaderFontColor), reinterpret_cast<setter>(WalletItem_put_HeaderFontColor), nullptr, nullptr },
        { "header_color", reinterpret_cast<getter>(WalletItem_get_HeaderColor), reinterpret_cast<setter>(WalletItem_put_HeaderColor), nullptr, nullptr },
        { "header_background_image", reinterpret_cast<getter>(WalletItem_get_HeaderBackgroundImage), reinterpret_cast<setter>(WalletItem_put_HeaderBackgroundImage), nullptr, nullptr },
        { "expiration_date", reinterpret_cast<getter>(WalletItem_get_ExpirationDate), reinterpret_cast<setter>(WalletItem_put_ExpirationDate), nullptr, nullptr },
        { "logo99x99", reinterpret_cast<getter>(WalletItem_get_Logo99x99), reinterpret_cast<setter>(WalletItem_put_Logo99x99), nullptr, nullptr },
        { "logo_image", reinterpret_cast<getter>(WalletItem_get_LogoImage), reinterpret_cast<setter>(WalletItem_put_LogoImage), nullptr, nullptr },
        { "promotional_image", reinterpret_cast<getter>(WalletItem_get_PromotionalImage), reinterpret_cast<setter>(WalletItem_put_PromotionalImage), nullptr, nullptr },
        { "logo159x159", reinterpret_cast<getter>(WalletItem_get_Logo159x159), reinterpret_cast<setter>(WalletItem_put_Logo159x159), nullptr, nullptr },
        { "last_updated", reinterpret_cast<getter>(WalletItem_get_LastUpdated), reinterpret_cast<setter>(WalletItem_put_LastUpdated), nullptr, nullptr },
        { "issuer_display_name", reinterpret_cast<getter>(WalletItem_get_IssuerDisplayName), reinterpret_cast<setter>(WalletItem_put_IssuerDisplayName), nullptr, nullptr },
        { "barcode", reinterpret_cast<getter>(WalletItem_get_Barcode), reinterpret_cast<setter>(WalletItem_put_Barcode), nullptr, nullptr },
        { "relevant_date_display_message", reinterpret_cast<getter>(WalletItem_get_RelevantDateDisplayMessage), reinterpret_cast<setter>(WalletItem_put_RelevantDateDisplayMessage), nullptr, nullptr },
        { "relevant_date", reinterpret_cast<getter>(WalletItem_get_RelevantDate), reinterpret_cast<setter>(WalletItem_put_RelevantDate), nullptr, nullptr },
        { "logo336x336", reinterpret_cast<getter>(WalletItem_get_Logo336x336), reinterpret_cast<setter>(WalletItem_put_Logo336x336), nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(WalletItem_get_Kind), nullptr, nullptr, nullptr },
        { "display_properties", reinterpret_cast<getter>(WalletItem_get_DisplayProperties), nullptr, nullptr, nullptr },
        { "id", reinterpret_cast<getter>(WalletItem_get_Id), nullptr, nullptr, nullptr },
        { "relevant_locations", reinterpret_cast<getter>(WalletItem_get_RelevantLocations), nullptr, nullptr, nullptr },
        { "transaction_history", reinterpret_cast<getter>(WalletItem_get_TransactionHistory), nullptr, nullptr, nullptr },
        { "verbs", reinterpret_cast<getter>(WalletItem_get_Verbs), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WalletItem[] = 
    {
        { Py_tp_new, _new_WalletItem },
        { Py_tp_dealloc, _dealloc_WalletItem },
        { Py_tp_methods, _methods_WalletItem },
        { Py_tp_getset, _getset_WalletItem },
        { },
    };

    static PyType_Spec type_spec_WalletItem =
    {
        "_winsdk_Windows_ApplicationModel_Wallet.WalletItem",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletItem),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletItem
    };

    // ----- WalletItemCustomProperty class --------------------
    constexpr const char* const type_name_WalletItemCustomProperty = "WalletItemCustomProperty";

    static PyObject* _new_WalletItemCustomProperty(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::hstring>(args, 1);

                winrt::Windows::ApplicationModel::Wallet::WalletItemCustomProperty instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletItemCustomProperty(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletItemCustomProperty_get_Value(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Value());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_Value(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Value(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItemCustomProperty_get_SummaryViewPosition(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SummaryViewPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_SummaryViewPosition(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletSummaryViewPosition>(arg);

            self->obj.SummaryViewPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItemCustomProperty_get_Name(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_Name(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItemCustomProperty_get_DetailViewPosition(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DetailViewPosition());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_DetailViewPosition(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletDetailViewPosition>(arg);

            self->obj.DetailViewPosition(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletItemCustomProperty_get_AutoDetectLinks(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AutoDetectLinks());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletItemCustomProperty_put_AutoDetectLinks(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.AutoDetectLinks(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_WalletItemCustomProperty(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletItemCustomProperty>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletItemCustomProperty[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletItemCustomProperty), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletItemCustomProperty[] = {
        { "value", reinterpret_cast<getter>(WalletItemCustomProperty_get_Value), reinterpret_cast<setter>(WalletItemCustomProperty_put_Value), nullptr, nullptr },
        { "summary_view_position", reinterpret_cast<getter>(WalletItemCustomProperty_get_SummaryViewPosition), reinterpret_cast<setter>(WalletItemCustomProperty_put_SummaryViewPosition), nullptr, nullptr },
        { "name", reinterpret_cast<getter>(WalletItemCustomProperty_get_Name), reinterpret_cast<setter>(WalletItemCustomProperty_put_Name), nullptr, nullptr },
        { "detail_view_position", reinterpret_cast<getter>(WalletItemCustomProperty_get_DetailViewPosition), reinterpret_cast<setter>(WalletItemCustomProperty_put_DetailViewPosition), nullptr, nullptr },
        { "auto_detect_links", reinterpret_cast<getter>(WalletItemCustomProperty_get_AutoDetectLinks), reinterpret_cast<setter>(WalletItemCustomProperty_put_AutoDetectLinks), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WalletItemCustomProperty[] = 
    {
        { Py_tp_new, _new_WalletItemCustomProperty },
        { Py_tp_dealloc, _dealloc_WalletItemCustomProperty },
        { Py_tp_methods, _methods_WalletItemCustomProperty },
        { Py_tp_getset, _getset_WalletItemCustomProperty },
        { },
    };

    static PyType_Spec type_spec_WalletItemCustomProperty =
    {
        "_winsdk_Windows_ApplicationModel_Wallet.WalletItemCustomProperty",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemCustomProperty),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletItemCustomProperty
    };

    // ----- WalletItemStore class --------------------
    constexpr const char* const type_name_WalletItemStore = "WalletItemStore";

    static PyObject* _new_WalletItemStore(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WalletItemStore);
        return nullptr;
    }

    static void _dealloc_WalletItemStore(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletItemStore_AddAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletItem>(args, 1);

                return py::convert(self->obj.AddAsync(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_ClearAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ClearAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_DeleteAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.DeleteAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_GetItemsAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetItemsAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletItemKind>(args, 0);

                return py::convert(self->obj.GetItemsAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_GetWalletItemAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.GetWalletItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_ImportItemAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Storage::Streams::IRandomAccessStreamReference>(args, 0);

                return py::convert(self->obj.ImportItemAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_ShowAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.ShowAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.ShowAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* WalletItemStore_UpdateAsync(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::ApplicationModel::Wallet::WalletItem>(args, 0);

                return py::convert(self->obj.UpdateAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_WalletItemStore(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletItemStore>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletItemStore[] = {
        { "add_async", reinterpret_cast<PyCFunction>(WalletItemStore_AddAsync), METH_VARARGS, nullptr },
        { "clear_async", reinterpret_cast<PyCFunction>(WalletItemStore_ClearAsync), METH_VARARGS, nullptr },
        { "delete_async", reinterpret_cast<PyCFunction>(WalletItemStore_DeleteAsync), METH_VARARGS, nullptr },
        { "get_items_async", reinterpret_cast<PyCFunction>(WalletItemStore_GetItemsAsync), METH_VARARGS, nullptr },
        { "get_wallet_item_async", reinterpret_cast<PyCFunction>(WalletItemStore_GetWalletItemAsync), METH_VARARGS, nullptr },
        { "import_item_async", reinterpret_cast<PyCFunction>(WalletItemStore_ImportItemAsync), METH_VARARGS, nullptr },
        { "show_async", reinterpret_cast<PyCFunction>(WalletItemStore_ShowAsync), METH_VARARGS, nullptr },
        { "update_async", reinterpret_cast<PyCFunction>(WalletItemStore_UpdateAsync), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletItemStore), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletItemStore[] = {
        { }
    };

    static PyType_Slot _type_slots_WalletItemStore[] = 
    {
        { Py_tp_new, _new_WalletItemStore },
        { Py_tp_dealloc, _dealloc_WalletItemStore },
        { Py_tp_methods, _methods_WalletItemStore },
        { Py_tp_getset, _getset_WalletItemStore },
        { },
    };

    static PyType_Spec type_spec_WalletItemStore =
    {
        "_winsdk_Windows_ApplicationModel_Wallet.WalletItemStore",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletItemStore),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletItemStore
    };

    // ----- WalletManager class --------------------
    constexpr const char* const type_name_WalletManager = "WalletManager";

    static PyObject* _new_WalletManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WalletManager);
        return nullptr;
    }

    static PyObject* WalletManager_RequestStoreAsync(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::ApplicationModel::Wallet::WalletManager::RequestStoreAsync());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletManager[] = {
        { "request_store_async", reinterpret_cast<PyCFunction>(WalletManager_RequestStoreAsync), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletManager[] = {
        { }
    };

    static PyType_Slot _type_slots_WalletManager[] = 
    {
        { Py_tp_new, _new_WalletManager },
        { Py_tp_methods, _methods_WalletManager },
        { Py_tp_getset, _getset_WalletManager },
        { },
    };

    static PyType_Spec type_spec_WalletManager =
    {
        "_winsdk_Windows_ApplicationModel_Wallet.WalletManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletManager
    };

    // ----- WalletRelevantLocation class --------------------
    constexpr const char* const type_name_WalletRelevantLocation = "WalletRelevantLocation";

    static PyObject* _new_WalletRelevantLocation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Wallet::WalletRelevantLocation instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletRelevantLocation(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletRelevantLocation_get_Position(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Position());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletRelevantLocation_put_Position(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Geolocation::BasicGeoposition>(arg);

            self->obj.Position(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletRelevantLocation_get_DisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayMessage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletRelevantLocation_put_DisplayMessage(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayMessage(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_WalletRelevantLocation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletRelevantLocation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletRelevantLocation[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletRelevantLocation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletRelevantLocation[] = {
        { "position", reinterpret_cast<getter>(WalletRelevantLocation_get_Position), reinterpret_cast<setter>(WalletRelevantLocation_put_Position), nullptr, nullptr },
        { "display_message", reinterpret_cast<getter>(WalletRelevantLocation_get_DisplayMessage), reinterpret_cast<setter>(WalletRelevantLocation_put_DisplayMessage), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WalletRelevantLocation[] = 
    {
        { Py_tp_new, _new_WalletRelevantLocation },
        { Py_tp_dealloc, _dealloc_WalletRelevantLocation },
        { Py_tp_methods, _methods_WalletRelevantLocation },
        { Py_tp_getset, _getset_WalletRelevantLocation },
        { },
    };

    static PyType_Spec type_spec_WalletRelevantLocation =
    {
        "_winsdk_Windows_ApplicationModel_Wallet.WalletRelevantLocation",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletRelevantLocation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletRelevantLocation
    };

    // ----- WalletTransaction class --------------------
    constexpr const char* const type_name_WalletTransaction = "WalletTransaction";

    static PyObject* _new_WalletTransaction(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::ApplicationModel::Wallet::WalletTransaction instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletTransaction(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletTransaction_get_TransactionDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TransactionDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_TransactionDate(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::IReference<winrt::Windows::Foundation::DateTime>>(arg);

            self->obj.TransactionDate(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_IsLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsLaunchable());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_IsLaunchable(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsLaunchable(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_IgnoreTimeOfDay(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IgnoreTimeOfDay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_IgnoreTimeOfDay(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IgnoreTimeOfDay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_DisplayLocation(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_DisplayLocation(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayLocation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_DisplayAmount(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DisplayAmount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_DisplayAmount(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.DisplayAmount(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* WalletTransaction_get_Description(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Description());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletTransaction_put_Description(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Description(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_WalletTransaction(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletTransaction>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletTransaction[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletTransaction), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletTransaction[] = {
        { "transaction_date", reinterpret_cast<getter>(WalletTransaction_get_TransactionDate), reinterpret_cast<setter>(WalletTransaction_put_TransactionDate), nullptr, nullptr },
        { "is_launchable", reinterpret_cast<getter>(WalletTransaction_get_IsLaunchable), reinterpret_cast<setter>(WalletTransaction_put_IsLaunchable), nullptr, nullptr },
        { "ignore_time_of_day", reinterpret_cast<getter>(WalletTransaction_get_IgnoreTimeOfDay), reinterpret_cast<setter>(WalletTransaction_put_IgnoreTimeOfDay), nullptr, nullptr },
        { "display_location", reinterpret_cast<getter>(WalletTransaction_get_DisplayLocation), reinterpret_cast<setter>(WalletTransaction_put_DisplayLocation), nullptr, nullptr },
        { "display_amount", reinterpret_cast<getter>(WalletTransaction_get_DisplayAmount), reinterpret_cast<setter>(WalletTransaction_put_DisplayAmount), nullptr, nullptr },
        { "description", reinterpret_cast<getter>(WalletTransaction_get_Description), reinterpret_cast<setter>(WalletTransaction_put_Description), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WalletTransaction[] = 
    {
        { Py_tp_new, _new_WalletTransaction },
        { Py_tp_dealloc, _dealloc_WalletTransaction },
        { Py_tp_methods, _methods_WalletTransaction },
        { Py_tp_getset, _getset_WalletTransaction },
        { },
    };

    static PyType_Spec type_spec_WalletTransaction =
    {
        "_winsdk_Windows_ApplicationModel_Wallet.WalletTransaction",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletTransaction),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletTransaction
    };

    // ----- WalletVerb class --------------------
    constexpr const char* const type_name_WalletVerb = "WalletVerb";

    static PyObject* _new_WalletVerb(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::ApplicationModel::Wallet::WalletVerb instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_WalletVerb(py::wrapper::Windows::ApplicationModel::Wallet::WalletVerb* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletVerb_get_Name(py::wrapper::Windows::ApplicationModel::Wallet::WalletVerb* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Name());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int WalletVerb_put_Name(py::wrapper::Windows::ApplicationModel::Wallet::WalletVerb* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::hstring>(arg);

            self->obj.Name(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_WalletVerb(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Wallet::WalletVerb>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletVerb[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletVerb), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletVerb[] = {
        { "name", reinterpret_cast<getter>(WalletVerb_get_Name), reinterpret_cast<setter>(WalletVerb_put_Name), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WalletVerb[] = 
    {
        { Py_tp_new, _new_WalletVerb },
        { Py_tp_dealloc, _dealloc_WalletVerb },
        { Py_tp_methods, _methods_WalletVerb },
        { Py_tp_getset, _getset_WalletVerb },
        { },
    };

    static PyType_Spec type_spec_WalletVerb =
    {
        "_winsdk_Windows_ApplicationModel_Wallet.WalletVerb",
        sizeof(py::wrapper::Windows::ApplicationModel::Wallet::WalletVerb),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletVerb
    };

    // ----- Windows.ApplicationModel.Wallet Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Wallet");

    static PyMethodDef module_methods[] = {
        {"_register_WalletActionKind", register_WalletActionKind, METH_O, "registers type"},
        {"_register_WalletBarcodeSymbology", register_WalletBarcodeSymbology, METH_O, "registers type"},
        {"_register_WalletDetailViewPosition", register_WalletDetailViewPosition, METH_O, "registers type"},
        {"_register_WalletItemKind", register_WalletItemKind, METH_O, "registers type"},
        {"_register_WalletSummaryViewPosition", register_WalletSummaryViewPosition, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_WalletActionKind);
        Py_VISIT(state->type_WalletBarcodeSymbology);
        Py_VISIT(state->type_WalletDetailViewPosition);
        Py_VISIT(state->type_WalletItemKind);
        Py_VISIT(state->type_WalletSummaryViewPosition);
        Py_VISIT(state->type_WalletBarcode);
        Py_VISIT(state->type_WalletItem);
        Py_VISIT(state->type_WalletItemCustomProperty);
        Py_VISIT(state->type_WalletItemStore);
        Py_VISIT(state->type_WalletManager);
        Py_VISIT(state->type_WalletRelevantLocation);
        Py_VISIT(state->type_WalletTransaction);
        Py_VISIT(state->type_WalletVerb);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_WalletActionKind);
        Py_CLEAR(state->type_WalletBarcodeSymbology);
        Py_CLEAR(state->type_WalletDetailViewPosition);
        Py_CLEAR(state->type_WalletItemKind);
        Py_CLEAR(state->type_WalletSummaryViewPosition);
        Py_CLEAR(state->type_WalletBarcode);
        Py_CLEAR(state->type_WalletItem);
        Py_CLEAR(state->type_WalletItemCustomProperty);
        Py_CLEAR(state->type_WalletItemStore);
        Py_CLEAR(state->type_WalletManager);
        Py_CLEAR(state->type_WalletRelevantLocation);
        Py_CLEAR(state->type_WalletTransaction);
        Py_CLEAR(state->type_WalletVerb);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_Wallet",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Wallet

PyMODINIT_FUNC PyInit__winsdk_Windows_ApplicationModel_Wallet(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_WalletBarcode = py::register_python_type(module.get(), type_name_WalletBarcode, &type_spec_WalletBarcode, bases.get());
    if (!state->type_WalletBarcode)
    {
        return nullptr;
    }

    Py_INCREF(state->type_WalletBarcode);

    state->type_WalletItem = py::register_python_type(module.get(), type_name_WalletItem, &type_spec_WalletItem, bases.get());
    if (!state->type_WalletItem)
    {
        return nullptr;
    }

    Py_INCREF(state->type_WalletItem);

    state->type_WalletItemCustomProperty = py::register_python_type(module.get(), type_name_WalletItemCustomProperty, &type_spec_WalletItemCustomProperty, bases.get());
    if (!state->type_WalletItemCustomProperty)
    {
        return nullptr;
    }

    Py_INCREF(state->type_WalletItemCustomProperty);

    state->type_WalletItemStore = py::register_python_type(module.get(), type_name_WalletItemStore, &type_spec_WalletItemStore, bases.get());
    if (!state->type_WalletItemStore)
    {
        return nullptr;
    }

    Py_INCREF(state->type_WalletItemStore);

    state->type_WalletManager = py::register_python_type(module.get(), type_name_WalletManager, &type_spec_WalletManager, nullptr);
    if (!state->type_WalletManager)
    {
        return nullptr;
    }

    Py_INCREF(state->type_WalletManager);

    state->type_WalletRelevantLocation = py::register_python_type(module.get(), type_name_WalletRelevantLocation, &type_spec_WalletRelevantLocation, bases.get());
    if (!state->type_WalletRelevantLocation)
    {
        return nullptr;
    }

    Py_INCREF(state->type_WalletRelevantLocation);

    state->type_WalletTransaction = py::register_python_type(module.get(), type_name_WalletTransaction, &type_spec_WalletTransaction, bases.get());
    if (!state->type_WalletTransaction)
    {
        return nullptr;
    }

    Py_INCREF(state->type_WalletTransaction);

    state->type_WalletVerb = py::register_python_type(module.get(), type_name_WalletVerb, &type_spec_WalletVerb, bases.get());
    if (!state->type_WalletVerb)
    {
        return nullptr;
    }

    Py_INCREF(state->type_WalletVerb);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Wallet::WalletActionKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Wallet");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WalletActionKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Wallet::WalletActionKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Wallet::WalletBarcodeSymbology>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Wallet");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WalletBarcodeSymbology;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Wallet::WalletBarcodeSymbology is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Wallet::WalletDetailViewPosition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Wallet");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WalletDetailViewPosition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Wallet::WalletDetailViewPosition is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Wallet::WalletItemKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Wallet");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WalletItemKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Wallet::WalletItemKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Wallet::WalletSummaryViewPosition>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Wallet");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WalletSummaryViewPosition;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Wallet::WalletSummaryViewPosition is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Wallet::WalletBarcode>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Wallet");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WalletBarcode;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Wallet::WalletBarcode is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Wallet::WalletItem>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Wallet");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WalletItem;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Wallet::WalletItem is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Wallet::WalletItemCustomProperty>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Wallet");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WalletItemCustomProperty;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Wallet::WalletItemCustomProperty is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Wallet::WalletItemStore>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Wallet");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WalletItemStore;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Wallet::WalletItemStore is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Wallet::WalletManager>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Wallet");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WalletManager;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Wallet::WalletManager is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Wallet::WalletRelevantLocation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Wallet");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WalletRelevantLocation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Wallet::WalletRelevantLocation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Wallet::WalletTransaction>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Wallet");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WalletTransaction;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Wallet::WalletTransaction is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Wallet::WalletVerb>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Wallet;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Wallet");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WalletVerb;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Wallet::WalletVerb is not registered");
        return nullptr;
    }

    return python_type;
}
