// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Media.Effects.h"

PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::AudioCaptureEffectsManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::AudioEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::AudioEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::AudioEffectsManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::AudioRenderEffectsManager>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::CompositeVideoFrameContext>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::ProcessAudioFrameContext>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::ProcessVideoFrameContext>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::VideoCompositorDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::VideoEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::VideoTransformEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::VideoTransformSphericalProjection>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::IAudioEffectDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::IBasicAudioEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::IBasicVideoEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::IVideoCompositor>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::IVideoCompositorDefinition>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Media::Effects::IVideoEffectDefinition>::python_type;

namespace py::cpp::Windows::Media::Effects
{
    // ----- AudioCaptureEffectsManager class --------------------
    constexpr const char* const _type_name_AudioCaptureEffectsManager = "AudioCaptureEffectsManager";

    static PyObject* _new_AudioCaptureEffectsManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioCaptureEffectsManager);
        return nullptr;
    }

    static void _dealloc_AudioCaptureEffectsManager(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioCaptureEffectsManager_GetAudioCaptureEffects(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioCaptureEffects());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioCaptureEffectsManager_add_AudioCaptureEffectsChanged(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Effects::AudioCaptureEffectsManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioCaptureEffectsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioCaptureEffectsManager_remove_AudioCaptureEffectsChanged(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioCaptureEffectsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioCaptureEffectsManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::AudioCaptureEffectsManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioCaptureEffectsManager[] = {
        { "get_audio_capture_effects", reinterpret_cast<PyCFunction>(AudioCaptureEffectsManager_GetAudioCaptureEffects), METH_VARARGS, nullptr },
        { "add_audio_capture_effects_changed", reinterpret_cast<PyCFunction>(AudioCaptureEffectsManager_add_AudioCaptureEffectsChanged), METH_O, nullptr },
        { "remove_audio_capture_effects_changed", reinterpret_cast<PyCFunction>(AudioCaptureEffectsManager_remove_AudioCaptureEffectsChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioCaptureEffectsManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioCaptureEffectsManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AudioCaptureEffectsManager[] = 
    {
        { Py_tp_new, _new_AudioCaptureEffectsManager },
        { Py_tp_dealloc, _dealloc_AudioCaptureEffectsManager },
        { Py_tp_methods, _methods_AudioCaptureEffectsManager },
        { Py_tp_getset, _getset_AudioCaptureEffectsManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioCaptureEffectsManager =
    {
        "_winsdk_Windows_Media_Effects.AudioCaptureEffectsManager",
        sizeof(py::wrapper::Windows::Media::Effects::AudioCaptureEffectsManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioCaptureEffectsManager
    };

    // ----- AudioEffect class --------------------
    constexpr const char* const _type_name_AudioEffect = "AudioEffect";

    static PyObject* _new_AudioEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioEffect);
        return nullptr;
    }

    static void _dealloc_AudioEffect(py::wrapper::Windows::Media::Effects::AudioEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioEffect_get_AudioEffectType(py::wrapper::Windows::Media::Effects::AudioEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AudioEffectType());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::AudioEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioEffect[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioEffect[] = {
        { "audio_effect_type", reinterpret_cast<getter>(AudioEffect_get_AudioEffectType), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioEffect[] = 
    {
        { Py_tp_new, _new_AudioEffect },
        { Py_tp_dealloc, _dealloc_AudioEffect },
        { Py_tp_methods, _methods_AudioEffect },
        { Py_tp_getset, _getset_AudioEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioEffect =
    {
        "_winsdk_Windows_Media_Effects.AudioEffect",
        sizeof(py::wrapper::Windows::Media::Effects::AudioEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioEffect
    };

    // ----- AudioEffectDefinition class --------------------
    constexpr const char* const _type_name_AudioEffectDefinition = "AudioEffectDefinition";

    static PyObject* _new_AudioEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Media::Effects::AudioEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 1);

                winrt::Windows::Media::Effects::AudioEffectDefinition instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_AudioEffectDefinition(py::wrapper::Windows::Media::Effects::AudioEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::AudioEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::AudioEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::AudioEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(AudioEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(AudioEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioEffectDefinition[] = 
    {
        { Py_tp_new, _new_AudioEffectDefinition },
        { Py_tp_dealloc, _dealloc_AudioEffectDefinition },
        { Py_tp_methods, _methods_AudioEffectDefinition },
        { Py_tp_getset, _getset_AudioEffectDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioEffectDefinition =
    {
        "_winsdk_Windows_Media_Effects.AudioEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::AudioEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioEffectDefinition
    };

    // ----- AudioEffectsManager class --------------------
    constexpr const char* const _type_name_AudioEffectsManager = "AudioEffectsManager";

    static PyObject* _new_AudioEffectsManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioEffectsManager);
        return nullptr;
    }

    static PyObject* AudioEffectsManager_CreateAudioCaptureEffectsManager(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 1);

                return py::convert(winrt::Windows::Media::Effects::AudioEffectsManager::CreateAudioCaptureEffectsManager(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Capture::MediaCategory>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::AudioProcessing>(args, 2);

                return py::convert(winrt::Windows::Media::Effects::AudioEffectsManager::CreateAudioCaptureEffectsManager(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioEffectsManager_CreateAudioRenderEffectsManager(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 1);

                return py::convert(winrt::Windows::Media::Effects::AudioEffectsManager::CreateAudioRenderEffectsManager(param0, param1));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 3)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Media::Render::AudioRenderCategory>(args, 1);
                auto param2 = py::convert_to<winrt::Windows::Media::AudioProcessing>(args, 2);

                return py::convert(winrt::Windows::Media::Effects::AudioEffectsManager::CreateAudioRenderEffectsManager(param0, param1, param2));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioEffectsManager[] = {
        { "create_audio_capture_effects_manager", reinterpret_cast<PyCFunction>(AudioEffectsManager_CreateAudioCaptureEffectsManager), METH_VARARGS | METH_STATIC, nullptr },
        { "create_audio_render_effects_manager", reinterpret_cast<PyCFunction>(AudioEffectsManager_CreateAudioRenderEffectsManager), METH_VARARGS | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioEffectsManager[] = {
        { }
    };

    static PyType_Slot _type_slots_AudioEffectsManager[] = 
    {
        { Py_tp_new, _new_AudioEffectsManager },
        { Py_tp_methods, _methods_AudioEffectsManager },
        { Py_tp_getset, _getset_AudioEffectsManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioEffectsManager =
    {
        "_winsdk_Windows_Media_Effects.AudioEffectsManager",
        0,
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioEffectsManager
    };

    // ----- AudioRenderEffectsManager class --------------------
    constexpr const char* const _type_name_AudioRenderEffectsManager = "AudioRenderEffectsManager";

    static PyObject* _new_AudioRenderEffectsManager(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_AudioRenderEffectsManager);
        return nullptr;
    }

    static void _dealloc_AudioRenderEffectsManager(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* AudioRenderEffectsManager_GetAudioRenderEffects(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAudioRenderEffects());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_ShowSettingsUI(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.ShowSettingsUI();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_get_EffectsProviderSettingsLabel(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectsProviderSettingsLabel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_get_EffectsProviderThumbnail(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectsProviderThumbnail());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_add_AudioRenderEffectsChanged(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Media::Effects::AudioRenderEffectsManager, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.AudioRenderEffectsChanged(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AudioRenderEffectsManager_remove_AudioRenderEffectsChanged(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.AudioRenderEffectsChanged(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AudioRenderEffectsManager(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::AudioRenderEffectsManager>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AudioRenderEffectsManager[] = {
        { "get_audio_render_effects", reinterpret_cast<PyCFunction>(AudioRenderEffectsManager_GetAudioRenderEffects), METH_VARARGS, nullptr },
        { "show_settings_u_i", reinterpret_cast<PyCFunction>(AudioRenderEffectsManager_ShowSettingsUI), METH_VARARGS, nullptr },
        { "add_audio_render_effects_changed", reinterpret_cast<PyCFunction>(AudioRenderEffectsManager_add_AudioRenderEffectsChanged), METH_O, nullptr },
        { "remove_audio_render_effects_changed", reinterpret_cast<PyCFunction>(AudioRenderEffectsManager_remove_AudioRenderEffectsChanged), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_AudioRenderEffectsManager), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AudioRenderEffectsManager[] = {
        { "effects_provider_settings_label", reinterpret_cast<getter>(AudioRenderEffectsManager_get_EffectsProviderSettingsLabel), nullptr, nullptr, nullptr },
        { "effects_provider_thumbnail", reinterpret_cast<getter>(AudioRenderEffectsManager_get_EffectsProviderThumbnail), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AudioRenderEffectsManager[] = 
    {
        { Py_tp_new, _new_AudioRenderEffectsManager },
        { Py_tp_dealloc, _dealloc_AudioRenderEffectsManager },
        { Py_tp_methods, _methods_AudioRenderEffectsManager },
        { Py_tp_getset, _getset_AudioRenderEffectsManager },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_AudioRenderEffectsManager =
    {
        "_winsdk_Windows_Media_Effects.AudioRenderEffectsManager",
        sizeof(py::wrapper::Windows::Media::Effects::AudioRenderEffectsManager),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AudioRenderEffectsManager
    };

    // ----- CompositeVideoFrameContext class --------------------
    constexpr const char* const _type_name_CompositeVideoFrameContext = "CompositeVideoFrameContext";

    static PyObject* _new_CompositeVideoFrameContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_CompositeVideoFrameContext);
        return nullptr;
    }

    static void _dealloc_CompositeVideoFrameContext(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* CompositeVideoFrameContext_GetOverlayForSurface(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DSurface>(args, 0);

                return py::convert(self->obj.GetOverlayForSurface(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CompositeVideoFrameContext_get_BackgroundFrame(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BackgroundFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeVideoFrameContext_get_OutputFrame(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CompositeVideoFrameContext_get_SurfacesToOverlay(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SurfacesToOverlay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CompositeVideoFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::CompositeVideoFrameContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CompositeVideoFrameContext[] = {
        { "get_overlay_for_surface", reinterpret_cast<PyCFunction>(CompositeVideoFrameContext_GetOverlayForSurface), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CompositeVideoFrameContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CompositeVideoFrameContext[] = {
        { "background_frame", reinterpret_cast<getter>(CompositeVideoFrameContext_get_BackgroundFrame), nullptr, nullptr, nullptr },
        { "output_frame", reinterpret_cast<getter>(CompositeVideoFrameContext_get_OutputFrame), nullptr, nullptr, nullptr },
        { "surfaces_to_overlay", reinterpret_cast<getter>(CompositeVideoFrameContext_get_SurfacesToOverlay), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CompositeVideoFrameContext[] = 
    {
        { Py_tp_new, _new_CompositeVideoFrameContext },
        { Py_tp_dealloc, _dealloc_CompositeVideoFrameContext },
        { Py_tp_methods, _methods_CompositeVideoFrameContext },
        { Py_tp_getset, _getset_CompositeVideoFrameContext },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_CompositeVideoFrameContext =
    {
        "_winsdk_Windows_Media_Effects.CompositeVideoFrameContext",
        sizeof(py::wrapper::Windows::Media::Effects::CompositeVideoFrameContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CompositeVideoFrameContext
    };

    // ----- ProcessAudioFrameContext class --------------------
    constexpr const char* const _type_name_ProcessAudioFrameContext = "ProcessAudioFrameContext";

    static PyObject* _new_ProcessAudioFrameContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessAudioFrameContext);
        return nullptr;
    }

    static void _dealloc_ProcessAudioFrameContext(py::wrapper::Windows::Media::Effects::ProcessAudioFrameContext* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessAudioFrameContext_get_InputFrame(py::wrapper::Windows::Media::Effects::ProcessAudioFrameContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessAudioFrameContext_get_OutputFrame(py::wrapper::Windows::Media::Effects::ProcessAudioFrameContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProcessAudioFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::ProcessAudioFrameContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessAudioFrameContext[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessAudioFrameContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessAudioFrameContext[] = {
        { "input_frame", reinterpret_cast<getter>(ProcessAudioFrameContext_get_InputFrame), nullptr, nullptr, nullptr },
        { "output_frame", reinterpret_cast<getter>(ProcessAudioFrameContext_get_OutputFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessAudioFrameContext[] = 
    {
        { Py_tp_new, _new_ProcessAudioFrameContext },
        { Py_tp_dealloc, _dealloc_ProcessAudioFrameContext },
        { Py_tp_methods, _methods_ProcessAudioFrameContext },
        { Py_tp_getset, _getset_ProcessAudioFrameContext },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessAudioFrameContext =
    {
        "_winsdk_Windows_Media_Effects.ProcessAudioFrameContext",
        sizeof(py::wrapper::Windows::Media::Effects::ProcessAudioFrameContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessAudioFrameContext
    };

    // ----- ProcessVideoFrameContext class --------------------
    constexpr const char* const _type_name_ProcessVideoFrameContext = "ProcessVideoFrameContext";

    static PyObject* _new_ProcessVideoFrameContext(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessVideoFrameContext);
        return nullptr;
    }

    static void _dealloc_ProcessVideoFrameContext(py::wrapper::Windows::Media::Effects::ProcessVideoFrameContext* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessVideoFrameContext_get_InputFrame(py::wrapper::Windows::Media::Effects::ProcessVideoFrameContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessVideoFrameContext_get_OutputFrame(py::wrapper::Windows::Media::Effects::ProcessVideoFrameContext* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputFrame());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProcessVideoFrameContext(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::ProcessVideoFrameContext>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessVideoFrameContext[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessVideoFrameContext), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessVideoFrameContext[] = {
        { "input_frame", reinterpret_cast<getter>(ProcessVideoFrameContext_get_InputFrame), nullptr, nullptr, nullptr },
        { "output_frame", reinterpret_cast<getter>(ProcessVideoFrameContext_get_OutputFrame), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessVideoFrameContext[] = 
    {
        { Py_tp_new, _new_ProcessVideoFrameContext },
        { Py_tp_dealloc, _dealloc_ProcessVideoFrameContext },
        { Py_tp_methods, _methods_ProcessVideoFrameContext },
        { Py_tp_getset, _getset_ProcessVideoFrameContext },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessVideoFrameContext =
    {
        "_winsdk_Windows_Media_Effects.ProcessVideoFrameContext",
        sizeof(py::wrapper::Windows::Media::Effects::ProcessVideoFrameContext),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessVideoFrameContext
    };

    // ----- VideoCompositorDefinition class --------------------
    constexpr const char* const _type_name_VideoCompositorDefinition = "VideoCompositorDefinition";

    static PyObject* _new_VideoCompositorDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Media::Effects::VideoCompositorDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 1);

                winrt::Windows::Media::Effects::VideoCompositorDefinition instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoCompositorDefinition(py::wrapper::Windows::Media::Effects::VideoCompositorDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoCompositorDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::VideoCompositorDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoCompositorDefinition_get_Properties(py::wrapper::Windows::Media::Effects::VideoCompositorDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoCompositorDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::VideoCompositorDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoCompositorDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoCompositorDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoCompositorDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(VideoCompositorDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoCompositorDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoCompositorDefinition[] = 
    {
        { Py_tp_new, _new_VideoCompositorDefinition },
        { Py_tp_dealloc, _dealloc_VideoCompositorDefinition },
        { Py_tp_methods, _methods_VideoCompositorDefinition },
        { Py_tp_getset, _getset_VideoCompositorDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoCompositorDefinition =
    {
        "_winsdk_Windows_Media_Effects.VideoCompositorDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::VideoCompositorDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoCompositorDefinition
    };

    // ----- VideoEffectDefinition class --------------------
    constexpr const char* const _type_name_VideoEffectDefinition = "VideoEffectDefinition";

    static PyObject* _new_VideoEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                winrt::Windows::Media::Effects::VideoEffectDefinition instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 1);

                winrt::Windows::Media::Effects::VideoEffectDefinition instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoEffectDefinition(py::wrapper::Windows::Media::Effects::VideoEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::VideoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::VideoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::VideoEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(VideoEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoEffectDefinition[] = 
    {
        { Py_tp_new, _new_VideoEffectDefinition },
        { Py_tp_dealloc, _dealloc_VideoEffectDefinition },
        { Py_tp_methods, _methods_VideoEffectDefinition },
        { Py_tp_getset, _getset_VideoEffectDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoEffectDefinition =
    {
        "_winsdk_Windows_Media_Effects.VideoEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::VideoEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoEffectDefinition
    };

    // ----- VideoTransformEffectDefinition class --------------------
    constexpr const char* const _type_name_VideoTransformEffectDefinition = "VideoTransformEffectDefinition";

    static PyObject* _new_VideoTransformEffectDefinition(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Media::Effects::VideoTransformEffectDefinition instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_VideoTransformEffectDefinition(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoTransformEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_Rotation(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_Rotation(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaRotation>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_ProcessingAlgorithm(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProcessingAlgorithm());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_ProcessingAlgorithm(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Transcoding::MediaVideoProcessingAlgorithm>(arg);

            self->obj.ProcessingAlgorithm(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_PaddingColor(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PaddingColor());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_PaddingColor(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.PaddingColor(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_OutputSize(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OutputSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_OutputSize(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Size>(arg);

            self->obj.OutputSize(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_Mirror(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Mirror());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_Mirror(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::MediaMirroringOptions>(arg);

            self->obj.Mirror(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_CropRectangle(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CropRectangle());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformEffectDefinition_put_CropRectangle(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Rect>(arg);

            self->obj.CropRectangle(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformEffectDefinition_get_SphericalProjection(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SphericalProjection());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VideoTransformEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::VideoTransformEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTransformEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTransformEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTransformEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_Rotation), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_Rotation), nullptr, nullptr },
        { "processing_algorithm", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_ProcessingAlgorithm), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_ProcessingAlgorithm), nullptr, nullptr },
        { "padding_color", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_PaddingColor), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_PaddingColor), nullptr, nullptr },
        { "output_size", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_OutputSize), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_OutputSize), nullptr, nullptr },
        { "mirror", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_Mirror), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_Mirror), nullptr, nullptr },
        { "crop_rectangle", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_CropRectangle), reinterpret_cast<setter>(VideoTransformEffectDefinition_put_CropRectangle), nullptr, nullptr },
        { "spherical_projection", reinterpret_cast<getter>(VideoTransformEffectDefinition_get_SphericalProjection), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTransformEffectDefinition[] = 
    {
        { Py_tp_new, _new_VideoTransformEffectDefinition },
        { Py_tp_dealloc, _dealloc_VideoTransformEffectDefinition },
        { Py_tp_methods, _methods_VideoTransformEffectDefinition },
        { Py_tp_getset, _getset_VideoTransformEffectDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoTransformEffectDefinition =
    {
        "_winsdk_Windows_Media_Effects.VideoTransformEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::VideoTransformEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTransformEffectDefinition
    };

    // ----- VideoTransformSphericalProjection class --------------------
    constexpr const char* const _type_name_VideoTransformSphericalProjection = "VideoTransformSphericalProjection";

    static PyObject* _new_VideoTransformSphericalProjection(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_VideoTransformSphericalProjection);
        return nullptr;
    }

    static void _dealloc_VideoTransformSphericalProjection(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* VideoTransformSphericalProjection_get_ViewOrientation(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ViewOrientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_ViewOrientation(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::Numerics::quaternion>(arg);

            self->obj.ViewOrientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformSphericalProjection_get_ProjectionMode(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProjectionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_ProjectionMode(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::Playback::SphericalVideoProjectionMode>(arg);

            self->obj.ProjectionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformSphericalProjection_get_IsEnabled(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsEnabled());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_IsEnabled(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<bool>(arg);

            self->obj.IsEnabled(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformSphericalProjection_get_HorizontalFieldOfViewInDegrees(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.HorizontalFieldOfViewInDegrees());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_HorizontalFieldOfViewInDegrees(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.HorizontalFieldOfViewInDegrees(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* VideoTransformSphericalProjection_get_FrameFormat(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FrameFormat());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int VideoTransformSphericalProjection_put_FrameFormat(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::SphericalVideoFrameFormat>(arg);

            self->obj.FrameFormat(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_VideoTransformSphericalProjection(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::VideoTransformSphericalProjection>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VideoTransformSphericalProjection[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VideoTransformSphericalProjection), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VideoTransformSphericalProjection[] = {
        { "view_orientation", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_ViewOrientation), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_ViewOrientation), nullptr, nullptr },
        { "projection_mode", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_ProjectionMode), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_ProjectionMode), nullptr, nullptr },
        { "is_enabled", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_IsEnabled), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_IsEnabled), nullptr, nullptr },
        { "horizontal_field_of_view_in_degrees", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_HorizontalFieldOfViewInDegrees), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_HorizontalFieldOfViewInDegrees), nullptr, nullptr },
        { "frame_format", reinterpret_cast<getter>(VideoTransformSphericalProjection_get_FrameFormat), reinterpret_cast<setter>(VideoTransformSphericalProjection_put_FrameFormat), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VideoTransformSphericalProjection[] = 
    {
        { Py_tp_new, _new_VideoTransformSphericalProjection },
        { Py_tp_dealloc, _dealloc_VideoTransformSphericalProjection },
        { Py_tp_methods, _methods_VideoTransformSphericalProjection },
        { Py_tp_getset, _getset_VideoTransformSphericalProjection },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_VideoTransformSphericalProjection =
    {
        "_winsdk_Windows_Media_Effects.VideoTransformSphericalProjection",
        sizeof(py::wrapper::Windows::Media::Effects::VideoTransformSphericalProjection),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VideoTransformSphericalProjection
    };

    // ----- IAudioEffectDefinition interface --------------------
    constexpr const char* const _type_name_IAudioEffectDefinition = "IAudioEffectDefinition";

    static PyObject* _new_IAudioEffectDefinition(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IAudioEffectDefinition);
        return nullptr;
    }

    static void _dealloc_IAudioEffectDefinition(py::wrapper::Windows::Media::Effects::IAudioEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IAudioEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::IAudioEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAudioEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::IAudioEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IAudioEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IAudioEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAudioEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IAudioEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAudioEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(IAudioEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IAudioEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAudioEffectDefinition[] = 
    {
        { Py_tp_new, _new_IAudioEffectDefinition },
        { Py_tp_dealloc, _dealloc_IAudioEffectDefinition },
        { Py_tp_methods, _methods_IAudioEffectDefinition },
        { Py_tp_getset, _getset_IAudioEffectDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IAudioEffectDefinition =
    {
        "_winsdk_Windows_Media_Effects.IAudioEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::IAudioEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAudioEffectDefinition
    };

    // ----- IBasicAudioEffect interface --------------------
    constexpr const char* const _type_name_IBasicAudioEffect = "IBasicAudioEffect";

    static PyObject* _new_IBasicAudioEffect(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBasicAudioEffect);
        return nullptr;
    }

    static void _dealloc_IBasicAudioEffect(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBasicAudioEffect_Close(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::MediaEffectClosedReason>(args, 0);

                self->obj.Close(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_DiscardQueuedFrames(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.DiscardQueuedFrames();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_ProcessFrame(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::ProcessAudioFrameContext>(args, 0);

                self->obj.ProcessFrame(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_SetEncodingProperties(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::AudioEncodingProperties>(args, 0);

                self->obj.SetEncodingProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_SetProperties(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_get_SupportedEncodingProperties(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedEncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBasicAudioEffect_get_UseInputFrameForOutput(py::wrapper::Windows::Media::Effects::IBasicAudioEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UseInputFrameForOutput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBasicAudioEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IBasicAudioEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBasicAudioEffect[] = {
        { "close", reinterpret_cast<PyCFunction>(IBasicAudioEffect_Close), METH_VARARGS, nullptr },
        { "discard_queued_frames", reinterpret_cast<PyCFunction>(IBasicAudioEffect_DiscardQueuedFrames), METH_VARARGS, nullptr },
        { "process_frame", reinterpret_cast<PyCFunction>(IBasicAudioEffect_ProcessFrame), METH_VARARGS, nullptr },
        { "set_encoding_properties", reinterpret_cast<PyCFunction>(IBasicAudioEffect_SetEncodingProperties), METH_VARARGS, nullptr },
        { "set_properties", reinterpret_cast<PyCFunction>(IBasicAudioEffect_SetProperties), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBasicAudioEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBasicAudioEffect[] = {
        { "supported_encoding_properties", reinterpret_cast<getter>(IBasicAudioEffect_get_SupportedEncodingProperties), nullptr, nullptr, nullptr },
        { "use_input_frame_for_output", reinterpret_cast<getter>(IBasicAudioEffect_get_UseInputFrameForOutput), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBasicAudioEffect[] = 
    {
        { Py_tp_new, _new_IBasicAudioEffect },
        { Py_tp_dealloc, _dealloc_IBasicAudioEffect },
        { Py_tp_methods, _methods_IBasicAudioEffect },
        { Py_tp_getset, _getset_IBasicAudioEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBasicAudioEffect =
    {
        "_winsdk_Windows_Media_Effects.IBasicAudioEffect",
        sizeof(py::wrapper::Windows::Media::Effects::IBasicAudioEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBasicAudioEffect
    };

    // ----- IBasicVideoEffect interface --------------------
    constexpr const char* const _type_name_IBasicVideoEffect = "IBasicVideoEffect";

    static PyObject* _new_IBasicVideoEffect(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IBasicVideoEffect);
        return nullptr;
    }

    static void _dealloc_IBasicVideoEffect(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IBasicVideoEffect_Close(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::MediaEffectClosedReason>(args, 0);

                self->obj.Close(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_DiscardQueuedFrames(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.DiscardQueuedFrames();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_ProcessFrame(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::ProcessVideoFrameContext>(args, 0);

                self->obj.ProcessFrame(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_SetEncodingProperties(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 1);

                self->obj.SetEncodingProperties(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_SetProperties(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_get_IsReadOnly(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsReadOnly());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_get_SupportedEncodingProperties(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedEncodingProperties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_get_SupportedMemoryTypes(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SupportedMemoryTypes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBasicVideoEffect_get_TimeIndependent(py::wrapper::Windows::Media::Effects::IBasicVideoEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeIndependent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBasicVideoEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IBasicVideoEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBasicVideoEffect[] = {
        { "close", reinterpret_cast<PyCFunction>(IBasicVideoEffect_Close), METH_VARARGS, nullptr },
        { "discard_queued_frames", reinterpret_cast<PyCFunction>(IBasicVideoEffect_DiscardQueuedFrames), METH_VARARGS, nullptr },
        { "process_frame", reinterpret_cast<PyCFunction>(IBasicVideoEffect_ProcessFrame), METH_VARARGS, nullptr },
        { "set_encoding_properties", reinterpret_cast<PyCFunction>(IBasicVideoEffect_SetEncodingProperties), METH_VARARGS, nullptr },
        { "set_properties", reinterpret_cast<PyCFunction>(IBasicVideoEffect_SetProperties), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IBasicVideoEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBasicVideoEffect[] = {
        { "is_read_only", reinterpret_cast<getter>(IBasicVideoEffect_get_IsReadOnly), nullptr, nullptr, nullptr },
        { "supported_encoding_properties", reinterpret_cast<getter>(IBasicVideoEffect_get_SupportedEncodingProperties), nullptr, nullptr, nullptr },
        { "supported_memory_types", reinterpret_cast<getter>(IBasicVideoEffect_get_SupportedMemoryTypes), nullptr, nullptr, nullptr },
        { "time_independent", reinterpret_cast<getter>(IBasicVideoEffect_get_TimeIndependent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBasicVideoEffect[] = 
    {
        { Py_tp_new, _new_IBasicVideoEffect },
        { Py_tp_dealloc, _dealloc_IBasicVideoEffect },
        { Py_tp_methods, _methods_IBasicVideoEffect },
        { Py_tp_getset, _getset_IBasicVideoEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IBasicVideoEffect =
    {
        "_winsdk_Windows_Media_Effects.IBasicVideoEffect",
        sizeof(py::wrapper::Windows::Media::Effects::IBasicVideoEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBasicVideoEffect
    };

    // ----- IVideoCompositor interface --------------------
    constexpr const char* const _type_name_IVideoCompositor = "IVideoCompositor";

    static PyObject* _new_IVideoCompositor(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IVideoCompositor);
        return nullptr;
    }

    static void _dealloc_IVideoCompositor(py::wrapper::Windows::Media::Effects::IVideoCompositor* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IVideoCompositor_Close(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::MediaEffectClosedReason>(args, 0);

                self->obj.Close(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_CompositeFrame(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::Effects::CompositeVideoFrameContext>(args, 0);

                self->obj.CompositeFrame(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_DiscardQueuedFrames(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.DiscardQueuedFrames();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_SetEncodingProperties(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Media::MediaProperties::VideoEncodingProperties>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::Graphics::DirectX::Direct3D11::IDirect3DDevice>(args, 1);

                self->obj.SetEncodingProperties(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_SetProperties(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IPropertySet>(args, 0);

                self->obj.SetProperties(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* IVideoCompositor_get_TimeIndependent(py::wrapper::Windows::Media::Effects::IVideoCompositor* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeIndependent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IVideoCompositor(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IVideoCompositor>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVideoCompositor[] = {
        { "close", reinterpret_cast<PyCFunction>(IVideoCompositor_Close), METH_VARARGS, nullptr },
        { "composite_frame", reinterpret_cast<PyCFunction>(IVideoCompositor_CompositeFrame), METH_VARARGS, nullptr },
        { "discard_queued_frames", reinterpret_cast<PyCFunction>(IVideoCompositor_DiscardQueuedFrames), METH_VARARGS, nullptr },
        { "set_encoding_properties", reinterpret_cast<PyCFunction>(IVideoCompositor_SetEncodingProperties), METH_VARARGS, nullptr },
        { "set_properties", reinterpret_cast<PyCFunction>(IVideoCompositor_SetProperties), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_IVideoCompositor), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVideoCompositor[] = {
        { "time_independent", reinterpret_cast<getter>(IVideoCompositor_get_TimeIndependent), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVideoCompositor[] = 
    {
        { Py_tp_new, _new_IVideoCompositor },
        { Py_tp_dealloc, _dealloc_IVideoCompositor },
        { Py_tp_methods, _methods_IVideoCompositor },
        { Py_tp_getset, _getset_IVideoCompositor },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IVideoCompositor =
    {
        "_winsdk_Windows_Media_Effects.IVideoCompositor",
        sizeof(py::wrapper::Windows::Media::Effects::IVideoCompositor),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVideoCompositor
    };

    // ----- IVideoCompositorDefinition interface --------------------
    constexpr const char* const _type_name_IVideoCompositorDefinition = "IVideoCompositorDefinition";

    static PyObject* _new_IVideoCompositorDefinition(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IVideoCompositorDefinition);
        return nullptr;
    }

    static void _dealloc_IVideoCompositorDefinition(py::wrapper::Windows::Media::Effects::IVideoCompositorDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IVideoCompositorDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::IVideoCompositorDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVideoCompositorDefinition_get_Properties(py::wrapper::Windows::Media::Effects::IVideoCompositorDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IVideoCompositorDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IVideoCompositorDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVideoCompositorDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IVideoCompositorDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVideoCompositorDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(IVideoCompositorDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IVideoCompositorDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVideoCompositorDefinition[] = 
    {
        { Py_tp_new, _new_IVideoCompositorDefinition },
        { Py_tp_dealloc, _dealloc_IVideoCompositorDefinition },
        { Py_tp_methods, _methods_IVideoCompositorDefinition },
        { Py_tp_getset, _getset_IVideoCompositorDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IVideoCompositorDefinition =
    {
        "_winsdk_Windows_Media_Effects.IVideoCompositorDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::IVideoCompositorDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVideoCompositorDefinition
    };

    // ----- IVideoEffectDefinition interface --------------------
    constexpr const char* const _type_name_IVideoEffectDefinition = "IVideoEffectDefinition";

    static PyObject* _new_IVideoEffectDefinition(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_IVideoEffectDefinition);
        return nullptr;
    }

    static void _dealloc_IVideoEffectDefinition(py::wrapper::Windows::Media::Effects::IVideoEffectDefinition* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* IVideoEffectDefinition_get_ActivatableClassId(py::wrapper::Windows::Media::Effects::IVideoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActivatableClassId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVideoEffectDefinition_get_Properties(py::wrapper::Windows::Media::Effects::IVideoEffectDefinition* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Properties());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IVideoEffectDefinition(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Media::Effects::IVideoEffectDefinition>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVideoEffectDefinition[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IVideoEffectDefinition), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVideoEffectDefinition[] = {
        { "activatable_class_id", reinterpret_cast<getter>(IVideoEffectDefinition_get_ActivatableClassId), nullptr, nullptr, nullptr },
        { "properties", reinterpret_cast<getter>(IVideoEffectDefinition_get_Properties), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVideoEffectDefinition[] = 
    {
        { Py_tp_new, _new_IVideoEffectDefinition },
        { Py_tp_dealloc, _dealloc_IVideoEffectDefinition },
        { Py_tp_methods, _methods_IVideoEffectDefinition },
        { Py_tp_getset, _getset_IVideoEffectDefinition },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_IVideoEffectDefinition =
    {
        "_winsdk_Windows_Media_Effects.IVideoEffectDefinition",
        sizeof(py::wrapper::Windows::Media::Effects::IVideoEffectDefinition),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVideoEffectDefinition
    };

    // ----- Windows.Media.Effects Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Media::Effects::AudioCaptureEffectsManager>::python_type = py::register_python_type(module, _type_name_AudioCaptureEffectsManager, &_type_spec_AudioCaptureEffectsManager, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::AudioEffect>::python_type = py::register_python_type(module, _type_name_AudioEffect, &_type_spec_AudioEffect, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::AudioEffectDefinition>::python_type = py::register_python_type(module, _type_name_AudioEffectDefinition, &_type_spec_AudioEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::AudioEffectsManager>::python_type = py::register_python_type(module, _type_name_AudioEffectsManager, &_type_spec_AudioEffectsManager, nullptr);
            py::winrt_type<winrt::Windows::Media::Effects::AudioRenderEffectsManager>::python_type = py::register_python_type(module, _type_name_AudioRenderEffectsManager, &_type_spec_AudioRenderEffectsManager, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::CompositeVideoFrameContext>::python_type = py::register_python_type(module, _type_name_CompositeVideoFrameContext, &_type_spec_CompositeVideoFrameContext, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::ProcessAudioFrameContext>::python_type = py::register_python_type(module, _type_name_ProcessAudioFrameContext, &_type_spec_ProcessAudioFrameContext, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::ProcessVideoFrameContext>::python_type = py::register_python_type(module, _type_name_ProcessVideoFrameContext, &_type_spec_ProcessVideoFrameContext, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::VideoCompositorDefinition>::python_type = py::register_python_type(module, _type_name_VideoCompositorDefinition, &_type_spec_VideoCompositorDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::VideoEffectDefinition>::python_type = py::register_python_type(module, _type_name_VideoEffectDefinition, &_type_spec_VideoEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::VideoTransformEffectDefinition>::python_type = py::register_python_type(module, _type_name_VideoTransformEffectDefinition, &_type_spec_VideoTransformEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::VideoTransformSphericalProjection>::python_type = py::register_python_type(module, _type_name_VideoTransformSphericalProjection, &_type_spec_VideoTransformSphericalProjection, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::IAudioEffectDefinition>::python_type = py::register_python_type(module, _type_name_IAudioEffectDefinition, &_type_spec_IAudioEffectDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::IBasicAudioEffect>::python_type = py::register_python_type(module, _type_name_IBasicAudioEffect, &_type_spec_IBasicAudioEffect, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::IBasicVideoEffect>::python_type = py::register_python_type(module, _type_name_IBasicVideoEffect, &_type_spec_IBasicVideoEffect, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::IVideoCompositor>::python_type = py::register_python_type(module, _type_name_IVideoCompositor, &_type_spec_IVideoCompositor, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::IVideoCompositorDefinition>::python_type = py::register_python_type(module, _type_name_IVideoCompositorDefinition, &_type_spec_IVideoCompositorDefinition, bases.get());
            py::winrt_type<winrt::Windows::Media::Effects::IVideoEffectDefinition>::python_type = py::register_python_type(module, _type_name_IVideoEffectDefinition, &_type_spec_IVideoEffectDefinition, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Media.Effects");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Media_Effects",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Media::Effects

PyMODINIT_FUNC
PyInit__winsdk_Windows_Media_Effects (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Media::Effects::module_def);
}
