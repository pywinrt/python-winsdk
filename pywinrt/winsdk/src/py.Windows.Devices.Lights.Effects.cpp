// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.Devices.Lights.Effects.h"

PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayBlinkEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayColorRampEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayCustomEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArraySolidEffect>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>::python_type;

namespace py::cpp::Windows::Devices::Lights::Effects
{
    // ----- LampArrayBitmapEffect class --------------------
    constexpr const char* const _type_name_LampArrayBitmapEffect = "LampArrayBitmapEffect";

    static PyObject* _new_LampArrayBitmapEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArrayBitmapEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayBitmapEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArrayBitmapEffect_get_UpdateInterval(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBitmapEffect_put_UpdateInterval(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.UpdateInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBitmapEffect_get_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBitmapEffect_put_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBitmapEffect_get_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBitmapEffect_put_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBitmapEffect_get_SuggestedBitmapSize(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SuggestedBitmapSize());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LampArrayBitmapEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBitmapEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBitmapEffect_add_BitmapRequested(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapEffect, winrt::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs>>(arg);

            return py::convert(self->obj.BitmapRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LampArrayBitmapEffect_remove_BitmapRequested(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.BitmapRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LampArrayBitmapEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayBitmapEffect[] = {
        { "add_bitmap_requested", reinterpret_cast<PyCFunction>(LampArrayBitmapEffect_add_BitmapRequested), METH_O, nullptr },
        { "remove_bitmap_requested", reinterpret_cast<PyCFunction>(LampArrayBitmapEffect_remove_BitmapRequested), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArrayBitmapEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArrayBitmapEffect[] = {
        { "update_interval", reinterpret_cast<getter>(LampArrayBitmapEffect_get_UpdateInterval), reinterpret_cast<setter>(LampArrayBitmapEffect_put_UpdateInterval), nullptr, nullptr },
        { "start_delay", reinterpret_cast<getter>(LampArrayBitmapEffect_get_StartDelay), reinterpret_cast<setter>(LampArrayBitmapEffect_put_StartDelay), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(LampArrayBitmapEffect_get_Duration), reinterpret_cast<setter>(LampArrayBitmapEffect_put_Duration), nullptr, nullptr },
        { "suggested_bitmap_size", reinterpret_cast<getter>(LampArrayBitmapEffect_get_SuggestedBitmapSize), nullptr, nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(LampArrayBitmapEffect_get_ZIndex), reinterpret_cast<setter>(LampArrayBitmapEffect_put_ZIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArrayBitmapEffect[] = 
    {
        { Py_tp_new, _new_LampArrayBitmapEffect },
        { Py_tp_dealloc, _dealloc_LampArrayBitmapEffect },
        { Py_tp_methods, _methods_LampArrayBitmapEffect },
        { Py_tp_getset, _getset_LampArrayBitmapEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArrayBitmapEffect =
    {
        "_winsdk_Windows_Devices_Lights_Effects.LampArrayBitmapEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayBitmapEffect
    };

    // ----- LampArrayBitmapRequestedEventArgs class --------------------
    constexpr const char* const _type_name_LampArrayBitmapRequestedEventArgs = "LampArrayBitmapRequestedEventArgs";

    static PyObject* _new_LampArrayBitmapRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LampArrayBitmapRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_LampArrayBitmapRequestedEventArgs(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArrayBitmapRequestedEventArgs_UpdateBitmap(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Graphics::Imaging::SoftwareBitmap>(args, 0);

                self->obj.UpdateBitmap(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayBitmapRequestedEventArgs_get_SinceStarted(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SinceStarted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LampArrayBitmapRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayBitmapRequestedEventArgs[] = {
        { "update_bitmap", reinterpret_cast<PyCFunction>(LampArrayBitmapRequestedEventArgs_UpdateBitmap), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArrayBitmapRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArrayBitmapRequestedEventArgs[] = {
        { "since_started", reinterpret_cast<getter>(LampArrayBitmapRequestedEventArgs_get_SinceStarted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArrayBitmapRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_LampArrayBitmapRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_LampArrayBitmapRequestedEventArgs },
        { Py_tp_methods, _methods_LampArrayBitmapRequestedEventArgs },
        { Py_tp_getset, _getset_LampArrayBitmapRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArrayBitmapRequestedEventArgs =
    {
        "_winsdk_Windows_Devices_Lights_Effects.LampArrayBitmapRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayBitmapRequestedEventArgs
    };

    // ----- LampArrayBlinkEffect class --------------------
    constexpr const char* const _type_name_LampArrayBlinkEffect = "LampArrayBlinkEffect";

    static PyObject* _new_LampArrayBlinkEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArrayBlinkEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayBlinkEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArrayBlinkEffect_get_SustainDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SustainDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_SustainDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.SustainDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_RepetitionMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepetitionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_RepetitionMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayRepetitionMode>(arg);

            self->obj.RepetitionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_RepetitionDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepetitionDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_RepetitionDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.RepetitionDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_Occurrences(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Occurrences());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_Occurrences(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Occurrences(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_DecayDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DecayDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_DecayDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.DecayDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_AttackDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AttackDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_AttackDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.AttackDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayBlinkEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayBlinkEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LampArrayBlinkEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayBlinkEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayBlinkEffect[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArrayBlinkEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArrayBlinkEffect[] = {
        { "sustain_duration", reinterpret_cast<getter>(LampArrayBlinkEffect_get_SustainDuration), reinterpret_cast<setter>(LampArrayBlinkEffect_put_SustainDuration), nullptr, nullptr },
        { "start_delay", reinterpret_cast<getter>(LampArrayBlinkEffect_get_StartDelay), reinterpret_cast<setter>(LampArrayBlinkEffect_put_StartDelay), nullptr, nullptr },
        { "repetition_mode", reinterpret_cast<getter>(LampArrayBlinkEffect_get_RepetitionMode), reinterpret_cast<setter>(LampArrayBlinkEffect_put_RepetitionMode), nullptr, nullptr },
        { "repetition_delay", reinterpret_cast<getter>(LampArrayBlinkEffect_get_RepetitionDelay), reinterpret_cast<setter>(LampArrayBlinkEffect_put_RepetitionDelay), nullptr, nullptr },
        { "occurrences", reinterpret_cast<getter>(LampArrayBlinkEffect_get_Occurrences), reinterpret_cast<setter>(LampArrayBlinkEffect_put_Occurrences), nullptr, nullptr },
        { "decay_duration", reinterpret_cast<getter>(LampArrayBlinkEffect_get_DecayDuration), reinterpret_cast<setter>(LampArrayBlinkEffect_put_DecayDuration), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(LampArrayBlinkEffect_get_Color), reinterpret_cast<setter>(LampArrayBlinkEffect_put_Color), nullptr, nullptr },
        { "attack_duration", reinterpret_cast<getter>(LampArrayBlinkEffect_get_AttackDuration), reinterpret_cast<setter>(LampArrayBlinkEffect_put_AttackDuration), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(LampArrayBlinkEffect_get_ZIndex), reinterpret_cast<setter>(LampArrayBlinkEffect_put_ZIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArrayBlinkEffect[] = 
    {
        { Py_tp_new, _new_LampArrayBlinkEffect },
        { Py_tp_dealloc, _dealloc_LampArrayBlinkEffect },
        { Py_tp_methods, _methods_LampArrayBlinkEffect },
        { Py_tp_getset, _getset_LampArrayBlinkEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArrayBlinkEffect =
    {
        "_winsdk_Windows_Devices_Lights_Effects.LampArrayBlinkEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayBlinkEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayBlinkEffect
    };

    // ----- LampArrayColorRampEffect class --------------------
    constexpr const char* const _type_name_LampArrayColorRampEffect = "LampArrayColorRampEffect";

    static PyObject* _new_LampArrayColorRampEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArrayColorRampEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayColorRampEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArrayColorRampEffect_get_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayColorRampEffect_get_RampDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RampDuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_RampDuration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.RampDuration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayColorRampEffect_get_CompletionBehavior(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompletionBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_CompletionBehavior(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayEffectCompletionBehavior>(arg);

            self->obj.CompletionBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayColorRampEffect_get_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayColorRampEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayColorRampEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LampArrayColorRampEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayColorRampEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayColorRampEffect[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArrayColorRampEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArrayColorRampEffect[] = {
        { "start_delay", reinterpret_cast<getter>(LampArrayColorRampEffect_get_StartDelay), reinterpret_cast<setter>(LampArrayColorRampEffect_put_StartDelay), nullptr, nullptr },
        { "ramp_duration", reinterpret_cast<getter>(LampArrayColorRampEffect_get_RampDuration), reinterpret_cast<setter>(LampArrayColorRampEffect_put_RampDuration), nullptr, nullptr },
        { "completion_behavior", reinterpret_cast<getter>(LampArrayColorRampEffect_get_CompletionBehavior), reinterpret_cast<setter>(LampArrayColorRampEffect_put_CompletionBehavior), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(LampArrayColorRampEffect_get_Color), reinterpret_cast<setter>(LampArrayColorRampEffect_put_Color), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(LampArrayColorRampEffect_get_ZIndex), reinterpret_cast<setter>(LampArrayColorRampEffect_put_ZIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArrayColorRampEffect[] = 
    {
        { Py_tp_new, _new_LampArrayColorRampEffect },
        { Py_tp_dealloc, _dealloc_LampArrayColorRampEffect },
        { Py_tp_methods, _methods_LampArrayColorRampEffect },
        { Py_tp_getset, _getset_LampArrayColorRampEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArrayColorRampEffect =
    {
        "_winsdk_Windows_Devices_Lights_Effects.LampArrayColorRampEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayColorRampEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayColorRampEffect
    };

    // ----- LampArrayCustomEffect class --------------------
    constexpr const char* const _type_name_LampArrayCustomEffect = "LampArrayCustomEffect";

    static PyObject* _new_LampArrayCustomEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArrayCustomEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayCustomEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArrayCustomEffect_get_UpdateInterval(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UpdateInterval());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayCustomEffect_put_UpdateInterval(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.UpdateInterval(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayCustomEffect_get_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayCustomEffect_put_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayCustomEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayCustomEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayCustomEffect_add_UpdateRequested(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::Devices::Lights::Effects::LampArrayCustomEffect, winrt::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs>>(arg);

            return py::convert(self->obj.UpdateRequested(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LampArrayCustomEffect_remove_UpdateRequested(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.UpdateRequested(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LampArrayCustomEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayCustomEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayCustomEffect[] = {
        { "add_update_requested", reinterpret_cast<PyCFunction>(LampArrayCustomEffect_add_UpdateRequested), METH_O, nullptr },
        { "remove_update_requested", reinterpret_cast<PyCFunction>(LampArrayCustomEffect_remove_UpdateRequested), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArrayCustomEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArrayCustomEffect[] = {
        { "update_interval", reinterpret_cast<getter>(LampArrayCustomEffect_get_UpdateInterval), reinterpret_cast<setter>(LampArrayCustomEffect_put_UpdateInterval), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(LampArrayCustomEffect_get_Duration), reinterpret_cast<setter>(LampArrayCustomEffect_put_Duration), nullptr, nullptr },
        { "z_index", reinterpret_cast<getter>(LampArrayCustomEffect_get_ZIndex), reinterpret_cast<setter>(LampArrayCustomEffect_put_ZIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArrayCustomEffect[] = 
    {
        { Py_tp_new, _new_LampArrayCustomEffect },
        { Py_tp_dealloc, _dealloc_LampArrayCustomEffect },
        { Py_tp_methods, _methods_LampArrayCustomEffect },
        { Py_tp_getset, _getset_LampArrayCustomEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArrayCustomEffect =
    {
        "_winsdk_Windows_Devices_Lights_Effects.LampArrayCustomEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayCustomEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayCustomEffect
    };

    // ----- LampArrayEffectPlaylist class --------------------
    constexpr const char* const _type_name_LampArrayEffectPlaylist = "LampArrayEffectPlaylist";

    static PyObject* _new_LampArrayEffectPlaylist(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArrayEffectPlaylist(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArrayEffectPlaylist_Append(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>(args, 0);

                self->obj.Append(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_First(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.First());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_GetAt(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(self->obj.GetAt(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_GetMany(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);
                auto param1_count = py::convert_to<winrt::com_array<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>::size_type>(args, 1);
                winrt::com_array<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect> param1 ( param1_count, py::empty_instance<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>::get() );

                auto return_value = self->obj.GetMany(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_IndexOf(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>(args, 0);
                uint32_t param1 {  };

                auto return_value = self->obj.IndexOf(param0, param1);

                py::pyobj_handle out_return_value{ py::convert(return_value) };
                if (!out_return_value)
                {
                    return nullptr;
                }
                py::pyobj_handle out1{ py::convert(param1) };
                if (!out1)
                {
                    return nullptr;
                }
                return PyTuple_Pack(2, out_return_value.get(), out1.get());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_OverrideZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);

                self->obj.OverrideZIndex(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_Pause(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Pause();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_PauseAll(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>>(args, 0);

                winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist::PauseAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_Start(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Start();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_StartAll(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>>(args, 0);

                winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist::StartAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_Stop(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.Stop();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_StopAll(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>>(args, 0);

                winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist::StopAll(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayEffectPlaylist_get_RepetitionMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RepetitionMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayEffectPlaylist_put_RepetitionMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayRepetitionMode>(arg);

            self->obj.RepetitionMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayEffectPlaylist_get_Occurrences(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Occurrences());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayEffectPlaylist_put_Occurrences(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Occurrences(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayEffectPlaylist_get_EffectStartMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EffectStartMode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArrayEffectPlaylist_put_EffectStartMode(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayEffectStartMode>(arg);

            self->obj.EffectStartMode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArrayEffectPlaylist_get_Size(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LampArrayEffectPlaylist(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _iterator_LampArrayEffectPlaylist(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self) noexcept
    {
        try
        {
            return py::convert(self->obj.First());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static Py_ssize_t _seq_length_LampArrayEffectPlaylist(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self) noexcept
    {
        try
        {
            return static_cast<Py_ssize_t>(self->obj.Size());
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _seq_item_LampArrayEffectPlaylist(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist* self, Py_ssize_t i) noexcept
    {
        try
        {
            return py::convert(self->obj.GetAt(static_cast<uint32_t>(i)));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayEffectPlaylist[] = {
        { "append", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_Append), METH_VARARGS, nullptr },
        { "first", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_First), METH_VARARGS, nullptr },
        { "get_at", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_GetAt), METH_VARARGS, nullptr },
        { "get_many", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_GetMany), METH_VARARGS, nullptr },
        { "index_of", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_IndexOf), METH_VARARGS, nullptr },
        { "override_z_index", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_OverrideZIndex), METH_VARARGS, nullptr },
        { "pause", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_Pause), METH_VARARGS, nullptr },
        { "pause_all", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_PauseAll), METH_VARARGS | METH_STATIC, nullptr },
        { "start", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_Start), METH_VARARGS, nullptr },
        { "start_all", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_StartAll), METH_VARARGS | METH_STATIC, nullptr },
        { "stop", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_Stop), METH_VARARGS, nullptr },
        { "stop_all", reinterpret_cast<PyCFunction>(LampArrayEffectPlaylist_StopAll), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArrayEffectPlaylist), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArrayEffectPlaylist[] = {
        { "repetition_mode", reinterpret_cast<getter>(LampArrayEffectPlaylist_get_RepetitionMode), reinterpret_cast<setter>(LampArrayEffectPlaylist_put_RepetitionMode), nullptr, nullptr },
        { "occurrences", reinterpret_cast<getter>(LampArrayEffectPlaylist_get_Occurrences), reinterpret_cast<setter>(LampArrayEffectPlaylist_put_Occurrences), nullptr, nullptr },
        { "effect_start_mode", reinterpret_cast<getter>(LampArrayEffectPlaylist_get_EffectStartMode), reinterpret_cast<setter>(LampArrayEffectPlaylist_put_EffectStartMode), nullptr, nullptr },
        { "size", reinterpret_cast<getter>(LampArrayEffectPlaylist_get_Size), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArrayEffectPlaylist[] = 
    {
        { Py_tp_new, _new_LampArrayEffectPlaylist },
        { Py_tp_dealloc, _dealloc_LampArrayEffectPlaylist },
        { Py_tp_methods, _methods_LampArrayEffectPlaylist },
        { Py_tp_getset, _getset_LampArrayEffectPlaylist },
        { Py_tp_iter, _iterator_LampArrayEffectPlaylist },
        { Py_sq_length, _seq_length_LampArrayEffectPlaylist },
        { Py_sq_item, _seq_item_LampArrayEffectPlaylist },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArrayEffectPlaylist =
    {
        "_winsdk_Windows_Devices_Lights_Effects.LampArrayEffectPlaylist",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayEffectPlaylist
    };

    // ----- LampArraySolidEffect class --------------------
    constexpr const char* const _type_name_LampArraySolidEffect = "LampArraySolidEffect";

    static PyObject* _new_LampArraySolidEffect(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Devices::Lights::LampArray>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                winrt::Windows::Devices::Lights::Effects::LampArraySolidEffect instance{ param0, param1 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_LampArraySolidEffect(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArraySolidEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArraySolidEffect_get_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.StartDelay());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_StartDelay(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.StartDelay(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArraySolidEffect_get_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_Duration(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TimeSpan>(arg);

            self->obj.Duration(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArraySolidEffect_get_CompletionBehavior(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CompletionBehavior());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_CompletionBehavior(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Devices::Lights::Effects::LampArrayEffectCompletionBehavior>(arg);

            self->obj.CompletionBehavior(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* LampArraySolidEffect_get_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Color());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int LampArraySolidEffect_put_Color(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Color>(arg);

            self->obj.Color(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_LampArraySolidEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArraySolidEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArraySolidEffect[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArraySolidEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArraySolidEffect[] = {
        { "z_index", reinterpret_cast<getter>(LampArraySolidEffect_get_ZIndex), reinterpret_cast<setter>(LampArraySolidEffect_put_ZIndex), nullptr, nullptr },
        { "start_delay", reinterpret_cast<getter>(LampArraySolidEffect_get_StartDelay), reinterpret_cast<setter>(LampArraySolidEffect_put_StartDelay), nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(LampArraySolidEffect_get_Duration), reinterpret_cast<setter>(LampArraySolidEffect_put_Duration), nullptr, nullptr },
        { "completion_behavior", reinterpret_cast<getter>(LampArraySolidEffect_get_CompletionBehavior), reinterpret_cast<setter>(LampArraySolidEffect_put_CompletionBehavior), nullptr, nullptr },
        { "color", reinterpret_cast<getter>(LampArraySolidEffect_get_Color), reinterpret_cast<setter>(LampArraySolidEffect_put_Color), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArraySolidEffect[] = 
    {
        { Py_tp_new, _new_LampArraySolidEffect },
        { Py_tp_dealloc, _dealloc_LampArraySolidEffect },
        { Py_tp_methods, _methods_LampArraySolidEffect },
        { Py_tp_getset, _getset_LampArraySolidEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArraySolidEffect =
    {
        "_winsdk_Windows_Devices_Lights_Effects.LampArraySolidEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArraySolidEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArraySolidEffect
    };

    // ----- LampArrayUpdateRequestedEventArgs class --------------------
    constexpr const char* const _type_name_LampArrayUpdateRequestedEventArgs = "LampArrayUpdateRequestedEventArgs";

    static PyObject* _new_LampArrayUpdateRequestedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_LampArrayUpdateRequestedEventArgs);
        return nullptr;
    }

    static void _dealloc_LampArrayUpdateRequestedEventArgs(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_SetColor(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Color>(args, 0);

                self->obj.SetColor(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_SetColorForIndex(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<int32_t>(args, 0);
                auto param1 = py::convert_to<winrt::Windows::UI::Color>(args, 1);

                self->obj.SetColorForIndex(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_SetColorsForIndices(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::array_view<winrt::Windows::UI::Color>>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                self->obj.SetColorsForIndices(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_SetSingleColorForIndices(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 2)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Color>(args, 0);
                auto param1 = py::convert_to<winrt::array_view<int32_t>>(args, 1);

                self->obj.SetSingleColorForIndices(param0, param1);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* LampArrayUpdateRequestedEventArgs_get_SinceStarted(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SinceStarted());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LampArrayUpdateRequestedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LampArrayUpdateRequestedEventArgs[] = {
        { "set_color", reinterpret_cast<PyCFunction>(LampArrayUpdateRequestedEventArgs_SetColor), METH_VARARGS, nullptr },
        { "set_color_for_index", reinterpret_cast<PyCFunction>(LampArrayUpdateRequestedEventArgs_SetColorForIndex), METH_VARARGS, nullptr },
        { "set_colors_for_indices", reinterpret_cast<PyCFunction>(LampArrayUpdateRequestedEventArgs_SetColorsForIndices), METH_VARARGS, nullptr },
        { "set_single_color_for_indices", reinterpret_cast<PyCFunction>(LampArrayUpdateRequestedEventArgs_SetSingleColorForIndices), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_LampArrayUpdateRequestedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LampArrayUpdateRequestedEventArgs[] = {
        { "since_started", reinterpret_cast<getter>(LampArrayUpdateRequestedEventArgs_get_SinceStarted), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LampArrayUpdateRequestedEventArgs[] = 
    {
        { Py_tp_new, _new_LampArrayUpdateRequestedEventArgs },
        { Py_tp_dealloc, _dealloc_LampArrayUpdateRequestedEventArgs },
        { Py_tp_methods, _methods_LampArrayUpdateRequestedEventArgs },
        { Py_tp_getset, _getset_LampArrayUpdateRequestedEventArgs },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_LampArrayUpdateRequestedEventArgs =
    {
        "_winsdk_Windows_Devices_Lights_Effects.LampArrayUpdateRequestedEventArgs",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LampArrayUpdateRequestedEventArgs
    };

    // ----- ILampArrayEffect interface --------------------
    constexpr const char* const _type_name_ILampArrayEffect = "ILampArrayEffect";

    static PyObject* _new_ILampArrayEffect(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(_type_name_ILampArrayEffect);
        return nullptr;
    }

    static void _dealloc_ILampArrayEffect(py::wrapper::Windows::Devices::Lights::Effects::ILampArrayEffect* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ILampArrayEffect_get_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::ILampArrayEffect* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ZIndex());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int ILampArrayEffect_put_ZIndex(py::wrapper::Windows::Devices::Lights::Effects::ILampArrayEffect* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ZIndex(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_ILampArrayEffect(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILampArrayEffect[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ILampArrayEffect), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILampArrayEffect[] = {
        { "z_index", reinterpret_cast<getter>(ILampArrayEffect_get_ZIndex), reinterpret_cast<setter>(ILampArrayEffect_put_ZIndex), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILampArrayEffect[] = 
    {
        { Py_tp_new, _new_ILampArrayEffect },
        { Py_tp_dealloc, _dealloc_ILampArrayEffect },
        { Py_tp_methods, _methods_ILampArrayEffect },
        { Py_tp_getset, _getset_ILampArrayEffect },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ILampArrayEffect =
    {
        "_winsdk_Windows_Devices_Lights_Effects.ILampArrayEffect",
        sizeof(py::wrapper::Windows::Devices::Lights::Effects::ILampArrayEffect),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILampArrayEffect
    };

    // ----- Windows.Devices.Lights.Effects Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapEffect>::python_type = py::register_python_type(module, _type_name_LampArrayBitmapEffect, &_type_spec_LampArrayBitmapEffect, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayBitmapRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_LampArrayBitmapRequestedEventArgs, &_type_spec_LampArrayBitmapRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayBlinkEffect>::python_type = py::register_python_type(module, _type_name_LampArrayBlinkEffect, &_type_spec_LampArrayBlinkEffect, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayColorRampEffect>::python_type = py::register_python_type(module, _type_name_LampArrayColorRampEffect, &_type_spec_LampArrayColorRampEffect, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayCustomEffect>::python_type = py::register_python_type(module, _type_name_LampArrayCustomEffect, &_type_spec_LampArrayCustomEffect, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayEffectPlaylist>::python_type = py::register_python_type(module, _type_name_LampArrayEffectPlaylist, &_type_spec_LampArrayEffectPlaylist, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArraySolidEffect>::python_type = py::register_python_type(module, _type_name_LampArraySolidEffect, &_type_spec_LampArraySolidEffect, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::LampArrayUpdateRequestedEventArgs>::python_type = py::register_python_type(module, _type_name_LampArrayUpdateRequestedEventArgs, &_type_spec_LampArrayUpdateRequestedEventArgs, bases.get());
            py::winrt_type<winrt::Windows::Devices::Lights::Effects::ILampArrayEffect>::python_type = py::register_python_type(module, _type_name_ILampArrayEffect, &_type_spec_ILampArrayEffect, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.Devices.Lights.Effects");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_Devices_Lights_Effects",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::Devices::Lights::Effects

PyMODINIT_FUNC
PyInit__winsdk_Windows_Devices_Lights_Effects (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::Devices::Lights::Effects::module_def);
}
