// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.5

#include "pybase.h"
#include "py.Windows.ApplicationModel.Activation.h"


namespace py::cpp::Windows::ApplicationModel::Activation
{
    struct module_state
    {
        PyObject* type_ActivationKind;
        PyObject* type_ApplicationExecutionState;
        PyTypeObject* type_AppointmentsProviderAddAppointmentActivatedEventArgs;
        PyTypeObject* type_AppointmentsProviderRemoveAppointmentActivatedEventArgs;
        PyTypeObject* type_AppointmentsProviderReplaceAppointmentActivatedEventArgs;
        PyTypeObject* type_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs;
        PyTypeObject* type_AppointmentsProviderShowTimeFrameActivatedEventArgs;
        PyTypeObject* type_BackgroundActivatedEventArgs;
        PyTypeObject* type_BarcodeScannerPreviewActivatedEventArgs;
        PyTypeObject* type_CachedFileUpdaterActivatedEventArgs;
        PyTypeObject* type_CameraSettingsActivatedEventArgs;
        PyTypeObject* type_CommandLineActivatedEventArgs;
        PyTypeObject* type_CommandLineActivationOperation;
        PyTypeObject* type_ContactCallActivatedEventArgs;
        PyTypeObject* type_ContactMapActivatedEventArgs;
        PyTypeObject* type_ContactMessageActivatedEventArgs;
        PyTypeObject* type_ContactPanelActivatedEventArgs;
        PyTypeObject* type_ContactPickerActivatedEventArgs;
        PyTypeObject* type_ContactPostActivatedEventArgs;
        PyTypeObject* type_ContactVideoCallActivatedEventArgs;
        PyTypeObject* type_DeviceActivatedEventArgs;
        PyTypeObject* type_DevicePairingActivatedEventArgs;
        PyTypeObject* type_DialReceiverActivatedEventArgs;
        PyTypeObject* type_FileActivatedEventArgs;
        PyTypeObject* type_FileOpenPickerActivatedEventArgs;
        PyTypeObject* type_FileOpenPickerContinuationEventArgs;
        PyTypeObject* type_FileSavePickerActivatedEventArgs;
        PyTypeObject* type_FileSavePickerContinuationEventArgs;
        PyTypeObject* type_FolderPickerContinuationEventArgs;
        PyTypeObject* type_LaunchActivatedEventArgs;
        PyTypeObject* type_LockScreenActivatedEventArgs;
        PyTypeObject* type_LockScreenCallActivatedEventArgs;
        PyTypeObject* type_LockScreenComponentActivatedEventArgs;
        PyTypeObject* type_PhoneCallActivatedEventArgs;
        PyTypeObject* type_PickerReturnedActivatedEventArgs;
        PyTypeObject* type_Print3DWorkflowActivatedEventArgs;
        PyTypeObject* type_PrintTaskSettingsActivatedEventArgs;
        PyTypeObject* type_ProtocolActivatedEventArgs;
        PyTypeObject* type_ProtocolForResultsActivatedEventArgs;
        PyTypeObject* type_RestrictedLaunchActivatedEventArgs;
        PyTypeObject* type_SearchActivatedEventArgs;
        PyTypeObject* type_ShareTargetActivatedEventArgs;
        PyTypeObject* type_SplashScreen;
        PyTypeObject* type_StartupTaskActivatedEventArgs;
        PyTypeObject* type_TileActivatedInfo;
        PyTypeObject* type_ToastNotificationActivatedEventArgs;
        PyTypeObject* type_UserDataAccountProviderActivatedEventArgs;
        PyTypeObject* type_VoiceCommandActivatedEventArgs;
        PyTypeObject* type_WalletActionActivatedEventArgs;
        PyTypeObject* type_WebAccountProviderActivatedEventArgs;
        PyTypeObject* type_WebAuthenticationBrokerContinuationEventArgs;
        PyTypeObject* type_IActivatedEventArgs;
        PyTypeObject* type_IActivatedEventArgsWithUser;
        PyTypeObject* type_IApplicationViewActivatedEventArgs;
        PyTypeObject* type_IAppointmentsProviderActivatedEventArgs;
        PyTypeObject* type_IAppointmentsProviderAddAppointmentActivatedEventArgs;
        PyTypeObject* type_IAppointmentsProviderRemoveAppointmentActivatedEventArgs;
        PyTypeObject* type_IAppointmentsProviderReplaceAppointmentActivatedEventArgs;
        PyTypeObject* type_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs;
        PyTypeObject* type_IAppointmentsProviderShowTimeFrameActivatedEventArgs;
        PyTypeObject* type_IBackgroundActivatedEventArgs;
        PyTypeObject* type_IBarcodeScannerPreviewActivatedEventArgs;
        PyTypeObject* type_ICachedFileUpdaterActivatedEventArgs;
        PyTypeObject* type_ICameraSettingsActivatedEventArgs;
        PyTypeObject* type_ICommandLineActivatedEventArgs;
        PyTypeObject* type_IContactActivatedEventArgs;
        PyTypeObject* type_IContactCallActivatedEventArgs;
        PyTypeObject* type_IContactMapActivatedEventArgs;
        PyTypeObject* type_IContactMessageActivatedEventArgs;
        PyTypeObject* type_IContactPanelActivatedEventArgs;
        PyTypeObject* type_IContactPickerActivatedEventArgs;
        PyTypeObject* type_IContactPostActivatedEventArgs;
        PyTypeObject* type_IContactVideoCallActivatedEventArgs;
        PyTypeObject* type_IContactsProviderActivatedEventArgs;
        PyTypeObject* type_IContinuationActivatedEventArgs;
        PyTypeObject* type_IDeviceActivatedEventArgs;
        PyTypeObject* type_IDevicePairingActivatedEventArgs;
        PyTypeObject* type_IDialReceiverActivatedEventArgs;
        PyTypeObject* type_IFileActivatedEventArgs;
        PyTypeObject* type_IFileActivatedEventArgsWithCallerPackageFamilyName;
        PyTypeObject* type_IFileActivatedEventArgsWithNeighboringFiles;
        PyTypeObject* type_IFileOpenPickerActivatedEventArgs;
        PyTypeObject* type_IFileOpenPickerActivatedEventArgs2;
        PyTypeObject* type_IFileOpenPickerContinuationEventArgs;
        PyTypeObject* type_IFileSavePickerActivatedEventArgs;
        PyTypeObject* type_IFileSavePickerActivatedEventArgs2;
        PyTypeObject* type_IFileSavePickerContinuationEventArgs;
        PyTypeObject* type_IFolderPickerContinuationEventArgs;
        PyTypeObject* type_ILaunchActivatedEventArgs;
        PyTypeObject* type_ILaunchActivatedEventArgs2;
        PyTypeObject* type_ILockScreenActivatedEventArgs;
        PyTypeObject* type_ILockScreenCallActivatedEventArgs;
        PyTypeObject* type_IPhoneCallActivatedEventArgs;
        PyTypeObject* type_IPickerReturnedActivatedEventArgs;
        PyTypeObject* type_IPrelaunchActivatedEventArgs;
        PyTypeObject* type_IPrint3DWorkflowActivatedEventArgs;
        PyTypeObject* type_IPrintTaskSettingsActivatedEventArgs;
        PyTypeObject* type_IProtocolActivatedEventArgs;
        PyTypeObject* type_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData;
        PyTypeObject* type_IProtocolForResultsActivatedEventArgs;
        PyTypeObject* type_IRestrictedLaunchActivatedEventArgs;
        PyTypeObject* type_ISearchActivatedEventArgs;
        PyTypeObject* type_ISearchActivatedEventArgsWithLinguisticDetails;
        PyTypeObject* type_IShareTargetActivatedEventArgs;
        PyTypeObject* type_IStartupTaskActivatedEventArgs;
        PyTypeObject* type_IToastNotificationActivatedEventArgs;
        PyTypeObject* type_IUserDataAccountProviderActivatedEventArgs;
        PyTypeObject* type_IViewSwitcherProvider;
        PyTypeObject* type_IVoiceCommandActivatedEventArgs;
        PyTypeObject* type_IWalletActionActivatedEventArgs;
        PyTypeObject* type_IWebAccountProviderActivatedEventArgs;
        PyTypeObject* type_IWebAuthenticationBrokerContinuationEventArgs;
    };

    static PyObject* register_ActivationKind(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ActivationKind)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ActivationKind = type;
        Py_INCREF(state->type_ActivationKind);


        Py_RETURN_NONE;
    }

    static PyObject* register_ApplicationExecutionState(PyObject* module, PyObject* type)
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
        assert(state);

        if (state->type_ApplicationExecutionState)
        {
            PyErr_SetString(PyExc_RuntimeError, "type has already been registered");
            return nullptr;
        }

        if (!PyType_Check(type))
        {
            PyErr_SetString(PyExc_TypeError, "argument is not a type");
            return nullptr;
        }

        state->type_ApplicationExecutionState = type;
        Py_INCREF(state->type_ApplicationExecutionState);


        Py_RETURN_NONE;
    }

    // ----- AppointmentsProviderAddAppointmentActivatedEventArgs class --------------------
    constexpr const char* const type_name_AppointmentsProviderAddAppointmentActivatedEventArgs = "AppointmentsProviderAddAppointmentActivatedEventArgs";

    static PyObject* _new_AppointmentsProviderAddAppointmentActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppointmentsProviderAddAppointmentActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderAddAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AddAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderAddAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "add_appointment_operation", reinterpret_cast<getter>(AppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentsProviderAddAppointmentActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_AppointmentsProviderAddAppointmentActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_AppointmentsProviderAddAppointmentActivatedEventArgs },
        { Py_tp_methods, _methods_AppointmentsProviderAddAppointmentActivatedEventArgs },
        { Py_tp_getset, _getset_AppointmentsProviderAddAppointmentActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_AppointmentsProviderAddAppointmentActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.AppointmentsProviderAddAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderAddAppointmentActivatedEventArgs
    };

    // ----- AppointmentsProviderRemoveAppointmentActivatedEventArgs class --------------------
    constexpr const char* const type_name_AppointmentsProviderRemoveAppointmentActivatedEventArgs = "AppointmentsProviderRemoveAppointmentActivatedEventArgs";

    static PyObject* _new_AppointmentsProviderRemoveAppointmentActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppointmentsProviderRemoveAppointmentActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderRemoveAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoveAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderRemoveAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "remove_appointment_operation", reinterpret_cast<getter>(AppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentsProviderRemoveAppointmentActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_AppointmentsProviderRemoveAppointmentActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_AppointmentsProviderRemoveAppointmentActivatedEventArgs },
        { Py_tp_methods, _methods_AppointmentsProviderRemoveAppointmentActivatedEventArgs },
        { Py_tp_getset, _getset_AppointmentsProviderRemoveAppointmentActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_AppointmentsProviderRemoveAppointmentActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.AppointmentsProviderRemoveAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderRemoveAppointmentActivatedEventArgs
    };

    // ----- AppointmentsProviderReplaceAppointmentActivatedEventArgs class --------------------
    constexpr const char* const type_name_AppointmentsProviderReplaceAppointmentActivatedEventArgs = "AppointmentsProviderReplaceAppointmentActivatedEventArgs";

    static PyObject* _new_AppointmentsProviderReplaceAppointmentActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppointmentsProviderReplaceAppointmentActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderReplaceAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReplaceAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderReplaceAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "replace_appointment_operation", reinterpret_cast<getter>(AppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentsProviderReplaceAppointmentActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_AppointmentsProviderReplaceAppointmentActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_AppointmentsProviderReplaceAppointmentActivatedEventArgs },
        { Py_tp_methods, _methods_AppointmentsProviderReplaceAppointmentActivatedEventArgs },
        { Py_tp_getset, _getset_AppointmentsProviderReplaceAppointmentActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_AppointmentsProviderReplaceAppointmentActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.AppointmentsProviderReplaceAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderReplaceAppointmentActivatedEventArgs
    };

    // ----- AppointmentsProviderShowAppointmentDetailsActivatedEventArgs class --------------------
    constexpr const char* const type_name_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs = "AppointmentsProviderShowAppointmentDetailsActivatedEventArgs";

    static PyObject* _new_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstanceStartDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoamingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "instance_start_date", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate), nullptr, nullptr, nullptr },
        { "local_id", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId), nullptr, nullptr, nullptr },
        { "roaming_id", reinterpret_cast<getter>(AppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs },
        { Py_tp_methods, _methods_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs },
        { Py_tp_getset, _getset_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.AppointmentsProviderShowAppointmentDetailsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs
    };

    // ----- AppointmentsProviderShowTimeFrameActivatedEventArgs class --------------------
    constexpr const char* const type_name_AppointmentsProviderShowTimeFrameActivatedEventArgs = "AppointmentsProviderShowTimeFrameActivatedEventArgs";

    static PyObject* _new_AppointmentsProviderShowTimeFrameActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_AppointmentsProviderShowTimeFrameActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_AppointmentsProviderShowTimeFrameActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* AppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeToShow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_AppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_AppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_AppointmentsProviderShowTimeFrameActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_AppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "duration", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration), nullptr, nullptr, nullptr },
        { "time_to_show", reinterpret_cast<getter>(AppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_AppointmentsProviderShowTimeFrameActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_AppointmentsProviderShowTimeFrameActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_AppointmentsProviderShowTimeFrameActivatedEventArgs },
        { Py_tp_methods, _methods_AppointmentsProviderShowTimeFrameActivatedEventArgs },
        { Py_tp_getset, _getset_AppointmentsProviderShowTimeFrameActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_AppointmentsProviderShowTimeFrameActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.AppointmentsProviderShowTimeFrameActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_AppointmentsProviderShowTimeFrameActivatedEventArgs
    };

    // ----- BackgroundActivatedEventArgs class --------------------
    constexpr const char* const type_name_BackgroundActivatedEventArgs = "BackgroundActivatedEventArgs";

    static PyObject* _new_BackgroundActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BackgroundActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_BackgroundActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BackgroundActivatedEventArgs_get_TaskInstance(py::wrapper::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskInstance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BackgroundActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BackgroundActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BackgroundActivatedEventArgs[] = {
        { "task_instance", reinterpret_cast<getter>(BackgroundActivatedEventArgs_get_TaskInstance), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BackgroundActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_BackgroundActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_BackgroundActivatedEventArgs },
        { Py_tp_methods, _methods_BackgroundActivatedEventArgs },
        { Py_tp_getset, _getset_BackgroundActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_BackgroundActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.BackgroundActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BackgroundActivatedEventArgs
    };

    // ----- BarcodeScannerPreviewActivatedEventArgs class --------------------
    constexpr const char* const type_name_BarcodeScannerPreviewActivatedEventArgs = "BarcodeScannerPreviewActivatedEventArgs";

    static PyObject* _new_BarcodeScannerPreviewActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_BarcodeScannerPreviewActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_BarcodeScannerPreviewActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* BarcodeScannerPreviewActivatedEventArgs_get_ConnectionId(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_BarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_BarcodeScannerPreviewActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_BarcodeScannerPreviewActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_BarcodeScannerPreviewActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "connection_id", reinterpret_cast<getter>(BarcodeScannerPreviewActivatedEventArgs_get_ConnectionId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_BarcodeScannerPreviewActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_BarcodeScannerPreviewActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_BarcodeScannerPreviewActivatedEventArgs },
        { Py_tp_methods, _methods_BarcodeScannerPreviewActivatedEventArgs },
        { Py_tp_getset, _getset_BarcodeScannerPreviewActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_BarcodeScannerPreviewActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.BarcodeScannerPreviewActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_BarcodeScannerPreviewActivatedEventArgs
    };

    // ----- CachedFileUpdaterActivatedEventArgs class --------------------
    constexpr const char* const type_name_CachedFileUpdaterActivatedEventArgs = "CachedFileUpdaterActivatedEventArgs";

    static PyObject* _new_CachedFileUpdaterActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CachedFileUpdaterActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_CachedFileUpdaterActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CachedFileUpdaterUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CachedFileUpdaterActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CachedFileUpdaterActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CachedFileUpdaterActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "cached_file_updater_u_i", reinterpret_cast<getter>(CachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CachedFileUpdaterActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_CachedFileUpdaterActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_CachedFileUpdaterActivatedEventArgs },
        { Py_tp_methods, _methods_CachedFileUpdaterActivatedEventArgs },
        { Py_tp_getset, _getset_CachedFileUpdaterActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_CachedFileUpdaterActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.CachedFileUpdaterActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CachedFileUpdaterActivatedEventArgs
    };

    // ----- CameraSettingsActivatedEventArgs class --------------------
    constexpr const char* const type_name_CameraSettingsActivatedEventArgs = "CameraSettingsActivatedEventArgs";

    static PyObject* _new_CameraSettingsActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CameraSettingsActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_CameraSettingsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_VideoDeviceController(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CameraSettingsActivatedEventArgs_get_VideoDeviceExtension(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceExtension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CameraSettingsActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CameraSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CameraSettingsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "video_device_controller", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_VideoDeviceController), nullptr, nullptr, nullptr },
        { "video_device_extension", reinterpret_cast<getter>(CameraSettingsActivatedEventArgs_get_VideoDeviceExtension), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CameraSettingsActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_CameraSettingsActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_CameraSettingsActivatedEventArgs },
        { Py_tp_methods, _methods_CameraSettingsActivatedEventArgs },
        { Py_tp_getset, _getset_CameraSettingsActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_CameraSettingsActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.CameraSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CameraSettingsActivatedEventArgs
    };

    // ----- CommandLineActivatedEventArgs class --------------------
    constexpr const char* const type_name_CommandLineActivatedEventArgs = "CommandLineActivatedEventArgs";

    static PyObject* _new_CommandLineActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CommandLineActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_CommandLineActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandLineActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandLineActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandLineActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandLineActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(CommandLineActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandLineActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_CommandLineActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_CommandLineActivatedEventArgs },
        { Py_tp_methods, _methods_CommandLineActivatedEventArgs },
        { Py_tp_getset, _getset_CommandLineActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_CommandLineActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.CommandLineActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandLineActivatedEventArgs
    };

    // ----- CommandLineActivationOperation class --------------------
    constexpr const char* const type_name_CommandLineActivationOperation = "CommandLineActivationOperation";

    static PyObject* _new_CommandLineActivationOperation(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_CommandLineActivationOperation);
        return nullptr;
    }

    static void _dealloc_CommandLineActivationOperation(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* CommandLineActivationOperation_GetDeferral(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetDeferral());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* CommandLineActivationOperation_get_ExitCode(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExitCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int CommandLineActivationOperation_put_ExitCode(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.ExitCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* CommandLineActivationOperation_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* CommandLineActivationOperation_get_CurrentDirectoryPath(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentDirectoryPath());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_CommandLineActivationOperation(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::CommandLineActivationOperation>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_CommandLineActivationOperation[] = {
        { "get_deferral", reinterpret_cast<PyCFunction>(CommandLineActivationOperation_GetDeferral), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_CommandLineActivationOperation), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_CommandLineActivationOperation[] = {
        { "exit_code", reinterpret_cast<getter>(CommandLineActivationOperation_get_ExitCode), reinterpret_cast<setter>(CommandLineActivationOperation_put_ExitCode), nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(CommandLineActivationOperation_get_Arguments), nullptr, nullptr, nullptr },
        { "current_directory_path", reinterpret_cast<getter>(CommandLineActivationOperation_get_CurrentDirectoryPath), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_CommandLineActivationOperation[] = 
    {
        { Py_tp_new, _new_CommandLineActivationOperation },
        { Py_tp_dealloc, _dealloc_CommandLineActivationOperation },
        { Py_tp_methods, _methods_CommandLineActivationOperation },
        { Py_tp_getset, _getset_CommandLineActivationOperation },
        { },
    };

    static PyType_Spec type_spec_CommandLineActivationOperation =
    {
        "_winsdk_Windows_ApplicationModel_Activation.CommandLineActivationOperation",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::CommandLineActivationOperation),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_CommandLineActivationOperation
    };

    // ----- ContactCallActivatedEventArgs class --------------------
    constexpr const char* const type_name_ContactCallActivatedEventArgs = "ContactCallActivatedEventArgs";

    static PyObject* _new_ContactCallActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactCallActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactCallActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(ContactCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactCallActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ContactCallActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ContactCallActivatedEventArgs },
        { Py_tp_methods, _methods_ContactCallActivatedEventArgs },
        { Py_tp_getset, _getset_ContactCallActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ContactCallActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ContactCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactCallActivatedEventArgs
    };

    // ----- ContactMapActivatedEventArgs class --------------------
    constexpr const char* const type_name_ContactMapActivatedEventArgs = "ContactMapActivatedEventArgs";

    static PyObject* _new_ContactMapActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactMapActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactMapActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactMapActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_Address(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMapActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactMapActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactMapActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactMapActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "address", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_Address), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactMapActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactMapActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ContactMapActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ContactMapActivatedEventArgs },
        { Py_tp_methods, _methods_ContactMapActivatedEventArgs },
        { Py_tp_getset, _getset_ContactMapActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ContactMapActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ContactMapActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactMapActivatedEventArgs
    };

    // ----- ContactMessageActivatedEventArgs class --------------------
    constexpr const char* const type_name_ContactMessageActivatedEventArgs = "ContactMessageActivatedEventArgs";

    static PyObject* _new_ContactMessageActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactMessageActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactMessageActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactMessageActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactMessageActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactMessageActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactMessageActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactMessageActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(ContactMessageActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactMessageActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ContactMessageActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ContactMessageActivatedEventArgs },
        { Py_tp_methods, _methods_ContactMessageActivatedEventArgs },
        { Py_tp_getset, _getset_ContactMessageActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ContactMessageActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ContactMessageActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactMessageActivatedEventArgs
    };

    // ----- ContactPanelActivatedEventArgs class --------------------
    constexpr const char* const type_name_ContactPanelActivatedEventArgs = "ContactPanelActivatedEventArgs";

    static PyObject* _new_ContactPanelActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactPanelActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactPanelActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactPanelActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPanelActivatedEventArgs_get_ContactPanel(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactPanel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPanelActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPanelActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPanelActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "contact_panel", reinterpret_cast<getter>(ContactPanelActivatedEventArgs_get_ContactPanel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactPanelActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ContactPanelActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ContactPanelActivatedEventArgs },
        { Py_tp_methods, _methods_ContactPanelActivatedEventArgs },
        { Py_tp_getset, _getset_ContactPanelActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ContactPanelActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ContactPanelActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPanelActivatedEventArgs
    };

    // ----- ContactPickerActivatedEventArgs class --------------------
    constexpr const char* const type_name_ContactPickerActivatedEventArgs = "ContactPickerActivatedEventArgs";

    static PyObject* _new_ContactPickerActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactPickerActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactPickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPickerActivatedEventArgs_get_ContactPickerUI(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactPickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPickerActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "contact_picker_u_i", reinterpret_cast<getter>(ContactPickerActivatedEventArgs_get_ContactPickerUI), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactPickerActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ContactPickerActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ContactPickerActivatedEventArgs },
        { Py_tp_methods, _methods_ContactPickerActivatedEventArgs },
        { Py_tp_getset, _getset_ContactPickerActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ContactPickerActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ContactPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPickerActivatedEventArgs
    };

    // ----- ContactPostActivatedEventArgs class --------------------
    constexpr const char* const type_name_ContactPostActivatedEventArgs = "ContactPostActivatedEventArgs";

    static PyObject* _new_ContactPostActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactPostActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactPostActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactPostActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactPostActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactPostActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactPostActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactPostActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(ContactPostActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactPostActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ContactPostActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ContactPostActivatedEventArgs },
        { Py_tp_methods, _methods_ContactPostActivatedEventArgs },
        { Py_tp_getset, _getset_ContactPostActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ContactPostActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ContactPostActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactPostActivatedEventArgs
    };

    // ----- ContactVideoCallActivatedEventArgs class --------------------
    constexpr const char* const type_name_ContactVideoCallActivatedEventArgs = "ContactVideoCallActivatedEventArgs";

    static PyObject* _new_ContactVideoCallActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ContactVideoCallActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ContactVideoCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ContactVideoCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ContactVideoCallActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ContactVideoCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ContactVideoCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(ContactVideoCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ContactVideoCallActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ContactVideoCallActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ContactVideoCallActivatedEventArgs },
        { Py_tp_methods, _methods_ContactVideoCallActivatedEventArgs },
        { Py_tp_getset, _getset_ContactVideoCallActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ContactVideoCallActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ContactVideoCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ContactVideoCallActivatedEventArgs
    };

    // ----- DeviceActivatedEventArgs class --------------------
    constexpr const char* const type_name_DeviceActivatedEventArgs = "DeviceActivatedEventArgs";

    static PyObject* _new_DeviceActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DeviceActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_DeviceActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DeviceActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_DeviceInformationId(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInformationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DeviceActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DeviceActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DeviceActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DeviceActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "device_information_id", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_DeviceInformationId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(DeviceActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DeviceActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_DeviceActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_DeviceActivatedEventArgs },
        { Py_tp_methods, _methods_DeviceActivatedEventArgs },
        { Py_tp_getset, _getset_DeviceActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_DeviceActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.DeviceActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DeviceActivatedEventArgs
    };

    // ----- DevicePairingActivatedEventArgs class --------------------
    constexpr const char* const type_name_DevicePairingActivatedEventArgs = "DevicePairingActivatedEventArgs";

    static PyObject* _new_DevicePairingActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DevicePairingActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_DevicePairingActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DevicePairingActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DevicePairingActivatedEventArgs_get_DeviceInformation(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DevicePairingActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DevicePairingActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DevicePairingActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "device_information", reinterpret_cast<getter>(DevicePairingActivatedEventArgs_get_DeviceInformation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DevicePairingActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_DevicePairingActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_DevicePairingActivatedEventArgs },
        { Py_tp_methods, _methods_DevicePairingActivatedEventArgs },
        { Py_tp_getset, _getset_DevicePairingActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_DevicePairingActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.DevicePairingActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DevicePairingActivatedEventArgs
    };

    // ----- DialReceiverActivatedEventArgs class --------------------
    constexpr const char* const type_name_DialReceiverActivatedEventArgs = "DialReceiverActivatedEventArgs";

    static PyObject* _new_DialReceiverActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_DialReceiverActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_DialReceiverActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* DialReceiverActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_AppName(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DialReceiverActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DialReceiverActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DialReceiverActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DialReceiverActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "app_name", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_AppName), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(DialReceiverActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DialReceiverActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_DialReceiverActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_DialReceiverActivatedEventArgs },
        { Py_tp_methods, _methods_DialReceiverActivatedEventArgs },
        { Py_tp_getset, _getset_DialReceiverActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_DialReceiverActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.DialReceiverActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DialReceiverActivatedEventArgs
    };

    // ----- FileActivatedEventArgs class --------------------
    constexpr const char* const type_name_FileActivatedEventArgs = "FileActivatedEventArgs";

    static PyObject* _new_FileActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FileActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_FileActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_Files(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Files());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_NeighboringFilesQuery(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NeighboringFilesQuery());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FileActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FileActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(FileActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "files", reinterpret_cast<getter>(FileActivatedEventArgs_get_Files), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(FileActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(FileActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "neighboring_files_query", reinterpret_cast<getter>(FileActivatedEventArgs_get_NeighboringFilesQuery), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(FileActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_FileActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_FileActivatedEventArgs },
        { Py_tp_methods, _methods_FileActivatedEventArgs },
        { Py_tp_getset, _getset_FileActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_FileActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.FileActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileActivatedEventArgs
    };

    // ----- FileOpenPickerActivatedEventArgs class --------------------
    constexpr const char* const type_name_FileOpenPickerActivatedEventArgs = "FileOpenPickerActivatedEventArgs";

    static PyObject* _new_FileOpenPickerActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FileOpenPickerActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_FileOpenPickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_FileOpenPickerUI(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileOpenPickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileOpenPickerActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FileOpenPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileOpenPickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "file_open_picker_u_i", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_FileOpenPickerUI), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(FileOpenPickerActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileOpenPickerActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_FileOpenPickerActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_FileOpenPickerActivatedEventArgs },
        { Py_tp_methods, _methods_FileOpenPickerActivatedEventArgs },
        { Py_tp_getset, _getset_FileOpenPickerActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_FileOpenPickerActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.FileOpenPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileOpenPickerActivatedEventArgs
    };

    // ----- FileOpenPickerContinuationEventArgs class --------------------
    constexpr const char* const type_name_FileOpenPickerContinuationEventArgs = "FileOpenPickerContinuationEventArgs";

    static PyObject* _new_FileOpenPickerContinuationEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FileOpenPickerContinuationEventArgs);
        return nullptr;
    }

    static void _dealloc_FileOpenPickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileOpenPickerContinuationEventArgs_get_Files(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Files());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileOpenPickerContinuationEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FileOpenPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileOpenPickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "files", reinterpret_cast<getter>(FileOpenPickerContinuationEventArgs_get_Files), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileOpenPickerContinuationEventArgs[] = 
    {
        { Py_tp_new, _new_FileOpenPickerContinuationEventArgs },
        { Py_tp_dealloc, _dealloc_FileOpenPickerContinuationEventArgs },
        { Py_tp_methods, _methods_FileOpenPickerContinuationEventArgs },
        { Py_tp_getset, _getset_FileOpenPickerContinuationEventArgs },
        { },
    };

    static PyType_Spec type_spec_FileOpenPickerContinuationEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.FileOpenPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileOpenPickerContinuationEventArgs
    };

    // ----- FileSavePickerActivatedEventArgs class --------------------
    constexpr const char* const type_name_FileSavePickerActivatedEventArgs = "FileSavePickerActivatedEventArgs";

    static PyObject* _new_FileSavePickerActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FileSavePickerActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_FileSavePickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_FileSavePickerUI(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileSavePickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerActivatedEventArgs_get_EnterpriseId(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EnterpriseId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileSavePickerActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FileSavePickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileSavePickerActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "file_save_picker_u_i", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_FileSavePickerUI), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "enterprise_id", reinterpret_cast<getter>(FileSavePickerActivatedEventArgs_get_EnterpriseId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileSavePickerActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_FileSavePickerActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_FileSavePickerActivatedEventArgs },
        { Py_tp_methods, _methods_FileSavePickerActivatedEventArgs },
        { Py_tp_getset, _getset_FileSavePickerActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_FileSavePickerActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.FileSavePickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileSavePickerActivatedEventArgs
    };

    // ----- FileSavePickerContinuationEventArgs class --------------------
    constexpr const char* const type_name_FileSavePickerContinuationEventArgs = "FileSavePickerContinuationEventArgs";

    static PyObject* _new_FileSavePickerContinuationEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FileSavePickerContinuationEventArgs);
        return nullptr;
    }

    static void _dealloc_FileSavePickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FileSavePickerContinuationEventArgs_get_File(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FileSavePickerContinuationEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FileSavePickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FileSavePickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "file", reinterpret_cast<getter>(FileSavePickerContinuationEventArgs_get_File), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FileSavePickerContinuationEventArgs[] = 
    {
        { Py_tp_new, _new_FileSavePickerContinuationEventArgs },
        { Py_tp_dealloc, _dealloc_FileSavePickerContinuationEventArgs },
        { Py_tp_methods, _methods_FileSavePickerContinuationEventArgs },
        { Py_tp_getset, _getset_FileSavePickerContinuationEventArgs },
        { },
    };

    static PyType_Spec type_spec_FileSavePickerContinuationEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.FileSavePickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FileSavePickerContinuationEventArgs
    };

    // ----- FolderPickerContinuationEventArgs class --------------------
    constexpr const char* const type_name_FolderPickerContinuationEventArgs = "FolderPickerContinuationEventArgs";

    static PyObject* _new_FolderPickerContinuationEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_FolderPickerContinuationEventArgs);
        return nullptr;
    }

    static void _dealloc_FolderPickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* FolderPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* FolderPickerContinuationEventArgs_get_Folder(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Folder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_FolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_FolderPickerContinuationEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_FolderPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_FolderPickerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_User), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "folder", reinterpret_cast<getter>(FolderPickerContinuationEventArgs_get_Folder), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_FolderPickerContinuationEventArgs[] = 
    {
        { Py_tp_new, _new_FolderPickerContinuationEventArgs },
        { Py_tp_dealloc, _dealloc_FolderPickerContinuationEventArgs },
        { Py_tp_methods, _methods_FolderPickerContinuationEventArgs },
        { Py_tp_getset, _getset_FolderPickerContinuationEventArgs },
        { },
    };

    static PyType_Spec type_spec_FolderPickerContinuationEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.FolderPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_FolderPickerContinuationEventArgs
    };

    // ----- LaunchActivatedEventArgs class --------------------
    constexpr const char* const type_name_LaunchActivatedEventArgs = "LaunchActivatedEventArgs";

    static PyObject* _new_LaunchActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LaunchActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_LaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_TileActivatedInfo(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TileActivatedInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_PrelaunchActivated(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrelaunchActivated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LaunchActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LaunchActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LaunchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "tile_activated_info", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_TileActivatedInfo), nullptr, nullptr, nullptr },
        { "prelaunch_activated", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_PrelaunchActivated), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(LaunchActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LaunchActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_LaunchActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_LaunchActivatedEventArgs },
        { Py_tp_methods, _methods_LaunchActivatedEventArgs },
        { Py_tp_getset, _getset_LaunchActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_LaunchActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.LaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LaunchActivatedEventArgs
    };

    // ----- LockScreenActivatedEventArgs class --------------------
    constexpr const char* const type_name_LockScreenActivatedEventArgs = "LockScreenActivatedEventArgs";

    static PyObject* _new_LockScreenActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LockScreenActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_LockScreenActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenActivatedEventArgs_get_Info(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Info());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LockScreenActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "info", reinterpret_cast<getter>(LockScreenActivatedEventArgs_get_Info), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LockScreenActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_LockScreenActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_LockScreenActivatedEventArgs },
        { Py_tp_methods, _methods_LockScreenActivatedEventArgs },
        { Py_tp_getset, _getset_LockScreenActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_LockScreenActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.LockScreenActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenActivatedEventArgs
    };

    // ----- LockScreenCallActivatedEventArgs class --------------------
    constexpr const char* const type_name_LockScreenCallActivatedEventArgs = "LockScreenCallActivatedEventArgs";

    static PyObject* _new_LockScreenCallActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LockScreenCallActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_LockScreenCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_CallUI(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenCallActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenCallActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LockScreenCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "call_u_i", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_CallUI), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(LockScreenCallActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LockScreenCallActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_LockScreenCallActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_LockScreenCallActivatedEventArgs },
        { Py_tp_methods, _methods_LockScreenCallActivatedEventArgs },
        { Py_tp_getset, _getset_LockScreenCallActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_LockScreenCallActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.LockScreenCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenCallActivatedEventArgs
    };

    // ----- LockScreenComponentActivatedEventArgs class --------------------
    constexpr const char* const type_name_LockScreenComponentActivatedEventArgs = "LockScreenComponentActivatedEventArgs";

    static PyObject* _new_LockScreenComponentActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_LockScreenComponentActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_LockScreenComponentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* LockScreenComponentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenComponentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* LockScreenComponentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_LockScreenComponentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_LockScreenComponentActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_LockScreenComponentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_LockScreenComponentActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(LockScreenComponentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(LockScreenComponentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(LockScreenComponentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_LockScreenComponentActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_LockScreenComponentActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_LockScreenComponentActivatedEventArgs },
        { Py_tp_methods, _methods_LockScreenComponentActivatedEventArgs },
        { Py_tp_getset, _getset_LockScreenComponentActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_LockScreenComponentActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.LockScreenComponentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_LockScreenComponentActivatedEventArgs
    };

    // ----- PhoneCallActivatedEventArgs class --------------------
    constexpr const char* const type_name_PhoneCallActivatedEventArgs = "PhoneCallActivatedEventArgs";

    static PyObject* _new_PhoneCallActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PhoneCallActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_PhoneCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PhoneCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PhoneCallActivatedEventArgs_get_LineId(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PhoneCallActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PhoneCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PhoneCallActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "line_id", reinterpret_cast<getter>(PhoneCallActivatedEventArgs_get_LineId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PhoneCallActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_PhoneCallActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_PhoneCallActivatedEventArgs },
        { Py_tp_methods, _methods_PhoneCallActivatedEventArgs },
        { Py_tp_getset, _getset_PhoneCallActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_PhoneCallActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.PhoneCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PhoneCallActivatedEventArgs
    };

    // ----- PickerReturnedActivatedEventArgs class --------------------
    constexpr const char* const type_name_PickerReturnedActivatedEventArgs = "PickerReturnedActivatedEventArgs";

    static PyObject* _new_PickerReturnedActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PickerReturnedActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_PickerReturnedActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PickerReturnedActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerReturnedActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerReturnedActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PickerReturnedActivatedEventArgs_get_PickerOperationId(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PickerOperationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PickerReturnedActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PickerReturnedActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PickerReturnedActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PickerReturnedActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(PickerReturnedActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(PickerReturnedActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(PickerReturnedActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "picker_operation_id", reinterpret_cast<getter>(PickerReturnedActivatedEventArgs_get_PickerOperationId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PickerReturnedActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_PickerReturnedActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_PickerReturnedActivatedEventArgs },
        { Py_tp_methods, _methods_PickerReturnedActivatedEventArgs },
        { Py_tp_getset, _getset_PickerReturnedActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_PickerReturnedActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.PickerReturnedActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PickerReturnedActivatedEventArgs
    };

    // ----- Print3DWorkflowActivatedEventArgs class --------------------
    constexpr const char* const type_name_Print3DWorkflowActivatedEventArgs = "Print3DWorkflowActivatedEventArgs";

    static PyObject* _new_Print3DWorkflowActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_Print3DWorkflowActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_Print3DWorkflowActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* Print3DWorkflowActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DWorkflowActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DWorkflowActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* Print3DWorkflowActivatedEventArgs_get_Workflow(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Workflow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_Print3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_Print3DWorkflowActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_Print3DWorkflowActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_Print3DWorkflowActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(Print3DWorkflowActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(Print3DWorkflowActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(Print3DWorkflowActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "workflow", reinterpret_cast<getter>(Print3DWorkflowActivatedEventArgs_get_Workflow), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_Print3DWorkflowActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_Print3DWorkflowActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_Print3DWorkflowActivatedEventArgs },
        { Py_tp_methods, _methods_Print3DWorkflowActivatedEventArgs },
        { Py_tp_getset, _getset_Print3DWorkflowActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_Print3DWorkflowActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.Print3DWorkflowActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_Print3DWorkflowActivatedEventArgs
    };

    // ----- PrintTaskSettingsActivatedEventArgs class --------------------
    constexpr const char* const type_name_PrintTaskSettingsActivatedEventArgs = "PrintTaskSettingsActivatedEventArgs";

    static PyObject* _new_PrintTaskSettingsActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_PrintTaskSettingsActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_PrintTaskSettingsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* PrintTaskSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintTaskSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* PrintTaskSettingsActivatedEventArgs_get_Configuration(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_PrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_PrintTaskSettingsActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_PrintTaskSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_PrintTaskSettingsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(PrintTaskSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(PrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(PrintTaskSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "configuration", reinterpret_cast<getter>(PrintTaskSettingsActivatedEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_PrintTaskSettingsActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_PrintTaskSettingsActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_PrintTaskSettingsActivatedEventArgs },
        { Py_tp_methods, _methods_PrintTaskSettingsActivatedEventArgs },
        { Py_tp_getset, _getset_PrintTaskSettingsActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_PrintTaskSettingsActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.PrintTaskSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_PrintTaskSettingsActivatedEventArgs
    };

    // ----- ProtocolActivatedEventArgs class --------------------
    constexpr const char* const type_name_ProtocolActivatedEventArgs = "ProtocolActivatedEventArgs";

    static PyObject* _new_ProtocolActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProtocolActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ProtocolActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProtocolActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_Uri(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_Data(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProtocolActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ProtocolActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProtocolActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(ProtocolActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProtocolActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ProtocolActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ProtocolActivatedEventArgs },
        { Py_tp_methods, _methods_ProtocolActivatedEventArgs },
        { Py_tp_getset, _getset_ProtocolActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ProtocolActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ProtocolActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProtocolActivatedEventArgs
    };

    // ----- ProtocolForResultsActivatedEventArgs class --------------------
    constexpr const char* const type_name_ProtocolForResultsActivatedEventArgs = "ProtocolForResultsActivatedEventArgs";

    static PyObject* _new_ProtocolForResultsActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ProtocolForResultsActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ProtocolForResultsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_Uri(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_Data(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtocolForResultsOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProtocolForResultsActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProtocolForResultsActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ProtocolForResultsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProtocolForResultsActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "uri", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "caller_package_family_name", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_Data), nullptr, nullptr, nullptr },
        { "protocol_for_results_operation", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(ProtocolForResultsActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProtocolForResultsActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ProtocolForResultsActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ProtocolForResultsActivatedEventArgs },
        { Py_tp_methods, _methods_ProtocolForResultsActivatedEventArgs },
        { Py_tp_getset, _getset_ProtocolForResultsActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ProtocolForResultsActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ProtocolForResultsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProtocolForResultsActivatedEventArgs
    };

    // ----- RestrictedLaunchActivatedEventArgs class --------------------
    constexpr const char* const type_name_RestrictedLaunchActivatedEventArgs = "RestrictedLaunchActivatedEventArgs";

    static PyObject* _new_RestrictedLaunchActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_RestrictedLaunchActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_RestrictedLaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* RestrictedLaunchActivatedEventArgs_get_SharedContext(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SharedContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_RestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_RestrictedLaunchActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_RestrictedLaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_RestrictedLaunchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "shared_context", reinterpret_cast<getter>(RestrictedLaunchActivatedEventArgs_get_SharedContext), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_RestrictedLaunchActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_RestrictedLaunchActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_RestrictedLaunchActivatedEventArgs },
        { Py_tp_methods, _methods_RestrictedLaunchActivatedEventArgs },
        { Py_tp_getset, _getset_RestrictedLaunchActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_RestrictedLaunchActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.RestrictedLaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_RestrictedLaunchActivatedEventArgs
    };

    // ----- SearchActivatedEventArgs class --------------------
    constexpr const char* const type_name_SearchActivatedEventArgs = "SearchActivatedEventArgs";

    static PyObject* _new_SearchActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SearchActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_SearchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SearchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinguisticDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SearchActivatedEventArgs_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SearchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::SearchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SearchActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SearchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SearchActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(SearchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(SearchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(SearchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(SearchActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(SearchActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "language", reinterpret_cast<getter>(SearchActivatedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(SearchActivatedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { "linguistic_details", reinterpret_cast<getter>(SearchActivatedEventArgs_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { "view_switcher", reinterpret_cast<getter>(SearchActivatedEventArgs_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SearchActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_SearchActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_SearchActivatedEventArgs },
        { Py_tp_methods, _methods_SearchActivatedEventArgs },
        { Py_tp_getset, _getset_SearchActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_SearchActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.SearchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::SearchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SearchActivatedEventArgs
    };

    // ----- ShareTargetActivatedEventArgs class --------------------
    constexpr const char* const type_name_ShareTargetActivatedEventArgs = "ShareTargetActivatedEventArgs";

    static PyObject* _new_ShareTargetActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ShareTargetActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ShareTargetActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ShareTargetActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareTargetActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareTargetActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareTargetActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ShareTargetActivatedEventArgs_get_ShareOperation(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShareOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ShareTargetActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ShareTargetActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ShareTargetActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "share_operation", reinterpret_cast<getter>(ShareTargetActivatedEventArgs_get_ShareOperation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ShareTargetActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ShareTargetActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ShareTargetActivatedEventArgs },
        { Py_tp_methods, _methods_ShareTargetActivatedEventArgs },
        { Py_tp_getset, _getset_ShareTargetActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ShareTargetActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ShareTargetActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ShareTargetActivatedEventArgs
    };

    // ----- SplashScreen class --------------------
    constexpr const char* const type_name_SplashScreen = "SplashScreen";

    static PyObject* _new_SplashScreen(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_SplashScreen);
        return nullptr;
    }

    static void _dealloc_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* SplashScreen_get_ImageLocation(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ImageLocation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplashScreen_add_Dismissed(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::Windows::Foundation::TypedEventHandler<winrt::Windows::ApplicationModel::Activation::SplashScreen, winrt::Windows::Foundation::IInspectable>>(arg);

            return py::convert(self->obj.Dismissed(param0));
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SplashScreen_remove_Dismissed(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen* self, PyObject* arg) noexcept
    {
        try
        {
            auto param0 = py::convert_to<winrt::event_token>(arg);

            self->obj.Dismissed(param0);
            Py_RETURN_NONE;
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SplashScreen(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::SplashScreen>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SplashScreen[] = {
        { "add_dismissed", reinterpret_cast<PyCFunction>(SplashScreen_add_Dismissed), METH_O, nullptr },
        { "remove_dismissed", reinterpret_cast<PyCFunction>(SplashScreen_remove_Dismissed), METH_O, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SplashScreen), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SplashScreen[] = {
        { "image_location", reinterpret_cast<getter>(SplashScreen_get_ImageLocation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SplashScreen[] = 
    {
        { Py_tp_new, _new_SplashScreen },
        { Py_tp_dealloc, _dealloc_SplashScreen },
        { Py_tp_methods, _methods_SplashScreen },
        { Py_tp_getset, _getset_SplashScreen },
        { },
    };

    static PyType_Spec type_spec_SplashScreen =
    {
        "_winsdk_Windows_ApplicationModel_Activation.SplashScreen",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::SplashScreen),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SplashScreen
    };

    // ----- StartupTaskActivatedEventArgs class --------------------
    constexpr const char* const type_name_StartupTaskActivatedEventArgs = "StartupTaskActivatedEventArgs";

    static PyObject* _new_StartupTaskActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_StartupTaskActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_StartupTaskActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* StartupTaskActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTaskActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTaskActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTaskActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* StartupTaskActivatedEventArgs_get_TaskId(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_StartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_StartupTaskActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_StartupTaskActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_StartupTaskActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "task_id", reinterpret_cast<getter>(StartupTaskActivatedEventArgs_get_TaskId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_StartupTaskActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_StartupTaskActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_StartupTaskActivatedEventArgs },
        { Py_tp_methods, _methods_StartupTaskActivatedEventArgs },
        { Py_tp_getset, _getset_StartupTaskActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_StartupTaskActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.StartupTaskActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_StartupTaskActivatedEventArgs
    };

    // ----- TileActivatedInfo class --------------------
    constexpr const char* const type_name_TileActivatedInfo = "TileActivatedInfo";

    static PyObject* _new_TileActivatedInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_TileActivatedInfo);
        return nullptr;
    }

    static void _dealloc_TileActivatedInfo(py::wrapper::Windows::ApplicationModel::Activation::TileActivatedInfo* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* TileActivatedInfo_get_RecentlyShownNotifications(py::wrapper::Windows::ApplicationModel::Activation::TileActivatedInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RecentlyShownNotifications());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_TileActivatedInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::TileActivatedInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_TileActivatedInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_TileActivatedInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_TileActivatedInfo[] = {
        { "recently_shown_notifications", reinterpret_cast<getter>(TileActivatedInfo_get_RecentlyShownNotifications), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_TileActivatedInfo[] = 
    {
        { Py_tp_new, _new_TileActivatedInfo },
        { Py_tp_dealloc, _dealloc_TileActivatedInfo },
        { Py_tp_methods, _methods_TileActivatedInfo },
        { Py_tp_getset, _getset_TileActivatedInfo },
        { },
    };

    static PyType_Spec type_spec_TileActivatedInfo =
    {
        "_winsdk_Windows_ApplicationModel_Activation.TileActivatedInfo",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::TileActivatedInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_TileActivatedInfo
    };

    // ----- ToastNotificationActivatedEventArgs class --------------------
    constexpr const char* const type_name_ToastNotificationActivatedEventArgs = "ToastNotificationActivatedEventArgs";

    static PyObject* _new_ToastNotificationActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_ToastNotificationActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ToastNotificationActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_Argument(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Argument());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ToastNotificationActivatedEventArgs_get_UserInput(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ToastNotificationActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ToastNotificationActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ToastNotificationActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "currently_shown_application_view_id", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "argument", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_Argument), nullptr, nullptr, nullptr },
        { "user_input", reinterpret_cast<getter>(ToastNotificationActivatedEventArgs_get_UserInput), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ToastNotificationActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ToastNotificationActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ToastNotificationActivatedEventArgs },
        { Py_tp_methods, _methods_ToastNotificationActivatedEventArgs },
        { Py_tp_getset, _getset_ToastNotificationActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ToastNotificationActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ToastNotificationActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ToastNotificationActivatedEventArgs
    };

    // ----- UserDataAccountProviderActivatedEventArgs class --------------------
    constexpr const char* const type_name_UserDataAccountProviderActivatedEventArgs = "UserDataAccountProviderActivatedEventArgs";

    static PyObject* _new_UserDataAccountProviderActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_UserDataAccountProviderActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_UserDataAccountProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* UserDataAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* UserDataAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_UserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_UserDataAccountProviderActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_UserDataAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_UserDataAccountProviderActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(UserDataAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(UserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(UserDataAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(UserDataAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_UserDataAccountProviderActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_UserDataAccountProviderActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_UserDataAccountProviderActivatedEventArgs },
        { Py_tp_methods, _methods_UserDataAccountProviderActivatedEventArgs },
        { Py_tp_getset, _getset_UserDataAccountProviderActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_UserDataAccountProviderActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.UserDataAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_UserDataAccountProviderActivatedEventArgs
    };

    // ----- VoiceCommandActivatedEventArgs class --------------------
    constexpr const char* const type_name_VoiceCommandActivatedEventArgs = "VoiceCommandActivatedEventArgs";

    static PyObject* _new_VoiceCommandActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_VoiceCommandActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_VoiceCommandActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* VoiceCommandActivatedEventArgs_get_Result(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_VoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_VoiceCommandActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_VoiceCommandActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_VoiceCommandActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "result", reinterpret_cast<getter>(VoiceCommandActivatedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_VoiceCommandActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_VoiceCommandActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_VoiceCommandActivatedEventArgs },
        { Py_tp_methods, _methods_VoiceCommandActivatedEventArgs },
        { Py_tp_getset, _getset_VoiceCommandActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_VoiceCommandActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.VoiceCommandActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_VoiceCommandActivatedEventArgs
    };

    // ----- WalletActionActivatedEventArgs class --------------------
    constexpr const char* const type_name_WalletActionActivatedEventArgs = "WalletActionActivatedEventArgs";

    static PyObject* _new_WalletActionActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WalletActionActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WalletActionActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WalletActionActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_ActionId(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_ActionKind(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActionKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WalletActionActivatedEventArgs_get_ItemId(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ItemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WalletActionActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_WalletActionActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WalletActionActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "action_id", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_ActionId), nullptr, nullptr, nullptr },
        { "action_kind", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_ActionKind), nullptr, nullptr, nullptr },
        { "item_id", reinterpret_cast<getter>(WalletActionActivatedEventArgs_get_ItemId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WalletActionActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_WalletActionActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_WalletActionActivatedEventArgs },
        { Py_tp_methods, _methods_WalletActionActivatedEventArgs },
        { Py_tp_getset, _getset_WalletActionActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_WalletActionActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.WalletActionActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WalletActionActivatedEventArgs
    };

    // ----- WebAccountProviderActivatedEventArgs class --------------------
    constexpr const char* const type_name_WebAccountProviderActivatedEventArgs = "WebAccountProviderActivatedEventArgs";

    static PyObject* _new_WebAccountProviderActivatedEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebAccountProviderActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_WebAccountProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_User(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebAccountProviderActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_WebAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebAccountProviderActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "user", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_User), nullptr, nullptr, nullptr },
        { "operation", reinterpret_cast<getter>(WebAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebAccountProviderActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_WebAccountProviderActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_WebAccountProviderActivatedEventArgs },
        { Py_tp_methods, _methods_WebAccountProviderActivatedEventArgs },
        { Py_tp_getset, _getset_WebAccountProviderActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_WebAccountProviderActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.WebAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebAccountProviderActivatedEventArgs
    };

    // ----- WebAuthenticationBrokerContinuationEventArgs class --------------------
    constexpr const char* const type_name_WebAuthenticationBrokerContinuationEventArgs = "WebAuthenticationBrokerContinuationEventArgs";

    static PyObject* _new_WebAuthenticationBrokerContinuationEventArgs(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(type_name_WebAuthenticationBrokerContinuationEventArgs);
        return nullptr;
    }

    static void _dealloc_WebAuthenticationBrokerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* WebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WebAuthenticationResult());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_WebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_WebAuthenticationBrokerContinuationEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_WebAuthenticationBrokerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_WebAuthenticationBrokerContinuationEventArgs[] = {
        { "kind", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "web_authentication_result", reinterpret_cast<getter>(WebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_WebAuthenticationBrokerContinuationEventArgs[] = 
    {
        { Py_tp_new, _new_WebAuthenticationBrokerContinuationEventArgs },
        { Py_tp_dealloc, _dealloc_WebAuthenticationBrokerContinuationEventArgs },
        { Py_tp_methods, _methods_WebAuthenticationBrokerContinuationEventArgs },
        { Py_tp_getset, _getset_WebAuthenticationBrokerContinuationEventArgs },
        { },
    };

    static PyType_Spec type_spec_WebAuthenticationBrokerContinuationEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.WebAuthenticationBrokerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_WebAuthenticationBrokerContinuationEventArgs
    };

    // ----- IActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IActivatedEventArgs = "IActivatedEventArgs";

    static PyObject* _new_IActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IActivatedEventArgs[] = {
        { "kind", reinterpret_cast<getter>(IActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IActivatedEventArgs },
        { Py_tp_methods, _methods_IActivatedEventArgs },
        { Py_tp_getset, _getset_IActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IActivatedEventArgs
    };

    // ----- IActivatedEventArgsWithUser interface --------------------
    constexpr const char* const type_name_IActivatedEventArgsWithUser = "IActivatedEventArgsWithUser";

    static PyObject* _new_IActivatedEventArgsWithUser(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IActivatedEventArgsWithUser);
        return nullptr;
    }

    static void _dealloc_IActivatedEventArgsWithUser(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IActivatedEventArgsWithUser_get_User(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.User());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgsWithUser_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgsWithUser_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IActivatedEventArgsWithUser_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IActivatedEventArgsWithUser(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IActivatedEventArgsWithUser[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IActivatedEventArgsWithUser), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IActivatedEventArgsWithUser[] = {
        { "user", reinterpret_cast<getter>(IActivatedEventArgsWithUser_get_User), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IActivatedEventArgsWithUser_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IActivatedEventArgsWithUser_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IActivatedEventArgsWithUser_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IActivatedEventArgsWithUser[] = 
    {
        { Py_tp_new, _new_IActivatedEventArgsWithUser },
        { Py_tp_dealloc, _dealloc_IActivatedEventArgsWithUser },
        { Py_tp_methods, _methods_IActivatedEventArgsWithUser },
        { Py_tp_getset, _getset_IActivatedEventArgsWithUser },
        { },
    };

    static PyType_Spec type_spec_IActivatedEventArgsWithUser =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IActivatedEventArgsWithUser",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IActivatedEventArgsWithUser
    };

    // ----- IApplicationViewActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IApplicationViewActivatedEventArgs = "IApplicationViewActivatedEventArgs";

    static PyObject* _new_IApplicationViewActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IApplicationViewActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IApplicationViewActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IApplicationViewActivatedEventArgs_get_CurrentlyShownApplicationViewId(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CurrentlyShownApplicationViewId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IApplicationViewActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IApplicationViewActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IApplicationViewActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IApplicationViewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IApplicationViewActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IApplicationViewActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IApplicationViewActivatedEventArgs[] = {
        { "currently_shown_application_view_id", reinterpret_cast<getter>(IApplicationViewActivatedEventArgs_get_CurrentlyShownApplicationViewId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IApplicationViewActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IApplicationViewActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IApplicationViewActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IApplicationViewActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IApplicationViewActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IApplicationViewActivatedEventArgs },
        { Py_tp_methods, _methods_IApplicationViewActivatedEventArgs },
        { Py_tp_getset, _getset_IApplicationViewActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IApplicationViewActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IApplicationViewActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IApplicationViewActivatedEventArgs
    };

    // ----- IAppointmentsProviderActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IAppointmentsProviderActivatedEventArgs = "IAppointmentsProviderActivatedEventArgs";

    static PyObject* _new_IAppointmentsProviderActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IAppointmentsProviderActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IAppointmentsProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IAppointmentsProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAppointmentsProviderActivatedEventArgs[] = {
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAppointmentsProviderActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IAppointmentsProviderActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IAppointmentsProviderActivatedEventArgs },
        { Py_tp_methods, _methods_IAppointmentsProviderActivatedEventArgs },
        { Py_tp_getset, _getset_IAppointmentsProviderActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IAppointmentsProviderActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IAppointmentsProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAppointmentsProviderActivatedEventArgs
    };

    // ----- IAppointmentsProviderAddAppointmentActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IAppointmentsProviderAddAppointmentActivatedEventArgs = "IAppointmentsProviderAddAppointmentActivatedEventArgs";

    static PyObject* _new_IAppointmentsProviderAddAppointmentActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IAppointmentsProviderAddAppointmentActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IAppointmentsProviderAddAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AddAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IAppointmentsProviderAddAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderAddAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAppointmentsProviderAddAppointmentActivatedEventArgs[] = {
        { "add_appointment_operation", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_AddAppointmentOperation), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderAddAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAppointmentsProviderAddAppointmentActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IAppointmentsProviderAddAppointmentActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IAppointmentsProviderAddAppointmentActivatedEventArgs },
        { Py_tp_methods, _methods_IAppointmentsProviderAddAppointmentActivatedEventArgs },
        { Py_tp_getset, _getset_IAppointmentsProviderAddAppointmentActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IAppointmentsProviderAddAppointmentActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IAppointmentsProviderAddAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAppointmentsProviderAddAppointmentActivatedEventArgs
    };

    // ----- IAppointmentsProviderRemoveAppointmentActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IAppointmentsProviderRemoveAppointmentActivatedEventArgs = "IAppointmentsProviderRemoveAppointmentActivatedEventArgs";

    static PyObject* _new_IAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IAppointmentsProviderRemoveAppointmentActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IAppointmentsProviderRemoveAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RemoveAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IAppointmentsProviderRemoveAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderRemoveAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = {
        { "remove_appointment_operation", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_RemoveAppointmentOperation), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderRemoveAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAppointmentsProviderRemoveAppointmentActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IAppointmentsProviderRemoveAppointmentActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IAppointmentsProviderRemoveAppointmentActivatedEventArgs },
        { Py_tp_methods, _methods_IAppointmentsProviderRemoveAppointmentActivatedEventArgs },
        { Py_tp_getset, _getset_IAppointmentsProviderRemoveAppointmentActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IAppointmentsProviderRemoveAppointmentActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IAppointmentsProviderRemoveAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAppointmentsProviderRemoveAppointmentActivatedEventArgs
    };

    // ----- IAppointmentsProviderReplaceAppointmentActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IAppointmentsProviderReplaceAppointmentActivatedEventArgs = "IAppointmentsProviderReplaceAppointmentActivatedEventArgs";

    static PyObject* _new_IAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IAppointmentsProviderReplaceAppointmentActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IAppointmentsProviderReplaceAppointmentActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReplaceAppointmentOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IAppointmentsProviderReplaceAppointmentActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderReplaceAppointmentActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = {
        { "replace_appointment_operation", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_ReplaceAppointmentOperation), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderReplaceAppointmentActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAppointmentsProviderReplaceAppointmentActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IAppointmentsProviderReplaceAppointmentActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IAppointmentsProviderReplaceAppointmentActivatedEventArgs },
        { Py_tp_methods, _methods_IAppointmentsProviderReplaceAppointmentActivatedEventArgs },
        { Py_tp_getset, _getset_IAppointmentsProviderReplaceAppointmentActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IAppointmentsProviderReplaceAppointmentActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IAppointmentsProviderReplaceAppointmentActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAppointmentsProviderReplaceAppointmentActivatedEventArgs
    };

    // ----- IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs = "IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs";

    static PyObject* _new_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.InstanceStartDate());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LocalId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RoamingId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = {
        { "instance_start_date", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_InstanceStartDate), nullptr, nullptr, nullptr },
        { "local_id", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_LocalId), nullptr, nullptr, nullptr },
        { "roaming_id", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_RoamingId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs },
        { Py_tp_methods, _methods_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs },
        { Py_tp_getset, _getset_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs
    };

    // ----- IAppointmentsProviderShowTimeFrameActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IAppointmentsProviderShowTimeFrameActivatedEventArgs = "IAppointmentsProviderShowTimeFrameActivatedEventArgs";

    static PyObject* _new_IAppointmentsProviderShowTimeFrameActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IAppointmentsProviderShowTimeFrameActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IAppointmentsProviderShowTimeFrameActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Duration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeToShow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IAppointmentsProviderShowTimeFrameActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IAppointmentsProviderShowTimeFrameActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IAppointmentsProviderShowTimeFrameActivatedEventArgs[] = {
        { "duration", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Duration), nullptr, nullptr, nullptr },
        { "time_to_show", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_TimeToShow), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IAppointmentsProviderShowTimeFrameActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IAppointmentsProviderShowTimeFrameActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IAppointmentsProviderShowTimeFrameActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IAppointmentsProviderShowTimeFrameActivatedEventArgs },
        { Py_tp_methods, _methods_IAppointmentsProviderShowTimeFrameActivatedEventArgs },
        { Py_tp_getset, _getset_IAppointmentsProviderShowTimeFrameActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IAppointmentsProviderShowTimeFrameActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IAppointmentsProviderShowTimeFrameActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IAppointmentsProviderShowTimeFrameActivatedEventArgs
    };

    // ----- IBackgroundActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IBackgroundActivatedEventArgs = "IBackgroundActivatedEventArgs";

    static PyObject* _new_IBackgroundActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IBackgroundActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IBackgroundActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBackgroundActivatedEventArgs_get_TaskInstance(py::wrapper::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskInstance());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBackgroundActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBackgroundActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IBackgroundActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBackgroundActivatedEventArgs[] = {
        { "task_instance", reinterpret_cast<getter>(IBackgroundActivatedEventArgs_get_TaskInstance), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBackgroundActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IBackgroundActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IBackgroundActivatedEventArgs },
        { Py_tp_methods, _methods_IBackgroundActivatedEventArgs },
        { Py_tp_getset, _getset_IBackgroundActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IBackgroundActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IBackgroundActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBackgroundActivatedEventArgs
    };

    // ----- IBarcodeScannerPreviewActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IBarcodeScannerPreviewActivatedEventArgs = "IBarcodeScannerPreviewActivatedEventArgs";

    static PyObject* _new_IBarcodeScannerPreviewActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IBarcodeScannerPreviewActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IBarcodeScannerPreviewActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IBarcodeScannerPreviewActivatedEventArgs_get_ConnectionId(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ConnectionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBarcodeScannerPreviewActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IBarcodeScannerPreviewActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IBarcodeScannerPreviewActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IBarcodeScannerPreviewActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IBarcodeScannerPreviewActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IBarcodeScannerPreviewActivatedEventArgs[] = {
        { "connection_id", reinterpret_cast<getter>(IBarcodeScannerPreviewActivatedEventArgs_get_ConnectionId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IBarcodeScannerPreviewActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IBarcodeScannerPreviewActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IBarcodeScannerPreviewActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IBarcodeScannerPreviewActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IBarcodeScannerPreviewActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IBarcodeScannerPreviewActivatedEventArgs },
        { Py_tp_methods, _methods_IBarcodeScannerPreviewActivatedEventArgs },
        { Py_tp_getset, _getset_IBarcodeScannerPreviewActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IBarcodeScannerPreviewActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IBarcodeScannerPreviewActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IBarcodeScannerPreviewActivatedEventArgs
    };

    // ----- ICachedFileUpdaterActivatedEventArgs interface --------------------
    constexpr const char* const type_name_ICachedFileUpdaterActivatedEventArgs = "ICachedFileUpdaterActivatedEventArgs";

    static PyObject* _new_ICachedFileUpdaterActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_ICachedFileUpdaterActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ICachedFileUpdaterActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CachedFileUpdaterUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICachedFileUpdaterActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICachedFileUpdaterActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ICachedFileUpdaterActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICachedFileUpdaterActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ICachedFileUpdaterActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICachedFileUpdaterActivatedEventArgs[] = {
        { "cached_file_updater_u_i", reinterpret_cast<getter>(ICachedFileUpdaterActivatedEventArgs_get_CachedFileUpdaterUI), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ICachedFileUpdaterActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ICachedFileUpdaterActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ICachedFileUpdaterActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICachedFileUpdaterActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ICachedFileUpdaterActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ICachedFileUpdaterActivatedEventArgs },
        { Py_tp_methods, _methods_ICachedFileUpdaterActivatedEventArgs },
        { Py_tp_getset, _getset_ICachedFileUpdaterActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ICachedFileUpdaterActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ICachedFileUpdaterActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICachedFileUpdaterActivatedEventArgs
    };

    // ----- ICameraSettingsActivatedEventArgs interface --------------------
    constexpr const char* const type_name_ICameraSettingsActivatedEventArgs = "ICameraSettingsActivatedEventArgs";

    static PyObject* _new_ICameraSettingsActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_ICameraSettingsActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ICameraSettingsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_VideoDeviceController(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceController());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_VideoDeviceExtension(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VideoDeviceExtension());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICameraSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ICameraSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICameraSettingsActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ICameraSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICameraSettingsActivatedEventArgs[] = {
        { "video_device_controller", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_VideoDeviceController), nullptr, nullptr, nullptr },
        { "video_device_extension", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_VideoDeviceExtension), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ICameraSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICameraSettingsActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ICameraSettingsActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ICameraSettingsActivatedEventArgs },
        { Py_tp_methods, _methods_ICameraSettingsActivatedEventArgs },
        { Py_tp_getset, _getset_ICameraSettingsActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ICameraSettingsActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ICameraSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICameraSettingsActivatedEventArgs
    };

    // ----- ICommandLineActivatedEventArgs interface --------------------
    constexpr const char* const type_name_ICommandLineActivatedEventArgs = "ICommandLineActivatedEventArgs";

    static PyObject* _new_ICommandLineActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_ICommandLineActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ICommandLineActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ICommandLineActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommandLineActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommandLineActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ICommandLineActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ICommandLineActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ICommandLineActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ICommandLineActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ICommandLineActivatedEventArgs[] = {
        { "operation", reinterpret_cast<getter>(ICommandLineActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ICommandLineActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ICommandLineActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ICommandLineActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ICommandLineActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ICommandLineActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ICommandLineActivatedEventArgs },
        { Py_tp_methods, _methods_ICommandLineActivatedEventArgs },
        { Py_tp_getset, _getset_ICommandLineActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ICommandLineActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ICommandLineActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ICommandLineActivatedEventArgs
    };

    // ----- IContactActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IContactActivatedEventArgs = "IContactActivatedEventArgs";

    static PyObject* _new_IContactActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IContactActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IContactActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IContactActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactActivatedEventArgs[] = {
        { "verb", reinterpret_cast<getter>(IContactActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IContactActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IContactActivatedEventArgs },
        { Py_tp_methods, _methods_IContactActivatedEventArgs },
        { Py_tp_getset, _getset_IContactActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IContactActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IContactActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactActivatedEventArgs
    };

    // ----- IContactCallActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IContactCallActivatedEventArgs = "IContactCallActivatedEventArgs";

    static PyObject* _new_IContactCallActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IContactCallActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IContactCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactCallActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IContactCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactCallActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactCallActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactCallActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IContactCallActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IContactCallActivatedEventArgs },
        { Py_tp_methods, _methods_IContactCallActivatedEventArgs },
        { Py_tp_getset, _getset_IContactCallActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IContactCallActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IContactCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactCallActivatedEventArgs
    };

    // ----- IContactMapActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IContactMapActivatedEventArgs = "IContactMapActivatedEventArgs";

    static PyObject* _new_IContactMapActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IContactMapActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IContactMapActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactMapActivatedEventArgs_get_Address(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Address());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMapActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IContactMapActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactMapActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactMapActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactMapActivatedEventArgs[] = {
        { "address", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_Address), nullptr, nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactMapActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactMapActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IContactMapActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IContactMapActivatedEventArgs },
        { Py_tp_methods, _methods_IContactMapActivatedEventArgs },
        { Py_tp_getset, _getset_IContactMapActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IContactMapActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IContactMapActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactMapActivatedEventArgs
    };

    // ----- IContactMessageActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IContactMessageActivatedEventArgs = "IContactMessageActivatedEventArgs";

    static PyObject* _new_IContactMessageActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IContactMessageActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IContactMessageActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactMessageActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactMessageActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IContactMessageActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactMessageActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactMessageActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactMessageActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactMessageActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactMessageActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IContactMessageActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IContactMessageActivatedEventArgs },
        { Py_tp_methods, _methods_IContactMessageActivatedEventArgs },
        { Py_tp_getset, _getset_IContactMessageActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IContactMessageActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IContactMessageActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactMessageActivatedEventArgs
    };

    // ----- IContactPanelActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IContactPanelActivatedEventArgs = "IContactPanelActivatedEventArgs";

    static PyObject* _new_IContactPanelActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IContactPanelActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IContactPanelActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactPanelActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPanelActivatedEventArgs_get_ContactPanel(py::wrapper::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactPanel());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IContactPanelActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactPanelActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactPanelActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactPanelActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactPanelActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "contact_panel", reinterpret_cast<getter>(IContactPanelActivatedEventArgs_get_ContactPanel), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactPanelActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IContactPanelActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IContactPanelActivatedEventArgs },
        { Py_tp_methods, _methods_IContactPanelActivatedEventArgs },
        { Py_tp_getset, _getset_IContactPanelActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IContactPanelActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IContactPanelActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactPanelActivatedEventArgs
    };

    // ----- IContactPickerActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IContactPickerActivatedEventArgs = "IContactPickerActivatedEventArgs";

    static PyObject* _new_IContactPickerActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IContactPickerActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IContactPickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactPickerActivatedEventArgs_get_ContactPickerUI(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContactPickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IContactPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactPickerActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactPickerActivatedEventArgs[] = {
        { "contact_picker_u_i", reinterpret_cast<getter>(IContactPickerActivatedEventArgs_get_ContactPickerUI), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactPickerActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IContactPickerActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IContactPickerActivatedEventArgs },
        { Py_tp_methods, _methods_IContactPickerActivatedEventArgs },
        { Py_tp_getset, _getset_IContactPickerActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IContactPickerActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IContactPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactPickerActivatedEventArgs
    };

    // ----- IContactPostActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IContactPostActivatedEventArgs = "IContactPostActivatedEventArgs";

    static PyObject* _new_IContactPostActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IContactPostActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IContactPostActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactPostActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactPostActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IContactPostActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactPostActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactPostActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactPostActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactPostActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactPostActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IContactPostActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IContactPostActivatedEventArgs },
        { Py_tp_methods, _methods_IContactPostActivatedEventArgs },
        { Py_tp_getset, _getset_IContactPostActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IContactPostActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IContactPostActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactPostActivatedEventArgs
    };

    // ----- IContactVideoCallActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IContactVideoCallActivatedEventArgs = "IContactVideoCallActivatedEventArgs";

    static PyObject* _new_IContactVideoCallActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IContactVideoCallActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IContactVideoCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_Contact(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_ServiceId(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_ServiceUserId(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ServiceUserId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactVideoCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IContactVideoCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactVideoCallActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactVideoCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactVideoCallActivatedEventArgs[] = {
        { "contact", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_Contact), nullptr, nullptr, nullptr },
        { "service_id", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_ServiceId), nullptr, nullptr, nullptr },
        { "service_user_id", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_ServiceUserId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactVideoCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactVideoCallActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IContactVideoCallActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IContactVideoCallActivatedEventArgs },
        { Py_tp_methods, _methods_IContactVideoCallActivatedEventArgs },
        { Py_tp_getset, _getset_IContactVideoCallActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IContactVideoCallActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IContactVideoCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactVideoCallActivatedEventArgs
    };

    // ----- IContactsProviderActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IContactsProviderActivatedEventArgs = "IContactsProviderActivatedEventArgs";

    static PyObject* _new_IContactsProviderActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IContactsProviderActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IContactsProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContactsProviderActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactsProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactsProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContactsProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IContactsProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContactsProviderActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IContactsProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContactsProviderActivatedEventArgs[] = {
        { "verb", reinterpret_cast<getter>(IContactsProviderActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContactsProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContactsProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContactsProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContactsProviderActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IContactsProviderActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IContactsProviderActivatedEventArgs },
        { Py_tp_methods, _methods_IContactsProviderActivatedEventArgs },
        { Py_tp_getset, _getset_IContactsProviderActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IContactsProviderActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IContactsProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContactsProviderActivatedEventArgs
    };

    // ----- IContinuationActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IContinuationActivatedEventArgs = "IContinuationActivatedEventArgs";

    static PyObject* _new_IContinuationActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IContinuationActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IContinuationActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IContinuationActivatedEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContinuationActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContinuationActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IContinuationActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IContinuationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IContinuationActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IContinuationActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IContinuationActivatedEventArgs[] = {
        { "continuation_data", reinterpret_cast<getter>(IContinuationActivatedEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IContinuationActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IContinuationActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IContinuationActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IContinuationActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IContinuationActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IContinuationActivatedEventArgs },
        { Py_tp_methods, _methods_IContinuationActivatedEventArgs },
        { Py_tp_getset, _getset_IContinuationActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IContinuationActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IContinuationActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IContinuationActivatedEventArgs
    };

    // ----- IDeviceActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IDeviceActivatedEventArgs = "IDeviceActivatedEventArgs";

    static PyObject* _new_IDeviceActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IDeviceActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IDeviceActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDeviceActivatedEventArgs_get_DeviceInformationId(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInformationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDeviceActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDeviceActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDeviceActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDeviceActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IDeviceActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDeviceActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IDeviceActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDeviceActivatedEventArgs[] = {
        { "device_information_id", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_DeviceInformationId), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IDeviceActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IDeviceActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IDeviceActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IDeviceActivatedEventArgs },
        { Py_tp_methods, _methods_IDeviceActivatedEventArgs },
        { Py_tp_getset, _getset_IDeviceActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IDeviceActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IDeviceActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDeviceActivatedEventArgs
    };

    // ----- IDevicePairingActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IDevicePairingActivatedEventArgs = "IDevicePairingActivatedEventArgs";

    static PyObject* _new_IDevicePairingActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IDevicePairingActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IDevicePairingActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDevicePairingActivatedEventArgs_get_DeviceInformation(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeviceInformation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDevicePairingActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDevicePairingActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDevicePairingActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IDevicePairingActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDevicePairingActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IDevicePairingActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDevicePairingActivatedEventArgs[] = {
        { "device_information", reinterpret_cast<getter>(IDevicePairingActivatedEventArgs_get_DeviceInformation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IDevicePairingActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IDevicePairingActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IDevicePairingActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IDevicePairingActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IDevicePairingActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IDevicePairingActivatedEventArgs },
        { Py_tp_methods, _methods_IDevicePairingActivatedEventArgs },
        { Py_tp_getset, _getset_IDevicePairingActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IDevicePairingActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IDevicePairingActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDevicePairingActivatedEventArgs
    };

    // ----- IDialReceiverActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IDialReceiverActivatedEventArgs = "IDialReceiverActivatedEventArgs";

    static PyObject* _new_IDialReceiverActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IDialReceiverActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IDialReceiverActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_AppName(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AppName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IDialReceiverActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IDialReceiverActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IDialReceiverActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IDialReceiverActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IDialReceiverActivatedEventArgs[] = {
        { "app_name", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_AppName), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IDialReceiverActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IDialReceiverActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IDialReceiverActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IDialReceiverActivatedEventArgs },
        { Py_tp_methods, _methods_IDialReceiverActivatedEventArgs },
        { Py_tp_getset, _getset_IDialReceiverActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IDialReceiverActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IDialReceiverActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IDialReceiverActivatedEventArgs
    };

    // ----- IFileActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IFileActivatedEventArgs = "IFileActivatedEventArgs";

    static PyObject* _new_IFileActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IFileActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IFileActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileActivatedEventArgs_get_Files(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Files());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgs_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IFileActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileActivatedEventArgs[] = {
        { "files", reinterpret_cast<getter>(IFileActivatedEventArgs_get_Files), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IFileActivatedEventArgs_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IFileActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IFileActivatedEventArgs },
        { Py_tp_methods, _methods_IFileActivatedEventArgs },
        { Py_tp_getset, _getset_IFileActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IFileActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IFileActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileActivatedEventArgs
    };

    // ----- IFileActivatedEventArgsWithCallerPackageFamilyName interface --------------------
    constexpr const char* const type_name_IFileActivatedEventArgsWithCallerPackageFamilyName = "IFileActivatedEventArgsWithCallerPackageFamilyName";

    static PyObject* _new_IFileActivatedEventArgsWithCallerPackageFamilyName(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IFileActivatedEventArgsWithCallerPackageFamilyName);
        return nullptr;
    }

    static void _dealloc_IFileActivatedEventArgsWithCallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileActivatedEventArgsWithCallerPackageFamilyName_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithCallerPackageFamilyName_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithCallerPackageFamilyName_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithCallerPackageFamilyName_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IFileActivatedEventArgsWithCallerPackageFamilyName(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileActivatedEventArgsWithCallerPackageFamilyName[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileActivatedEventArgsWithCallerPackageFamilyName), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileActivatedEventArgsWithCallerPackageFamilyName[] = {
        { "caller_package_family_name", reinterpret_cast<getter>(IFileActivatedEventArgsWithCallerPackageFamilyName_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileActivatedEventArgsWithCallerPackageFamilyName_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileActivatedEventArgsWithCallerPackageFamilyName_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileActivatedEventArgsWithCallerPackageFamilyName_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileActivatedEventArgsWithCallerPackageFamilyName[] = 
    {
        { Py_tp_new, _new_IFileActivatedEventArgsWithCallerPackageFamilyName },
        { Py_tp_dealloc, _dealloc_IFileActivatedEventArgsWithCallerPackageFamilyName },
        { Py_tp_methods, _methods_IFileActivatedEventArgsWithCallerPackageFamilyName },
        { Py_tp_getset, _getset_IFileActivatedEventArgsWithCallerPackageFamilyName },
        { },
    };

    static PyType_Spec type_spec_IFileActivatedEventArgsWithCallerPackageFamilyName =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IFileActivatedEventArgsWithCallerPackageFamilyName",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileActivatedEventArgsWithCallerPackageFamilyName
    };

    // ----- IFileActivatedEventArgsWithNeighboringFiles interface --------------------
    constexpr const char* const type_name_IFileActivatedEventArgsWithNeighboringFiles = "IFileActivatedEventArgsWithNeighboringFiles";

    static PyObject* _new_IFileActivatedEventArgsWithNeighboringFiles(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IFileActivatedEventArgsWithNeighboringFiles);
        return nullptr;
    }

    static void _dealloc_IFileActivatedEventArgsWithNeighboringFiles(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_NeighboringFilesQuery(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NeighboringFilesQuery());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_Files(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Files());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_Verb(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Verb());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileActivatedEventArgsWithNeighboringFiles_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IFileActivatedEventArgsWithNeighboringFiles(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileActivatedEventArgsWithNeighboringFiles[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileActivatedEventArgsWithNeighboringFiles), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileActivatedEventArgsWithNeighboringFiles[] = {
        { "neighboring_files_query", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_NeighboringFilesQuery), nullptr, nullptr, nullptr },
        { "files", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_Files), nullptr, nullptr, nullptr },
        { "verb", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_Verb), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileActivatedEventArgsWithNeighboringFiles_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileActivatedEventArgsWithNeighboringFiles[] = 
    {
        { Py_tp_new, _new_IFileActivatedEventArgsWithNeighboringFiles },
        { Py_tp_dealloc, _dealloc_IFileActivatedEventArgsWithNeighboringFiles },
        { Py_tp_methods, _methods_IFileActivatedEventArgsWithNeighboringFiles },
        { Py_tp_getset, _getset_IFileActivatedEventArgsWithNeighboringFiles },
        { },
    };

    static PyType_Spec type_spec_IFileActivatedEventArgsWithNeighboringFiles =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IFileActivatedEventArgsWithNeighboringFiles",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileActivatedEventArgsWithNeighboringFiles
    };

    // ----- IFileOpenPickerActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IFileOpenPickerActivatedEventArgs = "IFileOpenPickerActivatedEventArgs";

    static PyObject* _new_IFileOpenPickerActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IFileOpenPickerActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IFileOpenPickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileOpenPickerActivatedEventArgs_get_FileOpenPickerUI(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileOpenPickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IFileOpenPickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileOpenPickerActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileOpenPickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileOpenPickerActivatedEventArgs[] = {
        { "file_open_picker_u_i", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs_get_FileOpenPickerUI), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileOpenPickerActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IFileOpenPickerActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IFileOpenPickerActivatedEventArgs },
        { Py_tp_methods, _methods_IFileOpenPickerActivatedEventArgs },
        { Py_tp_getset, _getset_IFileOpenPickerActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IFileOpenPickerActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IFileOpenPickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileOpenPickerActivatedEventArgs
    };

    // ----- IFileOpenPickerActivatedEventArgs2 interface --------------------
    constexpr const char* const type_name_IFileOpenPickerActivatedEventArgs2 = "IFileOpenPickerActivatedEventArgs2";

    static PyObject* _new_IFileOpenPickerActivatedEventArgs2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IFileOpenPickerActivatedEventArgs2);
        return nullptr;
    }

    static void _dealloc_IFileOpenPickerActivatedEventArgs2(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileOpenPickerActivatedEventArgs2_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IFileOpenPickerActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileOpenPickerActivatedEventArgs2[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileOpenPickerActivatedEventArgs2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileOpenPickerActivatedEventArgs2[] = {
        { "caller_package_family_name", reinterpret_cast<getter>(IFileOpenPickerActivatedEventArgs2_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileOpenPickerActivatedEventArgs2[] = 
    {
        { Py_tp_new, _new_IFileOpenPickerActivatedEventArgs2 },
        { Py_tp_dealloc, _dealloc_IFileOpenPickerActivatedEventArgs2 },
        { Py_tp_methods, _methods_IFileOpenPickerActivatedEventArgs2 },
        { Py_tp_getset, _getset_IFileOpenPickerActivatedEventArgs2 },
        { },
    };

    static PyType_Spec type_spec_IFileOpenPickerActivatedEventArgs2 =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IFileOpenPickerActivatedEventArgs2",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileOpenPickerActivatedEventArgs2
    };

    // ----- IFileOpenPickerContinuationEventArgs interface --------------------
    constexpr const char* const type_name_IFileOpenPickerContinuationEventArgs = "IFileOpenPickerContinuationEventArgs";

    static PyObject* _new_IFileOpenPickerContinuationEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IFileOpenPickerContinuationEventArgs);
        return nullptr;
    }

    static void _dealloc_IFileOpenPickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_Files(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Files());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileOpenPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IFileOpenPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileOpenPickerContinuationEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileOpenPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileOpenPickerContinuationEventArgs[] = {
        { "files", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_Files), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileOpenPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileOpenPickerContinuationEventArgs[] = 
    {
        { Py_tp_new, _new_IFileOpenPickerContinuationEventArgs },
        { Py_tp_dealloc, _dealloc_IFileOpenPickerContinuationEventArgs },
        { Py_tp_methods, _methods_IFileOpenPickerContinuationEventArgs },
        { Py_tp_getset, _getset_IFileOpenPickerContinuationEventArgs },
        { },
    };

    static PyType_Spec type_spec_IFileOpenPickerContinuationEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IFileOpenPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileOpenPickerContinuationEventArgs
    };

    // ----- IFileSavePickerActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IFileSavePickerActivatedEventArgs = "IFileSavePickerActivatedEventArgs";

    static PyObject* _new_IFileSavePickerActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IFileSavePickerActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IFileSavePickerActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileSavePickerActivatedEventArgs_get_FileSavePickerUI(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.FileSavePickerUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IFileSavePickerActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileSavePickerActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileSavePickerActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileSavePickerActivatedEventArgs[] = {
        { "file_save_picker_u_i", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs_get_FileSavePickerUI), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileSavePickerActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IFileSavePickerActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IFileSavePickerActivatedEventArgs },
        { Py_tp_methods, _methods_IFileSavePickerActivatedEventArgs },
        { Py_tp_getset, _getset_IFileSavePickerActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IFileSavePickerActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IFileSavePickerActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileSavePickerActivatedEventArgs
    };

    // ----- IFileSavePickerActivatedEventArgs2 interface --------------------
    constexpr const char* const type_name_IFileSavePickerActivatedEventArgs2 = "IFileSavePickerActivatedEventArgs2";

    static PyObject* _new_IFileSavePickerActivatedEventArgs2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IFileSavePickerActivatedEventArgs2);
        return nullptr;
    }

    static void _dealloc_IFileSavePickerActivatedEventArgs2(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileSavePickerActivatedEventArgs2_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerActivatedEventArgs2_get_EnterpriseId(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.EnterpriseId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IFileSavePickerActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileSavePickerActivatedEventArgs2[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileSavePickerActivatedEventArgs2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileSavePickerActivatedEventArgs2[] = {
        { "caller_package_family_name", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs2_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "enterprise_id", reinterpret_cast<getter>(IFileSavePickerActivatedEventArgs2_get_EnterpriseId), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileSavePickerActivatedEventArgs2[] = 
    {
        { Py_tp_new, _new_IFileSavePickerActivatedEventArgs2 },
        { Py_tp_dealloc, _dealloc_IFileSavePickerActivatedEventArgs2 },
        { Py_tp_methods, _methods_IFileSavePickerActivatedEventArgs2 },
        { Py_tp_getset, _getset_IFileSavePickerActivatedEventArgs2 },
        { },
    };

    static PyType_Spec type_spec_IFileSavePickerActivatedEventArgs2 =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IFileSavePickerActivatedEventArgs2",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileSavePickerActivatedEventArgs2
    };

    // ----- IFileSavePickerContinuationEventArgs interface --------------------
    constexpr const char* const type_name_IFileSavePickerContinuationEventArgs = "IFileSavePickerContinuationEventArgs";

    static PyObject* _new_IFileSavePickerContinuationEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IFileSavePickerContinuationEventArgs);
        return nullptr;
    }

    static void _dealloc_IFileSavePickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_File(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.File());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFileSavePickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IFileSavePickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFileSavePickerContinuationEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IFileSavePickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFileSavePickerContinuationEventArgs[] = {
        { "file", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_File), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFileSavePickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFileSavePickerContinuationEventArgs[] = 
    {
        { Py_tp_new, _new_IFileSavePickerContinuationEventArgs },
        { Py_tp_dealloc, _dealloc_IFileSavePickerContinuationEventArgs },
        { Py_tp_methods, _methods_IFileSavePickerContinuationEventArgs },
        { Py_tp_getset, _getset_IFileSavePickerContinuationEventArgs },
        { },
    };

    static PyType_Spec type_spec_IFileSavePickerContinuationEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IFileSavePickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFileSavePickerContinuationEventArgs
    };

    // ----- IFolderPickerContinuationEventArgs interface --------------------
    constexpr const char* const type_name_IFolderPickerContinuationEventArgs = "IFolderPickerContinuationEventArgs";

    static PyObject* _new_IFolderPickerContinuationEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IFolderPickerContinuationEventArgs);
        return nullptr;
    }

    static void _dealloc_IFolderPickerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_Folder(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Folder());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IFolderPickerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IFolderPickerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IFolderPickerContinuationEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IFolderPickerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IFolderPickerContinuationEventArgs[] = {
        { "folder", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_Folder), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IFolderPickerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IFolderPickerContinuationEventArgs[] = 
    {
        { Py_tp_new, _new_IFolderPickerContinuationEventArgs },
        { Py_tp_dealloc, _dealloc_IFolderPickerContinuationEventArgs },
        { Py_tp_methods, _methods_IFolderPickerContinuationEventArgs },
        { Py_tp_getset, _getset_IFolderPickerContinuationEventArgs },
        { },
    };

    static PyType_Spec type_spec_IFolderPickerContinuationEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IFolderPickerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IFolderPickerContinuationEventArgs
    };

    // ----- ILaunchActivatedEventArgs interface --------------------
    constexpr const char* const type_name_ILaunchActivatedEventArgs = "ILaunchActivatedEventArgs";

    static PyObject* _new_ILaunchActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_ILaunchActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ILaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILaunchActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ILaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILaunchActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ILaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILaunchActivatedEventArgs[] = {
        { "arguments", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ILaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILaunchActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ILaunchActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ILaunchActivatedEventArgs },
        { Py_tp_methods, _methods_ILaunchActivatedEventArgs },
        { Py_tp_getset, _getset_ILaunchActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ILaunchActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ILaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILaunchActivatedEventArgs
    };

    // ----- ILaunchActivatedEventArgs2 interface --------------------
    constexpr const char* const type_name_ILaunchActivatedEventArgs2 = "ILaunchActivatedEventArgs2";

    static PyObject* _new_ILaunchActivatedEventArgs2(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_ILaunchActivatedEventArgs2);
        return nullptr;
    }

    static void _dealloc_ILaunchActivatedEventArgs2(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILaunchActivatedEventArgs2_get_TileActivatedInfo(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TileActivatedInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILaunchActivatedEventArgs2_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ILaunchActivatedEventArgs2(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILaunchActivatedEventArgs2[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ILaunchActivatedEventArgs2), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILaunchActivatedEventArgs2[] = {
        { "tile_activated_info", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_TileActivatedInfo), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_TileId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ILaunchActivatedEventArgs2_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILaunchActivatedEventArgs2[] = 
    {
        { Py_tp_new, _new_ILaunchActivatedEventArgs2 },
        { Py_tp_dealloc, _dealloc_ILaunchActivatedEventArgs2 },
        { Py_tp_methods, _methods_ILaunchActivatedEventArgs2 },
        { Py_tp_getset, _getset_ILaunchActivatedEventArgs2 },
        { },
    };

    static PyType_Spec type_spec_ILaunchActivatedEventArgs2 =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ILaunchActivatedEventArgs2",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILaunchActivatedEventArgs2
    };

    // ----- ILockScreenActivatedEventArgs interface --------------------
    constexpr const char* const type_name_ILockScreenActivatedEventArgs = "ILockScreenActivatedEventArgs";

    static PyObject* _new_ILockScreenActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_ILockScreenActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ILockScreenActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILockScreenActivatedEventArgs_get_Info(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Info());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ILockScreenActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILockScreenActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ILockScreenActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILockScreenActivatedEventArgs[] = {
        { "info", reinterpret_cast<getter>(ILockScreenActivatedEventArgs_get_Info), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILockScreenActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ILockScreenActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ILockScreenActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILockScreenActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ILockScreenActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ILockScreenActivatedEventArgs },
        { Py_tp_methods, _methods_ILockScreenActivatedEventArgs },
        { Py_tp_getset, _getset_ILockScreenActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ILockScreenActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ILockScreenActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILockScreenActivatedEventArgs
    };

    // ----- ILockScreenCallActivatedEventArgs interface --------------------
    constexpr const char* const type_name_ILockScreenCallActivatedEventArgs = "ILockScreenCallActivatedEventArgs";

    static PyObject* _new_ILockScreenCallActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_ILockScreenCallActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ILockScreenCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_CallUI(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallUI());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_Arguments(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Arguments());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_TileId(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TileId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ILockScreenCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ILockScreenCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ILockScreenCallActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ILockScreenCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ILockScreenCallActivatedEventArgs[] = {
        { "call_u_i", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_CallUI), nullptr, nullptr, nullptr },
        { "arguments", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_Arguments), nullptr, nullptr, nullptr },
        { "tile_id", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_TileId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ILockScreenCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ILockScreenCallActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ILockScreenCallActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ILockScreenCallActivatedEventArgs },
        { Py_tp_methods, _methods_ILockScreenCallActivatedEventArgs },
        { Py_tp_getset, _getset_ILockScreenCallActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ILockScreenCallActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ILockScreenCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ILockScreenCallActivatedEventArgs
    };

    // ----- IPhoneCallActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IPhoneCallActivatedEventArgs = "IPhoneCallActivatedEventArgs";

    static PyObject* _new_IPhoneCallActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IPhoneCallActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IPhoneCallActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPhoneCallActivatedEventArgs_get_LineId(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LineId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPhoneCallActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPhoneCallActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPhoneCallActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPhoneCallActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPhoneCallActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IPhoneCallActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPhoneCallActivatedEventArgs[] = {
        { "line_id", reinterpret_cast<getter>(IPhoneCallActivatedEventArgs_get_LineId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPhoneCallActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPhoneCallActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPhoneCallActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPhoneCallActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IPhoneCallActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IPhoneCallActivatedEventArgs },
        { Py_tp_methods, _methods_IPhoneCallActivatedEventArgs },
        { Py_tp_getset, _getset_IPhoneCallActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IPhoneCallActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IPhoneCallActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPhoneCallActivatedEventArgs
    };

    // ----- IPickerReturnedActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IPickerReturnedActivatedEventArgs = "IPickerReturnedActivatedEventArgs";

    static PyObject* _new_IPickerReturnedActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IPickerReturnedActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IPickerReturnedActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPickerReturnedActivatedEventArgs_get_PickerOperationId(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PickerOperationId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPickerReturnedActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPickerReturnedActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPickerReturnedActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPickerReturnedActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPickerReturnedActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IPickerReturnedActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPickerReturnedActivatedEventArgs[] = {
        { "picker_operation_id", reinterpret_cast<getter>(IPickerReturnedActivatedEventArgs_get_PickerOperationId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPickerReturnedActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPickerReturnedActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPickerReturnedActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPickerReturnedActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IPickerReturnedActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IPickerReturnedActivatedEventArgs },
        { Py_tp_methods, _methods_IPickerReturnedActivatedEventArgs },
        { Py_tp_getset, _getset_IPickerReturnedActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IPickerReturnedActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IPickerReturnedActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPickerReturnedActivatedEventArgs
    };

    // ----- IPrelaunchActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IPrelaunchActivatedEventArgs = "IPrelaunchActivatedEventArgs";

    static PyObject* _new_IPrelaunchActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IPrelaunchActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IPrelaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPrelaunchActivatedEventArgs_get_PrelaunchActivated(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrelaunchActivated());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrelaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrelaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrelaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPrelaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPrelaunchActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IPrelaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPrelaunchActivatedEventArgs[] = {
        { "prelaunch_activated", reinterpret_cast<getter>(IPrelaunchActivatedEventArgs_get_PrelaunchActivated), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPrelaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPrelaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPrelaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPrelaunchActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IPrelaunchActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IPrelaunchActivatedEventArgs },
        { Py_tp_methods, _methods_IPrelaunchActivatedEventArgs },
        { Py_tp_getset, _getset_IPrelaunchActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IPrelaunchActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IPrelaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPrelaunchActivatedEventArgs
    };

    // ----- IPrint3DWorkflowActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IPrint3DWorkflowActivatedEventArgs = "IPrint3DWorkflowActivatedEventArgs";

    static PyObject* _new_IPrint3DWorkflowActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IPrint3DWorkflowActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IPrint3DWorkflowActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPrint3DWorkflowActivatedEventArgs_get_Workflow(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Workflow());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrint3DWorkflowActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrint3DWorkflowActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrint3DWorkflowActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPrint3DWorkflowActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPrint3DWorkflowActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IPrint3DWorkflowActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPrint3DWorkflowActivatedEventArgs[] = {
        { "workflow", reinterpret_cast<getter>(IPrint3DWorkflowActivatedEventArgs_get_Workflow), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPrint3DWorkflowActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPrint3DWorkflowActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPrint3DWorkflowActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPrint3DWorkflowActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IPrint3DWorkflowActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IPrint3DWorkflowActivatedEventArgs },
        { Py_tp_methods, _methods_IPrint3DWorkflowActivatedEventArgs },
        { Py_tp_getset, _getset_IPrint3DWorkflowActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IPrint3DWorkflowActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IPrint3DWorkflowActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPrint3DWorkflowActivatedEventArgs
    };

    // ----- IPrintTaskSettingsActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IPrintTaskSettingsActivatedEventArgs = "IPrintTaskSettingsActivatedEventArgs";

    static PyObject* _new_IPrintTaskSettingsActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IPrintTaskSettingsActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IPrintTaskSettingsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IPrintTaskSettingsActivatedEventArgs_get_Configuration(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Configuration());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintTaskSettingsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IPrintTaskSettingsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IPrintTaskSettingsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IPrintTaskSettingsActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IPrintTaskSettingsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IPrintTaskSettingsActivatedEventArgs[] = {
        { "configuration", reinterpret_cast<getter>(IPrintTaskSettingsActivatedEventArgs_get_Configuration), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IPrintTaskSettingsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IPrintTaskSettingsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IPrintTaskSettingsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IPrintTaskSettingsActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IPrintTaskSettingsActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IPrintTaskSettingsActivatedEventArgs },
        { Py_tp_methods, _methods_IPrintTaskSettingsActivatedEventArgs },
        { Py_tp_getset, _getset_IPrintTaskSettingsActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IPrintTaskSettingsActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IPrintTaskSettingsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IPrintTaskSettingsActivatedEventArgs
    };

    // ----- IProtocolActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IProtocolActivatedEventArgs = "IProtocolActivatedEventArgs";

    static PyObject* _new_IProtocolActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IProtocolActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IProtocolActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IProtocolActivatedEventArgs_get_Uri(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Uri());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IProtocolActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IProtocolActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IProtocolActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IProtocolActivatedEventArgs[] = {
        { "uri", reinterpret_cast<getter>(IProtocolActivatedEventArgs_get_Uri), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IProtocolActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IProtocolActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IProtocolActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IProtocolActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IProtocolActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IProtocolActivatedEventArgs },
        { Py_tp_methods, _methods_IProtocolActivatedEventArgs },
        { Py_tp_getset, _getset_IProtocolActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IProtocolActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IProtocolActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IProtocolActivatedEventArgs
    };

    // ----- IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData interface --------------------
    constexpr const char* const type_name_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData = "IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData";

    static PyObject* _new_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData);
        return nullptr;
    }

    static void _dealloc_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_CallerPackageFamilyName(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CallerPackageFamilyName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_Data(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Data());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData[] = {
        { "caller_package_family_name", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_CallerPackageFamilyName), nullptr, nullptr, nullptr },
        { "data", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_Data), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData[] = 
    {
        { Py_tp_new, _new_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData },
        { Py_tp_dealloc, _dealloc_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData },
        { Py_tp_methods, _methods_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData },
        { Py_tp_getset, _getset_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData },
        { },
    };

    static PyType_Spec type_spec_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData
    };

    // ----- IProtocolForResultsActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IProtocolForResultsActivatedEventArgs = "IProtocolForResultsActivatedEventArgs";

    static PyObject* _new_IProtocolForResultsActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IProtocolForResultsActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IProtocolForResultsActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProtocolForResultsOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolForResultsActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolForResultsActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IProtocolForResultsActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IProtocolForResultsActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IProtocolForResultsActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IProtocolForResultsActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IProtocolForResultsActivatedEventArgs[] = {
        { "protocol_for_results_operation", reinterpret_cast<getter>(IProtocolForResultsActivatedEventArgs_get_ProtocolForResultsOperation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IProtocolForResultsActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IProtocolForResultsActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IProtocolForResultsActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IProtocolForResultsActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IProtocolForResultsActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IProtocolForResultsActivatedEventArgs },
        { Py_tp_methods, _methods_IProtocolForResultsActivatedEventArgs },
        { Py_tp_getset, _getset_IProtocolForResultsActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IProtocolForResultsActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IProtocolForResultsActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IProtocolForResultsActivatedEventArgs
    };

    // ----- IRestrictedLaunchActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IRestrictedLaunchActivatedEventArgs = "IRestrictedLaunchActivatedEventArgs";

    static PyObject* _new_IRestrictedLaunchActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IRestrictedLaunchActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IRestrictedLaunchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IRestrictedLaunchActivatedEventArgs_get_SharedContext(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SharedContext());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRestrictedLaunchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRestrictedLaunchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IRestrictedLaunchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IRestrictedLaunchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IRestrictedLaunchActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IRestrictedLaunchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IRestrictedLaunchActivatedEventArgs[] = {
        { "shared_context", reinterpret_cast<getter>(IRestrictedLaunchActivatedEventArgs_get_SharedContext), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IRestrictedLaunchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IRestrictedLaunchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IRestrictedLaunchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IRestrictedLaunchActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IRestrictedLaunchActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IRestrictedLaunchActivatedEventArgs },
        { Py_tp_methods, _methods_IRestrictedLaunchActivatedEventArgs },
        { Py_tp_getset, _getset_IRestrictedLaunchActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IRestrictedLaunchActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IRestrictedLaunchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IRestrictedLaunchActivatedEventArgs
    };

    // ----- ISearchActivatedEventArgs interface --------------------
    constexpr const char* const type_name_ISearchActivatedEventArgs = "ISearchActivatedEventArgs";

    static PyObject* _new_ISearchActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_ISearchActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_ISearchActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISearchActivatedEventArgs_get_Language(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Language());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchActivatedEventArgs_get_QueryText(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.QueryText());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ISearchActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ISearchActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISearchActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ISearchActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISearchActivatedEventArgs[] = {
        { "language", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_Language), nullptr, nullptr, nullptr },
        { "query_text", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_QueryText), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(ISearchActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISearchActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_ISearchActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_ISearchActivatedEventArgs },
        { Py_tp_methods, _methods_ISearchActivatedEventArgs },
        { Py_tp_getset, _getset_ISearchActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_ISearchActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ISearchActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISearchActivatedEventArgs
    };

    // ----- ISearchActivatedEventArgsWithLinguisticDetails interface --------------------
    constexpr const char* const type_name_ISearchActivatedEventArgsWithLinguisticDetails = "ISearchActivatedEventArgsWithLinguisticDetails";

    static PyObject* _new_ISearchActivatedEventArgsWithLinguisticDetails(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_ISearchActivatedEventArgsWithLinguisticDetails);
        return nullptr;
    }

    static void _dealloc_ISearchActivatedEventArgsWithLinguisticDetails(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* ISearchActivatedEventArgsWithLinguisticDetails_get_LinguisticDetails(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LinguisticDetails());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ISearchActivatedEventArgsWithLinguisticDetails(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ISearchActivatedEventArgsWithLinguisticDetails[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ISearchActivatedEventArgsWithLinguisticDetails), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ISearchActivatedEventArgsWithLinguisticDetails[] = {
        { "linguistic_details", reinterpret_cast<getter>(ISearchActivatedEventArgsWithLinguisticDetails_get_LinguisticDetails), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ISearchActivatedEventArgsWithLinguisticDetails[] = 
    {
        { Py_tp_new, _new_ISearchActivatedEventArgsWithLinguisticDetails },
        { Py_tp_dealloc, _dealloc_ISearchActivatedEventArgsWithLinguisticDetails },
        { Py_tp_methods, _methods_ISearchActivatedEventArgsWithLinguisticDetails },
        { Py_tp_getset, _getset_ISearchActivatedEventArgsWithLinguisticDetails },
        { },
    };

    static PyType_Spec type_spec_ISearchActivatedEventArgsWithLinguisticDetails =
    {
        "_winsdk_Windows_ApplicationModel_Activation.ISearchActivatedEventArgsWithLinguisticDetails",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ISearchActivatedEventArgsWithLinguisticDetails
    };

    // ----- IShareTargetActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IShareTargetActivatedEventArgs = "IShareTargetActivatedEventArgs";

    static PyObject* _new_IShareTargetActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IShareTargetActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IShareTargetActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IShareTargetActivatedEventArgs_get_ShareOperation(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ShareOperation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IShareTargetActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IShareTargetActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IShareTargetActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IShareTargetActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IShareTargetActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IShareTargetActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IShareTargetActivatedEventArgs[] = {
        { "share_operation", reinterpret_cast<getter>(IShareTargetActivatedEventArgs_get_ShareOperation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IShareTargetActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IShareTargetActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IShareTargetActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IShareTargetActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IShareTargetActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IShareTargetActivatedEventArgs },
        { Py_tp_methods, _methods_IShareTargetActivatedEventArgs },
        { Py_tp_getset, _getset_IShareTargetActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IShareTargetActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IShareTargetActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IShareTargetActivatedEventArgs
    };

    // ----- IStartupTaskActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IStartupTaskActivatedEventArgs = "IStartupTaskActivatedEventArgs";

    static PyObject* _new_IStartupTaskActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IStartupTaskActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IStartupTaskActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IStartupTaskActivatedEventArgs_get_TaskId(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TaskId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStartupTaskActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStartupTaskActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IStartupTaskActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IStartupTaskActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IStartupTaskActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IStartupTaskActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IStartupTaskActivatedEventArgs[] = {
        { "task_id", reinterpret_cast<getter>(IStartupTaskActivatedEventArgs_get_TaskId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IStartupTaskActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IStartupTaskActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IStartupTaskActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IStartupTaskActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IStartupTaskActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IStartupTaskActivatedEventArgs },
        { Py_tp_methods, _methods_IStartupTaskActivatedEventArgs },
        { Py_tp_getset, _getset_IStartupTaskActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IStartupTaskActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IStartupTaskActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IStartupTaskActivatedEventArgs
    };

    // ----- IToastNotificationActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IToastNotificationActivatedEventArgs = "IToastNotificationActivatedEventArgs";

    static PyObject* _new_IToastNotificationActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IToastNotificationActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IToastNotificationActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_Argument(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Argument());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_UserInput(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserInput());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IToastNotificationActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IToastNotificationActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IToastNotificationActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IToastNotificationActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IToastNotificationActivatedEventArgs[] = {
        { "argument", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_Argument), nullptr, nullptr, nullptr },
        { "user_input", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_UserInput), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IToastNotificationActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IToastNotificationActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IToastNotificationActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IToastNotificationActivatedEventArgs },
        { Py_tp_methods, _methods_IToastNotificationActivatedEventArgs },
        { Py_tp_getset, _getset_IToastNotificationActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IToastNotificationActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IToastNotificationActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IToastNotificationActivatedEventArgs
    };

    // ----- IUserDataAccountProviderActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IUserDataAccountProviderActivatedEventArgs = "IUserDataAccountProviderActivatedEventArgs";

    static PyObject* _new_IUserDataAccountProviderActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IUserDataAccountProviderActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IUserDataAccountProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IUserDataAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IUserDataAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IUserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IUserDataAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IUserDataAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IUserDataAccountProviderActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IUserDataAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IUserDataAccountProviderActivatedEventArgs[] = {
        { "operation", reinterpret_cast<getter>(IUserDataAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IUserDataAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IUserDataAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IUserDataAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IUserDataAccountProviderActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IUserDataAccountProviderActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IUserDataAccountProviderActivatedEventArgs },
        { Py_tp_methods, _methods_IUserDataAccountProviderActivatedEventArgs },
        { Py_tp_getset, _getset_IUserDataAccountProviderActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IUserDataAccountProviderActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IUserDataAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IUserDataAccountProviderActivatedEventArgs
    };

    // ----- IViewSwitcherProvider interface --------------------
    constexpr const char* const type_name_IViewSwitcherProvider = "IViewSwitcherProvider";

    static PyObject* _new_IViewSwitcherProvider(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IViewSwitcherProvider);
        return nullptr;
    }

    static void _dealloc_IViewSwitcherProvider(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IViewSwitcherProvider_get_ViewSwitcher(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ViewSwitcher());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IViewSwitcherProvider_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IViewSwitcherProvider_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IViewSwitcherProvider_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IViewSwitcherProvider(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IViewSwitcherProvider>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IViewSwitcherProvider[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IViewSwitcherProvider), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IViewSwitcherProvider[] = {
        { "view_switcher", reinterpret_cast<getter>(IViewSwitcherProvider_get_ViewSwitcher), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IViewSwitcherProvider_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IViewSwitcherProvider_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IViewSwitcherProvider_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IViewSwitcherProvider[] = 
    {
        { Py_tp_new, _new_IViewSwitcherProvider },
        { Py_tp_dealloc, _dealloc_IViewSwitcherProvider },
        { Py_tp_methods, _methods_IViewSwitcherProvider },
        { Py_tp_getset, _getset_IViewSwitcherProvider },
        { },
    };

    static PyType_Spec type_spec_IViewSwitcherProvider =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IViewSwitcherProvider",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IViewSwitcherProvider),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IViewSwitcherProvider
    };

    // ----- IVoiceCommandActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IVoiceCommandActivatedEventArgs = "IVoiceCommandActivatedEventArgs";

    static PyObject* _new_IVoiceCommandActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IVoiceCommandActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IVoiceCommandActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IVoiceCommandActivatedEventArgs_get_Result(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Result());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVoiceCommandActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVoiceCommandActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IVoiceCommandActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IVoiceCommandActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IVoiceCommandActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IVoiceCommandActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IVoiceCommandActivatedEventArgs[] = {
        { "result", reinterpret_cast<getter>(IVoiceCommandActivatedEventArgs_get_Result), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IVoiceCommandActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IVoiceCommandActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IVoiceCommandActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IVoiceCommandActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IVoiceCommandActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IVoiceCommandActivatedEventArgs },
        { Py_tp_methods, _methods_IVoiceCommandActivatedEventArgs },
        { Py_tp_getset, _getset_IVoiceCommandActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IVoiceCommandActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IVoiceCommandActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IVoiceCommandActivatedEventArgs
    };

    // ----- IWalletActionActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IWalletActionActivatedEventArgs = "IWalletActionActivatedEventArgs";

    static PyObject* _new_IWalletActionActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IWalletActionActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IWalletActionActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWalletActionActivatedEventArgs_get_ActionId(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActionId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_ActionKind(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ActionKind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_ItemId(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ItemId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWalletActionActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWalletActionActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWalletActionActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IWalletActionActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWalletActionActivatedEventArgs[] = {
        { "action_id", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_ActionId), nullptr, nullptr, nullptr },
        { "action_kind", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_ActionKind), nullptr, nullptr, nullptr },
        { "item_id", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_ItemId), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IWalletActionActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWalletActionActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IWalletActionActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IWalletActionActivatedEventArgs },
        { Py_tp_methods, _methods_IWalletActionActivatedEventArgs },
        { Py_tp_getset, _getset_IWalletActionActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IWalletActionActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IWalletActionActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWalletActionActivatedEventArgs
    };

    // ----- IWebAccountProviderActivatedEventArgs interface --------------------
    constexpr const char* const type_name_IWebAccountProviderActivatedEventArgs = "IWebAccountProviderActivatedEventArgs";

    static PyObject* _new_IWebAccountProviderActivatedEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IWebAccountProviderActivatedEventArgs);
        return nullptr;
    }

    static void _dealloc_IWebAccountProviderActivatedEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebAccountProviderActivatedEventArgs_get_Operation(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Operation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAccountProviderActivatedEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAccountProviderActivatedEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAccountProviderActivatedEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWebAccountProviderActivatedEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebAccountProviderActivatedEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebAccountProviderActivatedEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebAccountProviderActivatedEventArgs[] = {
        { "operation", reinterpret_cast<getter>(IWebAccountProviderActivatedEventArgs_get_Operation), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IWebAccountProviderActivatedEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IWebAccountProviderActivatedEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IWebAccountProviderActivatedEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebAccountProviderActivatedEventArgs[] = 
    {
        { Py_tp_new, _new_IWebAccountProviderActivatedEventArgs },
        { Py_tp_dealloc, _dealloc_IWebAccountProviderActivatedEventArgs },
        { Py_tp_methods, _methods_IWebAccountProviderActivatedEventArgs },
        { Py_tp_getset, _getset_IWebAccountProviderActivatedEventArgs },
        { },
    };

    static PyType_Spec type_spec_IWebAccountProviderActivatedEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IWebAccountProviderActivatedEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebAccountProviderActivatedEventArgs
    };

    // ----- IWebAuthenticationBrokerContinuationEventArgs interface --------------------
    constexpr const char* const type_name_IWebAuthenticationBrokerContinuationEventArgs = "IWebAuthenticationBrokerContinuationEventArgs";

    static PyObject* _new_IWebAuthenticationBrokerContinuationEventArgs(PyTypeObject* /* unused */, PyObject* /* unused */, PyObject* /* unused */)
    {
        py::set_invalid_activation_error(type_name_IWebAuthenticationBrokerContinuationEventArgs);
        return nullptr;
    }

    static void _dealloc_IWebAuthenticationBrokerContinuationEventArgs(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self)
    {
        auto tp = Py_TYPE(self);
        self->obj = nullptr;
        tp->tp_free(self);
        Py_DECREF(tp);
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WebAuthenticationResult());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_ContinuationData(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ContinuationData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_Kind(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Kind());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PreviousExecutionState());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* IWebAuthenticationBrokerContinuationEventArgs_get_SplashScreen(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.SplashScreen());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_IWebAuthenticationBrokerContinuationEventArgs(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_IWebAuthenticationBrokerContinuationEventArgs[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_IWebAuthenticationBrokerContinuationEventArgs), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_IWebAuthenticationBrokerContinuationEventArgs[] = {
        { "web_authentication_result", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_WebAuthenticationResult), nullptr, nullptr, nullptr },
        { "continuation_data", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_ContinuationData), nullptr, nullptr, nullptr },
        { "kind", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_Kind), nullptr, nullptr, nullptr },
        { "previous_execution_state", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_PreviousExecutionState), nullptr, nullptr, nullptr },
        { "splash_screen", reinterpret_cast<getter>(IWebAuthenticationBrokerContinuationEventArgs_get_SplashScreen), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_IWebAuthenticationBrokerContinuationEventArgs[] = 
    {
        { Py_tp_new, _new_IWebAuthenticationBrokerContinuationEventArgs },
        { Py_tp_dealloc, _dealloc_IWebAuthenticationBrokerContinuationEventArgs },
        { Py_tp_methods, _methods_IWebAuthenticationBrokerContinuationEventArgs },
        { Py_tp_getset, _getset_IWebAuthenticationBrokerContinuationEventArgs },
        { },
    };

    static PyType_Spec type_spec_IWebAuthenticationBrokerContinuationEventArgs =
    {
        "_winsdk_Windows_ApplicationModel_Activation.IWebAuthenticationBrokerContinuationEventArgs",
        sizeof(py::wrapper::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_IWebAuthenticationBrokerContinuationEventArgs
    };

    // ----- Windows.ApplicationModel.Activation Initialization --------------------
    PyDoc_STRVAR(module_doc, "Windows::ApplicationModel::Activation");

    static PyMethodDef module_methods[] = {
        {"_register_ActivationKind", register_ActivationKind, METH_O, "registers type"},
        {"_register_ApplicationExecutionState", register_ApplicationExecutionState, METH_O, "registers type"},
        {}};


    static int module_traverse(PyObject* module, visitproc visit, void* arg) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_VISIT(state->type_ActivationKind);
        Py_VISIT(state->type_ApplicationExecutionState);
        Py_VISIT(state->type_AppointmentsProviderAddAppointmentActivatedEventArgs);
        Py_VISIT(state->type_AppointmentsProviderRemoveAppointmentActivatedEventArgs);
        Py_VISIT(state->type_AppointmentsProviderReplaceAppointmentActivatedEventArgs);
        Py_VISIT(state->type_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs);
        Py_VISIT(state->type_AppointmentsProviderShowTimeFrameActivatedEventArgs);
        Py_VISIT(state->type_BackgroundActivatedEventArgs);
        Py_VISIT(state->type_BarcodeScannerPreviewActivatedEventArgs);
        Py_VISIT(state->type_CachedFileUpdaterActivatedEventArgs);
        Py_VISIT(state->type_CameraSettingsActivatedEventArgs);
        Py_VISIT(state->type_CommandLineActivatedEventArgs);
        Py_VISIT(state->type_CommandLineActivationOperation);
        Py_VISIT(state->type_ContactCallActivatedEventArgs);
        Py_VISIT(state->type_ContactMapActivatedEventArgs);
        Py_VISIT(state->type_ContactMessageActivatedEventArgs);
        Py_VISIT(state->type_ContactPanelActivatedEventArgs);
        Py_VISIT(state->type_ContactPickerActivatedEventArgs);
        Py_VISIT(state->type_ContactPostActivatedEventArgs);
        Py_VISIT(state->type_ContactVideoCallActivatedEventArgs);
        Py_VISIT(state->type_DeviceActivatedEventArgs);
        Py_VISIT(state->type_DevicePairingActivatedEventArgs);
        Py_VISIT(state->type_DialReceiverActivatedEventArgs);
        Py_VISIT(state->type_FileActivatedEventArgs);
        Py_VISIT(state->type_FileOpenPickerActivatedEventArgs);
        Py_VISIT(state->type_FileOpenPickerContinuationEventArgs);
        Py_VISIT(state->type_FileSavePickerActivatedEventArgs);
        Py_VISIT(state->type_FileSavePickerContinuationEventArgs);
        Py_VISIT(state->type_FolderPickerContinuationEventArgs);
        Py_VISIT(state->type_LaunchActivatedEventArgs);
        Py_VISIT(state->type_LockScreenActivatedEventArgs);
        Py_VISIT(state->type_LockScreenCallActivatedEventArgs);
        Py_VISIT(state->type_LockScreenComponentActivatedEventArgs);
        Py_VISIT(state->type_PhoneCallActivatedEventArgs);
        Py_VISIT(state->type_PickerReturnedActivatedEventArgs);
        Py_VISIT(state->type_Print3DWorkflowActivatedEventArgs);
        Py_VISIT(state->type_PrintTaskSettingsActivatedEventArgs);
        Py_VISIT(state->type_ProtocolActivatedEventArgs);
        Py_VISIT(state->type_ProtocolForResultsActivatedEventArgs);
        Py_VISIT(state->type_RestrictedLaunchActivatedEventArgs);
        Py_VISIT(state->type_SearchActivatedEventArgs);
        Py_VISIT(state->type_ShareTargetActivatedEventArgs);
        Py_VISIT(state->type_SplashScreen);
        Py_VISIT(state->type_StartupTaskActivatedEventArgs);
        Py_VISIT(state->type_TileActivatedInfo);
        Py_VISIT(state->type_ToastNotificationActivatedEventArgs);
        Py_VISIT(state->type_UserDataAccountProviderActivatedEventArgs);
        Py_VISIT(state->type_VoiceCommandActivatedEventArgs);
        Py_VISIT(state->type_WalletActionActivatedEventArgs);
        Py_VISIT(state->type_WebAccountProviderActivatedEventArgs);
        Py_VISIT(state->type_WebAuthenticationBrokerContinuationEventArgs);
        Py_VISIT(state->type_IActivatedEventArgs);
        Py_VISIT(state->type_IActivatedEventArgsWithUser);
        Py_VISIT(state->type_IApplicationViewActivatedEventArgs);
        Py_VISIT(state->type_IAppointmentsProviderActivatedEventArgs);
        Py_VISIT(state->type_IAppointmentsProviderAddAppointmentActivatedEventArgs);
        Py_VISIT(state->type_IAppointmentsProviderRemoveAppointmentActivatedEventArgs);
        Py_VISIT(state->type_IAppointmentsProviderReplaceAppointmentActivatedEventArgs);
        Py_VISIT(state->type_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs);
        Py_VISIT(state->type_IAppointmentsProviderShowTimeFrameActivatedEventArgs);
        Py_VISIT(state->type_IBackgroundActivatedEventArgs);
        Py_VISIT(state->type_IBarcodeScannerPreviewActivatedEventArgs);
        Py_VISIT(state->type_ICachedFileUpdaterActivatedEventArgs);
        Py_VISIT(state->type_ICameraSettingsActivatedEventArgs);
        Py_VISIT(state->type_ICommandLineActivatedEventArgs);
        Py_VISIT(state->type_IContactActivatedEventArgs);
        Py_VISIT(state->type_IContactCallActivatedEventArgs);
        Py_VISIT(state->type_IContactMapActivatedEventArgs);
        Py_VISIT(state->type_IContactMessageActivatedEventArgs);
        Py_VISIT(state->type_IContactPanelActivatedEventArgs);
        Py_VISIT(state->type_IContactPickerActivatedEventArgs);
        Py_VISIT(state->type_IContactPostActivatedEventArgs);
        Py_VISIT(state->type_IContactVideoCallActivatedEventArgs);
        Py_VISIT(state->type_IContactsProviderActivatedEventArgs);
        Py_VISIT(state->type_IContinuationActivatedEventArgs);
        Py_VISIT(state->type_IDeviceActivatedEventArgs);
        Py_VISIT(state->type_IDevicePairingActivatedEventArgs);
        Py_VISIT(state->type_IDialReceiverActivatedEventArgs);
        Py_VISIT(state->type_IFileActivatedEventArgs);
        Py_VISIT(state->type_IFileActivatedEventArgsWithCallerPackageFamilyName);
        Py_VISIT(state->type_IFileActivatedEventArgsWithNeighboringFiles);
        Py_VISIT(state->type_IFileOpenPickerActivatedEventArgs);
        Py_VISIT(state->type_IFileOpenPickerActivatedEventArgs2);
        Py_VISIT(state->type_IFileOpenPickerContinuationEventArgs);
        Py_VISIT(state->type_IFileSavePickerActivatedEventArgs);
        Py_VISIT(state->type_IFileSavePickerActivatedEventArgs2);
        Py_VISIT(state->type_IFileSavePickerContinuationEventArgs);
        Py_VISIT(state->type_IFolderPickerContinuationEventArgs);
        Py_VISIT(state->type_ILaunchActivatedEventArgs);
        Py_VISIT(state->type_ILaunchActivatedEventArgs2);
        Py_VISIT(state->type_ILockScreenActivatedEventArgs);
        Py_VISIT(state->type_ILockScreenCallActivatedEventArgs);
        Py_VISIT(state->type_IPhoneCallActivatedEventArgs);
        Py_VISIT(state->type_IPickerReturnedActivatedEventArgs);
        Py_VISIT(state->type_IPrelaunchActivatedEventArgs);
        Py_VISIT(state->type_IPrint3DWorkflowActivatedEventArgs);
        Py_VISIT(state->type_IPrintTaskSettingsActivatedEventArgs);
        Py_VISIT(state->type_IProtocolActivatedEventArgs);
        Py_VISIT(state->type_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData);
        Py_VISIT(state->type_IProtocolForResultsActivatedEventArgs);
        Py_VISIT(state->type_IRestrictedLaunchActivatedEventArgs);
        Py_VISIT(state->type_ISearchActivatedEventArgs);
        Py_VISIT(state->type_ISearchActivatedEventArgsWithLinguisticDetails);
        Py_VISIT(state->type_IShareTargetActivatedEventArgs);
        Py_VISIT(state->type_IStartupTaskActivatedEventArgs);
        Py_VISIT(state->type_IToastNotificationActivatedEventArgs);
        Py_VISIT(state->type_IUserDataAccountProviderActivatedEventArgs);
        Py_VISIT(state->type_IViewSwitcherProvider);
        Py_VISIT(state->type_IVoiceCommandActivatedEventArgs);
        Py_VISIT(state->type_IWalletActionActivatedEventArgs);
        Py_VISIT(state->type_IWebAccountProviderActivatedEventArgs);
        Py_VISIT(state->type_IWebAuthenticationBrokerContinuationEventArgs);

        return 0;
    }

    static int module_clear(PyObject* module) noexcept
    {
        auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));

        if (!state)
        {
            return 0;
        }

        Py_CLEAR(state->type_ActivationKind);
        Py_CLEAR(state->type_ApplicationExecutionState);
        Py_CLEAR(state->type_AppointmentsProviderAddAppointmentActivatedEventArgs);
        Py_CLEAR(state->type_AppointmentsProviderRemoveAppointmentActivatedEventArgs);
        Py_CLEAR(state->type_AppointmentsProviderReplaceAppointmentActivatedEventArgs);
        Py_CLEAR(state->type_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs);
        Py_CLEAR(state->type_AppointmentsProviderShowTimeFrameActivatedEventArgs);
        Py_CLEAR(state->type_BackgroundActivatedEventArgs);
        Py_CLEAR(state->type_BarcodeScannerPreviewActivatedEventArgs);
        Py_CLEAR(state->type_CachedFileUpdaterActivatedEventArgs);
        Py_CLEAR(state->type_CameraSettingsActivatedEventArgs);
        Py_CLEAR(state->type_CommandLineActivatedEventArgs);
        Py_CLEAR(state->type_CommandLineActivationOperation);
        Py_CLEAR(state->type_ContactCallActivatedEventArgs);
        Py_CLEAR(state->type_ContactMapActivatedEventArgs);
        Py_CLEAR(state->type_ContactMessageActivatedEventArgs);
        Py_CLEAR(state->type_ContactPanelActivatedEventArgs);
        Py_CLEAR(state->type_ContactPickerActivatedEventArgs);
        Py_CLEAR(state->type_ContactPostActivatedEventArgs);
        Py_CLEAR(state->type_ContactVideoCallActivatedEventArgs);
        Py_CLEAR(state->type_DeviceActivatedEventArgs);
        Py_CLEAR(state->type_DevicePairingActivatedEventArgs);
        Py_CLEAR(state->type_DialReceiverActivatedEventArgs);
        Py_CLEAR(state->type_FileActivatedEventArgs);
        Py_CLEAR(state->type_FileOpenPickerActivatedEventArgs);
        Py_CLEAR(state->type_FileOpenPickerContinuationEventArgs);
        Py_CLEAR(state->type_FileSavePickerActivatedEventArgs);
        Py_CLEAR(state->type_FileSavePickerContinuationEventArgs);
        Py_CLEAR(state->type_FolderPickerContinuationEventArgs);
        Py_CLEAR(state->type_LaunchActivatedEventArgs);
        Py_CLEAR(state->type_LockScreenActivatedEventArgs);
        Py_CLEAR(state->type_LockScreenCallActivatedEventArgs);
        Py_CLEAR(state->type_LockScreenComponentActivatedEventArgs);
        Py_CLEAR(state->type_PhoneCallActivatedEventArgs);
        Py_CLEAR(state->type_PickerReturnedActivatedEventArgs);
        Py_CLEAR(state->type_Print3DWorkflowActivatedEventArgs);
        Py_CLEAR(state->type_PrintTaskSettingsActivatedEventArgs);
        Py_CLEAR(state->type_ProtocolActivatedEventArgs);
        Py_CLEAR(state->type_ProtocolForResultsActivatedEventArgs);
        Py_CLEAR(state->type_RestrictedLaunchActivatedEventArgs);
        Py_CLEAR(state->type_SearchActivatedEventArgs);
        Py_CLEAR(state->type_ShareTargetActivatedEventArgs);
        Py_CLEAR(state->type_SplashScreen);
        Py_CLEAR(state->type_StartupTaskActivatedEventArgs);
        Py_CLEAR(state->type_TileActivatedInfo);
        Py_CLEAR(state->type_ToastNotificationActivatedEventArgs);
        Py_CLEAR(state->type_UserDataAccountProviderActivatedEventArgs);
        Py_CLEAR(state->type_VoiceCommandActivatedEventArgs);
        Py_CLEAR(state->type_WalletActionActivatedEventArgs);
        Py_CLEAR(state->type_WebAccountProviderActivatedEventArgs);
        Py_CLEAR(state->type_WebAuthenticationBrokerContinuationEventArgs);
        Py_CLEAR(state->type_IActivatedEventArgs);
        Py_CLEAR(state->type_IActivatedEventArgsWithUser);
        Py_CLEAR(state->type_IApplicationViewActivatedEventArgs);
        Py_CLEAR(state->type_IAppointmentsProviderActivatedEventArgs);
        Py_CLEAR(state->type_IAppointmentsProviderAddAppointmentActivatedEventArgs);
        Py_CLEAR(state->type_IAppointmentsProviderRemoveAppointmentActivatedEventArgs);
        Py_CLEAR(state->type_IAppointmentsProviderReplaceAppointmentActivatedEventArgs);
        Py_CLEAR(state->type_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs);
        Py_CLEAR(state->type_IAppointmentsProviderShowTimeFrameActivatedEventArgs);
        Py_CLEAR(state->type_IBackgroundActivatedEventArgs);
        Py_CLEAR(state->type_IBarcodeScannerPreviewActivatedEventArgs);
        Py_CLEAR(state->type_ICachedFileUpdaterActivatedEventArgs);
        Py_CLEAR(state->type_ICameraSettingsActivatedEventArgs);
        Py_CLEAR(state->type_ICommandLineActivatedEventArgs);
        Py_CLEAR(state->type_IContactActivatedEventArgs);
        Py_CLEAR(state->type_IContactCallActivatedEventArgs);
        Py_CLEAR(state->type_IContactMapActivatedEventArgs);
        Py_CLEAR(state->type_IContactMessageActivatedEventArgs);
        Py_CLEAR(state->type_IContactPanelActivatedEventArgs);
        Py_CLEAR(state->type_IContactPickerActivatedEventArgs);
        Py_CLEAR(state->type_IContactPostActivatedEventArgs);
        Py_CLEAR(state->type_IContactVideoCallActivatedEventArgs);
        Py_CLEAR(state->type_IContactsProviderActivatedEventArgs);
        Py_CLEAR(state->type_IContinuationActivatedEventArgs);
        Py_CLEAR(state->type_IDeviceActivatedEventArgs);
        Py_CLEAR(state->type_IDevicePairingActivatedEventArgs);
        Py_CLEAR(state->type_IDialReceiverActivatedEventArgs);
        Py_CLEAR(state->type_IFileActivatedEventArgs);
        Py_CLEAR(state->type_IFileActivatedEventArgsWithCallerPackageFamilyName);
        Py_CLEAR(state->type_IFileActivatedEventArgsWithNeighboringFiles);
        Py_CLEAR(state->type_IFileOpenPickerActivatedEventArgs);
        Py_CLEAR(state->type_IFileOpenPickerActivatedEventArgs2);
        Py_CLEAR(state->type_IFileOpenPickerContinuationEventArgs);
        Py_CLEAR(state->type_IFileSavePickerActivatedEventArgs);
        Py_CLEAR(state->type_IFileSavePickerActivatedEventArgs2);
        Py_CLEAR(state->type_IFileSavePickerContinuationEventArgs);
        Py_CLEAR(state->type_IFolderPickerContinuationEventArgs);
        Py_CLEAR(state->type_ILaunchActivatedEventArgs);
        Py_CLEAR(state->type_ILaunchActivatedEventArgs2);
        Py_CLEAR(state->type_ILockScreenActivatedEventArgs);
        Py_CLEAR(state->type_ILockScreenCallActivatedEventArgs);
        Py_CLEAR(state->type_IPhoneCallActivatedEventArgs);
        Py_CLEAR(state->type_IPickerReturnedActivatedEventArgs);
        Py_CLEAR(state->type_IPrelaunchActivatedEventArgs);
        Py_CLEAR(state->type_IPrint3DWorkflowActivatedEventArgs);
        Py_CLEAR(state->type_IPrintTaskSettingsActivatedEventArgs);
        Py_CLEAR(state->type_IProtocolActivatedEventArgs);
        Py_CLEAR(state->type_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData);
        Py_CLEAR(state->type_IProtocolForResultsActivatedEventArgs);
        Py_CLEAR(state->type_IRestrictedLaunchActivatedEventArgs);
        Py_CLEAR(state->type_ISearchActivatedEventArgs);
        Py_CLEAR(state->type_ISearchActivatedEventArgsWithLinguisticDetails);
        Py_CLEAR(state->type_IShareTargetActivatedEventArgs);
        Py_CLEAR(state->type_IStartupTaskActivatedEventArgs);
        Py_CLEAR(state->type_IToastNotificationActivatedEventArgs);
        Py_CLEAR(state->type_IUserDataAccountProviderActivatedEventArgs);
        Py_CLEAR(state->type_IViewSwitcherProvider);
        Py_CLEAR(state->type_IVoiceCommandActivatedEventArgs);
        Py_CLEAR(state->type_IWalletActionActivatedEventArgs);
        Py_CLEAR(state->type_IWebAccountProviderActivatedEventArgs);
        Py_CLEAR(state->type_IWebAuthenticationBrokerContinuationEventArgs);

        return 0;
    }


    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_ApplicationModel_Activation",
           module_doc,
           sizeof(module_state),
           module_methods,
           nullptr,
           module_traverse,
           module_clear,
           nullptr};

} // py::cpp::Windows::ApplicationModel::Activation

PyMODINIT_FUNC PyInit__winsdk_Windows_ApplicationModel_Activation(void) noexcept
{
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    py::pyobj_handle module{PyModule_Create(&module_def)};

    if (!module)
    {
        return nullptr;
    }

    auto object_type = py::get_python_type<py::Object>();
    if (!object_type)
    {
        return nullptr;
    }

    py::pyobj_handle bases{PyTuple_Pack(1, object_type)};

    if (!bases)
    {
        return nullptr;
    }

    py::pyobj_handle collections_abc_module{PyImport_ImportModule("collections.abc")};

    if (!collections_abc_module)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "Sequence")};

    if (!sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle sequence_bases{PyTuple_Pack(2, object_type, sequence_type.get())};

    if (!sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableSequence")};

    if (!mutable_sequence_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_sequence_bases{PyTuple_Pack(2, object_type, mutable_sequence_type.get())};

    if (!mutable_sequence_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "Mapping")};

    if (!mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mapping_bases{PyTuple_Pack(2, object_type, mapping_type.get())};

    if (!mapping_bases)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_type{PyObject_GetAttrString(collections_abc_module.get(), "MutableMapping")};

    if (!mutable_mapping_type)
    {
        return nullptr;
    }

    py::pyobj_handle mutable_mapping_bases{PyTuple_Pack(2, object_type, mutable_mapping_type.get())};

    if (!mutable_mapping_bases)
    {
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module.get()));
    assert(state);

    state->type_AppointmentsProviderAddAppointmentActivatedEventArgs = py::register_python_type(module.get(), type_name_AppointmentsProviderAddAppointmentActivatedEventArgs, &type_spec_AppointmentsProviderAddAppointmentActivatedEventArgs, bases.get());
    if (!state->type_AppointmentsProviderAddAppointmentActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AppointmentsProviderAddAppointmentActivatedEventArgs);

    state->type_AppointmentsProviderRemoveAppointmentActivatedEventArgs = py::register_python_type(module.get(), type_name_AppointmentsProviderRemoveAppointmentActivatedEventArgs, &type_spec_AppointmentsProviderRemoveAppointmentActivatedEventArgs, bases.get());
    if (!state->type_AppointmentsProviderRemoveAppointmentActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AppointmentsProviderRemoveAppointmentActivatedEventArgs);

    state->type_AppointmentsProviderReplaceAppointmentActivatedEventArgs = py::register_python_type(module.get(), type_name_AppointmentsProviderReplaceAppointmentActivatedEventArgs, &type_spec_AppointmentsProviderReplaceAppointmentActivatedEventArgs, bases.get());
    if (!state->type_AppointmentsProviderReplaceAppointmentActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AppointmentsProviderReplaceAppointmentActivatedEventArgs);

    state->type_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs = py::register_python_type(module.get(), type_name_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs, &type_spec_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs, bases.get());
    if (!state->type_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs);

    state->type_AppointmentsProviderShowTimeFrameActivatedEventArgs = py::register_python_type(module.get(), type_name_AppointmentsProviderShowTimeFrameActivatedEventArgs, &type_spec_AppointmentsProviderShowTimeFrameActivatedEventArgs, bases.get());
    if (!state->type_AppointmentsProviderShowTimeFrameActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_AppointmentsProviderShowTimeFrameActivatedEventArgs);

    state->type_BackgroundActivatedEventArgs = py::register_python_type(module.get(), type_name_BackgroundActivatedEventArgs, &type_spec_BackgroundActivatedEventArgs, bases.get());
    if (!state->type_BackgroundActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BackgroundActivatedEventArgs);

    state->type_BarcodeScannerPreviewActivatedEventArgs = py::register_python_type(module.get(), type_name_BarcodeScannerPreviewActivatedEventArgs, &type_spec_BarcodeScannerPreviewActivatedEventArgs, bases.get());
    if (!state->type_BarcodeScannerPreviewActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_BarcodeScannerPreviewActivatedEventArgs);

    state->type_CachedFileUpdaterActivatedEventArgs = py::register_python_type(module.get(), type_name_CachedFileUpdaterActivatedEventArgs, &type_spec_CachedFileUpdaterActivatedEventArgs, bases.get());
    if (!state->type_CachedFileUpdaterActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CachedFileUpdaterActivatedEventArgs);

    state->type_CameraSettingsActivatedEventArgs = py::register_python_type(module.get(), type_name_CameraSettingsActivatedEventArgs, &type_spec_CameraSettingsActivatedEventArgs, bases.get());
    if (!state->type_CameraSettingsActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CameraSettingsActivatedEventArgs);

    state->type_CommandLineActivatedEventArgs = py::register_python_type(module.get(), type_name_CommandLineActivatedEventArgs, &type_spec_CommandLineActivatedEventArgs, bases.get());
    if (!state->type_CommandLineActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CommandLineActivatedEventArgs);

    state->type_CommandLineActivationOperation = py::register_python_type(module.get(), type_name_CommandLineActivationOperation, &type_spec_CommandLineActivationOperation, bases.get());
    if (!state->type_CommandLineActivationOperation)
    {
        return nullptr;
    }

    Py_INCREF(state->type_CommandLineActivationOperation);

    state->type_ContactCallActivatedEventArgs = py::register_python_type(module.get(), type_name_ContactCallActivatedEventArgs, &type_spec_ContactCallActivatedEventArgs, bases.get());
    if (!state->type_ContactCallActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ContactCallActivatedEventArgs);

    state->type_ContactMapActivatedEventArgs = py::register_python_type(module.get(), type_name_ContactMapActivatedEventArgs, &type_spec_ContactMapActivatedEventArgs, bases.get());
    if (!state->type_ContactMapActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ContactMapActivatedEventArgs);

    state->type_ContactMessageActivatedEventArgs = py::register_python_type(module.get(), type_name_ContactMessageActivatedEventArgs, &type_spec_ContactMessageActivatedEventArgs, bases.get());
    if (!state->type_ContactMessageActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ContactMessageActivatedEventArgs);

    state->type_ContactPanelActivatedEventArgs = py::register_python_type(module.get(), type_name_ContactPanelActivatedEventArgs, &type_spec_ContactPanelActivatedEventArgs, bases.get());
    if (!state->type_ContactPanelActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ContactPanelActivatedEventArgs);

    state->type_ContactPickerActivatedEventArgs = py::register_python_type(module.get(), type_name_ContactPickerActivatedEventArgs, &type_spec_ContactPickerActivatedEventArgs, bases.get());
    if (!state->type_ContactPickerActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ContactPickerActivatedEventArgs);

    state->type_ContactPostActivatedEventArgs = py::register_python_type(module.get(), type_name_ContactPostActivatedEventArgs, &type_spec_ContactPostActivatedEventArgs, bases.get());
    if (!state->type_ContactPostActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ContactPostActivatedEventArgs);

    state->type_ContactVideoCallActivatedEventArgs = py::register_python_type(module.get(), type_name_ContactVideoCallActivatedEventArgs, &type_spec_ContactVideoCallActivatedEventArgs, bases.get());
    if (!state->type_ContactVideoCallActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ContactVideoCallActivatedEventArgs);

    state->type_DeviceActivatedEventArgs = py::register_python_type(module.get(), type_name_DeviceActivatedEventArgs, &type_spec_DeviceActivatedEventArgs, bases.get());
    if (!state->type_DeviceActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_DeviceActivatedEventArgs);

    state->type_DevicePairingActivatedEventArgs = py::register_python_type(module.get(), type_name_DevicePairingActivatedEventArgs, &type_spec_DevicePairingActivatedEventArgs, bases.get());
    if (!state->type_DevicePairingActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_DevicePairingActivatedEventArgs);

    state->type_DialReceiverActivatedEventArgs = py::register_python_type(module.get(), type_name_DialReceiverActivatedEventArgs, &type_spec_DialReceiverActivatedEventArgs, bases.get());
    if (!state->type_DialReceiverActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_DialReceiverActivatedEventArgs);

    state->type_FileActivatedEventArgs = py::register_python_type(module.get(), type_name_FileActivatedEventArgs, &type_spec_FileActivatedEventArgs, bases.get());
    if (!state->type_FileActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FileActivatedEventArgs);

    state->type_FileOpenPickerActivatedEventArgs = py::register_python_type(module.get(), type_name_FileOpenPickerActivatedEventArgs, &type_spec_FileOpenPickerActivatedEventArgs, bases.get());
    if (!state->type_FileOpenPickerActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FileOpenPickerActivatedEventArgs);

    state->type_FileOpenPickerContinuationEventArgs = py::register_python_type(module.get(), type_name_FileOpenPickerContinuationEventArgs, &type_spec_FileOpenPickerContinuationEventArgs, bases.get());
    if (!state->type_FileOpenPickerContinuationEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FileOpenPickerContinuationEventArgs);

    state->type_FileSavePickerActivatedEventArgs = py::register_python_type(module.get(), type_name_FileSavePickerActivatedEventArgs, &type_spec_FileSavePickerActivatedEventArgs, bases.get());
    if (!state->type_FileSavePickerActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FileSavePickerActivatedEventArgs);

    state->type_FileSavePickerContinuationEventArgs = py::register_python_type(module.get(), type_name_FileSavePickerContinuationEventArgs, &type_spec_FileSavePickerContinuationEventArgs, bases.get());
    if (!state->type_FileSavePickerContinuationEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FileSavePickerContinuationEventArgs);

    state->type_FolderPickerContinuationEventArgs = py::register_python_type(module.get(), type_name_FolderPickerContinuationEventArgs, &type_spec_FolderPickerContinuationEventArgs, bases.get());
    if (!state->type_FolderPickerContinuationEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_FolderPickerContinuationEventArgs);

    state->type_LaunchActivatedEventArgs = py::register_python_type(module.get(), type_name_LaunchActivatedEventArgs, &type_spec_LaunchActivatedEventArgs, bases.get());
    if (!state->type_LaunchActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_LaunchActivatedEventArgs);

    state->type_LockScreenActivatedEventArgs = py::register_python_type(module.get(), type_name_LockScreenActivatedEventArgs, &type_spec_LockScreenActivatedEventArgs, bases.get());
    if (!state->type_LockScreenActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_LockScreenActivatedEventArgs);

    state->type_LockScreenCallActivatedEventArgs = py::register_python_type(module.get(), type_name_LockScreenCallActivatedEventArgs, &type_spec_LockScreenCallActivatedEventArgs, bases.get());
    if (!state->type_LockScreenCallActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_LockScreenCallActivatedEventArgs);

    state->type_LockScreenComponentActivatedEventArgs = py::register_python_type(module.get(), type_name_LockScreenComponentActivatedEventArgs, &type_spec_LockScreenComponentActivatedEventArgs, bases.get());
    if (!state->type_LockScreenComponentActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_LockScreenComponentActivatedEventArgs);

    state->type_PhoneCallActivatedEventArgs = py::register_python_type(module.get(), type_name_PhoneCallActivatedEventArgs, &type_spec_PhoneCallActivatedEventArgs, bases.get());
    if (!state->type_PhoneCallActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PhoneCallActivatedEventArgs);

    state->type_PickerReturnedActivatedEventArgs = py::register_python_type(module.get(), type_name_PickerReturnedActivatedEventArgs, &type_spec_PickerReturnedActivatedEventArgs, bases.get());
    if (!state->type_PickerReturnedActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PickerReturnedActivatedEventArgs);

    state->type_Print3DWorkflowActivatedEventArgs = py::register_python_type(module.get(), type_name_Print3DWorkflowActivatedEventArgs, &type_spec_Print3DWorkflowActivatedEventArgs, bases.get());
    if (!state->type_Print3DWorkflowActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_Print3DWorkflowActivatedEventArgs);

    state->type_PrintTaskSettingsActivatedEventArgs = py::register_python_type(module.get(), type_name_PrintTaskSettingsActivatedEventArgs, &type_spec_PrintTaskSettingsActivatedEventArgs, bases.get());
    if (!state->type_PrintTaskSettingsActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_PrintTaskSettingsActivatedEventArgs);

    state->type_ProtocolActivatedEventArgs = py::register_python_type(module.get(), type_name_ProtocolActivatedEventArgs, &type_spec_ProtocolActivatedEventArgs, bases.get());
    if (!state->type_ProtocolActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ProtocolActivatedEventArgs);

    state->type_ProtocolForResultsActivatedEventArgs = py::register_python_type(module.get(), type_name_ProtocolForResultsActivatedEventArgs, &type_spec_ProtocolForResultsActivatedEventArgs, bases.get());
    if (!state->type_ProtocolForResultsActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ProtocolForResultsActivatedEventArgs);

    state->type_RestrictedLaunchActivatedEventArgs = py::register_python_type(module.get(), type_name_RestrictedLaunchActivatedEventArgs, &type_spec_RestrictedLaunchActivatedEventArgs, bases.get());
    if (!state->type_RestrictedLaunchActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_RestrictedLaunchActivatedEventArgs);

    state->type_SearchActivatedEventArgs = py::register_python_type(module.get(), type_name_SearchActivatedEventArgs, &type_spec_SearchActivatedEventArgs, bases.get());
    if (!state->type_SearchActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SearchActivatedEventArgs);

    state->type_ShareTargetActivatedEventArgs = py::register_python_type(module.get(), type_name_ShareTargetActivatedEventArgs, &type_spec_ShareTargetActivatedEventArgs, bases.get());
    if (!state->type_ShareTargetActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ShareTargetActivatedEventArgs);

    state->type_SplashScreen = py::register_python_type(module.get(), type_name_SplashScreen, &type_spec_SplashScreen, bases.get());
    if (!state->type_SplashScreen)
    {
        return nullptr;
    }

    Py_INCREF(state->type_SplashScreen);

    state->type_StartupTaskActivatedEventArgs = py::register_python_type(module.get(), type_name_StartupTaskActivatedEventArgs, &type_spec_StartupTaskActivatedEventArgs, bases.get());
    if (!state->type_StartupTaskActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_StartupTaskActivatedEventArgs);

    state->type_TileActivatedInfo = py::register_python_type(module.get(), type_name_TileActivatedInfo, &type_spec_TileActivatedInfo, bases.get());
    if (!state->type_TileActivatedInfo)
    {
        return nullptr;
    }

    Py_INCREF(state->type_TileActivatedInfo);

    state->type_ToastNotificationActivatedEventArgs = py::register_python_type(module.get(), type_name_ToastNotificationActivatedEventArgs, &type_spec_ToastNotificationActivatedEventArgs, bases.get());
    if (!state->type_ToastNotificationActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ToastNotificationActivatedEventArgs);

    state->type_UserDataAccountProviderActivatedEventArgs = py::register_python_type(module.get(), type_name_UserDataAccountProviderActivatedEventArgs, &type_spec_UserDataAccountProviderActivatedEventArgs, bases.get());
    if (!state->type_UserDataAccountProviderActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_UserDataAccountProviderActivatedEventArgs);

    state->type_VoiceCommandActivatedEventArgs = py::register_python_type(module.get(), type_name_VoiceCommandActivatedEventArgs, &type_spec_VoiceCommandActivatedEventArgs, bases.get());
    if (!state->type_VoiceCommandActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_VoiceCommandActivatedEventArgs);

    state->type_WalletActionActivatedEventArgs = py::register_python_type(module.get(), type_name_WalletActionActivatedEventArgs, &type_spec_WalletActionActivatedEventArgs, bases.get());
    if (!state->type_WalletActionActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_WalletActionActivatedEventArgs);

    state->type_WebAccountProviderActivatedEventArgs = py::register_python_type(module.get(), type_name_WebAccountProviderActivatedEventArgs, &type_spec_WebAccountProviderActivatedEventArgs, bases.get());
    if (!state->type_WebAccountProviderActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_WebAccountProviderActivatedEventArgs);

    state->type_WebAuthenticationBrokerContinuationEventArgs = py::register_python_type(module.get(), type_name_WebAuthenticationBrokerContinuationEventArgs, &type_spec_WebAuthenticationBrokerContinuationEventArgs, bases.get());
    if (!state->type_WebAuthenticationBrokerContinuationEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_WebAuthenticationBrokerContinuationEventArgs);

    state->type_IActivatedEventArgs = py::register_python_type(module.get(), type_name_IActivatedEventArgs, &type_spec_IActivatedEventArgs, bases.get());
    if (!state->type_IActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IActivatedEventArgs);

    state->type_IActivatedEventArgsWithUser = py::register_python_type(module.get(), type_name_IActivatedEventArgsWithUser, &type_spec_IActivatedEventArgsWithUser, bases.get());
    if (!state->type_IActivatedEventArgsWithUser)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IActivatedEventArgsWithUser);

    state->type_IApplicationViewActivatedEventArgs = py::register_python_type(module.get(), type_name_IApplicationViewActivatedEventArgs, &type_spec_IApplicationViewActivatedEventArgs, bases.get());
    if (!state->type_IApplicationViewActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IApplicationViewActivatedEventArgs);

    state->type_IAppointmentsProviderActivatedEventArgs = py::register_python_type(module.get(), type_name_IAppointmentsProviderActivatedEventArgs, &type_spec_IAppointmentsProviderActivatedEventArgs, bases.get());
    if (!state->type_IAppointmentsProviderActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IAppointmentsProviderActivatedEventArgs);

    state->type_IAppointmentsProviderAddAppointmentActivatedEventArgs = py::register_python_type(module.get(), type_name_IAppointmentsProviderAddAppointmentActivatedEventArgs, &type_spec_IAppointmentsProviderAddAppointmentActivatedEventArgs, bases.get());
    if (!state->type_IAppointmentsProviderAddAppointmentActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IAppointmentsProviderAddAppointmentActivatedEventArgs);

    state->type_IAppointmentsProviderRemoveAppointmentActivatedEventArgs = py::register_python_type(module.get(), type_name_IAppointmentsProviderRemoveAppointmentActivatedEventArgs, &type_spec_IAppointmentsProviderRemoveAppointmentActivatedEventArgs, bases.get());
    if (!state->type_IAppointmentsProviderRemoveAppointmentActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IAppointmentsProviderRemoveAppointmentActivatedEventArgs);

    state->type_IAppointmentsProviderReplaceAppointmentActivatedEventArgs = py::register_python_type(module.get(), type_name_IAppointmentsProviderReplaceAppointmentActivatedEventArgs, &type_spec_IAppointmentsProviderReplaceAppointmentActivatedEventArgs, bases.get());
    if (!state->type_IAppointmentsProviderReplaceAppointmentActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IAppointmentsProviderReplaceAppointmentActivatedEventArgs);

    state->type_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs = py::register_python_type(module.get(), type_name_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, &type_spec_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs, bases.get());
    if (!state->type_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs);

    state->type_IAppointmentsProviderShowTimeFrameActivatedEventArgs = py::register_python_type(module.get(), type_name_IAppointmentsProviderShowTimeFrameActivatedEventArgs, &type_spec_IAppointmentsProviderShowTimeFrameActivatedEventArgs, bases.get());
    if (!state->type_IAppointmentsProviderShowTimeFrameActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IAppointmentsProviderShowTimeFrameActivatedEventArgs);

    state->type_IBackgroundActivatedEventArgs = py::register_python_type(module.get(), type_name_IBackgroundActivatedEventArgs, &type_spec_IBackgroundActivatedEventArgs, bases.get());
    if (!state->type_IBackgroundActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IBackgroundActivatedEventArgs);

    state->type_IBarcodeScannerPreviewActivatedEventArgs = py::register_python_type(module.get(), type_name_IBarcodeScannerPreviewActivatedEventArgs, &type_spec_IBarcodeScannerPreviewActivatedEventArgs, bases.get());
    if (!state->type_IBarcodeScannerPreviewActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IBarcodeScannerPreviewActivatedEventArgs);

    state->type_ICachedFileUpdaterActivatedEventArgs = py::register_python_type(module.get(), type_name_ICachedFileUpdaterActivatedEventArgs, &type_spec_ICachedFileUpdaterActivatedEventArgs, bases.get());
    if (!state->type_ICachedFileUpdaterActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ICachedFileUpdaterActivatedEventArgs);

    state->type_ICameraSettingsActivatedEventArgs = py::register_python_type(module.get(), type_name_ICameraSettingsActivatedEventArgs, &type_spec_ICameraSettingsActivatedEventArgs, bases.get());
    if (!state->type_ICameraSettingsActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ICameraSettingsActivatedEventArgs);

    state->type_ICommandLineActivatedEventArgs = py::register_python_type(module.get(), type_name_ICommandLineActivatedEventArgs, &type_spec_ICommandLineActivatedEventArgs, bases.get());
    if (!state->type_ICommandLineActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ICommandLineActivatedEventArgs);

    state->type_IContactActivatedEventArgs = py::register_python_type(module.get(), type_name_IContactActivatedEventArgs, &type_spec_IContactActivatedEventArgs, bases.get());
    if (!state->type_IContactActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IContactActivatedEventArgs);

    state->type_IContactCallActivatedEventArgs = py::register_python_type(module.get(), type_name_IContactCallActivatedEventArgs, &type_spec_IContactCallActivatedEventArgs, bases.get());
    if (!state->type_IContactCallActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IContactCallActivatedEventArgs);

    state->type_IContactMapActivatedEventArgs = py::register_python_type(module.get(), type_name_IContactMapActivatedEventArgs, &type_spec_IContactMapActivatedEventArgs, bases.get());
    if (!state->type_IContactMapActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IContactMapActivatedEventArgs);

    state->type_IContactMessageActivatedEventArgs = py::register_python_type(module.get(), type_name_IContactMessageActivatedEventArgs, &type_spec_IContactMessageActivatedEventArgs, bases.get());
    if (!state->type_IContactMessageActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IContactMessageActivatedEventArgs);

    state->type_IContactPanelActivatedEventArgs = py::register_python_type(module.get(), type_name_IContactPanelActivatedEventArgs, &type_spec_IContactPanelActivatedEventArgs, bases.get());
    if (!state->type_IContactPanelActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IContactPanelActivatedEventArgs);

    state->type_IContactPickerActivatedEventArgs = py::register_python_type(module.get(), type_name_IContactPickerActivatedEventArgs, &type_spec_IContactPickerActivatedEventArgs, bases.get());
    if (!state->type_IContactPickerActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IContactPickerActivatedEventArgs);

    state->type_IContactPostActivatedEventArgs = py::register_python_type(module.get(), type_name_IContactPostActivatedEventArgs, &type_spec_IContactPostActivatedEventArgs, bases.get());
    if (!state->type_IContactPostActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IContactPostActivatedEventArgs);

    state->type_IContactVideoCallActivatedEventArgs = py::register_python_type(module.get(), type_name_IContactVideoCallActivatedEventArgs, &type_spec_IContactVideoCallActivatedEventArgs, bases.get());
    if (!state->type_IContactVideoCallActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IContactVideoCallActivatedEventArgs);

    state->type_IContactsProviderActivatedEventArgs = py::register_python_type(module.get(), type_name_IContactsProviderActivatedEventArgs, &type_spec_IContactsProviderActivatedEventArgs, bases.get());
    if (!state->type_IContactsProviderActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IContactsProviderActivatedEventArgs);

    state->type_IContinuationActivatedEventArgs = py::register_python_type(module.get(), type_name_IContinuationActivatedEventArgs, &type_spec_IContinuationActivatedEventArgs, bases.get());
    if (!state->type_IContinuationActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IContinuationActivatedEventArgs);

    state->type_IDeviceActivatedEventArgs = py::register_python_type(module.get(), type_name_IDeviceActivatedEventArgs, &type_spec_IDeviceActivatedEventArgs, bases.get());
    if (!state->type_IDeviceActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IDeviceActivatedEventArgs);

    state->type_IDevicePairingActivatedEventArgs = py::register_python_type(module.get(), type_name_IDevicePairingActivatedEventArgs, &type_spec_IDevicePairingActivatedEventArgs, bases.get());
    if (!state->type_IDevicePairingActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IDevicePairingActivatedEventArgs);

    state->type_IDialReceiverActivatedEventArgs = py::register_python_type(module.get(), type_name_IDialReceiverActivatedEventArgs, &type_spec_IDialReceiverActivatedEventArgs, bases.get());
    if (!state->type_IDialReceiverActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IDialReceiverActivatedEventArgs);

    state->type_IFileActivatedEventArgs = py::register_python_type(module.get(), type_name_IFileActivatedEventArgs, &type_spec_IFileActivatedEventArgs, bases.get());
    if (!state->type_IFileActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IFileActivatedEventArgs);

    state->type_IFileActivatedEventArgsWithCallerPackageFamilyName = py::register_python_type(module.get(), type_name_IFileActivatedEventArgsWithCallerPackageFamilyName, &type_spec_IFileActivatedEventArgsWithCallerPackageFamilyName, bases.get());
    if (!state->type_IFileActivatedEventArgsWithCallerPackageFamilyName)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IFileActivatedEventArgsWithCallerPackageFamilyName);

    state->type_IFileActivatedEventArgsWithNeighboringFiles = py::register_python_type(module.get(), type_name_IFileActivatedEventArgsWithNeighboringFiles, &type_spec_IFileActivatedEventArgsWithNeighboringFiles, bases.get());
    if (!state->type_IFileActivatedEventArgsWithNeighboringFiles)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IFileActivatedEventArgsWithNeighboringFiles);

    state->type_IFileOpenPickerActivatedEventArgs = py::register_python_type(module.get(), type_name_IFileOpenPickerActivatedEventArgs, &type_spec_IFileOpenPickerActivatedEventArgs, bases.get());
    if (!state->type_IFileOpenPickerActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IFileOpenPickerActivatedEventArgs);

    state->type_IFileOpenPickerActivatedEventArgs2 = py::register_python_type(module.get(), type_name_IFileOpenPickerActivatedEventArgs2, &type_spec_IFileOpenPickerActivatedEventArgs2, bases.get());
    if (!state->type_IFileOpenPickerActivatedEventArgs2)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IFileOpenPickerActivatedEventArgs2);

    state->type_IFileOpenPickerContinuationEventArgs = py::register_python_type(module.get(), type_name_IFileOpenPickerContinuationEventArgs, &type_spec_IFileOpenPickerContinuationEventArgs, bases.get());
    if (!state->type_IFileOpenPickerContinuationEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IFileOpenPickerContinuationEventArgs);

    state->type_IFileSavePickerActivatedEventArgs = py::register_python_type(module.get(), type_name_IFileSavePickerActivatedEventArgs, &type_spec_IFileSavePickerActivatedEventArgs, bases.get());
    if (!state->type_IFileSavePickerActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IFileSavePickerActivatedEventArgs);

    state->type_IFileSavePickerActivatedEventArgs2 = py::register_python_type(module.get(), type_name_IFileSavePickerActivatedEventArgs2, &type_spec_IFileSavePickerActivatedEventArgs2, bases.get());
    if (!state->type_IFileSavePickerActivatedEventArgs2)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IFileSavePickerActivatedEventArgs2);

    state->type_IFileSavePickerContinuationEventArgs = py::register_python_type(module.get(), type_name_IFileSavePickerContinuationEventArgs, &type_spec_IFileSavePickerContinuationEventArgs, bases.get());
    if (!state->type_IFileSavePickerContinuationEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IFileSavePickerContinuationEventArgs);

    state->type_IFolderPickerContinuationEventArgs = py::register_python_type(module.get(), type_name_IFolderPickerContinuationEventArgs, &type_spec_IFolderPickerContinuationEventArgs, bases.get());
    if (!state->type_IFolderPickerContinuationEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IFolderPickerContinuationEventArgs);

    state->type_ILaunchActivatedEventArgs = py::register_python_type(module.get(), type_name_ILaunchActivatedEventArgs, &type_spec_ILaunchActivatedEventArgs, bases.get());
    if (!state->type_ILaunchActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ILaunchActivatedEventArgs);

    state->type_ILaunchActivatedEventArgs2 = py::register_python_type(module.get(), type_name_ILaunchActivatedEventArgs2, &type_spec_ILaunchActivatedEventArgs2, bases.get());
    if (!state->type_ILaunchActivatedEventArgs2)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ILaunchActivatedEventArgs2);

    state->type_ILockScreenActivatedEventArgs = py::register_python_type(module.get(), type_name_ILockScreenActivatedEventArgs, &type_spec_ILockScreenActivatedEventArgs, bases.get());
    if (!state->type_ILockScreenActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ILockScreenActivatedEventArgs);

    state->type_ILockScreenCallActivatedEventArgs = py::register_python_type(module.get(), type_name_ILockScreenCallActivatedEventArgs, &type_spec_ILockScreenCallActivatedEventArgs, bases.get());
    if (!state->type_ILockScreenCallActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ILockScreenCallActivatedEventArgs);

    state->type_IPhoneCallActivatedEventArgs = py::register_python_type(module.get(), type_name_IPhoneCallActivatedEventArgs, &type_spec_IPhoneCallActivatedEventArgs, bases.get());
    if (!state->type_IPhoneCallActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IPhoneCallActivatedEventArgs);

    state->type_IPickerReturnedActivatedEventArgs = py::register_python_type(module.get(), type_name_IPickerReturnedActivatedEventArgs, &type_spec_IPickerReturnedActivatedEventArgs, bases.get());
    if (!state->type_IPickerReturnedActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IPickerReturnedActivatedEventArgs);

    state->type_IPrelaunchActivatedEventArgs = py::register_python_type(module.get(), type_name_IPrelaunchActivatedEventArgs, &type_spec_IPrelaunchActivatedEventArgs, bases.get());
    if (!state->type_IPrelaunchActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IPrelaunchActivatedEventArgs);

    state->type_IPrint3DWorkflowActivatedEventArgs = py::register_python_type(module.get(), type_name_IPrint3DWorkflowActivatedEventArgs, &type_spec_IPrint3DWorkflowActivatedEventArgs, bases.get());
    if (!state->type_IPrint3DWorkflowActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IPrint3DWorkflowActivatedEventArgs);

    state->type_IPrintTaskSettingsActivatedEventArgs = py::register_python_type(module.get(), type_name_IPrintTaskSettingsActivatedEventArgs, &type_spec_IPrintTaskSettingsActivatedEventArgs, bases.get());
    if (!state->type_IPrintTaskSettingsActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IPrintTaskSettingsActivatedEventArgs);

    state->type_IProtocolActivatedEventArgs = py::register_python_type(module.get(), type_name_IProtocolActivatedEventArgs, &type_spec_IProtocolActivatedEventArgs, bases.get());
    if (!state->type_IProtocolActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IProtocolActivatedEventArgs);

    state->type_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData = py::register_python_type(module.get(), type_name_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData, &type_spec_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData, bases.get());
    if (!state->type_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData);

    state->type_IProtocolForResultsActivatedEventArgs = py::register_python_type(module.get(), type_name_IProtocolForResultsActivatedEventArgs, &type_spec_IProtocolForResultsActivatedEventArgs, bases.get());
    if (!state->type_IProtocolForResultsActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IProtocolForResultsActivatedEventArgs);

    state->type_IRestrictedLaunchActivatedEventArgs = py::register_python_type(module.get(), type_name_IRestrictedLaunchActivatedEventArgs, &type_spec_IRestrictedLaunchActivatedEventArgs, bases.get());
    if (!state->type_IRestrictedLaunchActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IRestrictedLaunchActivatedEventArgs);

    state->type_ISearchActivatedEventArgs = py::register_python_type(module.get(), type_name_ISearchActivatedEventArgs, &type_spec_ISearchActivatedEventArgs, bases.get());
    if (!state->type_ISearchActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ISearchActivatedEventArgs);

    state->type_ISearchActivatedEventArgsWithLinguisticDetails = py::register_python_type(module.get(), type_name_ISearchActivatedEventArgsWithLinguisticDetails, &type_spec_ISearchActivatedEventArgsWithLinguisticDetails, bases.get());
    if (!state->type_ISearchActivatedEventArgsWithLinguisticDetails)
    {
        return nullptr;
    }

    Py_INCREF(state->type_ISearchActivatedEventArgsWithLinguisticDetails);

    state->type_IShareTargetActivatedEventArgs = py::register_python_type(module.get(), type_name_IShareTargetActivatedEventArgs, &type_spec_IShareTargetActivatedEventArgs, bases.get());
    if (!state->type_IShareTargetActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IShareTargetActivatedEventArgs);

    state->type_IStartupTaskActivatedEventArgs = py::register_python_type(module.get(), type_name_IStartupTaskActivatedEventArgs, &type_spec_IStartupTaskActivatedEventArgs, bases.get());
    if (!state->type_IStartupTaskActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IStartupTaskActivatedEventArgs);

    state->type_IToastNotificationActivatedEventArgs = py::register_python_type(module.get(), type_name_IToastNotificationActivatedEventArgs, &type_spec_IToastNotificationActivatedEventArgs, bases.get());
    if (!state->type_IToastNotificationActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IToastNotificationActivatedEventArgs);

    state->type_IUserDataAccountProviderActivatedEventArgs = py::register_python_type(module.get(), type_name_IUserDataAccountProviderActivatedEventArgs, &type_spec_IUserDataAccountProviderActivatedEventArgs, bases.get());
    if (!state->type_IUserDataAccountProviderActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IUserDataAccountProviderActivatedEventArgs);

    state->type_IViewSwitcherProvider = py::register_python_type(module.get(), type_name_IViewSwitcherProvider, &type_spec_IViewSwitcherProvider, bases.get());
    if (!state->type_IViewSwitcherProvider)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IViewSwitcherProvider);

    state->type_IVoiceCommandActivatedEventArgs = py::register_python_type(module.get(), type_name_IVoiceCommandActivatedEventArgs, &type_spec_IVoiceCommandActivatedEventArgs, bases.get());
    if (!state->type_IVoiceCommandActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IVoiceCommandActivatedEventArgs);

    state->type_IWalletActionActivatedEventArgs = py::register_python_type(module.get(), type_name_IWalletActionActivatedEventArgs, &type_spec_IWalletActionActivatedEventArgs, bases.get());
    if (!state->type_IWalletActionActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IWalletActionActivatedEventArgs);

    state->type_IWebAccountProviderActivatedEventArgs = py::register_python_type(module.get(), type_name_IWebAccountProviderActivatedEventArgs, &type_spec_IWebAccountProviderActivatedEventArgs, bases.get());
    if (!state->type_IWebAccountProviderActivatedEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IWebAccountProviderActivatedEventArgs);

    state->type_IWebAuthenticationBrokerContinuationEventArgs = py::register_python_type(module.get(), type_name_IWebAuthenticationBrokerContinuationEventArgs, &type_spec_IWebAuthenticationBrokerContinuationEventArgs, bases.get());
    if (!state->type_IWebAuthenticationBrokerContinuationEventArgs)
    {
        return nullptr;
    }

    Py_INCREF(state->type_IWebAuthenticationBrokerContinuationEventArgs);


    return module.detach();
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Activation::ActivationKind>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ActivationKind;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ActivationKind is not registered");
        return nullptr;
    }

    return python_type;
}

PyObject* py::py_type<winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ApplicationExecutionState;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ApplicationExecutionState is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppointmentsProviderAddAppointmentActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::AppointmentsProviderAddAppointmentActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppointmentsProviderRemoveAppointmentActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::AppointmentsProviderRemoveAppointmentActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppointmentsProviderReplaceAppointmentActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::AppointmentsProviderReplaceAppointmentActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppointmentsProviderShowAppointmentDetailsActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowAppointmentDetailsActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_AppointmentsProviderShowTimeFrameActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::AppointmentsProviderShowTimeFrameActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BackgroundActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::BackgroundActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_BarcodeScannerPreviewActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::BarcodeScannerPreviewActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CachedFileUpdaterActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::CachedFileUpdaterActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CameraSettingsActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::CameraSettingsActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CommandLineActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::CommandLineActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::CommandLineActivationOperation>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_CommandLineActivationOperation;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::CommandLineActivationOperation is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactCallActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ContactCallActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactMapActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ContactMapActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactMessageActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ContactMessageActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactPanelActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ContactPanelActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactPickerActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ContactPickerActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactPostActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ContactPostActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ContactVideoCallActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ContactVideoCallActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DeviceActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::DeviceActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DevicePairingActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::DevicePairingActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_DialReceiverActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::DialReceiverActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::FileActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FileActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::FileActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FileOpenPickerActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::FileOpenPickerActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FileOpenPickerContinuationEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::FileOpenPickerContinuationEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FileSavePickerActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::FileSavePickerActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FileSavePickerContinuationEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::FileSavePickerContinuationEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_FolderPickerContinuationEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::FolderPickerContinuationEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LaunchActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::LaunchActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LockScreenActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::LockScreenActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LockScreenCallActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::LockScreenCallActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_LockScreenComponentActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::LockScreenComponentActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PhoneCallActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::PhoneCallActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PickerReturnedActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::PickerReturnedActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_Print3DWorkflowActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::Print3DWorkflowActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_PrintTaskSettingsActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::PrintTaskSettingsActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProtocolActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ProtocolActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ProtocolForResultsActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ProtocolForResultsActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_RestrictedLaunchActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::RestrictedLaunchActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::SearchActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SearchActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::SearchActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ShareTargetActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ShareTargetActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::SplashScreen>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_SplashScreen;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::SplashScreen is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_StartupTaskActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::StartupTaskActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::TileActivatedInfo>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_TileActivatedInfo;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::TileActivatedInfo is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ToastNotificationActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ToastNotificationActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_UserDataAccountProviderActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::UserDataAccountProviderActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_VoiceCommandActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::VoiceCommandActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WalletActionActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::WalletActionActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebAccountProviderActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::WebAccountProviderActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_WebAuthenticationBrokerContinuationEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::WebAuthenticationBrokerContinuationEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IActivatedEventArgsWithUser;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IActivatedEventArgsWithUser is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IApplicationViewActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IApplicationViewActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAppointmentsProviderActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAppointmentsProviderAddAppointmentActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderAddAppointmentActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAppointmentsProviderRemoveAppointmentActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderRemoveAppointmentActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAppointmentsProviderReplaceAppointmentActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderReplaceAppointmentActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowAppointmentDetailsActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IAppointmentsProviderShowTimeFrameActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IAppointmentsProviderShowTimeFrameActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBackgroundActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IBackgroundActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IBarcodeScannerPreviewActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IBarcodeScannerPreviewActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICachedFileUpdaterActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ICachedFileUpdaterActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICameraSettingsActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ICameraSettingsActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ICommandLineActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ICommandLineActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IContactActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IContactActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IContactActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IContactCallActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IContactCallActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IContactMapActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IContactMapActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IContactMessageActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IContactMessageActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IContactPanelActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IContactPanelActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IContactPickerActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IContactPickerActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IContactPostActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IContactPostActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IContactVideoCallActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IContactVideoCallActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IContactsProviderActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IContactsProviderActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IContinuationActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IContinuationActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IDeviceActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IDeviceActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IDevicePairingActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IDevicePairingActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IDialReceiverActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IDialReceiverActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IFileActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IFileActivatedEventArgsWithCallerPackageFamilyName;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithCallerPackageFamilyName is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IFileActivatedEventArgsWithNeighboringFiles;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IFileActivatedEventArgsWithNeighboringFiles is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IFileOpenPickerActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IFileOpenPickerActivatedEventArgs2;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IFileOpenPickerActivatedEventArgs2 is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IFileOpenPickerContinuationEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IFileOpenPickerContinuationEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IFileSavePickerActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IFileSavePickerActivatedEventArgs2;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IFileSavePickerActivatedEventArgs2 is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IFileSavePickerContinuationEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IFileSavePickerContinuationEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IFolderPickerContinuationEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IFolderPickerContinuationEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ILaunchActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ILaunchActivatedEventArgs2;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ILaunchActivatedEventArgs2 is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ILockScreenActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ILockScreenActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ILockScreenCallActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ILockScreenCallActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IPhoneCallActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IPhoneCallActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IPickerReturnedActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IPickerReturnedActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IPrelaunchActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IPrelaunchActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IPrint3DWorkflowActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IPrint3DWorkflowActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IPrintTaskSettingsActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IPrintTaskSettingsActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IProtocolActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IProtocolActivatedEventArgsWithCallerPackageFamilyNameAndData is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IProtocolForResultsActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IProtocolForResultsActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IRestrictedLaunchActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IRestrictedLaunchActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ISearchActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_ISearchActivatedEventArgsWithLinguisticDetails;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::ISearchActivatedEventArgsWithLinguisticDetails is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IShareTargetActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IShareTargetActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IStartupTaskActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IStartupTaskActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IToastNotificationActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IToastNotificationActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IUserDataAccountProviderActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IUserDataAccountProviderActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IViewSwitcherProvider>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IViewSwitcherProvider;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IViewSwitcherProvider is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IVoiceCommandActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IVoiceCommandActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IWalletActionActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IWalletActionActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IWebAccountProviderActivatedEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IWebAccountProviderActivatedEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}

PyTypeObject* py::winrt_type<winrt::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs>::get_python_type() noexcept {
    using namespace py::cpp::Windows::ApplicationModel::Activation;

    PyObject* module = PyState_FindModule(&module_def);

    if (!module) {
        PyErr_SetString(PyExc_RuntimeError, "could not find module for Windows::ApplicationModel::Activation");
        return nullptr;
    }

    auto state = reinterpret_cast<module_state*>(PyModule_GetState(module));
    assert(state);

    auto python_type = state->type_IWebAuthenticationBrokerContinuationEventArgs;

    if (!python_type) {
        PyErr_SetString(PyExc_RuntimeError, "type winrt::Windows::ApplicationModel::Activation::IWebAuthenticationBrokerContinuationEventArgs is not registered");
        return nullptr;
    }

    return python_type;
}
