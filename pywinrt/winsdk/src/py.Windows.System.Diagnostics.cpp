// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.System.Diagnostics.h"

PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::DiagnosticActionResult>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::DiagnosticInvoker>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessCpuUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiskUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemCpuUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemMemoryUsage>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>::python_type;

namespace py::cpp::Windows::System::Diagnostics
{
    // ----- DiagnosticActionResult class --------------------
    constexpr const char* const _type_name_DiagnosticActionResult = "DiagnosticActionResult";

    static PyObject* _new_DiagnosticActionResult(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DiagnosticActionResult);
        return nullptr;
    }

    static void _dealloc_DiagnosticActionResult(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DiagnosticActionResult_get_ExtendedError(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExtendedError());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* DiagnosticActionResult_get_Results(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Results());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DiagnosticActionResult(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::DiagnosticActionResult>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DiagnosticActionResult[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_DiagnosticActionResult), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DiagnosticActionResult[] = {
        { "extended_error", reinterpret_cast<getter>(DiagnosticActionResult_get_ExtendedError), nullptr, nullptr, nullptr },
        { "results", reinterpret_cast<getter>(DiagnosticActionResult_get_Results), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_DiagnosticActionResult[] = 
    {
        { Py_tp_new, _new_DiagnosticActionResult },
        { Py_tp_dealloc, _dealloc_DiagnosticActionResult },
        { Py_tp_methods, _methods_DiagnosticActionResult },
        { Py_tp_getset, _getset_DiagnosticActionResult },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DiagnosticActionResult =
    {
        "_winsdk_Windows_System_Diagnostics.DiagnosticActionResult",
        sizeof(py::wrapper::Windows::System::Diagnostics::DiagnosticActionResult),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DiagnosticActionResult
    };

    // ----- DiagnosticInvoker class --------------------
    constexpr const char* const _type_name_DiagnosticInvoker = "DiagnosticInvoker";

    static PyObject* _new_DiagnosticInvoker(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_DiagnosticInvoker);
        return nullptr;
    }

    static void _dealloc_DiagnosticInvoker(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* DiagnosticInvoker_GetDefault(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::DiagnosticInvoker::GetDefault());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_GetForUser(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::User>(args, 0);

                return py::convert(winrt::Windows::System::Diagnostics::DiagnosticInvoker::GetForUser(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_RunDiagnosticActionAsync(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Data::Json::JsonObject>(args, 0);

                return py::convert(self->obj.RunDiagnosticActionAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_RunDiagnosticActionFromStringAsync(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::hstring>(args, 0);

                return py::convert(self->obj.RunDiagnosticActionFromStringAsync(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* DiagnosticInvoker_get_IsSupported(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::Diagnostics::DiagnosticInvoker::IsSupported());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_DiagnosticInvoker(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::DiagnosticInvoker>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_DiagnosticInvoker[] = {
        { "get_default", reinterpret_cast<PyCFunction>(DiagnosticInvoker_GetDefault), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_user", reinterpret_cast<PyCFunction>(DiagnosticInvoker_GetForUser), METH_VARARGS | METH_STATIC, nullptr },
        { "run_diagnostic_action_async", reinterpret_cast<PyCFunction>(DiagnosticInvoker_RunDiagnosticActionAsync), METH_VARARGS, nullptr },
        { "run_diagnostic_action_from_string_async", reinterpret_cast<PyCFunction>(DiagnosticInvoker_RunDiagnosticActionFromStringAsync), METH_VARARGS, nullptr },
        { "get_is_supported", reinterpret_cast<PyCFunction>(DiagnosticInvoker_get_IsSupported), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_DiagnosticInvoker), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_DiagnosticInvoker[] = {
        { }
    };

    static PyType_Slot _type_slots_DiagnosticInvoker[] = 
    {
        { Py_tp_new, _new_DiagnosticInvoker },
        { Py_tp_dealloc, _dealloc_DiagnosticInvoker },
        { Py_tp_methods, _methods_DiagnosticInvoker },
        { Py_tp_getset, _getset_DiagnosticInvoker },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_DiagnosticInvoker =
    {
        "_winsdk_Windows_System_Diagnostics.DiagnosticInvoker",
        sizeof(py::wrapper::Windows::System::Diagnostics::DiagnosticInvoker),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_DiagnosticInvoker
    };

    // ----- ProcessCpuUsage class --------------------
    constexpr const char* const _type_name_ProcessCpuUsage = "ProcessCpuUsage";

    static PyObject* _new_ProcessCpuUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessCpuUsage);
        return nullptr;
    }

    static void _dealloc_ProcessCpuUsage(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessCpuUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ProcessCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessCpuUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessCpuUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(ProcessCpuUsage_GetReport), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessCpuUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessCpuUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_ProcessCpuUsage[] = 
    {
        { Py_tp_new, _new_ProcessCpuUsage },
        { Py_tp_dealloc, _dealloc_ProcessCpuUsage },
        { Py_tp_methods, _methods_ProcessCpuUsage },
        { Py_tp_getset, _getset_ProcessCpuUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessCpuUsage =
    {
        "_winsdk_Windows_System_Diagnostics.ProcessCpuUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessCpuUsage
    };

    // ----- ProcessCpuUsageReport class --------------------
    constexpr const char* const _type_name_ProcessCpuUsageReport = "ProcessCpuUsageReport";

    static PyObject* _new_ProcessCpuUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessCpuUsageReport);
        return nullptr;
    }

    static void _dealloc_ProcessCpuUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessCpuUsageReport_get_KernelTime(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KernelTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessCpuUsageReport_get_UserTime(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProcessCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessCpuUsageReport[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessCpuUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessCpuUsageReport[] = {
        { "kernel_time", reinterpret_cast<getter>(ProcessCpuUsageReport_get_KernelTime), nullptr, nullptr, nullptr },
        { "user_time", reinterpret_cast<getter>(ProcessCpuUsageReport_get_UserTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessCpuUsageReport[] = 
    {
        { Py_tp_new, _new_ProcessCpuUsageReport },
        { Py_tp_dealloc, _dealloc_ProcessCpuUsageReport },
        { Py_tp_methods, _methods_ProcessCpuUsageReport },
        { Py_tp_getset, _getset_ProcessCpuUsageReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessCpuUsageReport =
    {
        "_winsdk_Windows_System_Diagnostics.ProcessCpuUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessCpuUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessCpuUsageReport
    };

    // ----- ProcessDiagnosticInfo class --------------------
    constexpr const char* const _type_name_ProcessDiagnosticInfo = "ProcessDiagnosticInfo";

    static PyObject* _new_ProcessDiagnosticInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessDiagnosticInfo);
        return nullptr;
    }

    static void _dealloc_ProcessDiagnosticInfo(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessDiagnosticInfo_GetAppDiagnosticInfos(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetAppDiagnosticInfos());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_GetForCurrentProcess(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::GetForCurrentProcess());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_GetForProcesses(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::GetForProcesses());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_TryGetForProcessId(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<uint32_t>(args, 0);

                return py::convert(winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo::TryGetForProcessId(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_CpuUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CpuUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_DiskUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DiskUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ExecutableFileName(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ExecutableFileName());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_MemoryUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MemoryUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_Parent(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Parent());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ProcessId(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProcessId());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_ProcessStartTime(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ProcessStartTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiagnosticInfo_get_IsPackaged(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IsPackaged());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProcessDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiagnosticInfo[] = {
        { "get_app_diagnostic_infos", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_GetAppDiagnosticInfos), METH_VARARGS, nullptr },
        { "get_for_current_process", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_GetForCurrentProcess), METH_VARARGS | METH_STATIC, nullptr },
        { "get_for_processes", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_GetForProcesses), METH_VARARGS | METH_STATIC, nullptr },
        { "try_get_for_process_id", reinterpret_cast<PyCFunction>(ProcessDiagnosticInfo_TryGetForProcessId), METH_VARARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessDiagnosticInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessDiagnosticInfo[] = {
        { "cpu_usage", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_CpuUsage), nullptr, nullptr, nullptr },
        { "disk_usage", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_DiskUsage), nullptr, nullptr, nullptr },
        { "executable_file_name", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_ExecutableFileName), nullptr, nullptr, nullptr },
        { "memory_usage", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_MemoryUsage), nullptr, nullptr, nullptr },
        { "parent", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_Parent), nullptr, nullptr, nullptr },
        { "process_id", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_ProcessId), nullptr, nullptr, nullptr },
        { "process_start_time", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_ProcessStartTime), nullptr, nullptr, nullptr },
        { "is_packaged", reinterpret_cast<getter>(ProcessDiagnosticInfo_get_IsPackaged), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessDiagnosticInfo[] = 
    {
        { Py_tp_new, _new_ProcessDiagnosticInfo },
        { Py_tp_dealloc, _dealloc_ProcessDiagnosticInfo },
        { Py_tp_methods, _methods_ProcessDiagnosticInfo },
        { Py_tp_getset, _getset_ProcessDiagnosticInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessDiagnosticInfo =
    {
        "_winsdk_Windows_System_Diagnostics.ProcessDiagnosticInfo",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiagnosticInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiagnosticInfo
    };

    // ----- ProcessDiskUsage class --------------------
    constexpr const char* const _type_name_ProcessDiskUsage = "ProcessDiskUsage";

    static PyObject* _new_ProcessDiskUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessDiskUsage);
        return nullptr;
    }

    static void _dealloc_ProcessDiskUsage(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessDiskUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ProcessDiskUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiskUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiskUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(ProcessDiskUsage_GetReport), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessDiskUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessDiskUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_ProcessDiskUsage[] = 
    {
        { Py_tp_new, _new_ProcessDiskUsage },
        { Py_tp_dealloc, _dealloc_ProcessDiskUsage },
        { Py_tp_methods, _methods_ProcessDiskUsage },
        { Py_tp_getset, _getset_ProcessDiskUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessDiskUsage =
    {
        "_winsdk_Windows_System_Diagnostics.ProcessDiskUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiskUsage
    };

    // ----- ProcessDiskUsageReport class --------------------
    constexpr const char* const _type_name_ProcessDiskUsageReport = "ProcessDiskUsageReport";

    static PyObject* _new_ProcessDiskUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessDiskUsageReport);
        return nullptr;
    }

    static void _dealloc_ProcessDiskUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessDiskUsageReport_get_BytesReadCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesReadCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_BytesWrittenCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.BytesWrittenCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_OtherBytesCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OtherBytesCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_OtherOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.OtherOperationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_ReadOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ReadOperationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessDiskUsageReport_get_WriteOperationCount(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WriteOperationCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProcessDiskUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessDiskUsageReport[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessDiskUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessDiskUsageReport[] = {
        { "bytes_read_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_BytesReadCount), nullptr, nullptr, nullptr },
        { "bytes_written_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_BytesWrittenCount), nullptr, nullptr, nullptr },
        { "other_bytes_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_OtherBytesCount), nullptr, nullptr, nullptr },
        { "other_operation_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_OtherOperationCount), nullptr, nullptr, nullptr },
        { "read_operation_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_ReadOperationCount), nullptr, nullptr, nullptr },
        { "write_operation_count", reinterpret_cast<getter>(ProcessDiskUsageReport_get_WriteOperationCount), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessDiskUsageReport[] = 
    {
        { Py_tp_new, _new_ProcessDiskUsageReport },
        { Py_tp_dealloc, _dealloc_ProcessDiskUsageReport },
        { Py_tp_methods, _methods_ProcessDiskUsageReport },
        { Py_tp_getset, _getset_ProcessDiskUsageReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessDiskUsageReport =
    {
        "_winsdk_Windows_System_Diagnostics.ProcessDiskUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessDiskUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessDiskUsageReport
    };

    // ----- ProcessMemoryUsage class --------------------
    constexpr const char* const _type_name_ProcessMemoryUsage = "ProcessMemoryUsage";

    static PyObject* _new_ProcessMemoryUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessMemoryUsage);
        return nullptr;
    }

    static void _dealloc_ProcessMemoryUsage(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessMemoryUsage_GetReport(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_ProcessMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessMemoryUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(ProcessMemoryUsage_GetReport), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessMemoryUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessMemoryUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_ProcessMemoryUsage[] = 
    {
        { Py_tp_new, _new_ProcessMemoryUsage },
        { Py_tp_dealloc, _dealloc_ProcessMemoryUsage },
        { Py_tp_methods, _methods_ProcessMemoryUsage },
        { Py_tp_getset, _getset_ProcessMemoryUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessMemoryUsage =
    {
        "_winsdk_Windows_System_Diagnostics.ProcessMemoryUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessMemoryUsage
    };

    // ----- ProcessMemoryUsageReport class --------------------
    constexpr const char* const _type_name_ProcessMemoryUsageReport = "ProcessMemoryUsageReport";

    static PyObject* _new_ProcessMemoryUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_ProcessMemoryUsageReport);
        return nullptr;
    }

    static void _dealloc_ProcessMemoryUsageReport(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* ProcessMemoryUsageReport_get_NonPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.NonPagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PageFaultCount(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PageFaultCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PageFileSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PageFileSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakNonPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PeakNonPagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakPageFileSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PeakPageFileSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakPagedPoolSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PeakPagedPoolSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakVirtualMemorySizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PeakVirtualMemorySizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PeakWorkingSetSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PeakWorkingSetSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_PrivatePageCount(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PrivatePageCount());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_VirtualMemorySizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VirtualMemorySizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* ProcessMemoryUsageReport_get_WorkingSetSizeInBytes(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.WorkingSetSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_ProcessMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_ProcessMemoryUsageReport[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_ProcessMemoryUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_ProcessMemoryUsageReport[] = {
        { "non_paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_NonPagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "page_fault_count", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PageFaultCount), nullptr, nullptr, nullptr },
        { "page_file_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PageFileSizeInBytes), nullptr, nullptr, nullptr },
        { "paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_non_paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakNonPagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_page_file_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakPageFileSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_paged_pool_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakPagedPoolSizeInBytes), nullptr, nullptr, nullptr },
        { "peak_virtual_memory_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakVirtualMemorySizeInBytes), nullptr, nullptr, nullptr },
        { "peak_working_set_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PeakWorkingSetSizeInBytes), nullptr, nullptr, nullptr },
        { "private_page_count", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_PrivatePageCount), nullptr, nullptr, nullptr },
        { "virtual_memory_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_VirtualMemorySizeInBytes), nullptr, nullptr, nullptr },
        { "working_set_size_in_bytes", reinterpret_cast<getter>(ProcessMemoryUsageReport_get_WorkingSetSizeInBytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_ProcessMemoryUsageReport[] = 
    {
        { Py_tp_new, _new_ProcessMemoryUsageReport },
        { Py_tp_dealloc, _dealloc_ProcessMemoryUsageReport },
        { Py_tp_methods, _methods_ProcessMemoryUsageReport },
        { Py_tp_getset, _getset_ProcessMemoryUsageReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_ProcessMemoryUsageReport =
    {
        "_winsdk_Windows_System_Diagnostics.ProcessMemoryUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::ProcessMemoryUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_ProcessMemoryUsageReport
    };

    // ----- SystemCpuUsage class --------------------
    constexpr const char* const _type_name_SystemCpuUsage = "SystemCpuUsage";

    static PyObject* _new_SystemCpuUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemCpuUsage);
        return nullptr;
    }

    static void _dealloc_SystemCpuUsage(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemCpuUsage_GetReport(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_SystemCpuUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemCpuUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemCpuUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(SystemCpuUsage_GetReport), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemCpuUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemCpuUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_SystemCpuUsage[] = 
    {
        { Py_tp_new, _new_SystemCpuUsage },
        { Py_tp_dealloc, _dealloc_SystemCpuUsage },
        { Py_tp_methods, _methods_SystemCpuUsage },
        { Py_tp_getset, _getset_SystemCpuUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemCpuUsage =
    {
        "_winsdk_Windows_System_Diagnostics.SystemCpuUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemCpuUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemCpuUsage
    };

    // ----- SystemCpuUsageReport class --------------------
    constexpr const char* const _type_name_SystemCpuUsageReport = "SystemCpuUsageReport";

    static PyObject* _new_SystemCpuUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemCpuUsageReport);
        return nullptr;
    }

    static void _dealloc_SystemCpuUsageReport(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemCpuUsageReport_get_IdleTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.IdleTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemCpuUsageReport_get_KernelTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KernelTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemCpuUsageReport_get_UserTime(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.UserTime());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemCpuUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemCpuUsageReport[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemCpuUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemCpuUsageReport[] = {
        { "idle_time", reinterpret_cast<getter>(SystemCpuUsageReport_get_IdleTime), nullptr, nullptr, nullptr },
        { "kernel_time", reinterpret_cast<getter>(SystemCpuUsageReport_get_KernelTime), nullptr, nullptr, nullptr },
        { "user_time", reinterpret_cast<getter>(SystemCpuUsageReport_get_UserTime), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemCpuUsageReport[] = 
    {
        { Py_tp_new, _new_SystemCpuUsageReport },
        { Py_tp_dealloc, _dealloc_SystemCpuUsageReport },
        { Py_tp_methods, _methods_SystemCpuUsageReport },
        { Py_tp_getset, _getset_SystemCpuUsageReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemCpuUsageReport =
    {
        "_winsdk_Windows_System_Diagnostics.SystemCpuUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemCpuUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemCpuUsageReport
    };

    // ----- SystemDiagnosticInfo class --------------------
    constexpr const char* const _type_name_SystemDiagnosticInfo = "SystemDiagnosticInfo";

    static PyObject* _new_SystemDiagnosticInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemDiagnosticInfo);
        return nullptr;
    }

    static void _dealloc_SystemDiagnosticInfo(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemDiagnosticInfo_GetForCurrentSystem(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::GetForCurrentSystem());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_IsArchitectureSupported(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::System::ProcessorArchitecture>(args, 0);

                return py::convert(winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::IsArchitectureSupported(param0));
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_CpuUsage(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CpuUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_MemoryUsage(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MemoryUsage());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemDiagnosticInfo_get_PreferredArchitecture(PyObject* /*unused*/, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(winrt::Windows::System::Diagnostics::SystemDiagnosticInfo::PreferredArchitecture());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemDiagnosticInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemDiagnosticInfo[] = {
        { "get_for_current_system", reinterpret_cast<PyCFunction>(SystemDiagnosticInfo_GetForCurrentSystem), METH_VARARGS | METH_STATIC, nullptr },
        { "is_architecture_supported", reinterpret_cast<PyCFunction>(SystemDiagnosticInfo_IsArchitectureSupported), METH_VARARGS | METH_STATIC, nullptr },
        { "get_preferred_architecture", reinterpret_cast<PyCFunction>(SystemDiagnosticInfo_get_PreferredArchitecture), METH_NOARGS | METH_STATIC, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemDiagnosticInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemDiagnosticInfo[] = {
        { "cpu_usage", reinterpret_cast<getter>(SystemDiagnosticInfo_get_CpuUsage), nullptr, nullptr, nullptr },
        { "memory_usage", reinterpret_cast<getter>(SystemDiagnosticInfo_get_MemoryUsage), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemDiagnosticInfo[] = 
    {
        { Py_tp_new, _new_SystemDiagnosticInfo },
        { Py_tp_dealloc, _dealloc_SystemDiagnosticInfo },
        { Py_tp_methods, _methods_SystemDiagnosticInfo },
        { Py_tp_getset, _getset_SystemDiagnosticInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemDiagnosticInfo =
    {
        "_winsdk_Windows_System_Diagnostics.SystemDiagnosticInfo",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemDiagnosticInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemDiagnosticInfo
    };

    // ----- SystemMemoryUsage class --------------------
    constexpr const char* const _type_name_SystemMemoryUsage = "SystemMemoryUsage";

    static PyObject* _new_SystemMemoryUsage(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemMemoryUsage);
        return nullptr;
    }

    static void _dealloc_SystemMemoryUsage(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemMemoryUsage_GetReport(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(self->obj.GetReport());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_SystemMemoryUsage(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemMemoryUsage>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMemoryUsage[] = {
        { "get_report", reinterpret_cast<PyCFunction>(SystemMemoryUsage_GetReport), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMemoryUsage), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMemoryUsage[] = {
        { }
    };

    static PyType_Slot _type_slots_SystemMemoryUsage[] = 
    {
        { Py_tp_new, _new_SystemMemoryUsage },
        { Py_tp_dealloc, _dealloc_SystemMemoryUsage },
        { Py_tp_methods, _methods_SystemMemoryUsage },
        { Py_tp_getset, _getset_SystemMemoryUsage },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemMemoryUsage =
    {
        "_winsdk_Windows_System_Diagnostics.SystemMemoryUsage",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsage),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMemoryUsage
    };

    // ----- SystemMemoryUsageReport class --------------------
    constexpr const char* const _type_name_SystemMemoryUsageReport = "SystemMemoryUsageReport";

    static PyObject* _new_SystemMemoryUsageReport(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_SystemMemoryUsageReport);
        return nullptr;
    }

    static void _dealloc_SystemMemoryUsageReport(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* SystemMemoryUsageReport_get_AvailableSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.AvailableSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMemoryUsageReport_get_CommittedSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.CommittedSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* SystemMemoryUsageReport_get_TotalPhysicalSizeInBytes(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TotalPhysicalSizeInBytes());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyObject* _from_SystemMemoryUsageReport(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_SystemMemoryUsageReport[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_SystemMemoryUsageReport), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_SystemMemoryUsageReport[] = {
        { "available_size_in_bytes", reinterpret_cast<getter>(SystemMemoryUsageReport_get_AvailableSizeInBytes), nullptr, nullptr, nullptr },
        { "committed_size_in_bytes", reinterpret_cast<getter>(SystemMemoryUsageReport_get_CommittedSizeInBytes), nullptr, nullptr, nullptr },
        { "total_physical_size_in_bytes", reinterpret_cast<getter>(SystemMemoryUsageReport_get_TotalPhysicalSizeInBytes), nullptr, nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_SystemMemoryUsageReport[] = 
    {
        { Py_tp_new, _new_SystemMemoryUsageReport },
        { Py_tp_dealloc, _dealloc_SystemMemoryUsageReport },
        { Py_tp_methods, _methods_SystemMemoryUsageReport },
        { Py_tp_getset, _getset_SystemMemoryUsageReport },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_SystemMemoryUsageReport =
    {
        "_winsdk_Windows_System_Diagnostics.SystemMemoryUsageReport",
        sizeof(py::wrapper::Windows::System::Diagnostics::SystemMemoryUsageReport),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_SystemMemoryUsageReport
    };

    // ----- Windows.System.Diagnostics Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::System::Diagnostics::DiagnosticActionResult>::python_type = py::register_python_type(module, _type_name_DiagnosticActionResult, &_type_spec_DiagnosticActionResult, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::DiagnosticInvoker>::python_type = py::register_python_type(module, _type_name_DiagnosticInvoker, &_type_spec_DiagnosticInvoker, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::ProcessCpuUsage>::python_type = py::register_python_type(module, _type_name_ProcessCpuUsage, &_type_spec_ProcessCpuUsage, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::ProcessCpuUsageReport>::python_type = py::register_python_type(module, _type_name_ProcessCpuUsageReport, &_type_spec_ProcessCpuUsageReport, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiagnosticInfo>::python_type = py::register_python_type(module, _type_name_ProcessDiagnosticInfo, &_type_spec_ProcessDiagnosticInfo, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiskUsage>::python_type = py::register_python_type(module, _type_name_ProcessDiskUsage, &_type_spec_ProcessDiskUsage, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::ProcessDiskUsageReport>::python_type = py::register_python_type(module, _type_name_ProcessDiskUsageReport, &_type_spec_ProcessDiskUsageReport, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsage>::python_type = py::register_python_type(module, _type_name_ProcessMemoryUsage, &_type_spec_ProcessMemoryUsage, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::ProcessMemoryUsageReport>::python_type = py::register_python_type(module, _type_name_ProcessMemoryUsageReport, &_type_spec_ProcessMemoryUsageReport, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::SystemCpuUsage>::python_type = py::register_python_type(module, _type_name_SystemCpuUsage, &_type_spec_SystemCpuUsage, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::SystemCpuUsageReport>::python_type = py::register_python_type(module, _type_name_SystemCpuUsageReport, &_type_spec_SystemCpuUsageReport, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::SystemDiagnosticInfo>::python_type = py::register_python_type(module, _type_name_SystemDiagnosticInfo, &_type_spec_SystemDiagnosticInfo, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::SystemMemoryUsage>::python_type = py::register_python_type(module, _type_name_SystemMemoryUsage, &_type_spec_SystemMemoryUsage, bases.get());
            py::winrt_type<winrt::Windows::System::Diagnostics::SystemMemoryUsageReport>::python_type = py::register_python_type(module, _type_name_SystemMemoryUsageReport, &_type_spec_SystemMemoryUsageReport, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.System.Diagnostics");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_System_Diagnostics",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::System::Diagnostics

PyMODINIT_FUNC
PyInit__winsdk_Windows_System_Diagnostics (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::System::Diagnostics::module_def);
}
