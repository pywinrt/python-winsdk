// WARNING: Please don't edit this file. It was generated by Python/WinRT v1.0.0-beta.1

#include "pybase.h"
#include "py.Windows.UI.Input.Preview.Injection.h"

PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InputInjector>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>::python_type;
PyTypeObject* py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>::python_type;

PyObject* py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>::convert(winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>());
}
winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint return_value{};

    PyObject* py_PositionX = PyDict_GetItemString(obj, "position_x");
    if (!py_PositionX) { throw winrt::hresult_invalid_argument(); }
    return_value.PositionX = converter<int32_t>::convert_to(py_PositionX);

    PyObject* py_PositionY = PyDict_GetItemString(obj, "position_y");
    if (!py_PositionY) { throw winrt::hresult_invalid_argument(); }
    return_value.PositionY = converter<int32_t>::convert_to(py_PositionY);

    return return_value;
}

PyObject* py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>::convert(winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>());
}
winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo return_value{};

    PyObject* py_PointerId = PyDict_GetItemString(obj, "pointer_id");
    if (!py_PointerId) { throw winrt::hresult_invalid_argument(); }
    return_value.PointerId = converter<uint32_t>::convert_to(py_PointerId);

    PyObject* py_PointerOptions = PyDict_GetItemString(obj, "pointer_options");
    if (!py_PointerOptions) { throw winrt::hresult_invalid_argument(); }
    return_value.PointerOptions = converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerOptions>::convert_to(py_PointerOptions);

    PyObject* py_PixelLocation = PyDict_GetItemString(obj, "pixel_location");
    if (!py_PixelLocation) { throw winrt::hresult_invalid_argument(); }
    return_value.PixelLocation = converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>::convert_to(py_PixelLocation);

    PyObject* py_TimeOffsetInMilliseconds = PyDict_GetItemString(obj, "time_offset_in_milliseconds");
    if (!py_TimeOffsetInMilliseconds) { throw winrt::hresult_invalid_argument(); }
    return_value.TimeOffsetInMilliseconds = converter<uint32_t>::convert_to(py_TimeOffsetInMilliseconds);

    PyObject* py_PerformanceCount = PyDict_GetItemString(obj, "performance_count");
    if (!py_PerformanceCount) { throw winrt::hresult_invalid_argument(); }
    return_value.PerformanceCount = converter<uint64_t>::convert_to(py_PerformanceCount);

    return return_value;
}

PyObject* py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>::convert(winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle instance) noexcept
{
    return py::wrap_struct(instance, py::get_python_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>());
}
winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>::convert_to(PyObject* obj)
{
    throw_if_pyobj_null(obj);

    if (Py_TYPE(obj) == py::get_python_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>())
    {
        return reinterpret_cast<py::winrt_struct_wrapper<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>*>(obj)->obj;
    }

    if (!PyDict_Check(obj))
    {
        throw winrt::hresult_invalid_argument();
    }

    winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle return_value{};

    PyObject* py_Left = PyDict_GetItemString(obj, "left");
    if (!py_Left) { throw winrt::hresult_invalid_argument(); }
    return_value.Left = converter<int32_t>::convert_to(py_Left);

    PyObject* py_Top = PyDict_GetItemString(obj, "top");
    if (!py_Top) { throw winrt::hresult_invalid_argument(); }
    return_value.Top = converter<int32_t>::convert_to(py_Top);

    PyObject* py_Bottom = PyDict_GetItemString(obj, "bottom");
    if (!py_Bottom) { throw winrt::hresult_invalid_argument(); }
    return_value.Bottom = converter<int32_t>::convert_to(py_Bottom);

    PyObject* py_Right = PyDict_GetItemString(obj, "right");
    if (!py_Right) { throw winrt::hresult_invalid_argument(); }
    return_value.Right = converter<int32_t>::convert_to(py_Right);

    return return_value;
}

namespace py::cpp::Windows::UI::Input::Preview::Injection
{
    // ----- InjectedInputGamepadInfo class --------------------
    constexpr const char* const _type_name_InjectedInputGamepadInfo = "InjectedInputGamepadInfo";

    static PyObject* _new_InjectedInputGamepadInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Gaming::Input::GamepadReading>(args, 0);

                winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo instance{ param0 };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputGamepadInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InjectedInputGamepadInfo_get_RightTrigger(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_RightTrigger(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RightTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_RightThumbstickY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightThumbstickY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_RightThumbstickY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RightThumbstickY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_RightThumbstickX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.RightThumbstickX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_RightThumbstickX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.RightThumbstickX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_LeftTrigger(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftTrigger());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_LeftTrigger(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.LeftTrigger(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_LeftThumbstickY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftThumbstickY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_LeftThumbstickY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.LeftThumbstickY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_LeftThumbstickX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.LeftThumbstickX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_LeftThumbstickX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.LeftThumbstickX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputGamepadInfo_get_Buttons(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Buttons());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputGamepadInfo_put_Buttons(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::Gaming::Input::GamepadButtons>(arg);

            self->obj.Buttons(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_InjectedInputGamepadInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputGamepadInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputGamepadInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputGamepadInfo[] = {
        { "right_trigger", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_RightTrigger), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_RightTrigger), nullptr, nullptr },
        { "right_thumbstick_y", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_RightThumbstickY), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_RightThumbstickY), nullptr, nullptr },
        { "right_thumbstick_x", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_RightThumbstickX), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_RightThumbstickX), nullptr, nullptr },
        { "left_trigger", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_LeftTrigger), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_LeftTrigger), nullptr, nullptr },
        { "left_thumbstick_y", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_LeftThumbstickY), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_LeftThumbstickY), nullptr, nullptr },
        { "left_thumbstick_x", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_LeftThumbstickX), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_LeftThumbstickX), nullptr, nullptr },
        { "buttons", reinterpret_cast<getter>(InjectedInputGamepadInfo_get_Buttons), reinterpret_cast<setter>(InjectedInputGamepadInfo_put_Buttons), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputGamepadInfo[] = 
    {
        { Py_tp_new, _new_InjectedInputGamepadInfo },
        { Py_tp_dealloc, _dealloc_InjectedInputGamepadInfo },
        { Py_tp_methods, _methods_InjectedInputGamepadInfo },
        { Py_tp_getset, _getset_InjectedInputGamepadInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InjectedInputGamepadInfo =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputGamepadInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputGamepadInfo
    };

    // ----- InjectedInputKeyboardInfo class --------------------
    constexpr const char* const _type_name_InjectedInputKeyboardInfo = "InjectedInputKeyboardInfo";

    static PyObject* _new_InjectedInputKeyboardInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputKeyboardInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InjectedInputKeyboardInfo_get_VirtualKey(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.VirtualKey());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputKeyboardInfo_put_VirtualKey(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint16_t>(arg);

            self->obj.VirtualKey(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputKeyboardInfo_get_ScanCode(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.ScanCode());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputKeyboardInfo_put_ScanCode(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint16_t>(arg);

            self->obj.ScanCode(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputKeyboardInfo_get_KeyOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.KeyOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputKeyboardInfo_put_KeyOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyOptions>(arg);

            self->obj.KeyOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_InjectedInputKeyboardInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputKeyboardInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputKeyboardInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputKeyboardInfo[] = {
        { "virtual_key", reinterpret_cast<getter>(InjectedInputKeyboardInfo_get_VirtualKey), reinterpret_cast<setter>(InjectedInputKeyboardInfo_put_VirtualKey), nullptr, nullptr },
        { "scan_code", reinterpret_cast<getter>(InjectedInputKeyboardInfo_get_ScanCode), reinterpret_cast<setter>(InjectedInputKeyboardInfo_put_ScanCode), nullptr, nullptr },
        { "key_options", reinterpret_cast<getter>(InjectedInputKeyboardInfo_get_KeyOptions), reinterpret_cast<setter>(InjectedInputKeyboardInfo_put_KeyOptions), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputKeyboardInfo[] = 
    {
        { Py_tp_new, _new_InjectedInputKeyboardInfo },
        { Py_tp_dealloc, _dealloc_InjectedInputKeyboardInfo },
        { Py_tp_methods, _methods_InjectedInputKeyboardInfo },
        { Py_tp_getset, _getset_InjectedInputKeyboardInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InjectedInputKeyboardInfo =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputKeyboardInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputKeyboardInfo
    };

    // ----- InjectedInputMouseInfo class --------------------
    constexpr const char* const _type_name_InjectedInputMouseInfo = "InjectedInputMouseInfo";

    static PyObject* _new_InjectedInputMouseInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputMouseInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InjectedInputMouseInfo_get_TimeOffsetInMilliseconds(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeOffsetInMilliseconds());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_TimeOffsetInMilliseconds(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.TimeOffsetInMilliseconds(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputMouseInfo_get_MouseOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MouseOptions());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_MouseOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseOptions>(arg);

            self->obj.MouseOptions(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputMouseInfo_get_MouseData(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.MouseData());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_MouseData(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<uint32_t>(arg);

            self->obj.MouseData(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputMouseInfo_get_DeltaY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeltaY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_DeltaY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DeltaY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputMouseInfo_get_DeltaX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.DeltaX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputMouseInfo_put_DeltaX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.DeltaX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_InjectedInputMouseInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputMouseInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputMouseInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputMouseInfo[] = {
        { "time_offset_in_milliseconds", reinterpret_cast<getter>(InjectedInputMouseInfo_get_TimeOffsetInMilliseconds), reinterpret_cast<setter>(InjectedInputMouseInfo_put_TimeOffsetInMilliseconds), nullptr, nullptr },
        { "mouse_options", reinterpret_cast<getter>(InjectedInputMouseInfo_get_MouseOptions), reinterpret_cast<setter>(InjectedInputMouseInfo_put_MouseOptions), nullptr, nullptr },
        { "mouse_data", reinterpret_cast<getter>(InjectedInputMouseInfo_get_MouseData), reinterpret_cast<setter>(InjectedInputMouseInfo_put_MouseData), nullptr, nullptr },
        { "delta_y", reinterpret_cast<getter>(InjectedInputMouseInfo_get_DeltaY), reinterpret_cast<setter>(InjectedInputMouseInfo_put_DeltaY), nullptr, nullptr },
        { "delta_x", reinterpret_cast<getter>(InjectedInputMouseInfo_get_DeltaX), reinterpret_cast<setter>(InjectedInputMouseInfo_put_DeltaX), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputMouseInfo[] = 
    {
        { Py_tp_new, _new_InjectedInputMouseInfo },
        { Py_tp_dealloc, _dealloc_InjectedInputMouseInfo },
        { Py_tp_methods, _methods_InjectedInputMouseInfo },
        { Py_tp_getset, _getset_InjectedInputMouseInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InjectedInputMouseInfo =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputMouseInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputMouseInfo
    };

    // ----- InjectedInputPenInfo class --------------------
    constexpr const char* const _type_name_InjectedInputPenInfo = "InjectedInputPenInfo";

    static PyObject* _new_InjectedInputPenInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputPenInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InjectedInputPenInfo_get_TiltY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TiltY());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_TiltY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TiltY(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_TiltX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TiltX());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_TiltX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.TiltX(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_Rotation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Rotation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_Rotation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Rotation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_Pressure(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_Pressure(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Pressure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_PointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_PointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>(arg);

            self->obj.PointerInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_PenParameters(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PenParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_PenParameters(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenParameters>(arg);

            self->obj.PenParameters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPenInfo_get_PenButtons(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PenButtons());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPenInfo_put_PenButtons(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenButtons>(arg);

            self->obj.PenButtons(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_InjectedInputPenInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputPenInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputPenInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputPenInfo[] = {
        { "tilt_y", reinterpret_cast<getter>(InjectedInputPenInfo_get_TiltY), reinterpret_cast<setter>(InjectedInputPenInfo_put_TiltY), nullptr, nullptr },
        { "tilt_x", reinterpret_cast<getter>(InjectedInputPenInfo_get_TiltX), reinterpret_cast<setter>(InjectedInputPenInfo_put_TiltX), nullptr, nullptr },
        { "rotation", reinterpret_cast<getter>(InjectedInputPenInfo_get_Rotation), reinterpret_cast<setter>(InjectedInputPenInfo_put_Rotation), nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(InjectedInputPenInfo_get_Pressure), reinterpret_cast<setter>(InjectedInputPenInfo_put_Pressure), nullptr, nullptr },
        { "pointer_info", reinterpret_cast<getter>(InjectedInputPenInfo_get_PointerInfo), reinterpret_cast<setter>(InjectedInputPenInfo_put_PointerInfo), nullptr, nullptr },
        { "pen_parameters", reinterpret_cast<getter>(InjectedInputPenInfo_get_PenParameters), reinterpret_cast<setter>(InjectedInputPenInfo_put_PenParameters), nullptr, nullptr },
        { "pen_buttons", reinterpret_cast<getter>(InjectedInputPenInfo_get_PenButtons), reinterpret_cast<setter>(InjectedInputPenInfo_put_PenButtons), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputPenInfo[] = 
    {
        { Py_tp_new, _new_InjectedInputPenInfo },
        { Py_tp_dealloc, _dealloc_InjectedInputPenInfo },
        { Py_tp_methods, _methods_InjectedInputPenInfo },
        { Py_tp_getset, _getset_InjectedInputPenInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InjectedInputPenInfo =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputPenInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputPenInfo
    };

    // ----- InjectedInputTouchInfo class --------------------
    constexpr const char* const _type_name_InjectedInputTouchInfo = "InjectedInputTouchInfo";

    static PyObject* _new_InjectedInputTouchInfo(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        if (kwds != nullptr)
        {
            py::set_invalid_kwd_args_error();
            return nullptr;
        }

        Py_ssize_t arg_count = PyTuple_Size(args);
        if (arg_count == 0)
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo instance{  };
                return py::wrap(instance, type);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputTouchInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InjectedInputTouchInfo_get_TouchParameters(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TouchParameters());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_TouchParameters(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchParameters>(arg);

            self->obj.TouchParameters(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputTouchInfo_get_Pressure(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Pressure());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_Pressure(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<double>(arg);

            self->obj.Pressure(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputTouchInfo_get_PointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerInfo());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_PointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>(arg);

            self->obj.PointerInfo(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputTouchInfo_get_Orientation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Orientation());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_Orientation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<int32_t>(arg);

            self->obj.Orientation(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputTouchInfo_get_Contact(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Contact());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputTouchInfo_put_Contact(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>(arg);

            self->obj.Contact(param0);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* _from_InjectedInputTouchInfo(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InjectedInputTouchInfo[] = {
        { "_from", reinterpret_cast<PyCFunction>(_from_InjectedInputTouchInfo), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InjectedInputTouchInfo[] = {
        { "touch_parameters", reinterpret_cast<getter>(InjectedInputTouchInfo_get_TouchParameters), reinterpret_cast<setter>(InjectedInputTouchInfo_put_TouchParameters), nullptr, nullptr },
        { "pressure", reinterpret_cast<getter>(InjectedInputTouchInfo_get_Pressure), reinterpret_cast<setter>(InjectedInputTouchInfo_put_Pressure), nullptr, nullptr },
        { "pointer_info", reinterpret_cast<getter>(InjectedInputTouchInfo_get_PointerInfo), reinterpret_cast<setter>(InjectedInputTouchInfo_put_PointerInfo), nullptr, nullptr },
        { "orientation", reinterpret_cast<getter>(InjectedInputTouchInfo_get_Orientation), reinterpret_cast<setter>(InjectedInputTouchInfo_put_Orientation), nullptr, nullptr },
        { "contact", reinterpret_cast<getter>(InjectedInputTouchInfo_get_Contact), reinterpret_cast<setter>(InjectedInputTouchInfo_put_Contact), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputTouchInfo[] = 
    {
        { Py_tp_new, _new_InjectedInputTouchInfo },
        { Py_tp_dealloc, _dealloc_InjectedInputTouchInfo },
        { Py_tp_methods, _methods_InjectedInputTouchInfo },
        { Py_tp_getset, _getset_InjectedInputTouchInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InjectedInputTouchInfo =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputTouchInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputTouchInfo
    };

    // ----- InputInjector class --------------------
    constexpr const char* const _type_name_InputInjector = "InputInjector";

    static PyObject* _new_InputInjector(PyTypeObject* type, PyObject* args, PyObject* kwds) noexcept
    {
        py::set_invalid_activation_error(_type_name_InputInjector);
        return nullptr;
    }

    static void _dealloc_InputInjector(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self)
    {
        auto hash_value = std::hash<winrt::Windows::Foundation::IInspectable>{}(self->obj);
        py::wrapped_instance(hash_value, nullptr);
        self->obj = nullptr;
    }

    static PyObject* InputInjector_InitializeGamepadInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.InitializeGamepadInjection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InitializePenInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputVisualizationMode>(args, 0);

                self->obj.InitializePenInjection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InitializeTouchInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputVisualizationMode>(args, 0);

                self->obj.InitializeTouchInjection(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectGamepadInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo>(args, 0);

                self->obj.InjectGamepadInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectKeyboardInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo>>(args, 0);

                self->obj.InjectKeyboardInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectMouseInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo>>(args, 0);

                self->obj.InjectMouseInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectPenInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo>(args, 0);

                self->obj.InjectPenInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectShortcut(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputShortcut>(args, 0);

                self->obj.InjectShortcut(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_InjectTouchInput(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 1)
        {
            try
            {
                auto param0 = py::convert_to<winrt::Windows::Foundation::Collections::IIterable<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo>>(args, 0);

                self->obj.InjectTouchInput(param0);
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_TryCreate(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Input::Preview::Injection::InputInjector::TryCreate());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_TryCreateForAppBroadcastOnly(PyObject* /*unused*/, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                return py::convert(winrt::Windows::UI::Input::Preview::Injection::InputInjector::TryCreateForAppBroadcastOnly());
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_UninitializeGamepadInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.UninitializeGamepadInjection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_UninitializePenInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.UninitializePenInjection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* InputInjector_UninitializeTouchInjection(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector* self, PyObject* args) noexcept
    {
        Py_ssize_t arg_count = PyTuple_Size(args);

        if (arg_count == 0)
        {
            try
            {
                self->obj.UninitializeTouchInjection();
                Py_RETURN_NONE;
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }
        else
        {
            py::set_invalid_arg_count_error(arg_count);
            return nullptr;
        }
    }

    static PyObject* _from_InputInjector(PyObject* /*unused*/, PyObject* arg) noexcept
    {
        try
        {
            auto return_value = py::convert_to<winrt::Windows::Foundation::IInspectable>(arg);
            return py::convert(return_value.as<winrt::Windows::UI::Input::Preview::Injection::InputInjector>());
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static PyMethodDef _methods_InputInjector[] = {
        { "initialize_gamepad_injection", reinterpret_cast<PyCFunction>(InputInjector_InitializeGamepadInjection), METH_VARARGS, nullptr },
        { "initialize_pen_injection", reinterpret_cast<PyCFunction>(InputInjector_InitializePenInjection), METH_VARARGS, nullptr },
        { "initialize_touch_injection", reinterpret_cast<PyCFunction>(InputInjector_InitializeTouchInjection), METH_VARARGS, nullptr },
        { "inject_gamepad_input", reinterpret_cast<PyCFunction>(InputInjector_InjectGamepadInput), METH_VARARGS, nullptr },
        { "inject_keyboard_input", reinterpret_cast<PyCFunction>(InputInjector_InjectKeyboardInput), METH_VARARGS, nullptr },
        { "inject_mouse_input", reinterpret_cast<PyCFunction>(InputInjector_InjectMouseInput), METH_VARARGS, nullptr },
        { "inject_pen_input", reinterpret_cast<PyCFunction>(InputInjector_InjectPenInput), METH_VARARGS, nullptr },
        { "inject_shortcut", reinterpret_cast<PyCFunction>(InputInjector_InjectShortcut), METH_VARARGS, nullptr },
        { "inject_touch_input", reinterpret_cast<PyCFunction>(InputInjector_InjectTouchInput), METH_VARARGS, nullptr },
        { "try_create", reinterpret_cast<PyCFunction>(InputInjector_TryCreate), METH_VARARGS | METH_STATIC, nullptr },
        { "try_create_for_app_broadcast_only", reinterpret_cast<PyCFunction>(InputInjector_TryCreateForAppBroadcastOnly), METH_VARARGS | METH_STATIC, nullptr },
        { "uninitialize_gamepad_injection", reinterpret_cast<PyCFunction>(InputInjector_UninitializeGamepadInjection), METH_VARARGS, nullptr },
        { "uninitialize_pen_injection", reinterpret_cast<PyCFunction>(InputInjector_UninitializePenInjection), METH_VARARGS, nullptr },
        { "uninitialize_touch_injection", reinterpret_cast<PyCFunction>(InputInjector_UninitializeTouchInjection), METH_VARARGS, nullptr },
        { "_from", reinterpret_cast<PyCFunction>(_from_InputInjector), METH_O | METH_STATIC, nullptr },
        { }
    };

    static PyGetSetDef _getset_InputInjector[] = {
        { }
    };

    static PyType_Slot _type_slots_InputInjector[] = 
    {
        { Py_tp_new, _new_InputInjector },
        { Py_tp_dealloc, _dealloc_InputInjector },
        { Py_tp_methods, _methods_InputInjector },
        { Py_tp_getset, _getset_InputInjector },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InputInjector =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InputInjector",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InputInjector),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InputInjector
    };

    // ----- InjectedInputPoint struct --------------------
    constexpr const char* const _type_name_InjectedInputPoint = "InjectedInputPoint";

    PyObject* _new_InjectedInputPoint(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _PositionX{};
        int32_t _PositionY{};

        static const char* kwlist[] = {"position_x", "position_y", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "ii", const_cast<char**>(kwlist), &_PositionX, &_PositionY))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint return_value{ _PositionX, _PositionY };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputPoint(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self)
    {
    }

    static PyObject* InjectedInputPoint_get_PositionX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionX);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPoint_set_PositionX(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PositionX = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPoint_get_PositionY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PositionY);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPoint_set_PositionY(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PositionY = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_InjectedInputPoint[] = {
        { "position_x", reinterpret_cast<getter>(InjectedInputPoint_get_PositionX), reinterpret_cast<setter>(InjectedInputPoint_set_PositionX), nullptr, nullptr },
        { "position_y", reinterpret_cast<getter>(InjectedInputPoint_get_PositionY), reinterpret_cast<setter>(InjectedInputPoint_set_PositionY), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputPoint[] = 
    {
        { Py_tp_new, _new_InjectedInputPoint },
        { Py_tp_dealloc, _dealloc_InjectedInputPoint },
        { Py_tp_getset, _getset_InjectedInputPoint },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InjectedInputPoint =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputPoint",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPoint),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputPoint
    };

    // ----- InjectedInputPointerInfo struct --------------------
    constexpr const char* const _type_name_InjectedInputPointerInfo = "InjectedInputPointerInfo";

    PyObject* _new_InjectedInputPointerInfo(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        uint32_t _PointerId{};
        uint32_t _PointerOptions{};
        PyObject* _PixelLocation{};
        uint32_t _TimeOffsetInMilliseconds{};
        uint64_t _PerformanceCount{};

        static const char* kwlist[] = {"pointer_id", "pointer_options", "pixel_location", "time_offset_in_milliseconds", "performance_count", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "IIOIK", const_cast<char**>(kwlist), &_PointerId, &_PointerOptions, &_PixelLocation, &_TimeOffsetInMilliseconds, &_PerformanceCount))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo return_value{ _PointerId, static_cast<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerOptions>(_PointerOptions), py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>::convert_to(_PixelLocation), _TimeOffsetInMilliseconds, _PerformanceCount };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputPointerInfo(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self)
    {
    }

    static PyObject* InjectedInputPointerInfo_get_PointerId(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerId);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_PointerId(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PointerId = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPointerInfo_get_PointerOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PointerOptions);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_PointerOptions(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PointerOptions = py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerOptions>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPointerInfo_get_PixelLocation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PixelLocation);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_PixelLocation(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PixelLocation = py::converter<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPointerInfo_get_TimeOffsetInMilliseconds(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.TimeOffsetInMilliseconds);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_TimeOffsetInMilliseconds(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.TimeOffsetInMilliseconds = py::converter<uint32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputPointerInfo_get_PerformanceCount(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.PerformanceCount);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputPointerInfo_set_PerformanceCount(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.PerformanceCount = py::converter<uint64_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_InjectedInputPointerInfo[] = {
        { "pointer_id", reinterpret_cast<getter>(InjectedInputPointerInfo_get_PointerId), reinterpret_cast<setter>(InjectedInputPointerInfo_set_PointerId), nullptr, nullptr },
        { "pointer_options", reinterpret_cast<getter>(InjectedInputPointerInfo_get_PointerOptions), reinterpret_cast<setter>(InjectedInputPointerInfo_set_PointerOptions), nullptr, nullptr },
        { "pixel_location", reinterpret_cast<getter>(InjectedInputPointerInfo_get_PixelLocation), reinterpret_cast<setter>(InjectedInputPointerInfo_set_PixelLocation), nullptr, nullptr },
        { "time_offset_in_milliseconds", reinterpret_cast<getter>(InjectedInputPointerInfo_get_TimeOffsetInMilliseconds), reinterpret_cast<setter>(InjectedInputPointerInfo_set_TimeOffsetInMilliseconds), nullptr, nullptr },
        { "performance_count", reinterpret_cast<getter>(InjectedInputPointerInfo_get_PerformanceCount), reinterpret_cast<setter>(InjectedInputPointerInfo_set_PerformanceCount), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputPointerInfo[] = 
    {
        { Py_tp_new, _new_InjectedInputPointerInfo },
        { Py_tp_dealloc, _dealloc_InjectedInputPointerInfo },
        { Py_tp_getset, _getset_InjectedInputPointerInfo },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InjectedInputPointerInfo =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputPointerInfo",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputPointerInfo
    };

    // ----- InjectedInputRectangle struct --------------------
    constexpr const char* const _type_name_InjectedInputRectangle = "InjectedInputRectangle";

    PyObject* _new_InjectedInputRectangle(PyTypeObject* type, PyObject* args, PyObject* kwds)
    {
        auto tuple_size = PyTuple_Size(args);

        if ((tuple_size == 0) && (kwds == nullptr))
        {
            try
            {
                winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle return_value{};
                return py::convert(return_value);
            }
            catch (...)
            {
                py::to_PyErr();
                return nullptr;
            }
        }

        if ((tuple_size == 1) && (kwds == nullptr))
        {
            auto arg = PyTuple_GetItem(args, 0);
            if (PyDict_Check(arg))
            {
                try
                {
                    auto return_value = py::convert_to<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>(arg);
                    return py::convert(return_value);
                }
                catch (...)
                {
                    py::to_PyErr();
                    return nullptr;
                }
            }
        }

        int32_t _Left{};
        int32_t _Top{};
        int32_t _Bottom{};
        int32_t _Right{};

        static const char* kwlist[] = {"left", "top", "bottom", "right", nullptr};
        if (!PyArg_ParseTupleAndKeywords(args, kwds, "iiii", const_cast<char**>(kwlist), &_Left, &_Top, &_Bottom, &_Right))
        {
            return nullptr;
        }

        try
        {
            winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle return_value{ _Left, _Top, _Bottom, _Right };
            return py::convert(return_value);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static void _dealloc_InjectedInputRectangle(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self)
    {
    }

    static PyObject* InjectedInputRectangle_get_Left(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Left);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputRectangle_set_Left(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Left = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputRectangle_get_Top(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Top);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputRectangle_set_Top(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Top = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputRectangle_get_Bottom(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Bottom);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputRectangle_set_Bottom(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Bottom = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyObject* InjectedInputRectangle_get_Right(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, void* /*unused*/) noexcept
    {
        try
        {
            return py::convert(self->obj.Right);
        }
        catch (...)
        {
            py::to_PyErr();
            return nullptr;
        }
    }

    static int InjectedInputRectangle_set_Right(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle* self, PyObject* arg, void* /*unused*/) noexcept
    {
        if (arg == nullptr)
        {
            PyErr_SetString(PyExc_TypeError, "property delete not supported");
            return -1;
        }

        try
        {
            self->obj.Right = py::converter<int32_t>::convert_to(arg);
            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyGetSetDef _getset_InjectedInputRectangle[] = {
        { "left", reinterpret_cast<getter>(InjectedInputRectangle_get_Left), reinterpret_cast<setter>(InjectedInputRectangle_set_Left), nullptr, nullptr },
        { "top", reinterpret_cast<getter>(InjectedInputRectangle_get_Top), reinterpret_cast<setter>(InjectedInputRectangle_set_Top), nullptr, nullptr },
        { "bottom", reinterpret_cast<getter>(InjectedInputRectangle_get_Bottom), reinterpret_cast<setter>(InjectedInputRectangle_set_Bottom), nullptr, nullptr },
        { "right", reinterpret_cast<getter>(InjectedInputRectangle_get_Right), reinterpret_cast<setter>(InjectedInputRectangle_set_Right), nullptr, nullptr },
        { }
    };

    static PyType_Slot _type_slots_InjectedInputRectangle[] = 
    {
        { Py_tp_new, _new_InjectedInputRectangle },
        { Py_tp_dealloc, _dealloc_InjectedInputRectangle },
        { Py_tp_getset, _getset_InjectedInputRectangle },
        { 0, nullptr },
    };

    static PyType_Spec _type_spec_InjectedInputRectangle =
    {
        "_winsdk_Windows_UI_Input_Preview_Injection.InjectedInputRectangle",
        sizeof(py::wrapper::Windows::UI::Input::Preview::Injection::InjectedInputRectangle),
        0,
        Py_TPFLAGS_DEFAULT,
        _type_slots_InjectedInputRectangle
    };

    // ----- Windows.UI.Input.Preview.Injection Initialization --------------------
    static int module_exec(PyObject* module) noexcept
    {
        try
        {
            py::pyobj_handle bases { PyTuple_Pack(1, py::winrt_type<py::Object>::python_type) };

            py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputGamepadInfo>::python_type = py::register_python_type(module, _type_name_InjectedInputGamepadInfo, &_type_spec_InjectedInputGamepadInfo, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputKeyboardInfo>::python_type = py::register_python_type(module, _type_name_InjectedInputKeyboardInfo, &_type_spec_InjectedInputKeyboardInfo, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputMouseInfo>::python_type = py::register_python_type(module, _type_name_InjectedInputMouseInfo, &_type_spec_InjectedInputMouseInfo, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPenInfo>::python_type = py::register_python_type(module, _type_name_InjectedInputPenInfo, &_type_spec_InjectedInputPenInfo, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputTouchInfo>::python_type = py::register_python_type(module, _type_name_InjectedInputTouchInfo, &_type_spec_InjectedInputTouchInfo, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InputInjector>::python_type = py::register_python_type(module, _type_name_InputInjector, &_type_spec_InputInjector, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPoint>::python_type = py::register_python_type(module, _type_name_InjectedInputPoint, &_type_spec_InjectedInputPoint, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputPointerInfo>::python_type = py::register_python_type(module, _type_name_InjectedInputPointerInfo, &_type_spec_InjectedInputPointerInfo, bases.get());
            py::winrt_type<winrt::Windows::UI::Input::Preview::Injection::InjectedInputRectangle>::python_type = py::register_python_type(module, _type_name_InjectedInputRectangle, &_type_spec_InjectedInputRectangle, bases.get());

            return 0;
        }
        catch (...)
        {
            py::to_PyErr();
            return -1;
        }
    }

    static PyModuleDef_Slot module_slots[] = {{Py_mod_exec, module_exec}, {}};

    PyDoc_STRVAR(module_doc, "Windows.UI.Input.Preview.Injection");

    static PyModuleDef module_def
        = {PyModuleDef_HEAD_INIT,
           "_winsdk_Windows_UI_Input_Preview_Injection",
           module_doc,
           0,
           nullptr,
           module_slots,
           nullptr,
           nullptr,
           nullptr};
} // py::cpp::Windows::UI::Input::Preview::Injection

PyMODINIT_FUNC
PyInit__winsdk_Windows_UI_Input_Preview_Injection (void) noexcept
{
    return PyModuleDef_Init(&py::cpp::Windows::UI::Input::Preview::Injection::module_def);
}
